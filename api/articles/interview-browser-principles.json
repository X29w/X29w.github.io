{"title":"interview-browser-principles","uid":"7dfa44f5bf9784913186c2660b6488c1","slug":"interview-browser-principles","date":"2024-05-30T15:01:58.000Z","updated":"2024-06-04T06:18:06.358Z","comments":true,"path":"api/articles/interview-browser-principles.json","keywords":null,"cover":null,"content":"<h1 id=\"浏览器原理\"><a href=\"#浏览器原理\" class=\"headerlink\" title=\"浏览器原理\"></a>浏览器原理</h1><h2 id=\"什么是-XSS-攻击？\"><a href=\"#什么是-XSS-攻击？\" class=\"headerlink\" title=\"什么是 XSS 攻击？\"></a>什么是 XSS 攻击？</h2><p>XSS（Cross-Site Scripting）攻击，即跨站脚本攻击，是指攻击者通过在目标网站上注入恶意脚本，当用户浏览该页面时，恶意脚本会在用户的浏览器上执行，从而盗取用户信息、篡改网页内容、进行钓鱼攻击等。</p>\n<h2 id=\"如何防御-XSS-攻击？\"><a href=\"#如何防御-XSS-攻击？\" class=\"headerlink\" title=\"如何防御 XSS 攻击？\"></a>如何防御 XSS 攻击？</h2><ol>\n<li><strong>输入验证与过滤</strong>：对用户提交的所有数据进行严格的输入验证，过滤特殊字符和脚本标签。</li>\n<li><strong>输出编码</strong>：对输出到HTML中的数据进行适当的HTML实体编码，如<code>&lt;</code>转换为<code>&amp;lt;</code>，防止脚本执行。</li>\n<li><strong>使用HTTP头部安全策略</strong>：设置<code>Content-Security-Policy</code>（CSP）来限制加载外部资源，减少XSS风险。</li>\n<li><strong>Cookie安全</strong>：对敏感的Cookie设置<code>HttpOnly</code>标志，禁止JavaScript访问，防止通过脚本窃取。</li>\n<li><strong>DOM安全处理</strong>：使用安全的DOM操作方法，避免直接拼接字符串生成HTML。</li>\n</ol>\n<h2 id=\"什么是-CSRF-攻击？\"><a href=\"#什么是-CSRF-攻击？\" class=\"headerlink\" title=\"什么是 CSRF 攻击？\"></a>什么是 CSRF 攻击？</h2><p>CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种攻击者利用用户已登录的身份，在用户不知情的情况下，诱使用户浏览器向目标网站发送恶意请求，执行操作如转账、修改密码等。</p>\n<h2 id=\"如何防御-CSRF-攻击？\"><a href=\"#如何防御-CSRF-攻击？\" class=\"headerlink\" title=\"如何防御 CSRF 攻击？\"></a>如何防御 CSRF 攻击？</h2><ol>\n<li><strong>Token验证</strong>：在表单或Ajax请求中加入一个随机生成且难以预测的Token，服务器验证每次请求携带的Token是否有效。</li>\n<li><strong>Referer检查</strong>：检查请求的来源Referer头部，确认是否来自可信域名，但此方法不完全可靠，因为Referer可以被伪造或禁用。</li>\n<li><strong>SameSite Cookie属性</strong>：为Cookie设置<code>SameSite=Lax</code>或<code>SameSite=Strict</code>，限制第三方上下文中的Cookie发送。</li>\n<li><strong>双重认证</strong>：对敏感操作要求用户提供额外的身份验证信息，如短信验证码。</li>\n</ol>\n<h2 id=\"什么是中间人攻击？\"><a href=\"#什么是中间人攻击？\" class=\"headerlink\" title=\"什么是中间人攻击？\"></a>什么是中间人攻击？</h2><p>中间人攻击（Man-in-the-Middle Attack, MITM）发生在攻击者拦截并可能篡改通信双方之间的数据传输过程中，通常通过监听、篡改或插入数据包来窃取敏感信息或误导通信双方。</p>\n<h2 id=\"如何防范中间人攻击？\"><a href=\"#如何防范中间人攻击？\" class=\"headerlink\" title=\"如何防范中间人攻击？\"></a>如何防范中间人攻击？</h2><ol>\n<li><strong>HTTPS加密</strong>：强制使用HTTPS协议，SSL&#x2F;TLS加密通信，确保数据在传输过程中的保密性和完整性。</li>\n<li><strong>证书验证</strong>：确保服务器证书有效且来自于受信任的CA，客户端验证服务器证书以防止中间人替换证书。</li>\n<li><strong>公共Wi-Fi谨慎使用</strong>：在不安全的公共网络下尽量避免进行敏感操作。</li>\n<li><strong>DNS安全</strong>：使用DNSSEC等技术防止DNS欺骗，确保域名解析的正确性。</li>\n</ol>\n<h2 id=\"有哪些可能引起前端安全的问题\"><a href=\"#有哪些可能引起前端安全的问题\" class=\"headerlink\" title=\"有哪些可能引起前端安全的问题?\"></a>有哪些可能引起前端安全的问题?</h2><ol>\n<li><strong>不安全的API使用</strong>：如未验证的第三方API调用。</li>\n<li><strong>敏感信息泄露</strong>：在错误信息或日志中泄露敏感数据。</li>\n<li><strong>不安全的存储</strong>：在本地存储中保存敏感信息而未加密。</li>\n<li><strong>点击劫持</strong>：缺乏X-Frame-Options头部保护，导致页面被嵌入iframe中进行点击劫持。</li>\n<li><strong>不安全的CORS配置</strong>：错误的CORS策略可能允许恶意站点访问API。</li>\n</ol>\n<h2 id=\"网络劫持有哪几种，如何防范？\"><a href=\"#网络劫持有哪几种，如何防范？\" class=\"headerlink\" title=\"网络劫持有哪几种，如何防范？\"></a>网络劫持有哪几种，如何防范？</h2><h3 id=\"DNS劫持\"><a href=\"#DNS劫持\" class=\"headerlink\" title=\"DNS劫持\"></a>DNS劫持</h3><ul>\n<li><strong>防范</strong>：使用DNSSEC，选择信誉良好的DNS服务商，定期检查DNS设置。</li>\n</ul>\n<h3 id=\"ARP欺骗\"><a href=\"#ARP欺骗\" class=\"headerlink\" title=\"ARP欺骗\"></a>ARP欺骗</h3><ul>\n<li><strong>防范</strong>：使用静态ARP绑定，部署ARP防护设备或软件，定期检查网络设备。</li>\n</ul>\n<h3 id=\"IP-Spoofing\"><a href=\"#IP-Spoofing\" class=\"headerlink\" title=\"IP Spoofing\"></a>IP Spoofing</h3><ul>\n<li><strong>防范</strong>：实施IP源地址验证，使用入侵检测系统（IDS）和防火墙规则。</li>\n</ul>\n<h3 id=\"SSLStrip\"><a href=\"#SSLStrip\" class=\"headerlink\" title=\"SSLStrip\"></a>SSLStrip</h3><ul>\n<li><strong>防范</strong>：全面采用HTTPS，启用HSTS（HTTP Strict Transport Security）策略，教育用户注意地址栏的HTTPS标志。</li>\n</ul>\n<h3 id=\"Session-Hijacking\"><a href=\"#Session-Hijacking\" class=\"headerlink\" title=\"Session Hijacking\"></a>Session Hijacking</h3><ul>\n<li><strong>防范</strong>：使用安全的Session管理，定期更换Session ID，实施TLS客户端证书验证。</li>\n</ul>\n<p>通过这些措施，可以大大增强系统的安全性，减少被攻击的风险。</p>\n<h2 id=\"对浏览器的缓存机制的理解\"><a href=\"#对浏览器的缓存机制的理解\" class=\"headerlink\" title=\"对浏览器的缓存机制的理解\"></a>对浏览器的缓存机制的理解</h2><p>浏览器缓存机制是基于HTTP协议实现的一种提高网页加载速度的技术，通过存储用户访问过的网页资源（如HTML、CSS、JavaScript文件、图片等），在后续请求时直接从本地缓存读取，无需再次向服务器发起请求，从而减少网络延迟和带宽消耗。</p>\n<h2 id=\"浏览器资源缓存的位置有哪些？\"><a href=\"#浏览器资源缓存的位置有哪些？\" class=\"headerlink\" title=\"浏览器资源缓存的位置有哪些？\"></a>浏览器资源缓存的位置有哪些？</h2><p>浏览器缓存可以存储在多个位置，主要包括：</p>\n<ol>\n<li><strong>内存缓存</strong>：最快速的缓存方式，位于RAM中，用于存储最近和频繁访问的资源，关闭浏览器后清空。</li>\n<li><strong>磁盘缓存</strong>：持久化存储，如硬盘上的某个目录，用于长期存储资源，重启浏览器后依然可用。</li>\n<li><strong>Service Worker缓存</strong>：一种特殊的浏览器缓存机制，允许开发者编写脚本控制缓存逻辑，为离线访问和性能优化提供更多灵活性。</li>\n<li><strong>Application Cache（AppCache，已废弃）</strong>：旧版的离线缓存机制，已被Service Worker取代，但仍可能在一些老网站中见到。</li>\n</ol>\n<h2 id=\"协商缓存和强缓存的区别\"><a href=\"#协商缓存和强缓存的区别\" class=\"headerlink\" title=\"协商缓存和强缓存的区别\"></a>协商缓存和强缓存的区别</h2><p><strong>强缓存</strong>（也称作无条件缓存）：</p>\n<ul>\n<li>浏览器在本地有资源副本，且根据资源的<code>Cache-Control</code>或<code>Expires</code>头部判断该副本仍然有效时，直接使用本地缓存，无需向服务器发出请求。</li>\n<li>提高效率，减少不必要的网络交互。</li>\n</ul>\n<p><strong>协商缓存</strong>（也称作有条件缓存）：</p>\n<ul>\n<li>当强缓存未命中时，浏览器会发送请求到服务器，并带上上次请求得到的<code>ETag</code>或<code>Last-Modified</code>等验证信息。</li>\n<li>服务器根据这些验证信息判断资源是否更新，如果资源未变，则返回一个304状态码，告诉浏览器继续使用本地缓存；如果资源已更新，则返回新的资源和新的验证信息。</li>\n</ul>\n<h2 id=\"为什么需要浏览器缓存？\"><a href=\"#为什么需要浏览器缓存？\" class=\"headerlink\" title=\"为什么需要浏览器缓存？\"></a>为什么需要浏览器缓存？</h2><ol>\n<li><strong>加速页面加载</strong>：减少资源下载时间，提高用户体验。</li>\n<li><strong>节省带宽</strong>：重复利用已下载的资源，减少数据传输量。</li>\n<li><strong>减轻服务器压力</strong>：减少对服务器的请求次数，特别是在高流量时段。</li>\n<li><strong>提升应用可用性</strong>：在弱网或无网络环境下，可依赖缓存资源提供基本功能。</li>\n</ol>\n<h2 id=\"点击刷新按钮或者按-F5、按-Ctrl-F5（强制刷新）、地址栏回车有什么区别？\"><a href=\"#点击刷新按钮或者按-F5、按-Ctrl-F5（强制刷新）、地址栏回车有什么区别？\" class=\"headerlink\" title=\"点击刷新按钮或者按 F5、按 Ctrl+F5（强制刷新）、地址栏回车有什么区别？\"></a>点击刷新按钮或者按 F5、按 Ctrl+F5（强制刷新）、地址栏回车有什么区别？</h2><h3 id=\"点击刷新按钮或按-F5\"><a href=\"#点击刷新按钮或按-F5\" class=\"headerlink\" title=\"点击刷新按钮或按 F5\"></a>点击刷新按钮或按 F5</h3><ul>\n<li>正常刷新页面，浏览器首先尝试使用强缓存，如果强缓存未命中，则进行协商缓存。这通常意味着如果资源没有改变，页面部分或全部内容可以从本地缓存加载。</li>\n</ul>\n<h3 id=\"按-Ctrl-F5（强制刷新）\"><a href=\"#按-Ctrl-F5（强制刷新）\" class=\"headerlink\" title=\"按 Ctrl+F5（强制刷新）\"></a>按 Ctrl+F5（强制刷新）</h3><ul>\n<li>强制刷新，绕过浏览器的强缓存和协商缓存机制，直接从服务器重新下载页面所有资源，确保获取最新版本。适用于开发中检查页面更新的情况。</li>\n</ul>\n<h3 id=\"地址栏回车\"><a href=\"#地址栏回车\" class=\"headerlink\" title=\"地址栏回车\"></a>地址栏回车</h3><ul>\n<li>类似于点击刷新按钮或F5，执行普通刷新操作。浏览器会根据资源的缓存策略判断是否使用缓存。如果缓存有效（根据强缓存或协商缓存），则直接使用缓存资源；否则，从服务器重新请求资源。</li>\n</ul>\n<p>总结而言，正常刷新（F5或刷新按钮）和地址栏回车会遵循浏览器的缓存策略，可能使用缓存；而Ctrl+F5强制刷新则跳过这些策略，确保从服务器拉取所有内容的新鲜副本。</p>\n<h2 id=\"对浏览器的理解\"><a href=\"#对浏览器的理解\" class=\"headerlink\" title=\"对浏览器的理解\"></a>对浏览器的理解</h2><p>浏览器是用户访问互联网内容的主要工具，它将从服务器接收的HTML、CSS、JavaScript等文件解析、渲染，并展示为可视化的网页。浏览器不仅负责页面展示，还提供了一个运行环境来执行JavaScript代码，支持用户与网页的交互，管理cookies和存储，以及实现网络通信等功能。</p>\n<h2 id=\"对浏览器内核的理解\"><a href=\"#对浏览器内核的理解\" class=\"headerlink\" title=\"对浏览器内核的理解\"></a>对浏览器内核的理解</h2><p>浏览器内核，也称为渲染引擎，是浏览器的核心组件，负责解析网页内容（HTML、CSS）并将其转换为用户可见的界面。它主要由两个部分构成：渲染引擎（负责布局和绘制）和JavaScript引擎（负责执行脚本）。内核决定了浏览器如何处理网页代码，影响页面的加载速度、兼容性和渲染效果。</p>\n<h2 id=\"常见的浏览器内核比较\"><a href=\"#常见的浏览器内核比较\" class=\"headerlink\" title=\"常见的浏览器内核比较\"></a>常见的浏览器内核比较</h2><ul>\n<li><strong>Trident（Internet Explorer）</strong>：早期Windows系统上的IE浏览器使用的内核，已逐渐被淘汰。</li>\n<li><strong>Gecko（Firefox）</strong>：Mozilla Firefox浏览器的内核，支持高级网页标准和较好的兼容性。</li>\n<li><strong>WebKit</strong>：最初由苹果开发，用于Safari浏览器，后来成为许多移动浏览器的基础，如早期的Android浏览器。</li>\n<li><strong>Blink</strong>：Google从WebKit分支出来的一个项目，现用于Chrome、Opera等现代浏览器，特点是快速迭代和高性能。</li>\n</ul>\n<h2 id=\"常见浏览器所用内核\"><a href=\"#常见浏览器所用内核\" class=\"headerlink\" title=\"常见浏览器所用内核\"></a>常见浏览器所用内核</h2><ul>\n<li>Chrome &#x2F; Opera：Blink</li>\n<li>Firefox：Gecko</li>\n<li>Safari：WebKit</li>\n<li>Edge（新版本）：Blink</li>\n<li>Internet Explorer（旧版本）：Trident</li>\n</ul>\n<h2 id=\"浏览器的主要组成部分\"><a href=\"#浏览器的主要组成部分\" class=\"headerlink\" title=\"浏览器的主要组成部分\"></a>浏览器的主要组成部分</h2><ol>\n<li><strong>用户界面</strong>：地址栏、前进&#x2F;后退按钮、书签菜单等。</li>\n<li><strong>浏览器引擎</strong>：协调用户界面与渲染引擎之间的交互。</li>\n<li><strong>渲染引擎</strong>：解析HTML和CSS，构建页面布局并渲染。</li>\n<li><strong>网络模块</strong>：处理网络请求，如HTTP&#x2F;HTTPS请求。</li>\n<li><strong>JavaScript引擎</strong>：解析和执行JavaScript代码。</li>\n<li><strong>数据存储</strong>：Cookie、LocalStorage、IndexedDB等。</li>\n</ol>\n<h2 id=\"浏览器渲染原理\"><a href=\"#浏览器渲染原理\" class=\"headerlink\" title=\"浏览器渲染原理\"></a>浏览器渲染原理</h2><p>浏览器渲染过程大致分为以下几个阶段：</p>\n<ol>\n<li><strong>解析HTML</strong>：构建DOM树。</li>\n<li><strong>解析CSS</strong>：构建CSSOM（CSS对象模型）。</li>\n<li><strong>合并DOM与CSSOM</strong>：生成Render Tree（渲染树）。</li>\n<li><strong>布局</strong>：计算每个节点的几何信息。</li>\n<li><strong>绘制</strong>：将Render Tree渲染到屏幕上。</li>\n</ol>\n<h2 id=\"浏览器渲染过程\"><a href=\"#浏览器渲染过程\" class=\"headerlink\" title=\"浏览器渲染过程\"></a>浏览器渲染过程</h2><ol>\n<li><strong>加载资源</strong>：请求HTML文档，然后根据文档内的引用加载CSS、JavaScript、图片等资源。</li>\n<li><strong>解析与构建</strong>：解析HTML生成DOM树，解析CSS生成CSSOM，结合两者构建Render Tree。</li>\n<li><strong>布局与绘制</strong>：计算布局（Layout），确定元素在视口中的位置和尺寸，然后绘制到屏幕。</li>\n</ol>\n<h2 id=\"浏览器渲染优化\"><a href=\"#浏览器渲染优化\" class=\"headerlink\" title=\"浏览器渲染优化\"></a>浏览器渲染优化</h2><ul>\n<li><strong>减少HTTP请求</strong>：合并文件、使用雪碧图、开启HTTP2等。</li>\n<li><strong>资源压缩</strong>：减小文件大小，如GZIP压缩。</li>\n<li><strong>懒加载</strong>：只在需要时加载图片或其他资源。</li>\n<li><strong>使用CDN</strong>：减少资源加载延迟。</li>\n<li><strong>预加载与预读取</strong>：提前请求可能需要的资源。</li>\n</ul>\n<h2 id=\"渲染过程中遇到-JS-文件如何处理？\"><a href=\"#渲染过程中遇到-JS-文件如何处理？\" class=\"headerlink\" title=\"渲染过程中遇到 JS 文件如何处理？\"></a>渲染过程中遇到 JS 文件如何处理？</h2><p>当浏览器遇到JavaScript文件时，通常会暂停HTML解析，加载并执行JS，这是因为JS可能修改DOM结构或CSSOM。这种行为被称为“JavaScript阻塞”，为减少其负面影响，可以使用<code>async</code>或<code>defer</code>属性异步加载脚本。</p>\n<h2 id=\"什么是文档的预解析？\"><a href=\"#什么是文档的预解析？\" class=\"headerlink\" title=\"什么是文档的预解析？\"></a>什么是文档的预解析？</h2><p>文档预解析（Pre-parser）是浏览器的一个优化策略，它在主线程执行JavaScript之前，提前分析HTML文档，识别并开始加载外部资源（如CSS和JS），从而减少实际解析时的等待时间。</p>\n<h2 id=\"CSS-如何阻塞文档解析？\"><a href=\"#CSS-如何阻塞文档解析？\" class=\"headerlink\" title=\"CSS 如何阻塞文档解析？\"></a>CSS 如何阻塞文档解析？</h2><p>外部CSS文件默认是阻塞的，意味着浏览器遇到<code>&lt;link&gt;</code>标签加载CSS时，会暂停HTML解析，直到CSSOM构建完成，因为CSS可能影响到元素的布局。内联样式不会阻塞解析，因为它不需要额外的HTTP请求。</p>\n<h2 id=\"如何优化关键渲染路径？\"><a href=\"#如何优化关键渲染路径？\" class=\"headerlink\" title=\"如何优化关键渲染路径？\"></a>如何优化关键渲染路径？</h2><ul>\n<li><strong>减少关键资源数量</strong>：确保首屏加载所需资源尽可能少。</li>\n<li><strong>优先加载关键CSS</strong>：内联关键CSS或使用媒体类型<code>print</code>加载非关键CSS。</li>\n<li><strong>异步加载JavaScript</strong>：避免阻塞渲染的关键路径。</li>\n<li><strong>避免使用@import</strong>：因为它会导致CSS加载延迟。</li>\n<li><strong>优化图片和图标</strong>：使用合适的格式和尺寸，考虑懒加载。</li>\n</ul>\n<h2 id=\"什么情况会阻塞渲染？\"><a href=\"#什么情况会阻塞渲染？\" class=\"headerlink\" title=\"什么情况会阻塞渲染？\"></a>什么情况会阻塞渲染？</h2><ul>\n<li><strong>解析中的JavaScript</strong>：同步脚本会阻塞HTML解析。</li>\n<li><strong>等待外部CSS</strong>：构建Render Tree需要完整的CSSOM。</li>\n<li><strong>大型图片和媒体文件</strong>：下载时间长，影响首屏渲染。</li>\n<li><strong>重排与重绘</strong>：频繁的DOM操作可能导致页面多次渲染。</li>\n<li><strong>网络拥塞</strong>：资源加载慢也会延后渲染过程。</li>\n</ul>\n<h2 id=\"浏览器本地存储方式及使用场景\"><a href=\"#浏览器本地存储方式及使用场景\" class=\"headerlink\" title=\"浏览器本地存储方式及使用场景\"></a>浏览器本地存储方式及使用场景</h2><p>浏览器提供了多种本地存储技术，以便开发者在客户端存储数据。这些技术包括Cookie、LocalStorage、SessionStorage和IndexedDB，每种都有其特定的用途和限制。</p>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p><strong>使用场景</strong>：</p>\n<ul>\n<li>会话管理：跟踪用户会话状态，如登录状态。</li>\n<li>用户偏好设置：存储用户的界面偏好，如语言选择。</li>\n<li>跨页面数据传递：在不同页面间共享少量数据。</li>\n</ul>\n<h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3><p><strong>使用场景</strong>：</p>\n<ul>\n<li>持久化存储：适合长期存储大量用户数据，如用户配置。</li>\n<li>离线应用：缓存用户数据，支持离线浏览功能。</li>\n<li>客户端数据缓存：存储不敏感的应用数据，提高应用性能。</li>\n</ul>\n<h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3><p><strong>使用场景</strong>：</p>\n<ul>\n<li>临时会话数据：存储仅在当前会话中有效的数据，如表单暂存。</li>\n<li>单页应用状态：在SPA中存储页面间跳转的状态信息。</li>\n</ul>\n<h3 id=\"IndexedDB\"><a href=\"#IndexedDB\" class=\"headerlink\" title=\"IndexedDB\"></a>IndexedDB</h3><p><strong>使用场景</strong>：</p>\n<ul>\n<li>大量结构化数据存储：适合存储大量复杂数据，如图片库、用户生成的内容。</li>\n<li>离线应用数据库：为离线应用提供数据存储解决方案。</li>\n<li>高性能数据检索：利用索引实现快速查询。</li>\n</ul>\n<h2 id=\"Cookie有哪些字段及其作用\"><a href=\"#Cookie有哪些字段及其作用\" class=\"headerlink\" title=\"Cookie有哪些字段及其作用\"></a>Cookie有哪些字段及其作用</h2><p>Cookie由多个字段组成，每个字段都有其特定的意义：</p>\n<ul>\n<li><strong>Name</strong>：键名，用于标识存储的数据项。</li>\n<li><strong>Value</strong>：键值，存储的具体数据。</li>\n<li><strong>Expires&#x2F;Max-Age</strong>：定义Cookie的有效期，过期后浏览器会自动删除。</li>\n<li><strong>Domain</strong>：指定Cookie所属的域名，决定了哪些站点可以访问该Cookie。</li>\n<li><strong>Path</strong>：定义了Cookie的路径，指定了浏览器发送Cookie的条件，只有访问匹配该路径的URL时才会发送Cookie。</li>\n<li><strong>Secure</strong>：指示浏览器仅在HTTPS连接下发送Cookie。</li>\n<li><strong>HttpOnly</strong>：标记为HttpOnly的Cookie不能被JavaScript访问，增加了安全性。</li>\n</ul>\n<h2 id=\"Cookie、LocalStorage、SessionStorage区别\"><a href=\"#Cookie、LocalStorage、SessionStorage区别\" class=\"headerlink\" title=\"Cookie、LocalStorage、SessionStorage区别\"></a>Cookie、LocalStorage、SessionStorage区别</h2><ul>\n<li><strong>存储容量</strong>：Cookie通常限制在4KB左右，LocalStorage和SessionStorage则远大于此，通常为5MB或更多。</li>\n<li><strong>有效期</strong>：Cookie可以设置过期时间，LocalStorage持久存储除非手动删除，SessionStorage仅在当前会话有效，关闭浏览器即清除。</li>\n<li><strong>作用域</strong>：Cookie可跨域名（需正确设置Domain），LocalStorage和SessionStorage限于同源策略下，不能跨域。</li>\n<li><strong>与服务器通信</strong>：Cookie随每次HTTP请求自动发送到服务器，LocalStorage和SessionStorage不参与网络请求。</li>\n</ul>\n<h2 id=\"前端储存的方式\"><a href=\"#前端储存的方式\" class=\"headerlink\" title=\"前端储存的方式\"></a>前端储存的方式</h2><p>前端储存方式主要包括：</p>\n<ol>\n<li><strong>Cookie</strong>：最早的传统存储方式，主要用于会话管理和用户偏好设置。</li>\n<li><strong>LocalStorage</strong>：HTML5引入的持久化本地存储，适合长期存储大量数据。</li>\n<li><strong>SessionStorage</strong>：HTML5引入的会话存储，数据仅在当前浏览器会话中有效。</li>\n<li><strong>IndexedDB</strong>：一种客户端存储大量结构化数据的数据库。</li>\n<li><strong>Web SQL</strong>（已废弃）：曾是HTML5标准的一部分，但现在不推荐使用。</li>\n<li><strong>Cache API</strong>：用于存储资源的缓存机制，改善网页性能。</li>\n<li><strong>Service Worker Cache</strong>：配合Service Worker使用，为离线体验和网络请求优化提供缓存。</li>\n</ol>\n<h2 id=\"IndexedDB的特点\"><a href=\"#IndexedDB的特点\" class=\"headerlink\" title=\"IndexedDB的特点\"></a>IndexedDB的特点</h2><ul>\n<li><strong>异步API</strong>：所有操作都是异步的，不会阻塞UI线程，提升用户体验。</li>\n<li><strong>事务处理</strong>：支持事务，确保数据的一致性和完整性。</li>\n<li><strong>灵活的数据模型</strong>：可以存储复杂的结构化数据，包括对象和数组。</li>\n<li><strong>索引支持</strong>：提供索引功能，加速数据检索。</li>\n<li><strong>大容量存储</strong>：能够处理大量数据，适合存储多媒体文件等大数据量。</li>\n<li><strong>同源策略</strong>：遵循同源策略，但可以通过IndexedDB的API在Service Workers中实现跨域数据访问。</li>\n</ul>\n<h2 id=\"什么是同源策略\"><a href=\"#什么是同源策略\" class=\"headerlink\" title=\"什么是同源策略\"></a>什么是同源策略</h2><p>同源策略（Same-Origin Policy）是浏览器为了保证安全，实施的一种重要安全策略。它规定了一个网页脚本只能读取来自同一源（即协议、域名、端口号相同的源）的资源，而对不同源的资源进行访问则会受到限制。这意味着，一个网页上的脚本不能随意读取另一个网页的数据，除非这两个网页满足同源条件。这样做可以有效防止恶意网站通过脚本读取其他网站的敏感信息，如 cookie、localStorage 等。</p>\n<h2 id=\"如何解决跨域问题\"><a href=\"#如何解决跨域问题\" class=\"headerlink\" title=\"如何解决跨域问题\"></a>如何解决跨域问题</h2><p>解决跨域问题的常见方法有以下几种：</p>\n<ol>\n<li><strong>CORS（跨源资源共享）</strong>：服务器通过在响应头中添加特定的 <code>Access-Control-Allow-Origin</code> 字段，允许特定源的请求。</li>\n<li><strong>JSONP（JSON with Padding）</strong>：利用 <code>&lt;script&gt;</code> 标签没有同源限制的特性，通过动态插入 <code>&lt;script&gt;</code> 来实现跨域请求。</li>\n<li><strong>代理服务器</strong>：设置一个代理服务器，将请求转发到目标服务器，从而绕过浏览器的同源策略限制。</li>\n<li><strong>WebSocket</strong>：WebSocket 协议本身不遵循同源策略，可以用于跨域实时通信。</li>\n<li><strong>使用 <code>postMessage</code> API</strong>：允许来自不同源的脚本采用异步方式进行有限制的通信。</li>\n</ol>\n<h2 id=\"事件是什么？事件模型？\"><a href=\"#事件是什么？事件模型？\" class=\"headerlink\" title=\"事件是什么？事件模型？\"></a>事件是什么？事件模型？</h2><p>事件是在用户与网页交互或在网页内部发生某些改变时，浏览器生成并传递给JavaScript代码的信号。事件模型描述了事件如何在DOM树中传播和处理，主要分为两种模型：</p>\n<ol>\n<li><strong>捕获阶段</strong>：事件从根节点开始，向下传播到目标元素。</li>\n<li><strong>目标阶段</strong>：事件到达实际的目标元素，并触发相应的事件处理器。</li>\n<li><strong>冒泡阶段</strong>：事件从目标元素开始，向外层元素传播，直到根节点。</li>\n</ol>\n<h2 id=\"如何阻止事件冒泡\"><a href=\"#如何阻止事件冒泡\" class=\"headerlink\" title=\"如何阻止事件冒泡\"></a>如何阻止事件冒泡</h2><p>在JavaScript中，可以通过调用事件对象的 <code>stopPropagation()</code> 方法来阻止事件向上冒泡。例如，在事件处理函数中：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">element.addEventListener(&#39;click&#39;, function(event) &#123;\n    event.stopPropagation();\n    &#x2F;&#x2F; 处理点击事件的代码...\n&#125;, false);</code></pre>\n\n<h2 id=\"对事件委托的理解\"><a href=\"#对事件委托的理解\" class=\"headerlink\" title=\"对事件委托的理解\"></a>对事件委托的理解</h2><p>事件委托（Event Delegation）是一种高效的事件处理模式，它允许将事件监听器添加到一个父元素上，而不是每个子元素上。当事件在子元素上触发时，通过判断事件对象（如 <code>event.target</code>）来确定实际的目标元素，并执行相应逻辑。这种方法减少了内存消耗，提高了性能，特别是在动态添加或删除子元素的场景下特别有用。</p>\n<h2 id=\"事件委托的使用场景\"><a href=\"#事件委托的使用场景\" class=\"headerlink\" title=\"事件委托的使用场景\"></a>事件委托的使用场景</h2><ul>\n<li><strong>大量动态生成的元素</strong>：如列表项、表格行等，无需为每个元素单独绑定事件监听器。</li>\n<li><strong>减少内存占用</strong>：适用于需要绑定大量事件处理器的场景。</li>\n<li><strong>简化DOM操作</strong>：避免频繁地添加和移除事件监听器。</li>\n</ul>\n<h2 id=\"同步和异步的区别\"><a href=\"#同步和异步的区别\" class=\"headerlink\" title=\"同步和异步的区别\"></a>同步和异步的区别</h2><ul>\n<li><strong>同步</strong>：程序按照代码的编写顺序依次执行，每个任务必须等待前一个任务完成才能开始。这会阻塞后续任务，直到当前任务结束。</li>\n<li><strong>异步</strong>：任务不立即等待结果，而是继续执行后续代码，当任务完成时通过回调、Promise、async&#x2F;await等方式通知主线程，实现非阻塞操作。</li>\n</ul>\n<h2 id=\"对事件循环的理解\"><a href=\"#对事件循环的理解\" class=\"headerlink\" title=\"对事件循环的理解\"></a>对事件循环的理解</h2><p>事件循环（Event Loop）是JavaScript运行环境（如浏览器和Node.js）处理异步操作的核心机制。它不断地检查是否有待处理的任务，包括宏观任务（Macro Task）和微观任务（Micro Task）。执行流程大致如下：</p>\n<ol>\n<li>执行当前宏任务队列中的所有任务。</li>\n<li>清空当前微任务队列中的所有任务。</li>\n<li>如果还有未处理的宏任务或新的微任务产生，重复步骤1和2。</li>\n<li>当所有任务执行完毕，进入休眠，等待下一轮事件触发。</li>\n</ol>\n<h2 id=\"宏任务和微任务分别有哪些\"><a href=\"#宏任务和微任务分别有哪些\" class=\"headerlink\" title=\"宏任务和微任务分别有哪些\"></a>宏任务和微任务分别有哪些</h2><ul>\n<li><strong>宏任务</strong>：包括setTimeout、setInterval、I&#x2F;O、UI渲染、事件处理（如click事件）、setImmediate（Node.js特有）等。</li>\n<li><strong>微任务</strong>：包括Promise的回调、MutationObserver、process.nextTick（Node.js特有）、queueMicrotask（ES2019引入）等。</li>\n</ul>\n<h2 id=\"什么是执行栈\"><a href=\"#什么是执行栈\" class=\"headerlink\" title=\"什么是执行栈\"></a>什么是执行栈</h2><p>执行栈（Call Stack）是编程中的一个概念，用于跟踪函数的调用过程和执行顺序。每当函数被调用时，都会创建一个新的栈帧（包含函数的局部变量、参数等信息）并压入栈顶；函数执行完毕后，其对应的栈帧会被弹出栈。JavaScript是单线程且使用执行栈来管理函数调用，确保函数按照调用顺序执行。</p>\n<h2 id=\"Node-js-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？\"><a href=\"#Node-js-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？\" class=\"headerlink\" title=\"Node.js 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？\"></a>Node.js 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h2><p>Node.js的Event Loop和浏览器中的Event Loop的主要区别在于它们处理任务队列的方式和特定的宏任务类型。Node.js中特有的宏任务类型包括I&#x2F;O操作和<code>setImmediate</code>，而浏览器中没有<code>setImmediate</code>，但有<code>requestAnimationFrame</code>。</p>\n<p><code>process.nextTick</code>是Node.js中的一个特殊API，它将任务安排在当前执行栈的末尾，但在任何其他微任务之前执行。这意味着即使在当前函数还没有完全返回，<code>process.nextTick</code>的回调也会在当前事件循环迭代结束前被执行，这使得它比Promise的回调或<code>setImmediate</code>更快执行。</p>\n<h2 id=\"事件触发的过程是怎样的\"><a href=\"#事件触发的过程是怎样的\" class=\"headerlink\" title=\"事件触发的过程是怎样的\"></a>事件触发的过程是怎样的</h2><p>事件触发的基本过程包括：</p>\n<ol>\n<li><strong>事件产生</strong>：用户交互（如点击、键盘输入）或系统行为（如页面加载完成）导致事件产生。</li>\n<li><strong>事件捕获&#x2F;目标阶段判断</strong>：根据事件模型，事件可能先经过捕获阶段向目标元素传播，然后在目标元素触发事件处理函数，最后进入冒泡阶段向上回传。</li>\n<li><strong>查找事件监听器</strong>：在事件到达相应的阶段时，查找该阶段注册的事件监听器。</li>\n<li><strong>调用事件处理函数</strong>：执行找到的事件处理函数，可能包括阻止默认行为、阻止事件传播等操作。</li>\n<li><strong>事件循环处理</strong>：对于异步事件，事件处理可能涉及事件循环，等待特定时机执行。</li>\n<li><strong>后续任务执行</strong>：事件处理完成后，根据事件循环机制继续执行其他排队的任务。</li>\n</ol>\n<h2 id=\"V8的垃圾回收机制是怎样的\"><a href=\"#V8的垃圾回收机制是怎样的\" class=\"headerlink\" title=\"V8的垃圾回收机制是怎样的\"></a>V8的垃圾回收机制是怎样的</h2><p>V8引擎的垃圾回收机制是其高效执行JavaScript代码的关键部分，主要包括以下几个方面：</p>\n<h3 id=\"1-分代回收机制\"><a href=\"#1-分代回收机制\" class=\"headerlink\" title=\"1. 分代回收机制\"></a>1. 分代回收机制</h3><p>V8将内存分为新生代（Young Generation）和老生代（Old Generation）两部分，依据对象的生命周期长短进行管理。</p>\n<ul>\n<li><p><strong>新生代</strong>：主要用于存放新创建的对象。新生代又分为两个子区域：From Space和To Space。当From Space区域填满时，垃圾回收器会执行Scavenge算法，将存活的对象复制到To Space，并清空From Space。这个过程会重复进行，From Space和To Space的角色会互换，以此方式快速回收短期存活的对象。</p>\n</li>\n<li><p><strong>老生代</strong>：长期存活或体积较大的对象会被晋升到老生代。老生代的回收相对复杂，使用标记-清除（Mark-and-Sweep）或标记-整理（Mark-Compact）算法。标记阶段遍历所有可达对象并打标记，清除阶段回收未标记的对象。整理阶段则在回收后整理内存碎片，避免内存碎片化。</p>\n</li>\n</ul>\n<h3 id=\"2-引用计数\"><a href=\"#2-引用计数\" class=\"headerlink\" title=\"2. 引用计数\"></a>2. 引用计数</h3><p>虽然V8主要依赖分代回收，但它也使用引用计数作为辅助手段。引用计数会追踪每个对象的引用数量，当一个对象的引用数变为0时，该对象就被认为是不可达的，可以被回收。然而，引用计数法容易导致循环引用问题，因此在V8中不是主要的回收策略。</p>\n<h3 id=\"3-并发与增量回收\"><a href=\"#3-并发与增量回收\" class=\"headerlink\" title=\"3. 并发与增量回收\"></a>3. 并发与增量回收</h3><p>为了减少垃圾回收对JavaScript执行的影响，V8引入了并发（Concurrent）、增量（Incremental）和并行（Parallel）回收技术。这些技术允许垃圾回收在主线程执行代码的同时进行，比如并发标记可以在主线程暂停之外的时间进行，而增量标记和清理则把回收过程分成多个小步骤，穿插在JS代码执行之间，以此减少因垃圾回收造成的页面卡顿现象。</p>\n<h3 id=\"4-停顿（Stop-The-World）\"><a href=\"#4-停顿（Stop-The-World）\" class=\"headerlink\" title=\"4. 停顿（Stop-The-World）\"></a>4. 停顿（Stop-The-World）</h3><p>尽管V8努力减少垃圾回收带来的暂停时间，但在某些情况下，如老生代的完整标记清除操作，仍然需要“停顿”主线程，暂停JavaScript执行以完成垃圾回收。这是因为在单线程环境下，为了保证数据一致性，回收操作必须在一个无干扰的环境中进行。</p>\n<h2 id=\"哪些操作会造成内存泄漏\"><a href=\"#哪些操作会造成内存泄漏\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏\"></a>哪些操作会造成内存泄漏</h2><h3 id=\"1-全局变量\"><a href=\"#1-全局变量\" class=\"headerlink\" title=\"1. 全局变量\"></a>1. 全局变量</h3><ul>\n<li><strong>说明</strong>：将对象直接赋值给全局变量，或在闭包中不恰当地引用对象，会导致这些对象一直保持可达状态，无法被垃圾回收。</li>\n</ul>\n<h3 id=\"2-循环引用\"><a href=\"#2-循环引用\" class=\"headerlink\" title=\"2. 循环引用\"></a>2. 循环引用</h3><ul>\n<li><strong>说明</strong>：两个或多个对象互相引用，形成闭环，即使这些对象不再被外部引用，只要闭环存在，垃圾回收器就不会回收它们。</li>\n</ul>\n<h3 id=\"3-未清理的事件监听器\"><a href=\"#3-未清理的事件监听器\" class=\"headerlink\" title=\"3. 未清理的事件监听器\"></a>3. 未清理的事件监听器</h3><ul>\n<li><strong>说明</strong>：为DOM元素或其他对象添加事件监听器后忘记移除，特别是当监听器引用了外部作用域的变量时，会导致这些变量和相关对象无法被回收。</li>\n</ul>\n<h3 id=\"4-被遗忘的定时器或回调\"><a href=\"#4-被遗忘的定时器或回调\" class=\"headerlink\" title=\"4. 被遗忘的定时器或回调\"></a>4. 被遗忘的定时器或回调</h3><ul>\n<li><strong>说明</strong>：设置的<code>setTimeout</code>、<code>setInterval</code>或其它异步操作的回调函数中引用了不再需要的对象，若不取消这些定时器或清除回调，对象会持续被引用。</li>\n</ul>\n<h3 id=\"5-DOM元素引用\"><a href=\"#5-DOM元素引用\" class=\"headerlink\" title=\"5. DOM元素引用\"></a>5. DOM元素引用</h3><ul>\n<li><strong>说明</strong>：即使从DOM树中移除了元素，但如果JavaScript中还保留着对该元素的引用，元素及其相关的子元素和数据仍然不会被回收。</li>\n</ul>\n<h3 id=\"6-缓存不当\"><a href=\"#6-缓存不当\" class=\"headerlink\" title=\"6. 缓存不当\"></a>6. 缓存不当</h3><ul>\n<li><strong>说明</strong>：无限制或不当管理的缓存（如使用Map或WeakMap存储大量对象）可能导致大量不再使用的数据占用内存，尤其是当缓存对象包含了大量子对象时。</li>\n</ul>\n<h3 id=\"7-V8的特殊情况\"><a href=\"#7-V8的特殊情况\" class=\"headerlink\" title=\"7. V8的特殊情况\"></a>7. V8的特殊情况</h3><ul>\n<li><strong>如</strong>：使用<code>v8::Persistent</code>对象时，如果未正确管理，可能会导致对象无法被垃圾回收，因为<code>Persistent</code>对象会保持对象的引用直到显式释放。</li>\n</ul>\n<p>解决内存泄漏通常需要识别并修正上述问题，使用开发工具（如Chrome DevTools）监控内存使用情况，定期审查代码，及时解除不再需要的引用，以及合理管理事件监听器和定时器等。</p>\n<h2 id=\"TCP的三次握手和四次挥手\"><a href=\"#TCP的三次握手和四次挥手\" class=\"headerlink\" title=\"TCP的三次握手和四次挥手\"></a>TCP的三次握手和四次挥手</h2><p>TCP（三次握手和四次挥手）是传输控制协议的两个重要过程，分别用于建立和终止连接。它们确保了数据传输的可靠性和准确性。以下是对这两个过程的详细解释：</p>\n<h3 id=\"三次握手（Three-Way-Handshake）\"><a href=\"#三次握手（Three-Way-Handshake）\" class=\"headerlink\" title=\"三次握手（Three-Way Handshake）\"></a>三次握手（Three-Way Handshake）</h3><p>三次握手是 TCP 建立连接的过程，涉及客户端和服务器之间的三个步骤。</p>\n<ol>\n<li><p><strong>第一次握手（SYN）</strong></p>\n<ul>\n<li>客户端向服务器发送一个 SYN（同步序列号）包，表示请求建立连接。该包包含一个初始序列号（Sequence Number）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Client: SYN, Seq &#x3D; X</code></pre>\n</li>\n<li><p><strong>第二次握手（SYN-ACK）</strong></p>\n<ul>\n<li>服务器收到 SYN 包后，回应一个 SYN-ACK 包。SYN 表示服务器同意建立连接，并且 ACK 表示确认收到客户端的 SYN 包。该包包含服务器的初始序列号（Seq &#x3D; Y）和对客户端序列号的确认（Ack &#x3D; X + 1）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Server: SYN, ACK, Seq &#x3D; Y, Ack &#x3D; X + 1</code></pre>\n</li>\n<li><p><strong>第三次握手（ACK）</strong></p>\n<ul>\n<li>客户端收到服务器的 SYN-ACK 包后，发送一个 ACK 包给服务器，表示确认收到服务器的 SYN-ACK 包，并且连接建立成功。该包的确认号是服务器的序列号加 1（Ack &#x3D; Y + 1）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Client: ACK, Seq &#x3D; X + 1, Ack &#x3D; Y + 1</code></pre></li>\n</ol>\n<p>完成三次握手后，客户端和服务器之间的连接就建立起来了，接下来可以进行数据传输。</p>\n<h3 id=\"四次挥手（Four-Way-Handshake）\"><a href=\"#四次挥手（Four-Way-Handshake）\" class=\"headerlink\" title=\"四次挥手（Four-Way Handshake）\"></a>四次挥手（Four-Way Handshake）</h3><p>四次挥手是 TCP 断开连接的过程，涉及客户端和服务器之间的四个步骤。</p>\n<ol>\n<li><p><strong>第一次挥手（FIN）</strong></p>\n<ul>\n<li>客户端发送一个 FIN（结束序列号）包，表示不再发送数据，但仍然可以接收数据。该包包含一个序列号（Seq &#x3D; U）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Client: FIN, Seq &#x3D; U</code></pre>\n</li>\n<li><p><strong>第二次挥手（ACK）</strong></p>\n<ul>\n<li>服务器收到 FIN 包后，回应一个 ACK 包，表示确认收到客户端的 FIN 包。该包的确认号是客户端的序列号加 1（Ack &#x3D; U + 1）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Server: ACK, Seq &#x3D; V, Ack &#x3D; U + 1</code></pre>\n</li>\n<li><p><strong>第三次挥手（FIN）</strong></p>\n<ul>\n<li>服务器发送一个 FIN 包，表示不再发送数据。该包包含一个序列号（Seq &#x3D; W）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Server: FIN, Seq &#x3D; W</code></pre>\n</li>\n<li><p><strong>第四次挥手（ACK）</strong></p>\n<ul>\n<li>客户端收到服务器的 FIN 包后，回应一个 ACK 包，表示确认收到服务器的 FIN 包，并且连接终止。该包的确认号是服务器的序列号加 1（Ack &#x3D; W + 1）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Client: ACK, Seq &#x3D; U + 1, Ack &#x3D; W + 1</code></pre></li>\n</ol>\n<p>完成四次挥手后，客户端和服务器之间的连接就断开了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>三次握手</strong>用于建立可靠的 TCP 连接，确保双方都准备好进行数据传输。</li>\n<li><strong>四次挥手</strong>用于优雅地关闭 TCP 连接，确保双方都同意断开连接，并且所有数据都已正确接收。</li>\n</ul>\n<p>理解三次握手和四次挥手对于掌握 TCP 协议和网络编程至关重要，能够帮助你更好地处理网络连接问题和优化网络通信。</p>\n","text":"浏览器原理什么是 XSS 攻击？XSS（Cross-Site Scripting）攻击，即跨站脚本攻击，是指攻击者通过在目标网站上注入恶意脚本，当用户浏览该页面时，恶意脚本会在用户的浏览器上执行，从而盗取用户信息、篡改网页内容、进行钓鱼攻击等。 如何防御 XSS 攻击？ 输入验证...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">浏览器原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">什么是 XSS 攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">如何防御 XSS 攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">什么是 CSRF 攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">如何防御 CSRF 攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">什么是中间人攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F\"><span class=\"toc-text\">如何防范中间人攻击？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">有哪些可能引起前端安全的问题?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F\"><span class=\"toc-text\">网络劫持有哪几种，如何防范？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DNS%E5%8A%AB%E6%8C%81\"><span class=\"toc-text\">DNS劫持</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ARP%E6%AC%BA%E9%AA%97\"><span class=\"toc-text\">ARP欺骗</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IP-Spoofing\"><span class=\"toc-text\">IP Spoofing</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSLStrip\"><span class=\"toc-text\">SSLStrip</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Session-Hijacking\"><span class=\"toc-text\">Session Hijacking</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对浏览器的缓存机制的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">浏览器资源缓存的位置有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%92%8C%E5%BC%BA%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">协商缓存和强缓存的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%EF%BC%9F\"><span class=\"toc-text\">为什么需要浏览器缓存？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%82%B9%E5%87%BB%E5%88%B7%E6%96%B0%E6%8C%89%E9%92%AE%E6%88%96%E8%80%85%E6%8C%89-F5%E3%80%81%E6%8C%89-Ctrl-F5%EF%BC%88%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%EF%BC%89%E3%80%81%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%9B%9E%E8%BD%A6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">点击刷新按钮或者按 F5、按 Ctrl+F5（强制刷新）、地址栏回车有什么区别？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%82%B9%E5%87%BB%E5%88%B7%E6%96%B0%E6%8C%89%E9%92%AE%E6%88%96%E6%8C%89-F5\"><span class=\"toc-text\">点击刷新按钮或按 F5</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89-Ctrl-F5%EF%BC%88%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%EF%BC%89\"><span class=\"toc-text\">按 Ctrl+F5（强制刷新）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%9B%9E%E8%BD%A6\"><span class=\"toc-text\">地址栏回车</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对浏览器的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对浏览器内核的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">常见的浏览器内核比较</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E5%86%85%E6%A0%B8\"><span class=\"toc-text\">常见浏览器所用内核</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">浏览器的主要组成部分</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">浏览器渲染原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">浏览器渲染过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">浏览器渲染优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0-JS-%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">渲染过程中遇到 JS 文件如何处理？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3%E7%9A%84%E9%A2%84%E8%A7%A3%E6%9E%90%EF%BC%9F\"><span class=\"toc-text\">什么是文档的预解析？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-%E5%A6%82%E4%BD%95%E9%98%BB%E5%A1%9E%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90%EF%BC%9F\"><span class=\"toc-text\">CSS 如何阻塞文档解析？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%EF%BC%9F\"><span class=\"toc-text\">如何优化关键渲染路径？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E9%98%BB%E5%A1%9E%E6%B8%B2%E6%9F%93%EF%BC%9F\"><span class=\"toc-text\">什么情况会阻塞渲染？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">浏览器本地存储方式及使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie\"><span class=\"toc-text\">Cookie</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LocalStorage\"><span class=\"toc-text\">LocalStorage</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SessionStorage\"><span class=\"toc-text\">SessionStorage</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IndexedDB\"><span class=\"toc-text\">IndexedDB</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cookie%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">Cookie有哪些字段及其作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cookie%E3%80%81LocalStorage%E3%80%81SessionStorage%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Cookie、LocalStorage、SessionStorage区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E5%82%A8%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">前端储存的方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IndexedDB%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">IndexedDB的特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">什么是同源策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">如何解决跨域问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%EF%BC%9F\"><span class=\"toc-text\">事件是什么？事件模型？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1\"><span class=\"toc-text\">如何阻止事件冒泡</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对事件委托的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">事件委托的使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">同步和异步的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对事件循环的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">宏任务和微任务分别有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E6%A0%88\"><span class=\"toc-text\">什么是执行栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Node-js-%E4%B8%AD%E7%9A%84-Event-Loop-%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9Fprocess-nextTick-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F\"><span class=\"toc-text\">Node.js 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">事件触发的过程是怎样的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84\"><span class=\"toc-text\">V8的垃圾回收机制是怎样的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1. 分代回收机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0\"><span class=\"toc-text\">2. 引用计数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A2%9E%E9%87%8F%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">3. 并发与增量回收</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%81%9C%E9%A1%BF%EF%BC%88Stop-The-World%EF%BC%89\"><span class=\"toc-text\">4. 停顿（Stop-The-World）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">哪些操作会造成内存泄漏</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">1. 全局变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">2. 循环引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%9C%AA%E6%B8%85%E7%90%86%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8\"><span class=\"toc-text\">3. 未清理的事件监听器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%A2%AB%E9%81%97%E5%BF%98%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%88%96%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">4. 被遗忘的定时器或回调</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-DOM%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">5. DOM元素引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E7%BC%93%E5%AD%98%E4%B8%8D%E5%BD%93\"><span class=\"toc-text\">6. 缓存不当</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-V8%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5\"><span class=\"toc-text\">7. V8的特殊情况</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">TCP的三次握手和四次挥手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88Three-Way-Handshake%EF%BC%89\"><span class=\"toc-text\">三次握手（Three-Way Handshake）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88Four-Way-Handshake%EF%BC%89\"><span class=\"toc-text\">四次挥手（Four-Way Handshake）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"interview-micro-front-end","uid":"2c8643e8bed9de396ca80bda6705cbc6","slug":"interview-micro-front-end","date":"2024-05-30T15:02:59.000Z","updated":"2024-06-04T12:09:01.635Z","comments":true,"path":"api/articles/interview-micro-front-end.json","keywords":null,"cover":null,"text":"微前端微前端概念详细解析微前端（Micro Frontend）是一种现代Web开发架构理念，它借鉴了微服务的思想，将原本庞大的前端应用拆分为多个小型、独立可部署的微应用集合。每个微应用都是一个完整的功能单元，拥有自己的业务逻辑、UI组件、数据管理、路由系统甚至开发团队。这些微应用...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"interview-computer-network","uid":"888bd5308fbcbb0b07f6bb2fddc55ca5","slug":"interview-computer-network","date":"2024-05-30T15:00:54.000Z","updated":"2024-06-04T06:39:25.229Z","comments":true,"path":"api/articles/interview-computer-network.json","keywords":null,"cover":null,"text":"计算机网络GET和POST的请求的区别 数据位置：GET请求将参数附加在URL中，作为查询字符串；POST请求将参数放在请求体（request body）中。 数据大小：GET请求受URL长度限制，不适合传输大量数据；POST请求理论上无大小限制，更适合大数据量传输。 幂等性：G...","link":"","photos":[],"count_time":{"symbolsCount":"8.7k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}}}