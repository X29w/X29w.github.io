{"title":"interview-typescript","uid":"b868df7e10c8c1094284a225631a6d16","slug":"interview-typescript","date":"2024-06-04T06:31:14.000Z","updated":"2024-06-04T06:32:11.859Z","comments":true,"path":"api/articles/interview-typescript.json","keywords":null,"cover":null,"content":"<h1 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h1><h2 id=\"为什么要使用-TypeScript\"><a href=\"#为什么要使用-TypeScript\" class=\"headerlink\" title=\"为什么要使用 TypeScript?\"></a>为什么要使用 TypeScript?</h2><p>TypeScript 是 JavaScript 的一个超集，它在 JS 的基础上添加了静态类型系统和其他一些增强功能，旨在提高代码的可维护性、可读性和开发效率。使用 TypeScript 的主要优势包括：</p>\n<ol>\n<li><strong>静态类型检查</strong>：在编码阶段就能发现类型错误，减少运行时错误。</li>\n<li><strong>代码编辑器支持</strong>：大多数现代IDE和编辑器对 TypeScript 提供了出色的代码补全、接口提示和错误检测。</li>\n<li><strong>易于维护和团队协作</strong>：类型注解使代码意图更加清晰，有助于团队成员理解代码结构。</li>\n<li><strong>未来JavaScript特性</strong>：TypeScript 支持很多即将成为标准的 ESNext 特性，如异步编程、装饰器等，让你提前享受新特性。</li>\n<li><strong>模块和命名空间</strong>：提供了更好的模块化支持，有助于组织大型代码库。</li>\n</ol>\n<h2 id=\"TypeScript-相对于-JavaScript-的优势\"><a href=\"#TypeScript-相对于-JavaScript-的优势\" class=\"headerlink\" title=\"TypeScript 相对于 JavaScript 的优势\"></a>TypeScript 相对于 JavaScript 的优势</h2><ul>\n<li><strong>类型安全性</strong>：减少因类型错误引起的运行时bug。</li>\n<li><strong>开发工具集成</strong>：丰富的IDE支持，如智能提示、重构支持等。</li>\n<li><strong>编译时检查</strong>：通过编译时发现潜在错误，提高代码质量。</li>\n<li><strong>易于规模化</strong>：适合大型项目，有利于维护和扩展。</li>\n</ul>\n<h2 id=\"const-和-readonly-的区别\"><a href=\"#const-和-readonly-的区别\" class=\"headerlink\" title=\"const 和 readonly 的区别\"></a>const 和 readonly 的区别</h2><ul>\n<li><strong>const</strong>：是一个变量声明关键字，表示声明的变量不可重新赋值，但是如果是对象或数组，其内部属性或元素是可以修改的。</li>\n<li><strong>readonly</strong>：是一个属性修饰符，用于类的属性上，表示该属性一旦被初始化后就不可更改。</li>\n</ul>\n<h2 id=\"枚举和常量枚举的区别\"><a href=\"#枚举和常量枚举的区别\" class=\"headerlink\" title=\"枚举和常量枚举的区别\"></a>枚举和常量枚举的区别</h2><ul>\n<li><strong>枚举（enum）</strong>：提供了一种定义一组命名常量的方式。枚举值默认是从0开始递增的数字，但也可以自定义。</li>\n<li><strong>常量枚举（const enums）</strong>：在编译阶段会被替换为字面量值，不会生成任何运行时代码，提高性能。常量枚举的成员只能是字符串或数字字面量。</li>\n</ul>\n<h2 id=\"接口和类型别名的区别\"><a href=\"#接口和类型别名的区别\" class=\"headerlink\" title=\"接口和类型别名的区别\"></a>接口和类型别名的区别</h2><ul>\n<li><strong>接口（interface）</strong>：用于描述对象的形状，可以用来定义函数参数、返回值类型或实现类的契约。接口可以被继承和实现。</li>\n<li><strong>类型别名（type alias）</strong>：为已存在的类型提供一个新的名字，可以是任何类型表达式，包括联合类型、元组类型等。类型别名不支持实现或继承。</li>\n</ul>\n<h2 id=\"TypeScript-中-any-类型的作用\"><a href=\"#TypeScript-中-any-类型的作用\" class=\"headerlink\" title=\"TypeScript 中 any 类型的作用\"></a>TypeScript 中 any 类型的作用</h2><p><code>any</code> 类型表示可以是任意类型，使用它可以绕过类型检查。通常在不确定类型或需要兼容旧的 JavaScript 代码时使用，但过度使用会削弱类型安全。</p>\n<h2 id=\"any、never、unknown、null-amp-undefined-和-void-的区别\"><a href=\"#any、never、unknown、null-amp-undefined-和-void-的区别\" class=\"headerlink\" title=\"any、never、unknown、null &amp; undefined 和 void 的区别\"></a>any、never、unknown、null &amp; undefined 和 void 的区别</h2><ul>\n<li><strong>any</strong>：可以代表任何类型，绕过类型检查。</li>\n<li><strong>never</strong>：表示永远不会出现的值的类型，用于函数永远抛出异常或永不停止执行的情况。</li>\n<li><strong>unknown</strong>：表示未知类型的值，比 any 更安全，因为需要显式类型断言才能使用。</li>\n<li><strong>null &amp; undefined</strong>：代表空值或未定义值，TypeScript 中可以单独或一起作为类型使用。</li>\n<li><strong>void</strong>：表示没有任何返回值的函数的返回类型。</li>\n</ul>\n<h2 id=\"TypeScript-中-type-和-interface-的区别\"><a href=\"#TypeScript-中-type-和-interface-的区别\" class=\"headerlink\" title=\"TypeScript 中 type 和 interface 的区别\"></a>TypeScript 中 type 和 interface 的区别</h2><ul>\n<li><strong>type</strong>：更灵活，可以定义更复杂的类型，如联合类型、元组类型、映射类型等，但不能用于实现或继承。</li>\n<li><strong>interface</strong>：主要用于描述对象结构，可以实现和继承，更适合定义对象、类或函数的形状。</li>\n</ul>\n<h2 id=\"工具类型的作用\"><a href=\"#工具类型的作用\" class=\"headerlink\" title=\"工具类型的作用\"></a>工具类型的作用</h2><ul>\n<li>**Exclude&lt;T, U&gt;**：从类型T中排除类型U的所有子类型。</li>\n<li>**Omit&lt;T, K&gt;**：从类型T中移除指定的一组键K。</li>\n<li>**Pick&lt;T, K&gt;**：从类型T中选取指定的一组键K组成新的类型。</li>\n<li>**Merge&lt;T, U&gt;**：合并类型T和U的属性，如果有同名属性，则U的属性会覆盖T的属性。</li>\n<li>**Intersection&lt;T, U&gt;**：取类型T和U的交集，即同时满足T和U的所有属性。</li>\n<li>**Overwrite&lt;T, U&gt;**：类似Merge，但U的属性会完全覆盖T的相同属性，而不是仅仅在冲突时覆盖。</li>\n</ul>\n<h2 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h2><p>方法重载允许在同一个类或接口中定义多个同名方法，但这些方法的参数列表必须不同（数量或类型），从而实现不同的功能。编译器会根据调用时的实际参数自动匹配合适的方法签名。</p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>泛型允许你在定义函数、接口或类的时候不预先指定具体的类型，而是在使用时根据传入的参数类型来推断或指定类型。这提高了代码的复用性和灵活性，减少了类型转换的需求。</p>\n<h2 id=\"TypeScript-底层转为JS\"><a href=\"#TypeScript-底层转为JS\" class=\"headerlink\" title=\"TypeScript 底层转为JS\"></a>TypeScript 底层转为JS</h2><p>TypeScript 通过编译器（tsc）将 TypeScript 代码转换为纯 JavaScript。这个过程包括：</p>\n<ul>\n<li><strong>类型检查</strong>：编译器首先检查代码中的类型错误。</li>\n<li><strong>类型擦除</strong>：由于JavaScript是动态类型语言，编译后的代码会移除所有的类型注解，确保JavaScript引擎能正确执行。</li>\n<li><strong>代码转换</strong>：将TypeScript的高级语法（如箭头函数、async&#x2F;await等）转换为ES5或ES6及以下版本的JavaScript，以保证浏览器或Node.js环境的兼容性。</li>\n<li><strong>输出</strong>：最终生成的JavaScript代码可以直接在浏览器或Node环境中运行，无需额外的TypeScript运行时支持。</li>\n</ul>\n","feature":true,"text":"TypeScript为什么要使用 TypeScript?TypeScript 是 JavaScript 的一个超集，它在 JS 的基础上添加了静态类型系统和其他一些增强功能，旨在提高代码的可维护性、可读性和开发效率。使用 TypeScript 的主要优势包括： 静态类型检查：在编...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TypeScript\"><span class=\"toc-text\">TypeScript</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-TypeScript\"><span class=\"toc-text\">为什么要使用 TypeScript?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TypeScript-%E7%9B%B8%E5%AF%B9%E4%BA%8E-JavaScript-%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">TypeScript 相对于 JavaScript 的优势</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#const-%E5%92%8C-readonly-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">const 和 readonly 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">枚举和常量枚举的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">接口和类型别名的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TypeScript-%E4%B8%AD-any-%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">TypeScript 中 any 类型的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#any%E3%80%81never%E3%80%81unknown%E3%80%81null-amp-undefined-%E5%92%8C-void-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">any、never、unknown、null &amp; undefined 和 void 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TypeScript-%E4%B8%AD-type-%E5%92%8C-interface-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">TypeScript 中 type 和 interface 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">工具类型的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">方法重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TypeScript-%E5%BA%95%E5%B1%82%E8%BD%AC%E4%B8%BAJS\"><span class=\"toc-text\">TypeScript 底层转为JS</span></a></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"interview-mobx","uid":"4cdce0b942af62337249f099a631de6a","slug":"interview-mobx","date":"2024-06-04T06:32:54.000Z","updated":"2024-06-04T06:36:50.710Z","comments":true,"path":"api/articles/interview-mobx.json","keywords":null,"cover":null,"text":"Mobx好的，作为“面试官”，我会从基础知识到进阶原理来设计一些关于MobX的面试问题，并提供相应的详细答案。MobX是一个非常受欢迎的状态管理库，用于JavaScript应用，特别是React应用中，它通过透明的函数式编程和自动追踪依赖关系简化了状态管理。 Mobx的原理是什么...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"interview-scence","uid":"2ced64525a6917341326d68b910b07f6","slug":"interview-scence","date":"2024-06-04T03:11:54.000Z","updated":"2024-06-04T03:13:35.443Z","comments":true,"path":"api/articles/interview-scence.json","keywords":null,"cover":null,"text":"场景题如何利用tailwind css进行网站的一键换肤利用 Tailwind CSS 实现网站的一键换肤，可以通过动态修改 Tailwind 的配置来改变主题色彩。以下是实现一键换肤的步骤： 1. Tailwind CSS 配置首先，在 tailwind.config.js 中...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}