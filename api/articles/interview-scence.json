{"title":"interview-scence","uid":"2ced64525a6917341326d68b910b07f6","slug":"interview-scence","date":"2024-06-04T03:11:54.000Z","updated":"2024-06-04T03:13:35.443Z","comments":true,"path":"api/articles/interview-scence.json","keywords":null,"cover":null,"content":"<h1 id=\"场景题\"><a href=\"#场景题\" class=\"headerlink\" title=\"场景题\"></a>场景题</h1><h2 id=\"如何利用tailwind-css进行网站的一键换肤\"><a href=\"#如何利用tailwind-css进行网站的一键换肤\" class=\"headerlink\" title=\"如何利用tailwind css进行网站的一键换肤\"></a>如何利用tailwind css进行网站的一键换肤</h2><p>利用 Tailwind CSS 实现网站的一键换肤，可以通过动态修改 Tailwind 的配置来改变主题色彩。以下是实现一键换肤的步骤：</p>\n<h3 id=\"1-Tailwind-CSS-配置\"><a href=\"#1-Tailwind-CSS-配置\" class=\"headerlink\" title=\"1. Tailwind CSS 配置\"></a>1. Tailwind CSS 配置</h3><p>首先，在 <code>tailwind.config.js</code> 中定义不同主题的配色方案：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; tailwind.config.js\nmodule.exports &#x3D; &#123;\n  darkMode: &#39;class&#39;, &#x2F;&#x2F; 启用 class 模式的暗黑模式切换\n  theme: &#123;\n    extend: &#123;\n      colors: &#123;\n        light: &#123;\n          primary: &#39;#ff6347&#39;, &#x2F;&#x2F; 浅色主题的主色\n          secondary: &#39;#4caf50&#39;, &#x2F;&#x2F; 浅色主题的副色\n        &#125;,\n        dark: &#123;\n          primary: &#39;#1e3a8a&#39;, &#x2F;&#x2F; 深色主题的主色\n          secondary: &#39;#f43f5e&#39;, &#x2F;&#x2F; 深色主题的副色\n        &#125;,\n      &#125;,\n    &#125;,\n  &#125;,\n  variants: &#123;\n    extend: &#123;\n      backgroundColor: [&#39;dark&#39;],\n      textColor: [&#39;dark&#39;],\n    &#125;,\n  &#125;,\n  plugins: [],\n&#125;;</code></pre>\n\n<h3 id=\"2-定义主题切换按钮\"><a href=\"#2-定义主题切换按钮\" class=\"headerlink\" title=\"2. 定义主题切换按钮\"></a>2. 定义主题切换按钮</h3><p>在 HTML 文件中添加一个主题切换按钮，并添加点击事件处理：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;link href&#x3D;&quot;dist&#x2F;output.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n  &lt;title&gt;Tailwind CSS 一键换肤&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body class&#x3D;&quot;light&quot;&gt;\n  &lt;div class&#x3D;&quot;container mx-auto&quot;&gt;\n    &lt;button id&#x3D;&quot;themeToggle&quot; class&#x3D;&quot;p-2 bg-light-primary text-white&quot;&gt;\n      切换主题\n    &lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script src&#x3D;&quot;theme-switcher.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<h3 id=\"3-实现主题切换功能\"><a href=\"#3-实现主题切换功能\" class=\"headerlink\" title=\"3. 实现主题切换功能\"></a>3. 实现主题切换功能</h3><p>在 JavaScript 文件中实现主题切换功能：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; theme-switcher.js\nconst themeToggle &#x3D; document.getElementById(&#39;themeToggle&#39;);\nconst body &#x3D; document.body;\n\nthemeToggle.addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123;\n  if (body.classList.contains(&#39;light&#39;)) &#123;\n    body.classList.remove(&#39;light&#39;);\n    body.classList.add(&#39;dark&#39;);\n    themeToggle.classList.remove(&#39;bg-light-primary&#39;);\n    themeToggle.classList.add(&#39;bg-dark-primary&#39;);\n  &#125; else &#123;\n    body.classList.remove(&#39;dark&#39;);\n    body.classList.add(&#39;light&#39;);\n    themeToggle.classList.remove(&#39;bg-dark-primary&#39;);\n    themeToggle.classList.add(&#39;bg-light-primary&#39;);\n  &#125;\n&#125;);</code></pre>\n\n<h3 id=\"4-使用-Tailwind-CSS-类进行样式应用\"><a href=\"#4-使用-Tailwind-CSS-类进行样式应用\" class=\"headerlink\" title=\"4. 使用 Tailwind CSS 类进行样式应用\"></a>4. 使用 Tailwind CSS 类进行样式应用</h3><p>在 HTML 文件中使用 Tailwind CSS 类进行样式应用：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;link href&#x3D;&quot;dist&#x2F;output.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;\n  &lt;title&gt;Tailwind CSS 一键换肤&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body class&#x3D;&quot;light&quot;&gt;\n  &lt;div class&#x3D;&quot;container mx-auto&quot;&gt;\n    &lt;button id&#x3D;&quot;themeToggle&quot; class&#x3D;&quot;p-2 bg-light-primary text-white&quot;&gt;\n      切换主题\n    &lt;&#x2F;button&gt;\n    &lt;div class&#x3D;&quot;p-4 text-light-secondary dark:text-dark-secondary&quot;&gt;\n      这是一个示例内容。\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script src&#x3D;&quot;theme-switcher.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<h3 id=\"5-编译-Tailwind-CSS\"><a href=\"#5-编译-Tailwind-CSS\" class=\"headerlink\" title=\"5. 编译 Tailwind CSS\"></a>5. 编译 Tailwind CSS</h3><p>最后，使用 Tailwind CSS 编译工具生成最终的 CSS 文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npx tailwindcss -o dist&#x2F;output.css --watch</code></pre>\n\n<p>通过上述步骤，你就可以使用 Tailwind CSS 实现网站的一键换肤功能了。这个方法利用了 Tailwind 的配置和类切换机制，使得主题切换更加灵活和高效。</p>\n<h2 id=\"大文件上传\"><a href=\"#大文件上传\" class=\"headerlink\" title=\"大文件上传\"></a>大文件上传</h2><p>在前端进行大文件上传时，需要考虑多方面的因素，包括用户体验、网络可靠性、服务器压力等。常见的解决方案包括文件分片上传、断点续传、并行上传等。以下是实现大文件上传的详细步骤和相关代码示例。</p>\n<h3 id=\"大文件上传的关键步骤\"><a href=\"#大文件上传的关键步骤\" class=\"headerlink\" title=\"大文件上传的关键步骤\"></a>大文件上传的关键步骤</h3><ol>\n<li><strong>文件分片</strong>：将大文件分成多个小片段（chunk），逐个上传，以减少单次上传的时间和出错风险。</li>\n<li><strong>并行上传</strong>：同时上传多个分片，提高上传效率。</li>\n<li><strong>断点续传</strong>：上传过程中若发生中断，可以从上次中断的位置继续上传，而不需要重新上传整个文件。</li>\n<li><strong>上传进度显示</strong>：实时显示上传进度，提升用户体验。</li>\n</ol>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><h4 id=\"1-文件分片\"><a href=\"#1-文件分片\" class=\"headerlink\" title=\"1. 文件分片\"></a>1. 文件分片</h4><p>首先，将大文件分割成小片段。以下代码演示了如何将文件分片：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function sliceFile(file, chunkSize) &#123;\n  const chunks &#x3D; [];\n  let start &#x3D; 0;\n  while (start &lt; file.size) &#123;\n    const end &#x3D; Math.min(start + chunkSize, file.size);\n    chunks.push(file.slice(start, end));\n    start &#x3D; end;\n  &#125;\n  return chunks;\n&#125;</code></pre>\n\n<h4 id=\"2-并行上传\"><a href=\"#2-并行上传\" class=\"headerlink\" title=\"2. 并行上传\"></a>2. 并行上传</h4><p>利用<code>Promise.all</code>同时上传多个分片，并在上传完成后通知服务器进行合并。以下是一个简单的并行上传示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function uploadChunks(chunks, uploadUrl) &#123;\n  const uploadPromises &#x3D; chunks.map((chunk, index) &#x3D;&gt; &#123;\n    const formData &#x3D; new FormData();\n    formData.append(&#39;file&#39;, chunk);\n    formData.append(&#39;chunkIndex&#39;, index);\n    \n    return fetch(uploadUrl, &#123;\n      method: &#39;POST&#39;,\n      body: formData,\n    &#125;).then(response &#x3D;&gt; response.json());\n  &#125;);\n\n  const results &#x3D; await Promise.all(uploadPromises);\n  return results;\n&#125;</code></pre>\n\n<h4 id=\"3-断点续传\"><a href=\"#3-断点续传\" class=\"headerlink\" title=\"3. 断点续传\"></a>3. 断点续传</h4><p>为了实现断点续传，需要在上传之前检查服务器上已上传的分片，并从中断的位置继续上传。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function getUploadedChunks(uploadUrl, fileName) &#123;\n  const response &#x3D; await fetch(&#96;$&#123;uploadUrl&#125;&#x2F;uploadedChunks?fileName&#x3D;$&#123;fileName&#125;&#96;);\n  const uploadedChunks &#x3D; await response.json();\n  return uploadedChunks;\n&#125;\n\nasync function resumeUpload(chunks, uploadedChunks, uploadUrl) &#123;\n  const uploadPromises &#x3D; chunks.map((chunk, index) &#x3D;&gt; &#123;\n    if (uploadedChunks.includes(index)) &#123;\n      return Promise.resolve(&#123; status: &#39;already uploaded&#39;, index &#125;);\n    &#125;\n    \n    const formData &#x3D; new FormData();\n    formData.append(&#39;file&#39;, chunk);\n    formData.append(&#39;chunkIndex&#39;, index);\n    \n    return fetch(uploadUrl, &#123;\n      method: &#39;POST&#39;,\n      body: formData,\n    &#125;).then(response &#x3D;&gt; response.json());\n  &#125;);\n\n  const results &#x3D; await Promise.all(uploadPromises);\n  return results;\n&#125;</code></pre>\n\n<h4 id=\"4-上传进度显示\"><a href=\"#4-上传进度显示\" class=\"headerlink\" title=\"4. 上传进度显示\"></a>4. 上传进度显示</h4><p>在上传过程中，实时显示上传进度，以提升用户体验。可以利用<code>XMLHttpRequest</code>或<code>fetch</code>的进度事件来实现。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function uploadWithProgress(chunks, uploadUrl, onProgress) &#123;\n  const totalChunks &#x3D; chunks.length;\n  let uploadedChunks &#x3D; 0;\n\n  const uploadPromises &#x3D; chunks.map((chunk, index) &#x3D;&gt; &#123;\n    const formData &#x3D; new FormData();\n    formData.append(&#39;file&#39;, chunk);\n    formData.append(&#39;chunkIndex&#39;, index);\n\n    return fetch(uploadUrl, &#123;\n      method: &#39;POST&#39;,\n      body: formData,\n    &#125;).then(response &#x3D;&gt; &#123;\n      uploadedChunks +&#x3D; 1;\n      onProgress(Math.round((uploadedChunks &#x2F; totalChunks) * 100));\n      return response.json();\n    &#125;);\n  &#125;);\n\n  const results &#x3D; await Promise.all(uploadPromises);\n  return results;\n&#125;\n\n&#x2F;&#x2F; Usage\nuploadWithProgress(chunks, uploadUrl, (progress) &#x3D;&gt; &#123;\n  console.log(&#96;Upload progress: $&#123;progress&#125;%&#96;);\n&#125;);</code></pre>\n\n<h3 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h3><p>结合上述步骤，实现一个完整的大文件上传功能：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const chunkSize &#x3D; 5 * 1024 * 1024; &#x2F;&#x2F; 5MB\n\nasync function uploadFile(file, uploadUrl) &#123;\n  const chunks &#x3D; sliceFile(file, chunkSize);\n  const uploadedChunks &#x3D; await getUploadedChunks(uploadUrl, file.name);\n\n  await resumeUpload(chunks, uploadedChunks, uploadUrl);\n\n  const mergeResponse &#x3D; await fetch(&#96;$&#123;uploadUrl&#125;&#x2F;merge&#96;, &#123;\n    method: &#39;POST&#39;,\n    headers: &#123;\n      &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,\n    &#125;,\n    body: JSON.stringify(&#123; fileName: file.name, totalChunks: chunks.length &#125;),\n  &#125;);\n\n  const result &#x3D; await mergeResponse.json();\n  return result;\n&#125;\n\n&#x2F;&#x2F; File input change event handler\ndocument.getElementById(&#39;fileInput&#39;).addEventListener(&#39;change&#39;, async (event) &#x3D;&gt; &#123;\n  const file &#x3D; event.target.files[0];\n  const uploadUrl &#x3D; &#39;https:&#x2F;&#x2F;your-upload-url.com&#x2F;upload&#39;;\n\n  const result &#x3D; await uploadFile(file, uploadUrl);\n  console.log(&#39;Upload result:&#39;, result);\n&#125;);</code></pre>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过文件分片、并行上传、断点续传和上传进度显示，可以实现一个高效、可靠的大文件上传功能。前端处理大文件上传时，需要考虑到网络波动、服务器压力等因素，通过上述技术手段可以大大提升用户体验和上传成功率。</p>\n<h2 id=\"如何理解前端工程化\"><a href=\"#如何理解前端工程化\" class=\"headerlink\" title=\"如何理解前端工程化\"></a>如何理解前端工程化</h2><p>前端工程化是指在前端开发中应用一系列的工程化手段和工具，以提高开发效率、代码质量和团队协作能力。前端工程化的目的是将前端开发过程规范化、自动化、模块化和工具化，使得前端开发更加高效和可靠。</p>\n<h3 id=\"前端工程化的核心要素\"><a href=\"#前端工程化的核心要素\" class=\"headerlink\" title=\"前端工程化的核心要素\"></a>前端工程化的核心要素</h3><ol>\n<li><p><strong>模块化</strong></p>\n<ul>\n<li>将代码分解成独立、可复用的模块，每个模块完成特定的功能，减少代码耦合度。</li>\n<li>使用ES6的模块系统（<code>import</code>&#x2F;<code>export</code>），或者使用模块打包工具（如Webpack、Rollup）来管理模块依赖。</li>\n</ul>\n</li>\n<li><p><strong>组件化</strong></p>\n<ul>\n<li>通过将UI拆分成独立的组件，每个组件包含自己的样式、逻辑和视图，便于开发、维护和复用。</li>\n<li>使用现代前端框架（如React、Vue、Angular）进行组件化开发。</li>\n</ul>\n</li>\n<li><p><strong>自动化</strong></p>\n<ul>\n<li>自动化的构建、测试、部署流程，减少人为错误，提高开发效率。</li>\n<li>使用构建工具（如Webpack、Gulp）进行代码打包、压缩、优化。</li>\n<li>使用任务管理工具（如NPM Scripts）自动化常见的开发任务。</li>\n<li>持续集成（CI）工具（如Jenkins、GitHub Actions）自动化测试和部署流程。</li>\n</ul>\n</li>\n<li><p><strong>规范化</strong></p>\n<ul>\n<li>代码风格、命名规范、文件组织结构的一致性，保证团队协作中的代码质量和可维护性。</li>\n<li>使用代码格式化工具（如Prettier）和代码检查工具（如ESLint）来保持代码风格一致。</li>\n</ul>\n</li>\n<li><p><strong>版本控制</strong></p>\n<ul>\n<li>使用版本控制系统（如Git）管理代码历史、分支和合并，便于多人协作和代码回溯。</li>\n<li>制定合理的分支策略（如Git Flow）和代码评审流程，保证代码质量和稳定性。</li>\n</ul>\n</li>\n<li><p><strong>性能优化</strong></p>\n<ul>\n<li>通过代码拆分（Code Splitting）、懒加载（Lazy Loading）、资源压缩（Minification）、缓存（Caching）等手段优化前端性能。</li>\n<li>使用性能监控工具（如Lighthouse、WebPageTest）定期检查和优化应用的性能表现。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"前端工程化的工具和技术\"><a href=\"#前端工程化的工具和技术\" class=\"headerlink\" title=\"前端工程化的工具和技术\"></a>前端工程化的工具和技术</h3><ol>\n<li><p><strong>构建工具</strong></p>\n<ul>\n<li><strong>Webpack</strong>：流行的模块打包工具，支持代码拆分、热加载等功能。</li>\n<li><strong>Gulp</strong>：基于流的构建工具，适合处理复杂的自动化任务。</li>\n<li><strong>Rollup</strong>：专注于构建库的模块打包工具，生成更小的包。</li>\n</ul>\n</li>\n<li><p><strong>任务管理工具</strong></p>\n<ul>\n<li><strong>NPM Scripts</strong>：通过<code>package.json</code>中的<code>scripts</code>字段定义和执行常见任务。</li>\n<li><strong>Grunt</strong>：基于任务的JavaScript任务管理工具。</li>\n</ul>\n</li>\n<li><p><strong>代码质量工具</strong></p>\n<ul>\n<li><strong>ESLint</strong>：JavaScript代码检查工具，帮助发现和修复代码中的问题。</li>\n<li><strong>Prettier</strong>：代码格式化工具，自动格式化代码以保持一致的代码风格。</li>\n</ul>\n</li>\n<li><p><strong>持续集成&#x2F;持续部署（CI&#x2F;CD）工具</strong></p>\n<ul>\n<li><strong>Jenkins</strong>：开源的自动化服务器，支持各种CI&#x2F;CD流程。</li>\n<li><strong>GitHub Actions</strong>：GitHub的CI&#x2F;CD服务，集成在GitHub平台上，易于配置和使用。</li>\n<li><strong>Travis CI</strong>：与GitHub紧密集成的CI服务，支持多种语言和平台。</li>\n</ul>\n</li>\n<li><p><strong>前端框架和库</strong></p>\n<ul>\n<li><strong>React</strong>：由Facebook开发的用于构建用户界面的库，强调组件化和声明式编程。</li>\n<li><strong>Vue</strong>：渐进式前端框架，易于上手，支持组件化和响应式数据绑定。</li>\n<li><strong>Angular</strong>：由Google开发的前端框架，提供完整的解决方案，适合大型应用开发。</li>\n</ul>\n</li>\n<li><p><strong>包管理工具</strong></p>\n<ul>\n<li><strong>npm</strong>：Node.js的包管理工具，是前端开发的基础设施之一。</li>\n<li><strong>Yarn</strong>：Facebook推出的包管理工具，强调速度和一致性。</li>\n<li><strong>pnpm</strong>：高效的包管理工具，具有更快的安装速度和更小的磁盘占用。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>前端工程化是一个系统化的过程，涉及代码的组织、工具的使用和流程的优化。通过前端工程化，可以提高开发效率、保证代码质量、增强团队协作能力，从而构建出更稳定、更高效的前端应用。了解并掌握前端工程化的各个方面和工具，对于现代前端开发者来说是至关重要的。</p>\n","feature":true,"text":"场景题如何利用tailwind css进行网站的一键换肤利用 Tailwind CSS 实现网站的一键换肤，可以通过动态修改 Tailwind 的配置来改变主题色彩。以下是实现一键换肤的步骤： 1. Tailwind CSS 配置首先，在 tailwind.config.js 中...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF%E9%A2%98\"><span class=\"toc-text\">场景题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8tailwind-css%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E7%9A%84%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4\"><span class=\"toc-text\">如何利用tailwind css进行网站的一键换肤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Tailwind-CSS-%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1. Tailwind CSS 配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E6%8C%89%E9%92%AE\"><span class=\"toc-text\">2. 定义主题切换按钮</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E7%8E%B0%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">3. 实现主题切换功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8-Tailwind-CSS-%E7%B1%BB%E8%BF%9B%E8%A1%8C%E6%A0%B7%E5%BC%8F%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4. 使用 Tailwind CSS 类进行样式应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%BC%96%E8%AF%91-Tailwind-CSS\"><span class=\"toc-text\">5. 编译 Tailwind CSS</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">大文件上传</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">大文件上传的关键步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">实现步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87\"><span class=\"toc-text\">1. 文件分片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%B9%B6%E8%A1%8C%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">2. 并行上传</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0\"><span class=\"toc-text\">3. 断点续传</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6%E6%98%BE%E7%A4%BA\"><span class=\"toc-text\">4. 上传进度显示</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">完整示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96\"><span class=\"toc-text\">如何理解前端工程化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0\"><span class=\"toc-text\">前端工程化的核心要素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">前端工程化的工具和技术</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"interview-typescript","uid":"b868df7e10c8c1094284a225631a6d16","slug":"interview-typescript","date":"2024-06-04T06:31:14.000Z","updated":"2024-06-04T11:36:29.411Z","comments":true,"path":"api/articles/interview-typescript.json","keywords":null,"cover":null,"text":"TypeScript为什么要使用 TypeScript?TypeScript 是 JavaScript 的一个超集，它在 JS 的基础上添加了静态类型系统和其他一些增强功能，旨在提高代码的可维护性、可读性和开发效率。使用 TypeScript 的主要优势包括： 静态类型检查：在编...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"interview-micro-front-end","uid":"2c8643e8bed9de396ca80bda6705cbc6","slug":"interview-micro-front-end","date":"2024-05-30T15:02:59.000Z","updated":"2024-06-04T12:09:01.635Z","comments":true,"path":"api/articles/interview-micro-front-end.json","keywords":null,"cover":null,"text":"微前端微前端概念详细解析微前端（Micro Frontend）是一种现代Web开发架构理念，它借鉴了微服务的思想，将原本庞大的前端应用拆分为多个小型、独立可部署的微应用集合。每个微应用都是一个完整的功能单元，拥有自己的业务逻辑、UI组件、数据管理、路由系统甚至开发团队。这些微应用...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}}}