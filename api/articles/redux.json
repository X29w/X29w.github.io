{"title":"Redux","uid":"0af45ef14bc511045b195273be18640c","slug":"redux","date":"2023-03-24T12:29:23.000Z","updated":"2023-03-24T12:33:42.595Z","comments":true,"path":"api/articles/redux.json","keywords":null,"cover":"https://th.bing.com/th/id/R.a3118e1ca33fffdf56eb9f49842e2779?rik=PXEmnkjI%2f6z19w&riu=http%3a%2f%2fninjadolinux.com.br%2fwp-content%2fuploads%2f2020%2f06%2fredux-cover-imgage.jpg&ehk=rKuob5QbPfHZBBYTxsJ5dPI3MoSbsY7oZ6cqUZi02sk%3d&risl=&pid=ImgRaw&r=0","content":"<h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><ul>\n<li>我们先明晰 Redux 的作用 ，实现集中式状态管理。</li>\n<li>Redux 适用于多交互、多数据源的场景。简单理解就是复杂</li>\n<li>从组件角度去考虑的话，当我们有以下的应用场景时，我们可以尝试采用 Redux 来实现</li>\n<li>某个组件的状态需要共享时</li>\n<li>一个组件需要改变其他组件的状态时</li>\n<li>一个组件需要改变全局的状态时</li>\n<li>除此之外，还有很多情况都需要使用 Redux 来实现</li>\n</ul>\n<img src=\"https://camo.githubusercontent.com/fff0da4b9407b914a56a380f29d84e77e873081ff4ee074256952cc850b29e4e/68747470733a2f2f6c6a63696d672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f696d6167652d32303231303930393139343434363938382e706e67\"/>\n\n<p>这张图，非常形象的将纯 React 和 采用 Redux 的区别体现了出来</p>\n<h2 id=\"Redux-的工作流程\"><a href=\"#Redux-的工作流程\" class=\"headerlink\" title=\"Redux 的工作流程\"></a>Redux 的工作流程</h2><img src=\"https://camo.githubusercontent.com/2812b487bd1531f405247c152855fe2eff3d1a5705e78f811d29f43e95376d27/68747470733a2f2f6c6a63696d672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f696d6167652d32303231303930393139343930303533322e706e67\"/>\n\n<p>首先组件会在 <code>Redux</code> 中派发一个 <code>action</code> 方法，通过调用 <code>store.dispatch</code> 方法，将 <code>action</code> 对象派发给 <code>store</code> ，当 <code>store</code> 接收到 <code>action</code> 对象时，会将先前的 <code>state</code> 与传来的 <code>action</code> 一同发送给 <code>reducer</code> <code>，reducer</code> 在接收到数据后，进行数据的更改，返回一个新的状态给 <code>store</code> ，最后由 <code>store</code> 更改 <code>state</code></p>\n<img src=\"https://camo.githubusercontent.com/40847f53b451a68ad0e0e600352512f9effb957378a2206de49f66815d978373/68747470733a2f2f70312d6a6a2e62797465696d672e636f6d2f746f732d636e2d692d74326f616761326173782f676f6c642d757365722d6173736574732f323031392f31312f31322f313665356664313539376661656334647e74706c762d74326f616761326173782d77617465726d61726b2e6177656270\" />\n\n<h2 id=\"Redux-三个核心概念\"><a href=\"#Redux-三个核心概念\" class=\"headerlink\" title=\"Redux 三个核心概念\"></a>Redux 三个核心概念</h2><h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>store</code> 是 <code>Redux</code> 的核心，可以理解为是 <code>Redux</code> 的数据中台，我们可以将任何我们想要存放的数据放在 <code>store</code> 中，在我们需要使用这些数据时，我们可以从中取出相应的数据。因此我们需要先创建一个 <code>store</code> ，在 Redux 中可以使用 <code>createStore API</code> 来创建一个 <code>store</code></p></blockquote>\n<p>在生产中，我们需要在 <code>src</code> 目录下的 <code>redux</code> 文件夹中新增一个 <code>store.js</code> 文件，在这个文件中，创建一个 <code>store</code> 对象，并暴露它</p>\n<p>因此我们需要从 redux 中暴露两个方法</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123;\n    createStore,\n    applyMiddleware\n&#125; from &#39;redux&#39;</code></pre>\n\n<p>并引入为 count 组件服务的 reducer</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import countReducer from &#39;.&#x2F;count_reducer&#39;</code></pre>\n<p>最后调用 createStore 方法来暴露 store</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export default createStore(countReducer, applyMiddleware(thunk))</code></pre>\n\n<p>在 <code>store</code> 对象下有一些常用的内置方法</p>\n<p>获取当前时刻的 <code>store</code> ，我们可以采用 <code>getStore</code> 方法</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const state &#x3D; store.getState();</code></pre>\n\n<p>在前面我们的流程图中，我们需要通过 store 中的 dispatch 方法来派生一个 <code>action</code> 对象给 <code>store</code></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">store.dispatch(&#96;action对象&#96;)</code></pre>\n\n<p>最后还有一个 <code>subscribe</code> 方法，这个方法可以帮助我们订阅 <code>store</code> 的改变，只要 <code>store</code> 发生改变，这个方法的回调就会执行</p>\n<p>为了监听数据的更新，我们可以将 <code>subscribe</code> 方法绑定在组件挂载完毕生命周期函数上，但是这样，当我们的组件数量很多时，会比较的麻烦，因此我们可以直接将 <code>subscribe</code> 函数用来监听整个 App组件的变化</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">store.subscribe(() &#x3D;&gt; &#123;\n    ReactDOM.render( &lt; App &#x2F;&gt; , document.getElementById(&#39;root&#39;))\n&#125;)</code></pre>\n\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p><code>action</code> 是 <code>store</code> 中唯一的数据来源，一般来说，我们会通过调用 <code>store.dispatch</code> 将 <code>action</code> 传到 <code>store</code><br>我们需要传递的 <code>action</code> 是一个对象，它必须要有一个 type 值<br>例如，这里我们暴露了一个用于返回一个 <code>action</code> 对象的方法</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export const createIncrementAction &#x3D; data &#x3D;&gt; (&#123;\n    type: INCREMENT,\n    data\n&#125;)</code></pre>\n<p>我们调用它时，会返回一个 action 对象</p>\n<h3 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h3><p>在 <code>Reducer</code> 中，我们需要指定状态的操作类型，要做怎样的数据更新，因此这个类型是必要的。<br><code>reducer</code> 会根据 <code>action</code> 的指示，对 <code>state</code> 进行对应的操作，然后返回操作后的 <code>state</code><br>如下，我们对接收的 <code>action</code> 中传来的 <code>type</code> 进行判断</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export default function countReducer(preState &#x3D; initState, action) &#123;\n    const &#123;\n        type,\n        data\n    &#125; &#x3D; action;\n    switch (type) &#123;\n        case INCREMENT:\n            return preState + data\n        case DECREMENT:\n            return preState - data\n        default:\n            return preState\n    &#125;\n&#125;</code></pre>\n<p>更改数据，返回新的状态</p>\n<h2 id=\"创建-constant-文件\"><a href=\"#创建-constant-文件\" class=\"headerlink\" title=\"创建 constant 文件\"></a>创建 constant 文件</h2><p>在我们正常的编码中，有可能会出现拼写错误的情况，但是我们会发现，拼写错误了不一定会报错，因此就会比较难搞。</p>\n<p>我们可以在 redux 目录下，创建一个 constant 文件，这个文件用于定义我们代码中常用的一些变量，例如</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export const INCREMENT &#x3D; &#39;increment&#39;\nexport const DECREMENT &#x3D; &#39;decrement&#39;</code></pre>\n\n<p>将这两个单词写在 constant 文件中，并对外暴露，当我们需要使用时，我们可以引入这个文件，并直接使用它的名称即可</p>\n<p>直接使用 INCREMENT 即可</p>\n<h2 id=\"实现异步-action\"><a href=\"#实现异步-action\" class=\"headerlink\" title=\"实现异步 action\"></a>实现异步 action</h2><p>一开始，我们直接调用一个异步函数，这虽然没有什么问题，但是难道 redux 就不可以实现了吗？</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">incrementAsync &#x3D; () &#x3D;&gt; &#123;\n    const &#123; value &#125; &#x3D; this.selectNumber\n    const &#123; count &#125; &#x3D; this.state;\n    setTimeout(() &#x3D;&gt; &#123;\n        this.setState(&#123; count: count + value * 1 &#125;)\n    &#125;, 500);\n&#125;</code></pre>\n\n<p>我们可以先尝试将它封装到 action 对象中调用</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export const createIncrementAsyncAction &#x3D; (data, time) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 无需引入 store ，在调用的时候是由 store 调用的\n    return (dispatch) &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n            dispatch(createIncrementAction(data))\n        &#125;, time)\n    &#125;\n&#125;</code></pre>\n\n<p>当我们点击异步加操作时，我们会调用这个函数，在这个函数里接收一个延时加的时间，还有action所需的数据，和原先的区别只在于返回的时一个定时器函数</p>\n<p>但是如果仅仅这样，很显然是会报错的，它默认需要接收一个对象</p>\n<p>如果我们需要实现传入函数，那我们就需要告诉：你只需要默默的帮我执行以下这个函数就好！</p>\n<p>这时我们就需要引入中间件，在原生的 redux 中暴露出 applyMiddleware 中间件执行函数，并引入 redux-thunk 中间件（需要手动下载）</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import thunk from &#39;redux-thunk&#39;</code></pre>\n\n<p>通过第二个参数传递下去就可以了</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export default createStore(countReducer, applyMiddleware(thunk))</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：异步 action 不是必须要写的，完全可以自己等待异步任务的结果后再去分发同步action</p></blockquote>\n<p>::: warn<br>采用 react-thunk 能让异步代码像同步代码一样执行，在 redux 中我们也是可以实现异步的，但是这样我们的代码中会有很多异步的细节，这不是我们想看到的，利用 react-thunk 之类的库，就能让我们只关心我们的业务<br>:::</p>\n<h2 id=\"Redux-三大原则\"><a href=\"#Redux-三大原则\" class=\"headerlink\" title=\"Redux 三大原则\"></a>Redux 三大原则</h2><p><strong>第一个原则</strong><br>单向数据流：整个 <code>Redux</code> 中，数据流向是单向的</p>\n<p>UI 组件 —&gt; <code>action</code> —&gt; <code>store</code> —&gt; <code>reducer</code> —&gt; <code>store</code></p>\n<p><strong>第二个原则</strong><br><code>state</code> 只读：在 Redux 中不能通过直接改变 <code>state</code> ，来控制状态的改变，如果想要改变 <code>state</code> ，则需要触发一次 <code>action。通过</code> <code>action</code> 执行 <code>reducer</code></p>\n<p><strong>第三个原则</strong><br>纯函数执行：每一个<code>reducer</code> 都是一个纯函数，不会有任何副作用，返回是一个新的 <code>state</code>，<code>state</code> 改变会触发 <code>store</code> 中的 <code>subscribe</code></p>\n<h2 id=\"容器组件和-UI-组件\"><a href=\"#容器组件和-UI-组件\" class=\"headerlink\" title=\"容器组件和 UI 组件\"></a>容器组件和 UI 组件</h2><ul>\n<li>所有的 UI 组件都需要有一个容器组件包裹</li>\n<li>容器组件来负责和 Redux 打交道，可以随意使用 Redux 的API</li>\n<li>UI 组件无任何 Redux API</li>\n<li>容器组件用于处理逻辑，UI 组件只会负责渲染和交互，不处理逻辑</li>\n</ul>\n<img src=\"https://camo.githubusercontent.com/40d68ea709c3da5c5f6076b277e9cf365e87cf931fb1a69389ccdc0a7bb2ac53/68747470733a2f2f6c6a63696d672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f696d6167652d32303231303931303039343432363236382e706e67\"/>\n\n<p>在我们的生产当中，我们可以直接将 UI 组件写在容器组件的代码文件当中，这样就无需多个文件</p>\n<p>首先，我们在 src 目录下，创建一个 containers 文件夹，用于存放各种容器组件，在该文件夹内创建 Count 文件夹，即表示即将创建 Count 容器组件，再创建 index.jsx 编写代码</p>\n<p>要实现容器组件和 UI 组件的连接，我们需要通过 connect 来实现</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 引入UI组件\nimport CountUI from &#39;..&#x2F;..&#x2F;components&#x2F;Count&#39;\n&#x2F;&#x2F; 引入 connect 连接UI组件\nimport &#123;connect&#125; from &#39;react-redux&#39;\n&#x2F;&#x2F; 建立连接\nexport default connect()(CountUI)</code></pre>\n\n<h2 id=\"Provider\"><a href=\"#Provider\" class=\"headerlink\" title=\"Provider\"></a>Provider</h2><p>由于我们的状态可能会被很多组件使用，所以 React-Redux 给我们提供了一个 Provider 组件，可以全局注入 redux 中的 store ，只需要把 Provider 注册在根部组件即可</p>\n<p>例如，当以下组件都需要使用 store 时，我们需要这么做，但是这样徒增了工作量，很不便利</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;Count store&#x3D;&#123;store&#125;&#x2F;&gt;\n&#123;&#x2F;* 示例 *&#x2F;&#125;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;</code></pre>\n\n<p>我们可以这么做：在 src 目录下的 index.js 文件中，引入 Provider ，直接用 Provider 标签包裹 App 组件，将 store 写在 Provider 中即可</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">ReactDOM.render(\n  &lt;Provider store&#x3D;&#123;store&#125;&gt;\n    &lt;App &#x2F;&gt;\n  &lt;&#x2F;Provider&gt;,\n  document.getElementById(&quot;root&quot;)\n);</code></pre>\n\n<p>这样我们在 App.jsx 文件中，组件无需手写指定 store ，即可使用 store</p>\n<h2 id=\"Connect\"><a href=\"#Connect\" class=\"headerlink\" title=\"Connect\"></a>Connect</h2><p>在前面我们看到的 react-redux 原理图时，我们会发现容器组件需要给 UI 组件传递状态和方法，并且是通过 props 来传递，看起来很简单。但是，我们会发现容器组件中似乎没有我们平常传递 props 的情形</p>\n<p>这时候就需要继续研究一下容器组件中的唯一一个函数 connect</p>\n<p>connect 方法是一个连接器，用于连接容器组件和 UI 组件，它第一次执行时，接收4个参数，这些参数都是可选的，它执行的执行的结果还是一个函数，第二次执行接收一个 UI 组件</p>\n<p>第一次执行时的四个参数：<em>mapStateToProps</em> 、<em>mapDispatchToProps</em> 、<em>mergeProps</em>、<em>options</em></p>\n<h3 id=\"mapStateToProps\"><a href=\"#mapStateToProps\" class=\"headerlink\" title=\"mapStateToProps\"></a>mapStateToProps</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const mapStateToProps &#x3D; state &#x3D;&gt; (&#123; count: state &#125;)</code></pre>\n\n<p>它接收 state 作为参数，并且返回一个对象，这个对象标识着 UI 组件的同名参数，</p>\n<p>返回的对象中的 key 就作为传递给 UI 组件 props 的 key，value 就作为 props 的 value</p>\n<p>如上面的代码，我们可以在 UI 组件中直接通过 props 来读取 count 值</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;h1&gt;当前求和为：&#123;this.props.count&#125;&lt;&#x2F;h1&gt;</code></pre>\n\n<h3 id=\"mapDispatchToProps\"><a href=\"#mapDispatchToProps\" class=\"headerlink\" title=\"mapDispatchToProps\"></a>mapDispatchToProps</h3><p>connect 接受的第二个参数是 mapDispatchToProps 它是用于建立 UI 组件的参数到 store.dispacth 方法的映射</p>\n<p>我们可以把参数写成对象形式，在这里面定义 action 执行的方法，例如 jia 执行什么函数，jian 执行什么函数？</p>\n<p>我们都可以在这个参数中定义，如下定义了几个方法对应的操作函数</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#123;\n    jia: createIncrementAction,\n    jian: createDecrementAction,\n    jiaAsync: createIncrementAsyncAction\n&#125;</code></pre>\n\n<p>似乎少了点什么，我们在这里调用了函数，创建了 action 对象，但是好像 store 并没有执行 dispatch ，那是不是断了呢？执行不了呢？</p>\n<p>其实这里 react-redux 已经帮我们做了优化，当调用 actionCreator 的时候，会立即发送 action 给 store 而不用手动的 dispatch</p>\n<ul>\n<li>自动调用 dispatch</li>\n</ul>\n<h3 id=\"完整开发\"><a href=\"#完整开发\" class=\"headerlink\" title=\"完整开发\"></a>完整开发</h3><p>首先我们在 containers 文件夹中，直接编写我们的容器组件，无需编写 UI 组件</p>\n<p>先打 rcc 打出指定代码段，然后暴露出 connect 方法</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123; connect &#125; from &#39;react-redux&#39;</code></pre>\n\n<p>从 action 文件中暴露创建 action 的方法</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123;createIncrementAction&#125; from &#39;..&#x2F;..&#x2F;redux&#x2F;count_action&#39;</code></pre>\n\n<p>编写 UI 组件，简单写个 demo，绑定 props 和方法</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">return (\n    &lt;div&gt;\n        &lt;h2&gt;当前求和为：&#123;this.props.count&#125;&lt;&#x2F;h2&gt;\n        &lt;button onClick&#x3D;&#123;this.add&#125;&gt;点我加1&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n);</code></pre>\n\n<p>调用 connect 包装暴露 UI 组件</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export default connect(\n    state &#x3D;&gt; (&#123; count: state &#125;),&#x2F;&#x2F; 状态\n    &#123; jia: createIncrementAction &#125; &#x2F;&#x2F; 方法\n)(Count);</code></pre>\n\n<p>第一次执行的参数就直接传递 state 和一个指定 action 的对象</p>\n<h2 id=\"数据共享\"><a href=\"#数据共享\" class=\"headerlink\" title=\"数据共享\"></a>数据共享</h2><h3 id=\"编写-Person-组件\"><a href=\"#编写-Person-组件\" class=\"headerlink\" title=\"编写 Person 组件\"></a>编写 Person 组件</h3><p>首先我们需要编写 index.jsx 文件，在这个文件里面编写 Person 组件的 UI 组件，并使用 connect 函数将它包装，映射它的状态和方法</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;div&gt;\n    &lt;h2&gt;我是 Person 组件,上方组件求和为:&#123;this.props.countAll&#125;&lt;&#x2F;h2&gt;\n    &lt;input ref&#x3D;&#123;c &#x3D;&gt; this.nameNode &#x3D; c&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;输入名字&quot; &#x2F;&gt;\n    &lt;input ref&#x3D;&#123;c &#x3D;&gt; this.ageNode &#x3D; c&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;输入年龄&quot; &#x2F;&gt;\n    &lt;button onClick&#x3D;&#123;this.addPerson&#125;&gt;添加&lt;&#x2F;button&gt;\n    &lt;ul&gt;\n        &#123;\n            this.props.persons.map((p) &#x3D;&gt; &#123;\n                return &lt;li key&#x3D;&#123;p.id&#125;&gt; &#123;p.name&#125;--&#123;p.age&#125;&lt;&#x2F;li&gt;\n            &#125;)\n        &#125;\n    &lt;&#x2F;ul&gt;\n&lt;&#x2F;div&gt;</code></pre>\n\n<p>我们可以看到这里采用了 ref 来获取到当前事件触发的节点，并通过 this.addPerson 的方式给按钮绑定了一个点击事件</p>\n<p><strong>编写点击事件回调</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">addPerson &#x3D; () &#x3D;&gt; &#123;\n    const name &#x3D; this.nameNode.value\n    const age &#x3D; this.ageNode.value\n    const personObj &#x3D; &#123; id: nanoid(), name, age &#125;\n    this.props.add(personObj)\n    this.nameNode.value &#x3D; &#39;&#39;\n    this.ageNode.value &#x3D; &#39;&#39;\n&#125;</code></pre>\n\n<p>在这里我们需要处理输入框中的数据，并且将这些数据用于创建一个 action 对象，传递给 store 进行状态的更新</p>\n<p>在这里我们需要回顾的是，这里我们使用了一个 nanoid 库，这个库我们之前也有使用过</p>\n<p><strong>下载，引入，暴露</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123; nanoid &#125; from &#39;nanoid&#39;</code></pre>\n\n<p>暴露的 nanoid 是一个函数，我们每一次调用时，都会返回一个不重复的数，用于确保 id 的唯一性，同时在后面的 map 遍历的过程中，我们将 id 作为了 key 值，这样也确保了 key 的唯一性，关于 key 的作用，可以看看 diffing 算法的文章</p>\n<p><strong>状态管理</strong><br>在这里我们需要非常熟练的采用 this.props.add 的方式来更新状态</p>\n<p>那么它是如何实现状态更新的呢？我们来看看</p>\n<p>在我们调用 connect 函数时，我们第一次调用时传入的第二个参数，就是用于传递方法的，我们传递了一个 add 方法</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export default connect(\n    state &#x3D;&gt; (&#123; persons: state.person, countAll: state.count &#125;),&#x2F;&#x2F;映射状态\n    &#123; add: createAddPersonAction &#125;\n)(Person);</code></pre>\n\n<p>它的原词是：mapDispatchToProps</p>\n<p>我的理解是，传入的东西会被映射映射成 props 对象下的方法，这也是我们能够在 props 下访问到 add 方法的原因</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于这一块 connect ，我们必须要能够形成自己的理解，这里非常的重要，它实现了数据的交互，不至于一个组件，而是全部组件</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>想象一个 store 仓库，在我们这个案例当中，Count 组件需要存放 count 值在 store 中，Person 组件需要存放新增用户对象在 store 中，我们要把这两个数据存放在一个对象当中。当某个组件需要使用 store 中的值时，可以通过 connect 中的两个参数来获取，例如这里我们需要使用到 Count 组件的值，可以通过 .count 来从 store 中取值。</p></blockquote>\n<p>也就是说，所有的值都存放在 store 当中，通过点运算符来获取，所有的操作 store 的方法都需要通过 action 来实现。当前组件需要使用的数据都需要在 connect 中暴露</p>\n<h3 id=\"编写-reducer\"><a href=\"#编写-reducer\" class=\"headerlink\" title=\"编写 reducer\"></a>编写 reducer</h3><p>首先，我们需要明确 reducer 的作用，它是用来干什么的？</p>\n<p>根据操作类型来指定状态的更新</p>\n<p>也就是说当我们点击了添加按钮后，会将输入框中的数据整合成一个对象，作为当前 action 对象的 data 传递给 reducer</p>\n<p>我们可以看看我们编写的 action 文件，和我们想的一样</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123; ADD_PERSON &#125; from &quot;..&#x2F;constant&quot;;\n&#x2F;&#x2F; 创建一个人的action 对象\nexport const createAddPersonAction &#x3D; (personObj) &#x3D;&gt; (&#123;\n  type: ADD_PERSON,\n  data: personObj,\n&#125;);</code></pre>\n\n<p>当 reducer 接收到 action 对象时，会对 type 进行判断</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export default function personReducer(preState &#x3D; initState, action) &#123;\n  const &#123; type, data &#125; &#x3D; action;\n  switch (type) &#123;\n    case ADD_PERSON:\n      return [data,...preState]\n    default:\n      return preState\n  &#125;\n&#125;</code></pre>\n\n<p>一般都采用 switch 来编写</p>\n<p>这里有个值得注意的地方是，这个 personReducer 函数是一个纯函数，什么是纯函数呢？这个是高阶函数部分的知识了，纯函数是一个不改变参数的函数，也就是说，传入的参数是不能被改变的。</p>\n<p>为什么要提这个呢？在我们 return 时，有时候会想通过数组的 API 来在数组前面塞一个值，不也可以吗？</p>\n<p>但是我们要采用 unshirt 方法，这个方法是会改变原数组的，也就是我们传入的参数会被改变，因此这样的方法是不可行的！</p>\n<h3 id=\"打通数据共享\"><a href=\"#打通数据共享\" class=\"headerlink\" title=\"打通数据共享\"></a>打通数据共享</h3><p>采用 Redux 来进行组件的数据交互真的挺方便。</p>\n<p>我们可以在 Count 组件中引入 Person 组件存在 store 中的状态。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">export default connect(state &#x3D;&gt; (&#123; count: state.count, personNum: state.person.length &#125;),\n    &#123;\n       ...\n    &#125;\n)(Count)</code></pre>\n\n<p>在这里我们将 store 中的 person 数组的长度暴露出来这样 Count 组件就可以直接通过 props 来使用了</p>\n<p>同样的我们也可以在 Person 组件中使用 Count 组件的值</p>\n<p>从而实现了我们的这个 Demo</p>\n<h3 id=\"最终优化\"><a href=\"#最终优化\" class=\"headerlink\" title=\"最终优化\"></a>最终优化</h3><ul>\n<li>利用对象的简写方法，将键名和键值同名，从而只写一个名即可</li>\n<li>合并 reducer ，我们可以将多个 reducer文件 写在一个 index 文件当中，需要采用 combineReducers 来合并</li>\n</ul>\n","text":"Redux 我们先明晰 Redux 的作用 ，实现集中式状态管理。 Redux 适用于多交互、多数据源的场景。简单理解就是复杂 从组件角度去考虑的话，当我们有以下的应用场景时，我们可以尝试采用 Redux 来实现 某个组件的状态需要共享时 一个组件需要改变其他组件的状态时 一个组...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Tecnology","slug":"Tecnology","count":8,"path":"api/categories/Tecnology.json"},{"name":"React","slug":"Tecnology/React","count":3,"path":"api/categories/Tecnology/React.json"}],"tags":[{"name":"tecnology","slug":"tecnology","count":8,"path":"api/tags/tecnology.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redux\"><span class=\"toc-text\">Redux</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redux-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Redux 的工作流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redux-%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Redux 三个核心概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Store\"><span class=\"toc-text\">Store</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Action\"><span class=\"toc-text\">Action</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reducer\"><span class=\"toc-text\">Reducer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA-constant-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">创建 constant 文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5-action\"><span class=\"toc-text\">实现异步 action</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redux-%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">Redux 三大原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%E5%92%8C-UI-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">容器组件和 UI 组件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Provider\"><span class=\"toc-text\">Provider</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Connect\"><span class=\"toc-text\">Connect</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mapStateToProps\"><span class=\"toc-text\">mapStateToProps</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mapDispatchToProps\"><span class=\"toc-text\">mapDispatchToProps</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">完整开发</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">数据共享</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99-Person-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">编写 Person 组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99-reducer\"><span class=\"toc-text\">编写 reducer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%93%E9%80%9A%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">打通数据共享</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%BB%88%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">最终优化</span></a></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"New Stage","uid":"8f54f0fd54caedd7dc4853b9b087c3d8","slug":"hangzhou","date":"2023-08-26T08:58:24.000Z","updated":"2023-08-26T09:03:14.163Z","comments":true,"path":"api/articles/hangzhou.json","keywords":null,"cover":"https://c.wallhere.com/photos/8e/4c/Cyberpunk_2077_video_games-2236580.jpg!d","text":"机遇、憧憬、恐惧、稳定人生的第三个阶段——杭州逝者如斯夫，不知从何时起，时间永远不像以前那样经得起消磨，随着一个又一个阶段的到来，时间的流逝仿佛也像是九九八十一难的妖怪愈演愈烈。 ","link":"","photos":[],"count_time":{"symbolsCount":90,"symbolsTime":"1 mins."},"categories":[{"name":"Essays","slug":"Essays","count":3,"path":"api/categories/Essays.json"}],"tags":[{"name":"随笔","slug":"随笔","count":3,"path":"api/tags/随笔.json"}],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"React-Router-Dom","uid":"1b063f23855641c095e348bf57d4f4f2","slug":"react-router-dom","date":"2023-03-22T14:10:34.000Z","updated":"2023-03-22T14:19:53.884Z","comments":true,"path":"api/articles/react-router-dom.json","keywords":null,"cover":"https://blog.mycode.website/wp-content/uploads/2017/10/complex-layouts.jpg","text":"React-Router-Dom 5查看印记中文网站关于 React-Router-Dom 的介绍 路由的基本使用index.js&#x2F;index.ts 入口文件中 ReactDOM.render( &lt;React.StrictMode&gt; &#123;&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"Tecnology","slug":"Tecnology","count":8,"path":"api/categories/Tecnology.json"},{"name":"React","slug":"Tecnology/React","count":3,"path":"api/categories/Tecnology/React.json"}],"tags":[{"name":"tecnology","slug":"tecnology","count":8,"path":"api/tags/tecnology.json"}],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}}}