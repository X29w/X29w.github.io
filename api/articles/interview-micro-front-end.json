{"title":"interview-micro-front-end","uid":"2c8643e8bed9de396ca80bda6705cbc6","slug":"interview-micro-front-end","date":"2024-05-30T15:02:59.000Z","updated":"2024-05-30T15:03:20.134Z","comments":true,"path":"api/articles/interview-micro-front-end.json","keywords":null,"cover":null,"content":"<h1 id=\"微前端\"><a href=\"#微前端\" class=\"headerlink\" title=\"微前端\"></a>微前端</h1><h2 id=\"微前端概念详细解析\"><a href=\"#微前端概念详细解析\" class=\"headerlink\" title=\"微前端概念详细解析\"></a>微前端概念详细解析</h2><p>微前端（Micro Frontend）是一种现代Web开发架构理念，它借鉴了微服务的思想，将原本庞大的前端应用拆分为多个小型、独立可部署的微应用集合。每个微应用都是一个完整的功能单元，拥有自己的业务逻辑、UI组件、数据管理、路由系统甚至开发团队。这些微应用可以独立开发、测试、部署，最终通过某种机制集成到同一个宿主应用中，共同构成用户面前的完整产品界面。</p>\n<p><strong>关键技术点</strong>：</p>\n<ul>\n<li><p><strong>模块化与解耦</strong>：微前端的核心在于高度模块化和业务解耦，确保每个微应用可以独立演进。</p>\n</li>\n<li><p><strong>通信机制</strong>：需要一套有效的跨微应用通信方案，以便微应用间能够相互通信和数据共享。</p>\n</li>\n<li><p><strong>资源加载与隔离</strong>：动态加载微应用资源，同时确保CSS、JavaScript的隔离，避免全局污染。</p>\n</li>\n<li><p><strong>路由管理</strong>：如何处理微应用内部路由与宿主应用路由的集成，保证良好的用户体验。</p>\n</li>\n<li><p><strong>部署策略</strong>：支持独立部署，每个微应用可以按需更新，减少整体部署风险。</p>\n</li>\n<li><p><strong>技术栈无关</strong>： 不同的微前端应用可以使用不同的技术栈，这为使用新技术、升级旧技术提供了可能。</p>\n</li>\n<li><p><strong>并行开发</strong>： 因为微前端应用是独立的，所以多个团队可以并行开发不同的应用，无需担心相互影响。</p>\n</li>\n</ul>\n<h2 id=\"qiankun-微前端框架工作原理深度剖析\"><a href=\"#qiankun-微前端框架工作原理深度剖析\" class=\"headerlink\" title=\"qiankun 微前端框架工作原理深度剖析\"></a>qiankun 微前端框架工作原理深度剖析</h2><p>qiankun 是一个流行的微前端实现框架，它基于single-spa并进行了大量优化和封装，提供了更加简洁的API和强大的功能。其工作原理可以细致分为以下几个方面：</p>\n<ol>\n<li><p><strong>应用容器化</strong>：qiankun 通过在宿主应用中创建一个或多个“沙箱”环境（容器），为每个子应用提供独立的运行空间。</p>\n</li>\n<li><p><strong>动态加载与挂载</strong>：利用动态导入（<code>import()</code>）API，qiankun 在需要时异步加载子应用的入口文件。加载完成后，通过特定的生命周期钩子（如<code>bootstrap</code>, <code>mount</code>, <code>unmount</code>）来控制子应用的初始化、挂载和卸载过程。</p>\n</li>\n<li><p><strong>沙箱机制</strong>：为了防止JavaScript全局变量冲突和CSS样式污染，qiankun 实现了沙箱机制，通过修改全局对象的原型链或代理等方式，为每个子应用创造独立的运行环境。</p>\n</li>\n<li><p><strong>路由与状态管理</strong>：qiankun 支持多种路由集成方案，包括直接使用宿主应用的路由系统、子应用自管理路由或两者的混合模式。同时，通过<code>actions</code>和<code>events</code>机制提供跨应用状态共享和通信能力。</p>\n</li>\n</ol>\n<h2 id=\"解决JS污染问题\"><a href=\"#解决JS污染问题\" class=\"headerlink\" title=\"解决JS污染问题\"></a>解决JS污染问题</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>qiankun 的 js 沙箱机制主要是通过代理 window 对象来实现的，它可以有效地隔离子应用的全局变量，防止子应用之间的全局变量污染。然而，这种机制并不能解决所有的 js 污染问题。例如，如果我们使用 onclick 或 addEventListener 给 <body> 添加了一个点击事件，js 沙箱并不能消除它的影响。</p></blockquote>\n<p>qiankun 的沙箱机制是解决JS污染的关键。它通过以下方式实现隔离：</p>\n<ul>\n<li><strong>全局变量代理</strong>：为每个子应用创建一个影子全局对象，代理真实全局对象，使子应用的全局变量变更不直接影响宿主或其他子应用。</li>\n<li><strong>事件委托与代理</strong>：对DOM事件监听进行代理，确保事件的注册和触发都在子应用内部完成，避免全局事件污染。</li>\n<li><strong>自定义元素封装</strong>：鼓励使用Web Components或类似技术封装子应用内的组件，确保CSS和JS逻辑的隔离。</li>\n</ul>\n<h2 id=\"CSS隔离机制与挑战\"><a href=\"#CSS隔离机制与挑战\" class=\"headerlink\" title=\"CSS隔离机制与挑战\"></a>CSS隔离机制与挑战</h2><p>qiankun 提供了多种CSS隔离方案：</p>\n<ul>\n<li><strong>Scoped CSS</strong>: 利用Webpack的CSS Modules或Vue、React等框架自带的Scoped CSS特性，限制样式的作用范围。</li>\n<li><strong>Shadow DOM</strong>: 对于支持的浏览器，利用Shadow DOM天然的样式隔离能力。</li>\n<li><strong>CSS-in-JS</strong>: 使用样式注入库如styled-components，确保样式与组件紧密绑定。</li>\n</ul>\n<p>缺点包括：增加了开发复杂度、可能的浏览器兼容性问题、以及对开发者技能的要求提高。替代方案包括使用BEM等命名约定，或引入第三方CSS隔离库如css-modules-require-hook。</p>\n<h2 id=\"父子项目通信\"><a href=\"#父子项目通信\" class=\"headerlink\" title=\"父子项目通信\"></a>父子项目通信</h2><p>在qiankun微前端框架中，父子项目间的通信是通过一套设计精良的机制来实现的，确保了不同微应用之间的高效协作。主要的通信手段包括<code>actions</code>和<code>events</code>，这两种方式各有侧重，适用于不同的通信场景。</p>\n<h3 id=\"1-Actions\"><a href=\"#1-Actions\" class=\"headerlink\" title=\"1. Actions\"></a>1. Actions</h3><p><code>actions</code>是qiankun提供的一种面向服务的通信模式，主要用于数据的请求与响应，具有明确的调用者和被调用者关系，适用于需要明确反馈结果的场景。</p>\n<h4 id=\"工作原理：\"><a href=\"#工作原理：\" class=\"headerlink\" title=\"工作原理：\"></a>工作原理：</h4><ul>\n<li><strong>定义</strong>：在子应用中，你可以定义一个或多个actions，每个action是一个函数，它接受参数并返回Promise，用于处理数据请求或业务逻辑。</li>\n<li><strong>注册</strong>：通过<code>registerMicroApps</code>方法注册子应用时，可以指定actions，或者在子应用内部通过<code>useActions</code> Hook来注册。</li>\n<li><strong>调用</strong>：在主应用或其他子应用中，同样使用<code>useActions</code> Hook来获取actions的调用能力。一旦调用，实际上是触发了一个跨应用的事件，由对应子应用的action处理并返回结果。</li>\n<li><strong>响应</strong>：被调用的子应用处理完逻辑后，通过返回Promise的resolve或reject来反馈结果，调用方可以根据此结果进行后续处理。</li>\n</ul>\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>明确的调用关系，便于理解和维护。</li>\n<li>支持Promise，方便处理异步逻辑。</li>\n<li>自带错误处理机制。</li>\n</ul>\n<h3 id=\"2-Events\"><a href=\"#2-Events\" class=\"headerlink\" title=\"2. Events\"></a>2. Events</h3><p><code>events</code>是基于发布&#x2F;订阅模式的事件总线机制，适用于无需直接响应或一对多的通信场景，如通知型消息广播。</p>\n<h4 id=\"工作原理：-1\"><a href=\"#工作原理：-1\" class=\"headerlink\" title=\"工作原理：\"></a>工作原理：</h4><ul>\n<li><strong>发布</strong>：任何应用（主应用或子应用）都可以通过<code>window.qiankun.emit</code>来发布一个事件，附带事件名和数据。</li>\n<li><strong>订阅</strong>：同样，任何应用也可以通过<code>window.qiankun.on</code>来订阅一个事件，当事件被发布时，所有订阅者都会收到通知并执行相应的回调函数。</li>\n<li><strong>取消订阅</strong>：为了管理内存和避免泄露，可以使用<code>window.qiankun.off</code>来取消已订阅的事件。</li>\n</ul>\n<h4 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>灵活的发布&#x2F;订阅模式，支持一对多的通讯。</li>\n<li>无需明确的调用关系，适用于全局事件通知。</li>\n</ul>\n<h3 id=\"实现一套通信机制\"><a href=\"#实现一套通信机制\" class=\"headerlink\" title=\"实现一套通信机制\"></a>实现一套通信机制</h3><p>如果要自定义一套通信机制，可以参考以下步骤：</p>\n<ol>\n<li><p><strong>建立消息中心</strong>：设计一个全局的消息中心，负责事件的注册、分发与注销。可以是一个单例模式的对象，确保全局唯一。</p>\n</li>\n<li><p><strong>事件注册与触发</strong>：允许应用注册特定类型的事件及其处理器，同时提供一个触发事件的方法。事件可以携带数据，处理器根据事件类型执行相应逻辑。</p>\n</li>\n<li><p><strong>消息格式与协议</strong>：定义统一的消息格式和通信协议，确保不同来源的消息可以被正确识别和处理，比如使用JSON作为数据载体，规定消息头包含事件类型、来源等信息。</p>\n</li>\n<li><p><strong>异步支持</strong>：考虑异步场景，确保处理器可以是异步函数，并且支持Promise或async&#x2F;await，便于处理复杂的业务逻辑。</p>\n</li>\n<li><p><strong>错误处理与日志</strong>：内置错误捕获和日志记录机制，对于未能正确处理的事件或异常，提供合理的错误反馈和记录。</p>\n</li>\n<li><p><strong>性能与优化</strong>：考虑通信的性能影响，比如批量处理事件、事件节流&#x2F;防抖等策略，减少不必要的渲染和计算。</p>\n</li>\n</ol>\n<p>通过这样的设计，可以构建一个灵活、高效且易于维护的通信机制，满足微前端架构下不同子应用间的协作需求。</p>\n<h2 id=\"路由模式整合\"><a href=\"#路由模式整合\" class=\"headerlink\" title=\"路由模式整合\"></a>路由模式整合</h2><p>解决子应用路由模式不一致的问题，qiankun 提倡以下策略：</p>\n<ul>\n<li><strong>统一模式</strong>：推荐所有子应用采用同一路由模式（通常是History模式），并在宿主应用层面做统一处理。</li>\n<li><strong>适配层</strong>：在宿主应用中实现路由模式适配逻辑，比如通过URL重写或路由中间件，确保子应用的路由可以正常工作。</li>\n</ul>\n<h2 id=\"组件共享方案\"><a href=\"#组件共享方案\" class=\"headerlink\" title=\"组件共享方案\"></a>组件共享方案</h2><ul>\n<li><strong>父子项目间的组件共享</strong>：主项目加载时，将组件挂载到全局对象（如window）上，在子项目中直接注册使用该组件。</li>\n<li><strong>npm包共享</strong>：将共享组件封装为npm包，各子应用按需安装使用。</li>\n<li><strong>微应用作为组件库</strong>：将某个微应用专门设计为组件库微应用，其他应用动态加载其组件。</li>\n<li><strong>远程组件加载</strong>：利用Web Components或前端微服务技术，实现跨项目组件的远程加载和使用。</li>\n</ul>\n<h2 id=\"依赖复用方案\"><a href=\"#依赖复用方案\" class=\"headerlink\" title=\"依赖复用方案\"></a>依赖复用方案</h2><p>除了npm包，qiankun 本身并不直接提供依赖复用的机制，但可以通过以下方式间接实现：</p>\n<ul>\n<li><p>在使用webpack构建的子项目中，要实现复用公共依赖，需要配置webpack的externals，将公共依赖指定为外部依赖，不打包进子项目的代码中。</p>\n</li>\n<li><p>子项目之间的依赖复用可以通过保证依赖的URL一致来实现。如果多个子项目都使用同一份CDN文件，加载时会先从缓存读取，避免重复加载。</p>\n</li>\n<li><p>子项目复用主项目的依赖可以通过给子项目的index.html中的公共依赖的script和link标签添加自定义属性ignore来实现。在qiankun运行子项目时，qiankun会忽略这些带有ignore属性的依赖，子项目独立运行时仍然可以加载这些依赖。</p>\n</li>\n<li><p>在使用qiankun微前端框架时，可能会出现子项目之间和主项目之间的全局变量冲突的问题。这是因为子项目不配置externals时，子项目的全局Vue变量不属于window对象，而qiankun在运行子项目时会先找子项目的window，再找父项目的window，导致全局变量冲突。</p>\n</li>\n</ul>\n<p>解决全局变量冲突的方案有三种：</p>\n<ul>\n<li>方案一是在注册子项目时，在beforeLoad钩子函数中处理全局变量，将子项目的全局Vue变量进行替换，以解决子项目独立运行时的全局变量冲突问题。</li>\n<li>方案二是通过主项目将依赖通过props传递给子项目，子项目在独立运行时使用传递过来的依赖，避免与主项目的全局变量冲突。</li>\n<li>方案三是修改主项目和子项目的依赖名称，使它们不会相互冲突，从而避免全局变量冲突的问题。</li>\n</ul>\n<p>作者：linwu<br>链接：<a href=\"https://juejin.cn/post/7252342216843296828\">https://juejin.cn/post/7252342216843296828</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。。</p>\n<h2 id=\"资源加载机制（import-html-entry）\"><a href=\"#资源加载机制（import-html-entry）\" class=\"headerlink\" title=\"资源加载机制（import-html-entry）\"></a>资源加载机制（import-html-entry）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>qiankun import-html-entry 是qiankun 框架中用于加载子应用的 HTML 入口文件的工具函数。它提供了一种方便的方式来动态加载和解析子应用的 HTML 入口文件，并返回一个可以加载子应用的 JavaScript 模块。<br><code>import-html-entry</code>是qiankun中用于加载子应用HTML入口的实用工具。其工作流程如下：</p></blockquote>\n<ul>\n<li><p>加载 HTML 入口文件：import-html-entry 会通过创建一个 <link> 标签来加载子应用的 HTML 入口文件。这样可以确保子应用的资源得到正确加载，并在加载完成后进行处理。</p>\n</li>\n<li><p>解析 HTML 入口文件：一旦 HTML 入口文件加载完成，import-html-entry 将解析该文件的内容，提取出子应用的 JavaScript 和 CSS 资源的 URL。</p>\n</li>\n<li><p>动态加载 JavaScript 和 CSS 资源：import-html-entry 使用动态创建 <script> 和 <link> 标签的方式，按照正确的顺序加载子应用的 JavaScript 和 CSS 资源。</p>\n</li>\n<li><p>创建沙箱环境：在加载子应用的 JavaScript 资源时，import-html-entry 会创建一个沙箱环境（sandbox），用于隔离子应用的全局变量和运行环境，防止子应用之间的冲突和污染。</p>\n</li>\n<li><p>返回子应用的入口模块：最后，import-html-entry 返回一个可以加载子应用的 JavaScript 模块。这个模块通常是一个包含子应用初始化代码的函数，可以在主应用中调用以加载和启动子应用。</p>\n</li>\n</ul>\n<h2 id=\"qiankun的优缺点\"><a href=\"#qiankun的优缺点\" class=\"headerlink\" title=\"qiankun的优缺点\"></a>qiankun的优缺点</h2><ul>\n<li><p>优点</p>\n<ul>\n<li>降低了应用改造的成本，通过html entry的方式引入子应用；</li>\n<li>提供了完备的沙箱方案，包括js沙箱和css沙箱；</li>\n<li>支持静态资源预加载能力。</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>适配成本较高，包括工程化、生命周期、静态资源路径、路由等方面的适配；</li>\n<li>css沙箱的严格隔离可能引发问题，js沙箱在某些场景下执行性能下降；</li>\n<li>无法同时激活多个子应用，不支持子应用保活；</li>\n<li>不支持vite等esmodule脚本运行。</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"微前端微前端概念详细解析微前端（Micro Frontend）是一种现代Web开发架构理念，它借鉴了微服务的思想，将原本庞大的前端应用拆分为多个小型、独立可部署的微应用集合。每个微应用都是一个完整的功能单元，拥有自己的业务逻辑、UI组件、数据管理、路由系统甚至开发团队。这些微应用...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E5%89%8D%E7%AB%AF\"><span class=\"toc-text\">微前端</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A6%82%E5%BF%B5%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">微前端概念详细解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#qiankun-%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90\"><span class=\"toc-text\">qiankun 微前端框架工作原理深度剖析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3JS%E6%B1%A1%E6%9F%93%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">解决JS污染问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%8C%91%E6%88%98\"><span class=\"toc-text\">CSS隔离机制与挑战</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">父子项目通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Actions\"><span class=\"toc-text\">1. Actions</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">工作原理：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">优点：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Events\"><span class=\"toc-text\">2. Events</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A-1\"><span class=\"toc-text\">工作原理：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9%EF%BC%9A-1\"><span class=\"toc-text\">优点：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%A5%97%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">实现一套通信机制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%95%B4%E5%90%88\"><span class=\"toc-text\">路由模式整合</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">组件共享方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E5%A4%8D%E7%94%A8%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">依赖复用方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88import-html-entry%EF%BC%89\"><span class=\"toc-text\">资源加载机制（import-html-entry）</span></a></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"interview-browser-principles","uid":"7dfa44f5bf9784913186c2660b6488c1","slug":"interview-browser-principles","date":"2024-05-30T15:01:58.000Z","updated":"2024-05-30T15:02:26.935Z","comments":true,"path":"api/articles/interview-browser-principles.json","keywords":null,"cover":null,"text":"浏览器原理什么是 XSS 攻击？XSS（Cross-Site Scripting）攻击，即跨站脚本攻击，是指攻击者通过在目标网站上注入恶意脚本，当用户浏览该页面时，恶意脚本会在用户的浏览器上执行，从而盗取用户信息、篡改网页内容、进行钓鱼攻击等。 如何防御 XSS 攻击？ 输入验证...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}