{"title":"interview-react","uid":"315f9f443ae2dc302897ea2ae6c37f7e","slug":"interview-react","date":"2024-12-29T04:03:32.000Z","updated":"2024-12-29T06:12:06.463Z","comments":true,"path":"api/articles/interview-react.json","keywords":null,"cover":"/images/interview-react/cover.png","content":"<h1 id=\"组件基础\"><a href=\"#组件基础\" class=\"headerlink\" title=\"组件基础\"></a>组件基础</h1><h2 id=\"React-事件机制\"><a href=\"#React-事件机制\" class=\"headerlink\" title=\"React 事件机制\"></a>React 事件机制</h2><ol>\n<li><strong>新的事件委托机制</strong>：</li>\n</ol>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; React 18+ 的事件绑定示例\nconst App &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 事件处理器\n  const handleClick &#x3D; (e: React.SyntheticEvent) &#x3D;&gt; &#123;\n    console.log(&quot;按钮被点击&quot;);\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;点击&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<ol start=\"2\">\n<li><strong>主要变化</strong>：</li>\n</ol>\n<ul>\n<li><p>事件委托位置变更：</p>\n<ul>\n<li>React 17 之前：统一绑定到 document 节点</li>\n<li>React 18：绑定到渲染树的根 DOM 容器(root container)</li>\n<li>这使得一个页面可以安全地运行多个 React 版本</li>\n</ul>\n</li>\n<li><p>事件系统升级：</p>\n<ul>\n<li>采用了新的自动批处理(Automatic Batching)</li>\n<li>支持 createRoot API</li>\n<li>更好的并发特性支持</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>事件执行流程</strong>：</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">DOM 事件触发\n→ 到达 Root Container\n→ React 事件处理系统接管\n→ 创建合成事件对象\n→ 按照事件传播规则执行(捕获→目标→冒泡)\n→ 自动进行批量更新处理</code></pre>\n\n<ol start=\"4\">\n<li><strong>新特性说明</strong>：</li>\n</ol>\n<ul>\n<li>自动批处理：</li>\n</ul>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; React 18 自动批处理示例\nconst handleClick &#x3D; () &#x3D;&gt; &#123;\n  setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 不会立即更新\n  setFlag((f) &#x3D;&gt; !f); &#x2F;&#x2F; 不会立即更新\n  &#x2F;&#x2F; React 会将这些状态更新批量处理，只触发一次重渲染\n&#125;;</code></pre>\n\n<ul>\n<li>事件优先级：<ul>\n<li>离散事件（如点击）</li>\n<li>连续事件（如滚动）</li>\n<li>所有用户事件默认都是高优先级</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>最佳实践</strong>：</li>\n</ol>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; React 18 推荐的事件处理方式\nconst MyComponent &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 使用 useCallback 缓存事件处理器\n  const handleClick &#x3D; useCallback((e: React.MouseEvent) &#x3D;&gt; &#123;\n    e.preventDefault();\n\n    &#x2F;&#x2F; 可以安全地访问事件对象\n    console.log(e.currentTarget);\n\n    &#x2F;&#x2F; 状态更新会自动批处理\n    setCount((c) &#x3D;&gt; c + 1);\n    setData((d) &#x3D;&gt; [...d, &quot;new item&quot;]);\n  &#125;, []);\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;点击&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<ol start=\"6\">\n<li><strong>注意事项</strong>：</li>\n</ol>\n<ul>\n<li>合成事件对象在事件处理完成后会被释放</li>\n<li>如需异步访问事件对象，需要调用 e.persist()</li>\n<li>事件处理器中的 this 绑定推荐使用箭头函数或 bind</li>\n<li>利用事件委托机制，避免在列表项等重复元素上直接绑定事件处理器</li>\n</ul>\n<p>这些变化使得 React 18+ 的事件系统更加强大和灵活，同时为并发渲染和自动批处理等新特性提供了基础。</p>\n<h2 id=\"React-的事件和普通的-HTML-事件有什么不同？\"><a href=\"#React-的事件和普通的-HTML-事件有什么不同？\" class=\"headerlink\" title=\"React 的事件和普通的 HTML 事件有什么不同？\"></a>React 的事件和普通的 HTML 事件有什么不同？</h2><h3 id=\"React-事件与-HTML-事件的主要区别\"><a href=\"#React-事件与-HTML-事件的主要区别\" class=\"headerlink\" title=\"React 事件与 HTML 事件的主要区别\"></a>React 事件与 HTML 事件的主要区别</h3><ol>\n<li><strong>事件命名方式</strong>:</li>\n</ol>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; HTML 原生事件\n&lt;button onclick&#x3D;&quot;handleClick()&quot;&gt;点击&lt;&#x2F;button&gt;\n\n&#x2F;&#x2F; React 事件 - 使用驼峰命名\n&lt;button onClick&#x3D;&#123;handleClick&#125;&gt;点击&lt;&#x2F;button&gt;</code></pre>\n\n<ol start=\"2\">\n<li><strong>事件处理器的写法</strong>:</li>\n</ol>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; HTML 原生事件 - 字符串形式\n&lt;button onclick&#x3D;&quot;console.log(&#39;clicked&#39;)&quot;&gt;\n\n&#x2F;&#x2F; React 事件 - 传递函数引用\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const handleClick &#x3D; (e) &#x3D;&gt; &#123;\n    console.log(&#39;clicked&#39;);\n  &#125;\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;点击&lt;&#x2F;button&gt;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li><strong>事件对象的差异</strong>:</li>\n</ol>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; React 事件对象是合成事件(SyntheticEvent)\nconst Button &#x3D; () &#x3D;&gt; &#123;\n  const handleClick &#x3D; (e) &#x3D;&gt; &#123;\n    console.log(e); &#x2F;&#x2F; SyntheticBaseEvent\n    console.log(e.nativeEvent); &#x2F;&#x2F; 原生事件对象\n\n    &#x2F;&#x2F; React 事件对象的跨浏览器兼容性处理\n    e.preventDefault(); &#x2F;&#x2F; 阻止默认行为\n    e.stopPropagation(); &#x2F;&#x2F; 阻止冒泡\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;点击&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<ol start=\"4\">\n<li><strong>事件处理机制</strong>:</li>\n</ol>\n<ul>\n<li>React 18 中的事件委托机制:<ul>\n<li>事件统一绑定到 Root Container</li>\n<li>使用事件池机制复用事件对象</li>\n<li>实现自动批处理</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li><strong>事件优先级处理</strong>:</li>\n</ol>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; React 会根据事件类型自动分配优先级\n  return (\n    &lt;div&gt;\n      &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;\n        &#123;&#x2F;* 离散事件 - 高优先级 *&#x2F;&#125;\n        点击\n      &lt;&#x2F;button&gt;\n      &lt;div onScroll&#x3D;&#123;handleScroll&#125;&gt;\n        &#123;&#x2F;* 连续事件 - 较低优先级 *&#x2F;&#125;\n        内容\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<ol start=\"6\">\n<li><strong>事件处理的性能优化</strong>:</li>\n</ol>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const List &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; React 事件委托，无需为每个项添加事件监听\n  const handleClick &#x3D; (id) &#x3D;&gt; &#123;\n    console.log(&quot;clicked item:&quot;, id);\n  &#125;;\n\n  return (\n    &lt;ul\n      onClick&#x3D;&#123;(e) &#x3D;&gt; &#123;\n        const id &#x3D; e.target.dataset.id;\n        if (id) &#123;\n          handleClick(id);\n        &#125;\n      &#125;&#125;\n    &gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125; data-id&#x3D;&#123;item.id&#125;&gt;\n          &#123;item.name&#125;\n        &lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;;</code></pre>\n\n<ol start=\"7\">\n<li><strong>this 绑定的处理</strong>:</li>\n</ol>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class Button extends React.Component &#123;\n  &#x2F;&#x2F; React 推荐使用箭头函数自动绑定 this\n  handleClick &#x3D; (e) &#x3D;&gt; &#123;\n    console.log(this); &#x2F;&#x2F; 正确指向组件实例\n  &#125;;\n\n  render() &#123;\n    return &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;点击&lt;&#x2F;button&gt;;\n  &#125;\n&#125;</code></pre>\n\n<ol start=\"8\">\n<li><strong>注意事项</strong>:</li>\n</ol>\n<ul>\n<li>React 事件在冒泡阶段被触发</li>\n<li>合成事件对象会被重用，异步访问需要调用 e.persist()</li>\n<li>React 18 中的自动批处理会影响事件处理中的状态更新时机</li>\n</ul>\n<p>这些区别使得 React 事件系统更加统一和高效，同时提供了更好的开发体验和性能优化机会。</p>\n<h2 id=\"React-组件中怎么做事件代理？它的原理是什么？\"><a href=\"#React-组件中怎么做事件代理？它的原理是什么？\" class=\"headerlink\" title=\"React 组件中怎么做事件代理？它的原理是什么？\"></a>React 组件中怎么做事件代理？它的原理是什么？</h2><h3 id=\"事件代理的实现原理\"><a href=\"#事件代理的实现原理\" class=\"headerlink\" title=\"事件代理的实现原理\"></a>事件代理的实现原理</h3><p>React 在根节点(Root Container)上实现了统一的事件处理器，通过事件冒泡机制来代理所有子元素的事件。</p>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const List &#x3D; () &#x3D;&gt; &#123;\n  const handleItemClick &#x3D; (e) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 通过事件对象获取目标元素信息\n    const targetId &#x3D; e.target.dataset.id;\n    if (targetId) &#123;\n      console.log(&#96;点击了项目 $&#123;targetId&#125;&#96;);\n    &#125;\n  &#125;;\n\n  return (\n    &lt;ul onClick&#x3D;&#123;handleItemClick&#125;&gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125; data-id&#x3D;&#123;item.id&#125;&gt;\n          &#123;item.text&#125;\n        &lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p>事件触发时的处理流程：</p>\n<ul>\n<li>事件从目标元素开始冒泡</li>\n<li>到达 Root Container</li>\n<li>React 的事件系统接管处理</li>\n<li>根据事件目标找到对应的组件</li>\n<li>执行注册的事件处理函数</li>\n</ul>\n<h3 id=\"优势特点\"><a href=\"#优势特点\" class=\"headerlink\" title=\"优势特点\"></a>优势特点</h3><ul>\n<li><strong>性能优化</strong>：避免了为大量子元素分别绑定事件处理器</li>\n<li><strong>动态元素</strong>：新增的元素会自动被事件代理机制处理</li>\n<li><strong>内存占用</strong>：减少了事件处理器的数量</li>\n<li><strong>统一管理</strong>：方便对事件进行统一管理和控制</li>\n</ul>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 推荐的事件代理模式\nconst TableList &#x3D; () &#x3D;&gt; &#123;\n  const handleAction &#x3D; useCallback((e) &#x3D;&gt; &#123;\n    const &#123; action, id &#125; &#x3D; e.target.dataset;\n\n    switch (action) &#123;\n      case &quot;edit&quot;:\n        handleEdit(id);\n        break;\n      case &quot;delete&quot;:\n        handleDelete(id);\n        break;\n    &#125;\n  &#125;, []);\n\n  return (\n    &lt;table onClick&#x3D;&#123;handleAction&#125;&gt;\n      &lt;tbody&gt;\n        &#123;data.map((item) &#x3D;&gt; (\n          &lt;tr key&#x3D;&#123;item.id&#125;&gt;\n            &lt;td&gt;&#123;item.name&#125;&lt;&#x2F;td&gt;\n            &lt;td&gt;\n              &lt;button data-action&#x3D;&quot;edit&quot; data-id&#x3D;&#123;item.id&#125;&gt;\n                编辑\n              &lt;&#x2F;button&gt;\n              &lt;button data-action&#x3D;&quot;delete&quot; data-id&#x3D;&#123;item.id&#125;&gt;\n                删除\n              &lt;&#x2F;button&gt;\n            &lt;&#x2F;td&gt;\n          &lt;&#x2F;tr&gt;\n        ))&#125;\n      &lt;&#x2F;tbody&gt;\n    &lt;&#x2F;table&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>确保事件处理函数具有良好的性能</li>\n<li>合理使用事件委托，不是所有场景都适合</li>\n<li>注意事件冒泡的影响，必要时使用 stopPropagation</li>\n<li>使用 dataset 属性传递数据而不是闭包</li>\n</ul>\n<h2 id=\"对-React-Fiber-的理解，它解决了什么问题？\"><a href=\"#对-React-Fiber-的理解，它解决了什么问题？\" class=\"headerlink\" title=\"对 React-Fiber 的理解，它解决了什么问题？\"></a>对 React-Fiber 的理解，它解决了什么问题？</h2><h3 id=\"Fiber-架构的本质\"><a href=\"#Fiber-架构的本质\" class=\"headerlink\" title=\"Fiber 架构的本质\"></a>Fiber 架构的本质</h3><p>Fiber 是 React 16 中采用的新协调引擎，本质上是一个虚拟堆栈帧的实现，用于更优雅地处理 React 组件的渲染工作。</p>\n<h3 id=\"解决的核心问题\"><a href=\"#解决的核心问题\" class=\"headerlink\" title=\"解决的核心问题\"></a>解决的核心问题</h3><h4 id=\"渲染阻塞\"><a href=\"#渲染阻塞\" class=\"headerlink\" title=\"渲染阻塞\"></a>渲染阻塞</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 在 Fiber 之前的问题示例\nfunction heavyComponent() &#123;\n  &#x2F;&#x2F; 大量计算会阻塞主线程\n  for (let i &#x3D; 0; i &lt; 1000000; i++) &#123;\n    &#x2F;&#x2F; 复杂计算\n  &#125;\n  return &lt;div&gt;Heavy Component&lt;&#x2F;div&gt;;\n&#125;</code></pre>\n\n<h4 id=\"优先级调度\"><a href=\"#优先级调度\" class=\"headerlink\" title=\"优先级调度\"></a>优先级调度</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; Fiber 架构下的优先级处理\nconst App &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 高优先级更新 - 用户输入\n  const handleInput &#x3D; (e) &#x3D;&gt; &#123;\n    setInputValue(e.target.value); &#x2F;&#x2F; 会被优先处理\n  &#125;;\n\n  &#x2F;&#x2F; 低优先级更新 - 数据更新\n  const handleDataUpdate &#x3D; () &#x3D;&gt; &#123;\n    setData(newData); &#x2F;&#x2F; 可以被中断和恢复\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;input onChange&#x3D;&#123;handleInput&#125; &#x2F;&gt;\n      &lt;ExpensiveList data&#x3D;&#123;data&#125; &#x2F;&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"Fiber-的工作原理\"><a href=\"#Fiber-的工作原理\" class=\"headerlink\" title=\"Fiber 的工作原理\"></a>Fiber 的工作原理</h3><h4 id=\"工作单元切片\"><a href=\"#工作单元切片\" class=\"headerlink\" title=\"工作单元切片\"></a>工作单元切片</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; Fiber 节点结构示例\nconst fiber &#x3D; &#123;\n  type: &quot;div&quot;,\n  props: &#123; children: [] &#125;,\n  sibling: null,\n  child: null,\n  return: null,\n  alternate: null,\n  &#x2F;&#x2F; 用于追踪工作进度\n  flags: 0,\n  lanes: 0,\n&#125;;</code></pre>\n\n<h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ul>\n<li><strong>可中断性</strong>：渲染工作可以分片执行</li>\n<li><strong>优先级</strong>：不同的更新可以分配不同的优先级</li>\n<li><strong>并发性</strong>：支持同时处理多个任务</li>\n<li><strong>错误边界</strong>：更好的错误处理机制</li>\n</ul>\n<h3 id=\"实际应用优势\"><a href=\"#实际应用优势\" class=\"headerlink\" title=\"实际应用优势\"></a>实际应用优势</h3><h4 id=\"更流畅的用户体验\"><a href=\"#更流畅的用户体验\" class=\"headerlink\" title=\"更流畅的用户体验\"></a>更流畅的用户体验</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 使用 Suspense 和 并发特性\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n      &lt;SlowComponent &#x2F;&gt;\n      &lt;InteractiveComponent &#x2F;&gt; &#123;&#x2F;* 交互不会被阻塞 *&#x2F;&#125;\n    &lt;&#x2F;Suspense&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>生命周期方法的调整</li>\n<li>异步渲染的考虑</li>\n<li>副作用的处理需要更谨慎</li>\n</ul>\n<h3 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h3><ul>\n<li>并发模式的全面启用</li>\n<li>更多的 Hooks API 支持</li>\n<li>更好的调试工具支持</li>\n</ul>\n<p>Fiber 架构是 React 重要的里程碑，它让 React 应用能够提供更好的用户体验，同时为未来的发展奠定了基础。</p>\n<h2 id=\"React-纯组件是什么，有什么作用？\"><a href=\"#React-纯组件是什么，有什么作用？\" class=\"headerlink\" title=\"React 纯组件是什么，有什么作用？\"></a>React 纯组件是什么，有什么作用？</h2><h3 id=\"纯组件的概念\"><a href=\"#纯组件的概念\" class=\"headerlink\" title=\"纯组件的概念\"></a>纯组件的概念</h3><p>纯组件(Pure Component)是 React 中的一个特殊组件类，它通过自动实现浅比较来优化组件的重渲染机制。</p>\n<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 类组件方式\nclass UserCard extends React.PureComponent &#123;\n  render() &#123;\n    const &#123; name, age &#125; &#x3D; this.props;\n    return (\n      &lt;div className&#x3D;&quot;user-card&quot;&gt;\n        &lt;h3&gt;&#123;name&#125;&lt;&#x2F;h3&gt;\n        &lt;p&gt;年龄: &#123;age&#125;&lt;&#x2F;p&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 函数组件方式\nconst UserCard &#x3D; React.memo((&#123; name, age &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;user-card&quot;&gt;\n      &lt;h3&gt;&#123;name&#125;&lt;&#x2F;h3&gt;\n      &lt;p&gt;年龄: &#123;age&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;);</code></pre>\n\n<h3 id=\"主要作用\"><a href=\"#主要作用\" class=\"headerlink\" title=\"主要作用\"></a>主要作用</h3><h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 优化前\nconst ExpensiveList &#x3D; (&#123; items &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;ul&gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 使用纯组件优化\nconst OptimizedList &#x3D; React.memo((&#123; items &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;ul&gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;);</code></pre>\n\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><h4 id=\"展示型组件\"><a href=\"#展示型组件\" class=\"headerlink\" title=\"展示型组件\"></a>展示型组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const PriceDisplay &#x3D; React.memo((&#123; price, currency &#125;) &#x3D;&gt; (\n  &lt;div className&#x3D;&quot;price&quot;&gt;\n    &#123;currency&#125; &#123;price.toFixed(2)&#125;\n  &lt;&#x2F;div&gt;\n));</code></pre>\n\n<h4 id=\"列表项组件\"><a href=\"#列表项组件\" class=\"headerlink\" title=\"列表项组件\"></a>列表项组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const TodoItem &#x3D; React.memo((&#123; todo, onToggle &#125;) &#x3D;&gt; (\n  &lt;li&gt;\n    &lt;input\n      type&#x3D;&quot;checkbox&quot;\n      checked&#x3D;&#123;todo.completed&#125;\n      onChange&#x3D;&#123;() &#x3D;&gt; onToggle(todo.id)&#125;\n    &#x2F;&gt;\n    &#123;todo.text&#125;\n  &lt;&#x2F;li&gt;\n));</code></pre>\n\n<h3 id=\"注意事项-2\"><a href=\"#注意事项-2\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><h4 id=\"避免内联对象和函数\"><a href=\"#避免内联对象和函数\" class=\"headerlink\" title=\"避免内联对象和函数\"></a>避免内联对象和函数</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 错误示范\nconst Parent &#x3D; () &#x3D;&gt; (\n  &lt;PureChild\n    style&#x3D;&#123;&#123; margin: 10 &#125;&#125; &#x2F;&#x2F; 每次渲染都会创建新对象\n    onClick&#x3D;&#123;() &#x3D;&gt; &#123;&#125;&#125; &#x2F;&#x2F; 每次渲染都会创建新函数\n  &#x2F;&gt;\n);\n\n&#x2F;&#x2F; 正确做法\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const style &#x3D; &#123; margin: 10 &#125;;\n  const handleClick &#x3D; useCallback(() &#x3D;&gt; &#123;&#125;, []);\n\n  return &lt;PureChild style&#x3D;&#123;style&#125; onClick&#x3D;&#123;handleClick&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h3><h4 id=\"普通组件-vs-纯组件\"><a href=\"#普通组件-vs-纯组件\" class=\"headerlink\" title=\"普通组件 vs 纯组件\"></a>普通组件 vs 纯组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 普通组件 - 每次父组件更新都会重渲染\nconst RegularComponent &#x3D; (&#123; data &#125;) &#x3D;&gt; &lt;div&gt;&#123;data.text&#125;&lt;&#x2F;div&gt;;\n\n&#x2F;&#x2F; 纯组件 - 只在 props 真正变化时重渲染\nconst PureComponent &#x3D; React.memo((&#123; data &#125;) &#x3D;&gt; &lt;div&gt;&#123;data.text&#125;&lt;&#x2F;div&gt;);</code></pre>\n\n<p>纯组件通过浅比较机制，可以有效减少不必要的重渲染，提高应用性能。但要注意合理使用，避免过度优化或错误使用导致的问题。</p>\n<h2 id=\"Component-Element-Instance-之间有什么区别和联系？\"><a href=\"#Component-Element-Instance-之间有什么区别和联系？\" class=\"headerlink\" title=\"Component, Element, Instance 之间有什么区别和联系？\"></a>Component, Element, Instance 之间有什么区别和联系？</h2><h3 id=\"Component、Element-和-Instance-的基本概念\"><a href=\"#Component、Element-和-Instance-的基本概念\" class=\"headerlink\" title=\"Component、Element 和 Instance 的基本概念\"></a>Component、Element 和 Instance 的基本概念</h3><h4 id=\"Component（组件）\"><a href=\"#Component（组件）\" class=\"headerlink\" title=\"Component（组件）\"></a>Component（组件）</h4><ul>\n<li>是一个函数或类</li>\n<li>接收 props 作为输入</li>\n<li>返回用于描述 UI 的 React Elements</li>\n</ul>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 函数组件\nfunction Welcome(props) &#123;\n  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;\n&#125;\n\n&#x2F;&#x2F; 类组件\nclass Welcome extends React.Component &#123;\n  render() &#123;\n    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"Element（元素）\"><a href=\"#Element（元素）\" class=\"headerlink\" title=\"Element（元素）\"></a>Element（元素）</h4><ul>\n<li>是一个普通对象</li>\n<li>描述你想要在屏幕上看到的内容</li>\n<li>是组件的返回值</li>\n</ul>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; React Element 的结构\nconst element &#x3D; &#123;\n  type: &quot;div&quot;,\n  props: &#123;\n    className: &quot;container&quot;,\n    children: &quot;Hello World&quot;,\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; JSX 创建 Element\nconst element &#x3D; &lt;div className&#x3D;&quot;container&quot;&gt;Hello World&lt;&#x2F;div&gt;;</code></pre>\n\n<h4 id=\"Instance（实例）\"><a href=\"#Instance（实例）\" class=\"headerlink\" title=\"Instance（实例）\"></a>Instance（实例）</h4><ul>\n<li>是组件被实例化后的对象</li>\n<li>包含组件的状态和生命周期方法</li>\n<li>只有类组件才有实例</li>\n</ul>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class Counter extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; count: 0 &#125;; &#x2F;&#x2F; 实例的状态\n  &#125;\n\n  render() &#123;\n    return &lt;div&gt;&#123;this.state.count&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"三者之间的关系\"><a href=\"#三者之间的关系\" class=\"headerlink\" title=\"三者之间的关系\"></a>三者之间的关系</h3><h4 id=\"创建过程\"><a href=\"#创建过程\" class=\"headerlink\" title=\"创建过程\"></a>创建过程</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 1. 定义组件\nclass MyComponent extends React.Component &#123;\n  render() &#123;\n    return &lt;div&gt;Hello&lt;&#x2F;div&gt;; &#x2F;&#x2F; 返回 Element\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 2. 创建 Element\nconst element &#x3D; &lt;MyComponent &#x2F;&gt;; &#x2F;&#x2F; &#123; type: MyComponent, props: &#123;&#125; &#125;\n\n&#x2F;&#x2F; 3. React 创建实例\n&#x2F;&#x2F; React 内部会创建实例: new MyComponent(props)</code></pre>\n\n<h4 id=\"函数组件的特殊性\"><a href=\"#函数组件的特殊性\" class=\"headerlink\" title=\"函数组件的特殊性\"></a>函数组件的特殊性</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 函数组件没有实例\nconst FunctionalComponent &#x3D; (props) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 没有 this，没有实例方法\n  return &lt;div&gt;&#123;props.message&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\n&#x2F;&#x2F; Hooks 让函数组件也能拥有状态\nconst HookedComponent &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n  &#x2F;&#x2F; 虽然有状态，但仍然没有实例\n  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"使用场景的区别\"><a href=\"#使用场景的区别\" class=\"headerlink\" title=\"使用场景的区别\"></a>使用场景的区别</h3><h4 id=\"Component-的使用\"><a href=\"#Component-的使用\" class=\"headerlink\" title=\"Component 的使用\"></a>Component 的使用</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 可复用的 UI 单元\nclass UserCard extends React.Component &#123;\n  render() &#123;\n    return (\n      &lt;div className&#x3D;&quot;user-card&quot;&gt;\n        &lt;img src&#x3D;&#123;this.props.avatar&#125; &#x2F;&gt;\n        &lt;h2&gt;&#123;this.props.name&#125;&lt;&#x2F;h2&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"Element-的使用\"><a href=\"#Element-的使用\" class=\"headerlink\" title=\"Element 的使用\"></a>Element 的使用</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 描述 UI 结构\nconst element &#x3D; (\n  &lt;div&gt;\n    &lt;UserCard avatar&#x3D;&quot;avatar.jpg&quot; name&#x3D;&quot;John&quot; &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n);</code></pre>\n\n<h4 id=\"Instance-的应用\"><a href=\"#Instance-的应用\" class=\"headerlink\" title=\"Instance 的应用\"></a>Instance 的应用</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class Modal extends React.Component &#123;\n  &#x2F;&#x2F; 实例方法\n  show() &#123;\n    this.setState(&#123; visible: true &#125;);\n  &#125;\n\n  hide() &#123;\n    this.setState(&#123; visible: false &#125;);\n  &#125;\n\n  render() &#123;\n    return this.state.visible ? (\n      &lt;div className&#x3D;&quot;modal&quot;&gt;&#123;this.props.children&#125;&lt;&#x2F;div&gt;\n    ) : null;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 通过 ref 访问实例方法\nclass App extends React.Component &#123;\n  modalRef &#x3D; React.createRef();\n\n  handleClick &#x3D; () &#x3D;&gt; &#123;\n    this.modalRef.current.show();\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;&gt;\n        &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;显示弹窗&lt;&#x2F;button&gt;\n        &lt;Modal ref&#x3D;&#123;this.modalRef&#125;&gt;弹窗内容&lt;&#x2F;Modal&gt;\n      &lt;&#x2F;&gt;\n    );\n  &#125;\n&#125;</code></pre>\n\n<p>理解这三者的区别和联系对于深入理解 React 的工作原理非常重要，也有助于我们更好地使用 React 进行开发。</p>\n<h2 id=\"React-高阶组件是什么，和普通组件有什么区别，适用什么场景\"><a href=\"#React-高阶组件是什么，和普通组件有什么区别，适用什么场景\" class=\"headerlink\" title=\"React 高阶组件是什么，和普通组件有什么区别，适用什么场景\"></a>React 高阶组件是什么，和普通组件有什么区别，适用什么场景</h2><h3 id=\"高阶组件的概念\"><a href=\"#高阶组件的概念\" class=\"headerlink\" title=\"高阶组件的概念\"></a>高阶组件的概念</h3><p>高阶组件(HOC)是 React 中用于复用组件逻辑的高级技术，它是一个函数，接收一个组件作为参数并返回一个新组件。</p>\n<h3 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 基础的高阶组件示例\nconst withSubscription &#x3D; (WrappedComponent) &#x3D;&gt; &#123;\n  return class extends React.Component &#123;\n    state &#x3D; &#123;\n      data: null,\n    &#125;;\n\n    componentDidMount() &#123;\n      &#x2F;&#x2F; 处理订阅逻辑\n      this.setState(&#123; data: &quot;subscribed data&quot; &#125;);\n    &#125;\n\n    render() &#123;\n      &#x2F;&#x2F; 将新数据和原始props传递给被包装组件\n      return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;\n    &#125;\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; 使用高阶组件\nconst EnhancedComponent &#x3D; withSubscription(OriginalComponent);</code></pre>\n\n<h3 id=\"与普通组件的区别\"><a href=\"#与普通组件的区别\" class=\"headerlink\" title=\"与普通组件的区别\"></a>与普通组件的区别</h3><h4 id=\"功能增强\"><a href=\"#功能增强\" class=\"headerlink\" title=\"功能增强\"></a>功能增强</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 普通组件\nconst Button &#x3D; (props) &#x3D;&gt; &#123;\n  return &lt;button&gt;&#123;props.text&#125;&lt;&#x2F;button&gt;;\n&#125;;\n\n&#x2F;&#x2F; 高阶组件增强\nconst withLogging &#x3D; (WrappedComponent) &#x3D;&gt; &#123;\n  return class extends React.Component &#123;\n    componentDidMount() &#123;\n      console.log(&quot;Component mounted&quot;);\n    &#125;\n\n    render() &#123;\n      return &lt;WrappedComponent &#123;...this.props&#125; &#x2F;&gt;;\n    &#125;\n  &#125;;\n&#125;;\n\nconst LoggedButton &#x3D; withLogging(Button);</code></pre>\n\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><h4 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const withAuth &#x3D; (WrappedComponent) &#x3D;&gt; &#123;\n  return function WithAuthComponent(props) &#123;\n    const isAuthenticated &#x3D; useAuth(); &#x2F;&#x2F; 自定义 hook 检查认证状态\n\n    if (!isAuthenticated) &#123;\n      return &lt;Navigate to&#x3D;&quot;&#x2F;login&quot; &#x2F;&gt;;\n    &#125;\n\n    return &lt;WrappedComponent &#123;...props&#125; &#x2F;&gt;;\n  &#125;;\n&#125;;</code></pre>\n\n<h4 id=\"数据获取\"><a href=\"#数据获取\" class=\"headerlink\" title=\"数据获取\"></a>数据获取</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const withData &#x3D; (WrappedComponent, dataSource) &#x3D;&gt; &#123;\n  return function WithDataComponent(props) &#123;\n    const [data, setData] &#x3D; useState(null);\n\n    useEffect(() &#x3D;&gt; &#123;\n      const fetchData &#x3D; async () &#x3D;&gt; &#123;\n        const result &#x3D; await dataSource();\n        setData(result);\n      &#125;;\n      fetchData();\n    &#125;, []);\n\n    return &lt;WrappedComponent data&#x3D;&#123;data&#125; &#123;...props&#125; &#x2F;&gt;;\n  &#125;;\n&#125;;</code></pre>\n\n<h4 id=\"属性代理\"><a href=\"#属性代理\" class=\"headerlink\" title=\"属性代理\"></a>属性代理</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const withStyles &#x3D; (WrappedComponent, styles) &#x3D;&gt; &#123;\n  return function WithStylesComponent(props) &#123;\n    return (\n      &lt;div style&#x3D;&#123;styles&#125;&gt;\n        &lt;WrappedComponent &#123;...props&#125; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-1\"><a href=\"#最佳实践-1\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组合多个-HOC\"><a href=\"#组合多个-HOC\" class=\"headerlink\" title=\"组合多个 HOC\"></a>组合多个 HOC</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 组合多个高阶组件\nconst enhance &#x3D; compose(withAuth, withStyles(styles), withData(dataSource));\n\nconst EnhancedComponent &#x3D; enhance(BaseComponent);</code></pre>\n\n<h3 id=\"注意事项-3\"><a href=\"#注意事项-3\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不要在渲染方法中使用 HOC</li>\n<li>务必复制静态方法</li>\n<li>Refs 不会被传递</li>\n<li>注意组件显示名称的设置</li>\n</ul>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 设置显示名称的最佳实践\nconst withHOC &#x3D; (WrappedComponent) &#x3D;&gt; &#123;\n  class WithHOC extends React.Component &#123;\n    &#x2F;* ... *&#x2F;\n  &#125;\n\n  WithHOC.displayName &#x3D; &#96;WithHOC($&#123;getDisplayName(WrappedComponent)&#125;)&#96;;\n  return WithHOC;\n&#125;;\n\nfunction getDisplayName(WrappedComponent) &#123;\n  return WrappedComponent.displayName || WrappedComponent.name || &quot;Component&quot;;\n&#125;</code></pre>\n\n<p>高阶组件是 React 中重要的代码复用模式，但随着 Hooks 的引入，某些场景下可能会更倾向于使用 Hooks。选择使用 HOC 还是 Hooks 应该根据具体场景来决定。</p>\n<h2 id=\"哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？\"><a href=\"#哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？\" class=\"headerlink\" title=\"哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？\"></a>哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h2><h3 id=\"触发重新渲染的方法\"><a href=\"#触发重新渲染的方法\" class=\"headerlink\" title=\"触发重新渲染的方法\"></a>触发重新渲染的方法</h3><h4 id=\"State-更新触发\"><a href=\"#State-更新触发\" class=\"headerlink\" title=\"State 更新触发\"></a>State 更新触发</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 触发重渲染\n    &#x2F;&#x2F; React 18 中的自动批处理会合并多个状态更新\n    setCount((c) &#x3D;&gt; c + 1);\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h4 id=\"Props-变化触发\"><a href=\"#Props-变化触发\" class=\"headerlink\" title=\"Props 变化触发\"></a>Props 变化触发</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Child &#x3D; (&#123; data &#125;) &#x3D;&gt; &#123;\n  console.log(&quot;Child rendering&quot;);\n  return &lt;div&gt;&#123;data&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const [value, setValue] &#x3D; useState(&quot;&quot;);\n  return (\n    &lt;&gt;\n      &lt;input onChange&#x3D;&#123;(e) &#x3D;&gt; setValue(e.target.value)&#125; &#x2F;&gt;\n      &lt;Child data&#x3D;&#123;value&#125; &#x2F;&gt; &#123;&#x2F;* props变化触发Child重渲染 *&#x2F;&#125;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"Context-更新触发\"><a href=\"#Context-更新触发\" class=\"headerlink\" title=\"Context 更新触发\"></a>Context 更新触发</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ThemeContext &#x3D; createContext();\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [theme, setTheme] &#x3D; useState(&quot;light&quot;);\n\n  return (\n    &lt;ThemeContext.Provider value&#x3D;&#123;theme&#125;&gt;\n      &lt;ThemedButton &#x2F;&gt; &#123;&#x2F;* context变化触发消费组件重渲染 *&#x2F;&#125;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setTheme(&quot;dark&quot;)&#125;&gt;切换主题&lt;&#x2F;button&gt;\n    &lt;&#x2F;ThemeContext.Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"重渲染过程中的工作\"><a href=\"#重渲染过程中的工作\" class=\"headerlink\" title=\"重渲染过程中的工作\"></a>重渲染过程中的工作</h3><h4 id=\"1-调和阶段-Reconciliation\"><a href=\"#1-调和阶段-Reconciliation\" class=\"headerlink\" title=\"1. 调和阶段(Reconciliation)\"></a>1. 调和阶段(Reconciliation)</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const TodoList &#x3D; () &#x3D;&gt; &#123;\n  const [todos, setTodos] &#x3D; useState([]);\n\n  const addTodo &#x3D; (text) &#x3D;&gt; &#123;\n    setTodos([...todos, &#123; id: Date.now(), text &#125;]);\n    &#x2F;&#x2F; React 会:\n    &#x2F;&#x2F; 1. 创建新的虚拟DOM树\n    &#x2F;&#x2F; 2. 通过Fiber进行diff比较\n    &#x2F;&#x2F; 3. 标记需要更新的节点\n  &#125;;\n\n  return (\n    &lt;ul&gt;\n      &#123;todos.map((todo) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"2-提交阶段-Commit\"><a href=\"#2-提交阶段-Commit\" class=\"headerlink\" title=\"2. 提交阶段(Commit)\"></a>2. 提交阶段(Commit)</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Form &#x3D; () &#x3D;&gt; &#123;\n  const [visible, setVisible] &#x3D; useState(false);\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setVisible(!visible)&#125;&gt;切换&lt;&#x2F;button&gt;\n      &#123;visible &amp;&amp; &lt;Modal &#x2F;&gt;&#125; &#123;&#x2F;* React 会:\n        1. 根据diff结果更新DOM\n        2. 调用useLayoutEffect\n        3. 调用useEffect\n      *&#x2F;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"3-渲染优化\"><a href=\"#3-渲染优化\" class=\"headerlink\" title=\"3. 渲染优化\"></a>3. 渲染优化</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ExpensiveList &#x3D; memo((&#123; items &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;ul&gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;);\n\n&#x2F;&#x2F; 使用memo避免不必要的重渲染\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const items &#x3D; useMemo(() &#x3D;&gt; generateItems(), []); &#x2F;&#x2F; 缓存数据\n\n  return (\n    &lt;&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount((c) &#x3D;&gt; c + 1)&#125;&gt;点击 (&#123;count&#125;)&lt;&#x2F;button&gt;\n      &lt;ExpensiveList items&#x3D;&#123;items&#125; &#x2F;&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-4\"><a href=\"#注意事项-4\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>React 18 中的自动批处理会合并多个状态更新</li>\n<li>异步更新可能会导致多次渲染</li>\n<li>应该使用适当的优化手段(memo, useMemo, useCallback)来避免不必要的重渲染</li>\n<li>重渲染不一定会导致 DOM 更新，React 会进行必要的优化</li>\n</ul>\n<h2 id=\"React-如何判断什么时候重新渲染组件？\"><a href=\"#React-如何判断什么时候重新渲染组件？\" class=\"headerlink\" title=\"React 如何判断什么时候重新渲染组件？\"></a>React 如何判断什么时候重新渲染组件？</h2><h3 id=\"React-判断重新渲染的机制\"><a href=\"#React-判断重新渲染的机制\" class=\"headerlink\" title=\"React 判断重新渲染的机制\"></a>React 判断重新渲染的机制</h3><h4 id=\"触发重新渲染的条件\"><a href=\"#触发重新渲染的条件\" class=\"headerlink\" title=\"触发重新渲染的条件\"></a>触发重新渲染的条件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ExampleComponent &#x3D; (&#123; data &#125;) &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  &#x2F;&#x2F; 以下情况会触发重新渲染:\n  &#x2F;&#x2F; 1. props(data) 发生变化\n  &#x2F;&#x2F; 2. state(count) 发生变化\n  &#x2F;&#x2F; 3. 父组件重新渲染\n  &#x2F;&#x2F; 4. context 值变化\n\n  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"默认的渲染行为\"><a href=\"#默认的渲染行为\" class=\"headerlink\" title=\"默认的渲染行为\"></a>默认的渲染行为</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 父组件重新渲染时，所有子组件默认都会重新渲染\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;Child1 &#x2F;&gt; &#123;&#x2F;* 会重新渲染 *&#x2F;&#125;\n      &lt;Child2 data&#x3D;&#123;count&#125; &#x2F;&gt; &#123;&#x2F;* 会重新渲染 *&#x2F;&#125;\n      &lt;Child3 data&#x3D;&quot;static&quot; &#x2F;&gt; &#123;&#x2F;* 也会重新渲染，即使props没变 *&#x2F;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"性能优化方案\"><a href=\"#性能优化方案\" class=\"headerlink\" title=\"性能优化方案\"></a>性能优化方案</h3><h4 id=\"使用-React-memo\"><a href=\"#使用-React-memo\" class=\"headerlink\" title=\"使用 React.memo\"></a>使用 React.memo</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const MemoizedChild &#x3D; React.memo((&#123; data &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 只有当 data prop 变化时才会重新渲染\n  return &lt;div&gt;&#123;data&#125;&lt;&#x2F;div&gt;;\n&#125;);\n\n&#x2F;&#x2F; 自定义比较函数\nconst areEqual &#x3D; (prevProps, nextProps) &#x3D;&gt; &#123;\n  return prevProps.data.id &#x3D;&#x3D;&#x3D; nextProps.data.id;\n&#125;;\n\nconst MemoizedWithCustomCompare &#x3D; React.memo(Component, areEqual);</code></pre>\n\n<h4 id=\"使用-useMemo\"><a href=\"#使用-useMemo\" class=\"headerlink\" title=\"使用 useMemo\"></a>使用 useMemo</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Parent &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  &#x2F;&#x2F; 缓存计算结果\n  const expensiveValue &#x3D; useMemo(() &#x3D;&gt; &#123;\n    return computeExpensiveValue(count);\n  &#125;, [count]);\n\n  return &lt;Child data&#x3D;&#123;expensiveValue&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h4 id=\"使用-useCallback\"><a href=\"#使用-useCallback\" class=\"headerlink\" title=\"使用 useCallback\"></a>使用 useCallback</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Parent &#x3D; () &#x3D;&gt; &#123;\n  const [items, setItems] &#x3D; useState([]);\n\n  &#x2F;&#x2F; 缓存回调函数\n  const handleClick &#x3D; useCallback(() &#x3D;&gt; &#123;\n    setItems((prev) &#x3D;&gt; [...prev, &quot;new item&quot;]);\n  &#125;, []); &#x2F;&#x2F; 依赖为空数组，函数永远不会改变\n\n  return &lt;Child onAdd&#x3D;&#123;handleClick&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"避免不必要渲染的最佳实践\"><a href=\"#避免不必要渲染的最佳实践\" class=\"headerlink\" title=\"避免不必要渲染的最佳实践\"></a>避免不必要渲染的最佳实践</h3><h4 id=\"状态提升和组件拆分\"><a href=\"#状态提升和组件拆分\" class=\"headerlink\" title=\"状态提升和组件拆分\"></a>状态提升和组件拆分</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  return (\n    &lt;&gt;\n      &lt;Counter count&#x3D;&#123;count&#125; onIncrement&#x3D;&#123;() &#x3D;&gt; setCount((c) &#x3D;&gt; c + 1)&#125; &#x2F;&gt;\n      &lt;ExpensiveList &#x2F;&gt; &#123;&#x2F;* 不依赖count，不会因count变化而重新渲染 *&#x2F;&#125;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"使用-children-prop\"><a href=\"#使用-children-prop\" class=\"headerlink\" title=\"使用 children prop\"></a>使用 children prop</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Wrapper &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState(false);\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setState(!state)&#125;&gt;Toggle&lt;&#x2F;button&gt;\n      &#123;children&#125; &#123;&#x2F;* children不会因为state变化而重新渲染 *&#x2F;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-5\"><a href=\"#注意事项-5\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不要过度优化</li>\n<li>确保比较函数的性能</li>\n<li>正确设置依赖数组</li>\n<li>合理使用 Context</li>\n<li>避免在渲染期间创建新的对象或函数</li>\n</ul>\n<p>React 的重新渲染机制是其性能优化的关键所在，合理使用各种优化手段可以显著提升应用性能。</p>\n<h2 id=\"React-声明组件有哪几种方法，有什么不同？\"><a href=\"#React-声明组件有哪几种方法，有什么不同？\" class=\"headerlink\" title=\"React 声明组件有哪几种方法，有什么不同？\"></a>React 声明组件有哪几种方法，有什么不同？</h2><h3 id=\"React-组件声明的主要方式\"><a href=\"#React-组件声明的主要方式\" class=\"headerlink\" title=\"React 组件声明的主要方式\"></a>React 组件声明的主要方式</h3><h4 id=\"函数组件（推荐）\"><a href=\"#函数组件（推荐）\" class=\"headerlink\" title=\"函数组件（推荐）\"></a>函数组件（推荐）</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 基础函数组件\nconst Welcome &#x3D; (props) &#x3D;&gt; &#123;\n  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;\n&#125;;\n\n&#x2F;&#x2F; 使用 Hooks 的函数组件\nconst Counter &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  useEffect(() &#x3D;&gt; &#123;\n    document.title &#x3D; &#96;点击了 $&#123;count&#125; 次&#96;;\n  &#125;, [count]);\n\n  return &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;点击次数: &#123;count&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h4 id=\"类组件\"><a href=\"#类组件\" class=\"headerlink\" title=\"类组件\"></a>类组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class Welcome extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; count: 0 &#125;;\n  &#125;\n\n  handleClick &#x3D; () &#x3D;&gt; &#123;\n    this.setState((state) &#x3D;&gt; (&#123;\n      count: state.count + 1,\n    &#125;));\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;点击次数: &#123;this.state.count&#125;&lt;&#x2F;button&gt;\n    );\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"两种方式的主要区别\"><a href=\"#两种方式的主要区别\" class=\"headerlink\" title=\"两种方式的主要区别\"></a>两种方式的主要区别</h3><h4 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 函数组件使用 Hooks 管理状态\nconst FunctionComponent &#x3D; () &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState(initialState);\n  return &lt;div&gt;&#123;state&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\n&#x2F;&#x2F; 类组件使用 this.state 管理状态\nclass ClassComponent extends React.Component &#123;\n  state &#x3D; &#123; value: initialState &#125;;\n  render() &#123;\n    return &lt;div&gt;&#123;this.state.value&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;</code></pre>\n\n<h4 id=\"生命周期处理\"><a href=\"#生命周期处理\" class=\"headerlink\" title=\"生命周期处理\"></a>生命周期处理</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 函数组件使用 useEffect 处理副作用\nconst FunctionComponent &#x3D; () &#x3D;&gt; &#123;\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 组件挂载后执行\n    console.log(&quot;mounted&quot;);\n    return () &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 组件卸载前执行\n      console.log(&quot;will unmount&quot;);\n    &#125;;\n  &#125;, []);\n\n  return &lt;div&gt;Function Component&lt;&#x2F;div&gt;;\n&#125;;\n\n&#x2F;&#x2F; 类组件使用生命周期方法\nclass ClassComponent extends React.Component &#123;\n  componentDidMount() &#123;\n    console.log(&quot;mounted&quot;);\n  &#125;\n\n  componentWillUnmount() &#123;\n    console.log(&quot;will unmount&quot;);\n  &#125;\n\n  render() &#123;\n    return &lt;div&gt;Class Component&lt;&#x2F;div&gt;;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"函数组件的优势\"><a href=\"#函数组件的优势\" class=\"headerlink\" title=\"函数组件的优势\"></a>函数组件的优势</h3><ul>\n<li>代码更简洁</li>\n<li>更容易理解和测试</li>\n<li>更好的性能优化</li>\n<li>更好的代码复用</li>\n<li>避免 this 绑定问题</li>\n</ul>\n<h3 id=\"最佳实践-2\"><a href=\"#最佳实践-2\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"使用函数组件和-Hooks\"><a href=\"#使用函数组件和-Hooks\" class=\"headerlink\" title=\"使用函数组件和 Hooks\"></a>使用函数组件和 Hooks</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const UserProfile &#x3D; () &#x3D;&gt; &#123;\n  const [user, setUser] &#x3D; useState(null);\n  const [loading, setLoading] &#x3D; useState(true);\n\n  useEffect(() &#x3D;&gt; &#123;\n    fetchUser().then((data) &#x3D;&gt; &#123;\n      setUser(data);\n      setLoading(false);\n    &#125;);\n  &#125;, []);\n\n  if (loading) return &lt;Loading &#x2F;&gt;;\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;&#123;user.name&#125;&lt;&#x2F;h1&gt;\n      &lt;p&gt;&#123;user.email&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-6\"><a href=\"#注意事项-6\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>优先使用函数组件</li>\n<li>合理使用 Hooks</li>\n<li>保持组件的纯函数特性</li>\n<li>避免过度解构和复杂的组件设计</li>\n</ul>\n<p>函数组件配合 Hooks 是 React 的未来发展方向，建议在新项目中优先使用函数组件。</p>\n<h2 id=\"对有状态组件和无状态组件的理解及使用场景\"><a href=\"#对有状态组件和无状态组件的理解及使用场景\" class=\"headerlink\" title=\"对有状态组件和无状态组件的理解及使用场景\"></a>对有状态组件和无状态组件的理解及使用场景</h2><h3 id=\"有状态组件和无状态组件的基本概念\"><a href=\"#有状态组件和无状态组件的基本概念\" class=\"headerlink\" title=\"有状态组件和无状态组件的基本概念\"></a>有状态组件和无状态组件的基本概念</h3><h4 id=\"无状态组件（展示型组件）\"><a href=\"#无状态组件（展示型组件）\" class=\"headerlink\" title=\"无状态组件（展示型组件）\"></a>无状态组件（展示型组件）</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 纯展示型组件，不包含状态\nconst UserCard &#x3D; (&#123; name, avatar, role &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;user-card&quot;&gt;\n      &lt;img src&#x3D;&#123;avatar&#125; alt&#x3D;&#123;name&#125; &#x2F;&gt;\n      &lt;h3&gt;&#123;name&#125;&lt;&#x2F;h3&gt;\n      &lt;span&gt;&#123;role&#125;&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"有状态组件（容器型组件）\"><a href=\"#有状态组件（容器型组件）\" class=\"headerlink\" title=\"有状态组件（容器型组件）\"></a>有状态组件（容器型组件）</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const UserProfile &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 包含状态管理\n  const [user, setUser] &#x3D; useState(null);\n  const [loading, setLoading] &#x3D; useState(true);\n\n  useEffect(() &#x3D;&gt; &#123;\n    fetchUserData().then((data) &#x3D;&gt; &#123;\n      setUser(data);\n      setLoading(false);\n    &#125;);\n  &#125;, []);\n\n  if (loading) return &lt;Loading &#x2F;&gt;;\n\n  return &lt;UserCard &#123;...user&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><h4 id=\"无状态组件适用场景\"><a href=\"#无状态组件适用场景\" class=\"headerlink\" title=\"无状态组件适用场景\"></a>无状态组件适用场景</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 1. 纯展示UI\nconst Button &#x3D; (&#123; text, onClick, type &#x3D; &quot;primary&quot; &#125;) &#x3D;&gt; (\n  &lt;button className&#x3D;&#123;&#96;btn btn-$&#123;type&#125;&#96;&#125; onClick&#x3D;&#123;onClick&#125;&gt;\n    &#123;text&#125;\n  &lt;&#x2F;button&gt;\n);\n\n&#x2F;&#x2F; 2. 列表项渲染\nconst TodoItem &#x3D; (&#123; todo, onToggle, onDelete &#125;) &#x3D;&gt; (\n  &lt;li&gt;\n    &lt;input\n      type&#x3D;&quot;checkbox&quot;\n      checked&#x3D;&#123;todo.completed&#125;\n      onChange&#x3D;&#123;() &#x3D;&gt; onToggle(todo.id)&#125;\n    &#x2F;&gt;\n    &lt;span&gt;&#123;todo.text&#125;&lt;&#x2F;span&gt;\n    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; onDelete(todo.id)&#125;&gt;删除&lt;&#x2F;button&gt;\n  &lt;&#x2F;li&gt;\n);</code></pre>\n\n<h4 id=\"有状态组件适用场景\"><a href=\"#有状态组件适用场景\" class=\"headerlink\" title=\"有状态组件适用场景\"></a>有状态组件适用场景</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 1. 数据管理\nconst TodoList &#x3D; () &#x3D;&gt; &#123;\n  const [todos, setTodos] &#x3D; useState([]);\n  const [filter, setFilter] &#x3D; useState(&quot;all&quot;);\n\n  const addTodo &#x3D; (text) &#x3D;&gt; &#123;\n    setTodos((prev) &#x3D;&gt; [...prev, &#123; id: Date.now(), text, completed: false &#125;]);\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;AddTodoForm onAdd&#x3D;&#123;addTodo&#125; &#x2F;&gt;\n      &lt;FilterButtons currentFilter&#x3D;&#123;filter&#125; onFilterChange&#x3D;&#123;setFilter&#125; &#x2F;&gt;\n      &lt;TodoItems todos&#x3D;&#123;todos&#125; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 2. 复杂交互逻辑\nconst Form &#x3D; () &#x3D;&gt; &#123;\n  const [values, setValues] &#x3D; useState(&#123;&#125;);\n  const [errors, setErrors] &#x3D; useState(&#123;&#125;);\n  const [isSubmitting, setIsSubmitting] &#x3D; useState(false);\n\n  const handleSubmit &#x3D; async (e) &#x3D;&gt; &#123;\n    e.preventDefault();\n    setIsSubmitting(true);\n    try &#123;\n      await submitForm(values);\n    &#125; catch (err) &#123;\n      setErrors(err.validationErrors);\n    &#125; finally &#123;\n      setIsSubmitting(false);\n    &#125;\n  &#125;;\n\n  return (\n    &lt;form onSubmit&#x3D;&#123;handleSubmit&#125;&gt;\n      &lt;FormFields values&#x3D;&#123;values&#125; onChange&#x3D;&#123;setValues&#125; errors&#x3D;&#123;errors&#125; &#x2F;&gt;\n      &lt;SubmitButton disabled&#x3D;&#123;isSubmitting&#125; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-3\"><a href=\"#最佳实践-3\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组件拆分原则\"><a href=\"#组件拆分原则\" class=\"headerlink\" title=\"组件拆分原则\"></a>组件拆分原则</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 将复杂组件拆分为状态组件和展示组件\nconst DataTable &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 状态管理逻辑\n  const [data, setData] &#x3D; useState([]);\n  const [sorting, setSorting] &#x3D; useState(&#123; field: &quot;id&quot;, order: &quot;asc&quot; &#125;);\n\n  &#x2F;&#x2F; 将展示部分抽离为无状态组件\n  return (\n    &lt;TablePresentation data&#x3D;&#123;data&#125; sorting&#x3D;&#123;sorting&#125; onSort&#x3D;&#123;setSorting&#125; &#x2F;&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 纯展示组件\nconst TablePresentation &#x3D; (&#123; data, sorting, onSort &#125;) &#x3D;&gt; (\n  &lt;table&gt;\n    &lt;TableHeader sorting&#x3D;&#123;sorting&#125; onSort&#x3D;&#123;onSort&#125; &#x2F;&gt;\n    &lt;TableBody data&#x3D;&#123;data&#125; &#x2F;&gt;\n  &lt;&#x2F;table&gt;\n);</code></pre>\n\n<h3 id=\"注意事项-7\"><a href=\"#注意事项-7\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>优先使用无状态组件，除非确实需要状态管理</li>\n<li>合理划分组件职责，保持单一职责原则</li>\n<li>避免过度拆分组件</li>\n<li>注意性能优化，合理使用 memo</li>\n<li>保持组件的可测试性</li>\n</ul>\n<p>通过合理使用有状态和无状态组件，可以使代码更加清晰、可维护，并且更容易进行测试和性能优化。</p>\n<h2 id=\"对-React-中-Fragment-的理解，它的使用场景是什么？\"><a href=\"#对-React-中-Fragment-的理解，它的使用场景是什么？\" class=\"headerlink\" title=\"对 React 中 Fragment 的理解，它的使用场景是什么？\"></a>对 React 中 Fragment 的理解，它的使用场景是什么？</h2><h3 id=\"Fragment-的基本概念\"><a href=\"#Fragment-的基本概念\" class=\"headerlink\" title=\"Fragment 的基本概念\"></a>Fragment 的基本概念</h3><p>Fragment 是 React 提供的一个特殊组件，允许将多个子元素组合在一起，而无需创建额外的 DOM 节点。</p>\n<h3 id=\"基本使用方式\"><a href=\"#基本使用方式\" class=\"headerlink\" title=\"基本使用方式\"></a>基本使用方式</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 完整语法\nconst List &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;React.Fragment&gt;\n      &lt;li&gt;Item 1&lt;&#x2F;li&gt;\n      &lt;li&gt;Item 2&lt;&#x2F;li&gt;\n      &lt;li&gt;Item 3&lt;&#x2F;li&gt;\n    &lt;&#x2F;React.Fragment&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 简写语法\nconst List &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;&gt;\n      &lt;li&gt;Item 1&lt;&#x2F;li&gt;\n      &lt;li&gt;Item 2&lt;&#x2F;li&gt;\n      &lt;li&gt;Item 3&lt;&#x2F;li&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"主要使用场景\"><a href=\"#主要使用场景\" class=\"headerlink\" title=\"主要使用场景\"></a>主要使用场景</h3><h4 id=\"返回多个元素\"><a href=\"#返回多个元素\" class=\"headerlink\" title=\"返回多个元素\"></a>返回多个元素</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Table &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;table&gt;\n      &lt;tbody&gt;\n        &lt;tr&gt;\n          &#123;&#x2F;* Fragment 避免添加多余的包装元素 *&#x2F;&#125;\n          &lt;&gt;\n            &lt;td&gt;Cell 1&lt;&#x2F;td&gt;\n            &lt;td&gt;Cell 2&lt;&#x2F;td&gt;\n          &lt;&#x2F;&gt;\n        &lt;&#x2F;tr&gt;\n      &lt;&#x2F;tbody&gt;\n    &lt;&#x2F;table&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"条件渲染-1\"><a href=\"#条件渲染-1\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ConditionalRender &#x3D; (&#123; isLoggedIn &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;&gt;\n      &#123;isLoggedIn ? (\n        &lt;&gt;\n          &lt;UserProfile &#x2F;&gt;\n          &lt;LogoutButton &#x2F;&gt;\n        &lt;&#x2F;&gt;\n      ) : (\n        &lt;&gt;\n          &lt;LoginForm &#x2F;&gt;\n          &lt;SignUpLink &#x2F;&gt;\n        &lt;&#x2F;&gt;\n      )&#125;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ItemList &#x3D; (&#123; items &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;ul&gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;Fragment key&#x3D;&#123;item.id&#125;&gt;\n          &lt;li&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n          &lt;li&gt;&#123;item.description&#125;&lt;&#x2F;li&gt;\n        &lt;&#x2F;Fragment&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"带-key-的-Fragment\"><a href=\"#带-key-的-Fragment\" class=\"headerlink\" title=\"带 key 的 Fragment\"></a>带 key 的 Fragment</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 当需要在 Fragment 上使用 key 时，必须使用完整语法\nconst Glossary &#x3D; (&#123; items &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;dl&gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;Fragment key&#x3D;&#123;item.id&#125;&gt;\n          &lt;dt&gt;&#123;item.term&#125;&lt;&#x2F;dt&gt;\n          &lt;dd&gt;&#123;item.description&#125;&lt;&#x2F;dd&gt;\n        &lt;&#x2F;Fragment&gt;\n      ))&#125;\n    &lt;&#x2F;dl&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"性能优化-1\"><a href=\"#性能优化-1\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 避免不必要的 DOM 嵌套\nconst OptimizedList &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;&gt;\n      &#123;&#x2F;* 不会创建额外的 DOM 节点 *&#x2F;&#125;\n      &lt;ListHeader &#x2F;&gt;\n      &lt;ListItems &#x2F;&gt;\n      &lt;ListFooter &#x2F;&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-8\"><a href=\"#注意事项-8\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>Fragment 不支持除 key 之外的其他属性</li>\n<li>短语法 <code>&lt;&gt;</code> 不支持 key 或其他属性</li>\n<li>Fragment 内部可以包含任意数量的子元素</li>\n<li>可以嵌套使用 Fragment</li>\n</ul>\n<p>Fragment 是 React 中一个非常实用的功能，它帮助我们创建更清晰的组件结构，同时避免了不必要的 DOM 节点。</p>\n<h2 id=\"React-如何获取组件对应的-DOM-元素？\"><a href=\"#React-如何获取组件对应的-DOM-元素？\" class=\"headerlink\" title=\"React 如何获取组件对应的 DOM 元素？\"></a>React 如何获取组件对应的 DOM 元素？</h2><h3 id=\"React-获取-DOM-元素的方法\"><a href=\"#React-获取-DOM-元素的方法\" class=\"headerlink\" title=\"React 获取 DOM 元素的方法\"></a>React 获取 DOM 元素的方法</h3><h4 id=\"使用-useRef-Hook\"><a href=\"#使用-useRef-Hook\" class=\"headerlink\" title=\"使用 useRef Hook\"></a>使用 useRef Hook</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const InputComponent &#x3D; () &#x3D;&gt; &#123;\n  const inputRef &#x3D; useRef(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 可以直接访问 DOM 元素\n    inputRef.current.focus();\n  &#125;, []);\n\n  return &lt;input ref&#x3D;&#123;inputRef&#125; type&#x3D;&quot;text&quot; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"回调-Refs\"><a href=\"#回调-Refs\" class=\"headerlink\" title=\"回调 Refs\"></a>回调 Refs</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const TextArea &#x3D; () &#x3D;&gt; &#123;\n  const [height, setHeight] &#x3D; useState(0);\n\n  const measuredRef &#x3D; useCallback((node) &#x3D;&gt; &#123;\n    if (node !&#x3D;&#x3D; null) &#123;\n      setHeight(node.getBoundingClientRect().height);\n    &#125;\n  &#125;, []);\n\n  return (\n    &lt;&gt;\n      &lt;textarea ref&#x3D;&#123;measuredRef&#125; &#x2F;&gt;\n      &lt;p&gt;高度: &#123;height&#125;px&lt;&#x2F;p&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"转发-Refs\"><a href=\"#转发-Refs\" class=\"headerlink\" title=\"转发 Refs\"></a>转发 Refs</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建一个可以转发 ref 的组件\nconst FancyButton &#x3D; forwardRef((props, ref) &#x3D;&gt; (\n  &lt;button ref&#x3D;&#123;ref&#125; className&#x3D;&quot;fancy-btn&quot; &#123;...props&#125;&gt;\n    &#123;props.children&#125;\n  &lt;&#x2F;button&gt;\n));\n\n&#x2F;&#x2F; 使用转发的 ref\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const buttonRef &#x3D; useRef(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 可以访问到按钮 DOM 元素\n    console.log(buttonRef.current);\n  &#125;, []);\n\n  return &lt;FancyButton ref&#x3D;&#123;buttonRef&#125;&gt;点击我&lt;&#x2F;FancyButton&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"多个-Refs-的管理\"><a href=\"#多个-Refs-的管理\" class=\"headerlink\" title=\"多个 Refs 的管理\"></a>多个 Refs 的管理</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const MultipleRefs &#x3D; () &#x3D;&gt; &#123;\n  const refs &#x3D; useRef(&#123;&#125;);\n\n  const setRef &#x3D; useCallback((element, id) &#x3D;&gt; &#123;\n    if (element) &#123;\n      refs.current[id] &#x3D; element;\n    &#125;\n  &#125;, []);\n\n  return (\n    &lt;div&gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;div key&#x3D;&#123;item.id&#125; ref&#x3D;&#123;(el) &#x3D;&gt; setRef(el, item.id)&#125;&gt;\n          &#123;item.content&#125;\n        &lt;&#x2F;div&gt;\n      ))&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"常见使用场景\"><a href=\"#常见使用场景\" class=\"headerlink\" title=\"常见使用场景\"></a>常见使用场景</h3><h4 id=\"表单操作\"><a href=\"#表单操作\" class=\"headerlink\" title=\"表单操作\"></a>表单操作</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Form &#x3D; () &#x3D;&gt; &#123;\n  const inputRef &#x3D; useRef(null);\n\n  const handleSubmit &#x3D; (e) &#x3D;&gt; &#123;\n    e.preventDefault();\n    &#x2F;&#x2F; 获取输入值\n    console.log(inputRef.current.value);\n    &#x2F;&#x2F; 清空输入\n    inputRef.current.value &#x3D; &quot;&quot;;\n    &#x2F;&#x2F; 聚焦\n    inputRef.current.focus();\n  &#125;;\n\n  return (\n    &lt;form onSubmit&#x3D;&#123;handleSubmit&#125;&gt;\n      &lt;input ref&#x3D;&#123;inputRef&#125; type&#x3D;&quot;text&quot; &#x2F;&gt;\n      &lt;button type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"媒体控制\"><a href=\"#媒体控制\" class=\"headerlink\" title=\"媒体控制\"></a>媒体控制</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const VideoPlayer &#x3D; () &#x3D;&gt; &#123;\n  const videoRef &#x3D; useRef(null);\n\n  const handlePlay &#x3D; () &#x3D;&gt; &#123;\n    videoRef.current.play();\n  &#125;;\n\n  const handlePause &#x3D; () &#x3D;&gt; &#123;\n    videoRef.current.pause();\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;video ref&#x3D;&#123;videoRef&#125; src&#x3D;&#123;videoUrl&#125; &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;handlePlay&#125;&gt;播放&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;handlePause&#125;&gt;暂停&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-9\"><a href=\"#注意事项-9\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>避免过度使用 refs</li>\n<li>不要在渲染过程中访问 refs</li>\n<li>使用 useCallback 缓存 ref 回调</li>\n<li>注意 ref 的清理工作</li>\n<li>优先考虑声明式的解决方案</li>\n</ul>\n<p>Refs 提供了一种访问 DOM 元素的方式，但应该谨慎使用，只在必要时才使用它们。</p>\n<h2 id=\"对-React-的插槽-Portals-的理解，如何使用，有哪些使用场景\"><a href=\"#对-React-的插槽-Portals-的理解，如何使用，有哪些使用场景\" class=\"headerlink\" title=\"对 React 的插槽(Portals)的理解，如何使用，有哪些使用场景\"></a>对 React 的插槽(Portals)的理解，如何使用，有哪些使用场景</h2><h3 id=\"Portals-的基本概念\"><a href=\"#Portals-的基本概念\" class=\"headerlink\" title=\"Portals 的基本概念\"></a>Portals 的基本概念</h3><p>Portal 提供了一种将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点的方案。</p>\n<h3 id=\"基本使用方式-1\"><a href=\"#基本使用方式-1\" class=\"headerlink\" title=\"基本使用方式\"></a>基本使用方式</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建一个 Portal\nconst Modal &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  return createPortal(children, document.getElementById(&quot;modal-root&quot;));\n&#125;;\n\n&#x2F;&#x2F; 使用 Portal\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [isOpen, setIsOpen] &#x3D; useState(false);\n\n  return (\n    &lt;div className&#x3D;&quot;app&quot;&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setIsOpen(true)&#125;&gt;打开弹窗&lt;&#x2F;button&gt;\n\n      &#123;isOpen &amp;&amp; (\n        &lt;Modal&gt;\n          &lt;div className&#x3D;&quot;modal&quot;&gt;\n            &lt;h2&gt;Modal 标题&lt;&#x2F;h2&gt;\n            &lt;p&gt;Modal 内容&lt;&#x2F;p&gt;\n            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setIsOpen(false)&#125;&gt;关闭&lt;&#x2F;button&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;Modal&gt;\n      )&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"常见使用场景-1\"><a href=\"#常见使用场景-1\" class=\"headerlink\" title=\"常见使用场景\"></a>常见使用场景</h3><h4 id=\"1-模态框\"><a href=\"#1-模态框\" class=\"headerlink\" title=\"1. 模态框\"></a>1. 模态框</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Modal &#x3D; (&#123; isOpen, onClose, children &#125;) &#x3D;&gt; &#123;\n  if (!isOpen) return null;\n\n  return createPortal(\n    &lt;div className&#x3D;&quot;modal-overlay&quot;&gt;\n      &lt;div className&#x3D;&quot;modal-content&quot;&gt;\n        &#123;children&#125;\n        &lt;button onClick&#x3D;&#123;onClose&#125;&gt;关闭&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;,\n    document.body\n  );\n&#125;;\n\n&#x2F;&#x2F; 使用模态框\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [showModal, setShowModal] &#x3D; useState(false);\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setShowModal(true)&#125;&gt;显示模态框&lt;&#x2F;button&gt;\n\n      &lt;Modal isOpen&#x3D;&#123;showModal&#125; onClose&#x3D;&#123;() &#x3D;&gt; setShowModal(false)&#125;&gt;\n        &lt;h2&gt;欢迎使用&lt;&#x2F;h2&gt;\n        &lt;p&gt;这是一个模态框示例&lt;&#x2F;p&gt;\n      &lt;&#x2F;Modal&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"2-提示框和通知\"><a href=\"#2-提示框和通知\" class=\"headerlink\" title=\"2. 提示框和通知\"></a>2. 提示框和通知</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Toast &#x3D; (&#123; message &#125;) &#x3D;&gt; &#123;\n  return createPortal(\n    &lt;div className&#x3D;&quot;toast&quot;&gt;&#123;message&#125;&lt;&#x2F;div&gt;,\n    document.getElementById(&quot;toast-root&quot;)\n  );\n&#125;;\n\nconst ToastManager &#x3D; () &#x3D;&gt; &#123;\n  const [toasts, setToasts] &#x3D; useState([]);\n\n  const addToast &#x3D; (message) &#x3D;&gt; &#123;\n    const id &#x3D; Date.now();\n    setToasts((prev) &#x3D;&gt; [...prev, &#123; id, message &#125;]);\n    setTimeout(() &#x3D;&gt; &#123;\n      setToasts((prev) &#x3D;&gt; prev.filter((toast) &#x3D;&gt; toast.id !&#x3D;&#x3D; id));\n    &#125;, 3000);\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; addToast(&quot;操作成功！&quot;)&#125;&gt;显示提示&lt;&#x2F;button&gt;\n\n      &#123;toasts.map((toast) &#x3D;&gt; (\n        &lt;Toast key&#x3D;&#123;toast.id&#125; message&#x3D;&#123;toast.message&#125; &#x2F;&gt;\n      ))&#125;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"3-悬浮提示\"><a href=\"#3-悬浮提示\" class=\"headerlink\" title=\"3. 悬浮提示\"></a>3. 悬浮提示</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Tooltip &#x3D; (&#123; text, position, children &#125;) &#x3D;&gt; &#123;\n  const [tooltipNode, setTooltipNode] &#x3D; useState(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    const node &#x3D; document.createElement(&quot;div&quot;);\n    document.body.appendChild(node);\n    setTooltipNode(node);\n\n    return () &#x3D;&gt; &#123;\n      document.body.removeChild(node);\n    &#125;;\n  &#125;, []);\n\n  return (\n    &lt;&gt;\n      &#123;children&#125;\n      &#123;tooltipNode &amp;&amp;\n        createPortal(\n          &lt;div className&#x3D;&quot;tooltip&quot; style&#x3D;&#123;position&#125;&gt;\n            &#123;text&#125;\n          &lt;&#x2F;div&gt;,\n          tooltipNode\n        )&#125;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"事件冒泡处理\"><a href=\"#事件冒泡处理\" class=\"headerlink\" title=\"事件冒泡处理\"></a>事件冒泡处理</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ModalWithEvent &#x3D; (&#123; onClose, children &#125;) &#x3D;&gt; &#123;\n  const handleClick &#x3D; (e) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 事件仍然遵循React的事件冒泡规则\n    e.stopPropagation();\n  &#125;;\n\n  return createPortal(\n    &lt;div className&#x3D;&quot;modal&quot; onClick&#x3D;&#123;handleClick&#125;&gt;\n      &#123;children&#125;\n    &lt;&#x2F;div&gt;,\n    document.body\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-10\"><a href=\"#注意事项-10\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>Portal 只改变 DOM 节点的物理位置</li>\n<li>事件冒泡仍然遵循 React 组件树</li>\n<li>需要正确管理 Portal 的生命周期</li>\n<li>确保目标容器在 Portal 渲染时存在</li>\n<li>注意内存泄漏问题</li>\n</ul>\n<h3 id=\"最佳实践-4\"><a href=\"#最佳实践-4\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const PortalWrapper &#x3D; (&#123; children, containerId &#125;) &#x3D;&gt; &#123;\n  const [container, setContainer] &#x3D; useState(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    let element &#x3D; document.getElementById(containerId);\n    if (!element) &#123;\n      element &#x3D; document.createElement(&quot;div&quot;);\n      element.id &#x3D; containerId;\n      document.body.appendChild(element);\n    &#125;\n    setContainer(element);\n\n    return () &#x3D;&gt; &#123;\n      if (element.parentNode) &#123;\n        element.parentNode.removeChild(element);\n      &#125;\n    &#125;;\n  &#125;, [containerId]);\n\n  return container ? createPortal(children, container) : null;\n&#125;;</code></pre>\n\n<p>Portal 是 React 中一个强大的功能，特别适合处理需要打破组件层级限制的 UI 元素，如模态框、提示框等。</p>\n<h2 id=\"在-React-中如何避免不必要的-render？\"><a href=\"#在-React-中如何避免不必要的-render？\" class=\"headerlink\" title=\"在 React 中如何避免不必要的 render？\"></a>在 React 中如何避免不必要的 render？</h2><h3 id=\"使用-React-memo-优化函数组件\"><a href=\"#使用-React-memo-优化函数组件\" class=\"headerlink\" title=\"使用 React.memo 优化函数组件\"></a>使用 React.memo 优化函数组件</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 使用 memo 包裹函数组件\nconst TodoItem &#x3D; React.memo((&#123; todo, onToggle &#125;) &#x3D;&gt; &#123;\n  console.log(&quot;TodoItem render&quot;);\n  return (\n    &lt;li&gt;\n      &lt;input\n        type&#x3D;&quot;checkbox&quot;\n        checked&#x3D;&#123;todo.completed&#125;\n        onChange&#x3D;&#123;() &#x3D;&gt; onToggle(todo.id)&#125;\n      &#x2F;&gt;\n      &#123;todo.text&#125;\n    &lt;&#x2F;li&gt;\n  );\n&#125;);</code></pre>\n\n<h3 id=\"使用-useMemo-缓存计算值\"><a href=\"#使用-useMemo-缓存计算值\" class=\"headerlink\" title=\"使用 useMemo 缓存计算值\"></a>使用 useMemo 缓存计算值</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ExpensiveComponent &#x3D; (&#123; data &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 缓存复杂计算的结果\n  const processedData &#x3D; useMemo(() &#x3D;&gt; &#123;\n    return expensiveCalculation(data);\n  &#125;, [data]); &#x2F;&#x2F; 只在 data 变化时重新计算\n\n  return &lt;div&gt;&#123;processedData&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"使用-useCallback-缓存函数\"><a href=\"#使用-useCallback-缓存函数\" class=\"headerlink\" title=\"使用 useCallback 缓存函数\"></a>使用 useCallback 缓存函数</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ParentComponent &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  &#x2F;&#x2F; 缓存回调函数\n  const handleClick &#x3D; useCallback(() &#x3D;&gt; &#123;\n    setCount((c) &#x3D;&gt; c + 1);\n  &#125;, []); &#x2F;&#x2F; 空依赖数组，函数永远不会改变\n\n  return (\n    &lt;&gt;\n      &lt;ChildComponent onClick&#x3D;&#123;handleClick&#125; &#x2F;&gt;\n      &lt;div&gt;Count: &#123;count&#125;&lt;&#x2F;div&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"合理拆分组件\"><a href=\"#合理拆分组件\" class=\"headerlink\" title=\"合理拆分组件\"></a>合理拆分组件</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const [text, setText] &#x3D; useState(&quot;&quot;);\n\n  return (\n    &lt;div&gt;\n      &#123;&#x2F;* 拆分后的组件只在各自的状态变化时重渲染 *&#x2F;&#125;\n      &lt;Counter count&#x3D;&#123;count&#125; setCount&#x3D;&#123;setCount&#125; &#x2F;&gt;\n      &lt;TextInput text&#x3D;&#123;text&#125; setText&#x3D;&#123;setText&#125; &#x2F;&gt;\n      &lt;ExpensiveList &#x2F;&gt; &#123;&#x2F;* 不依赖上面的状态，不会重渲染 *&#x2F;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"使用-children-属性\"><a href=\"#使用-children-属性\" class=\"headerlink\" title=\"使用 children 属性\"></a>使用 children 属性</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Wrapper &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState(false);\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setState(!state)&#125;&gt;Toggle&lt;&#x2F;button&gt;\n      &#123;children&#125; &#123;&#x2F;* children 不会因为 state 变化而重新渲染 *&#x2F;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"使用状态管理工具\"><a href=\"#使用状态管理工具\" class=\"headerlink\" title=\"使用状态管理工具\"></a>使用状态管理工具</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const TodoList &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 使用 useSelector 精确订阅所需的状态\n  const todos &#x3D; useSelector((state) &#x3D;&gt; state.todos);\n  const visibilityFilter &#x3D; useSelector((state) &#x3D;&gt; state.visibilityFilter);\n\n  return (\n    &lt;ul&gt;\n      &#123;getVisibleTodos(todos, visibilityFilter).map((todo) &#x3D;&gt; (\n        &lt;TodoItem key&#x3D;&#123;todo.id&#125; &#123;...todo&#125; &#x2F;&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"避免内联对象和函数-1\"><a href=\"#避免内联对象和函数-1\" class=\"headerlink\" title=\"避免内联对象和函数\"></a>避免内联对象和函数</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 不好的写法 - 每次渲染都创建新的对象和函数\nconst BadExample &#x3D; () &#x3D;&gt; (\n  &lt;ChildComponent\n    style&#x3D;&#123;&#123; margin: 10 &#125;&#125;\n    onClick&#x3D;&#123;() &#x3D;&gt; console.log(&quot;clicked&quot;)&#125;\n  &#x2F;&gt;\n);\n\n&#x2F;&#x2F; 好的写法\nconst GoodExample &#x3D; () &#x3D;&gt; &#123;\n  const style &#x3D; useMemo(() &#x3D;&gt; (&#123; margin: 10 &#125;), []);\n  const handleClick &#x3D; useCallback(() &#x3D;&gt; console.log(&quot;clicked&quot;), []);\n\n  return &lt;ChildComponent style&#x3D;&#123;style&#125; onClick&#x3D;&#123;handleClick&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"使用-React-lazy-和-Suspense\"><a href=\"#使用-React-lazy-和-Suspense\" class=\"headerlink\" title=\"使用 React.lazy 和 Suspense\"></a>使用 React.lazy 和 Suspense</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const LazyComponent &#x3D; React.lazy(() &#x3D;&gt; import(&quot;.&#x2F;LazyComponent&quot;));\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n      &lt;LazyComponent &#x2F;&gt; &#123;&#x2F;* 只在需要时才加载和渲染 *&#x2F;&#125;\n    &lt;&#x2F;Suspense&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-11\"><a href=\"#注意事项-11\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不要过度优化</li>\n<li>确保比较函数的性能</li>\n<li>正确设置依赖数组</li>\n<li>使用 React DevTools 分析渲染原因</li>\n<li>避免在渲染期间进行复杂计算</li>\n</ul>\n<p>合理使用这些优化技术可以显著提升应用性能，但要注意避免过度优化带来的复杂性。</p>\n<h2 id=\"对-React-context-的理解\"><a href=\"#对-React-context-的理解\" class=\"headerlink\" title=\"对 React context 的理解\"></a>对 React context 的理解</h2><h3 id=\"Context-的基本概念\"><a href=\"#Context-的基本概念\" class=\"headerlink\" title=\"Context 的基本概念\"></a>Context 的基本概念</h3><p>Context 提供了一种在组件树中共享数据的方式，无需手动通过 props 逐层传递。</p>\n<h3 id=\"基本使用方式-2\"><a href=\"#基本使用方式-2\" class=\"headerlink\" title=\"基本使用方式\"></a>基本使用方式</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建 Context\nconst ThemeContext &#x3D; createContext(&quot;light&quot;);\n\n&#x2F;&#x2F; 提供 Context\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [theme, setTheme] &#x3D; useState(&quot;light&quot;);\n\n  return (\n    &lt;ThemeContext.Provider value&#x3D;&#123;theme&#125;&gt;\n      &lt;Header &#x2F;&gt;\n      &lt;Main &#x2F;&gt;\n      &lt;Footer &#x2F;&gt;\n    &lt;&#x2F;ThemeContext.Provider&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 消费 Context\nconst ThemedButton &#x3D; () &#x3D;&gt; &#123;\n  const theme &#x3D; useContext(ThemeContext);\n  return &lt;button className&#x3D;&#123;theme&#125;&gt;按钮&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"动态-Context\"><a href=\"#动态-Context\" class=\"headerlink\" title=\"动态 Context\"></a>动态 Context</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建包含多个值的 Context\nconst AppContext &#x3D; createContext(&#123;\n  theme: &quot;light&quot;,\n  toggleTheme: () &#x3D;&gt; &#123;&#125;,\n  user: null,\n&#125;);\n\n&#x2F;&#x2F; 提供动态值\nconst AppProvider &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const [theme, setTheme] &#x3D; useState(&quot;light&quot;);\n  const [user, setUser] &#x3D; useState(null);\n\n  const contextValue &#x3D; &#123;\n    theme,\n    toggleTheme: () &#x3D;&gt; setTheme((t) &#x3D;&gt; (t &#x3D;&#x3D;&#x3D; &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;)),\n    user,\n  &#125;;\n\n  return (\n    &lt;AppContext.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;AppContext.Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"性能优化-2\"><a href=\"#性能优化-2\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 使用 memo 避免不必要的重渲染\nconst ThemedText &#x3D; memo((&#123; text &#125;) &#x3D;&gt; &#123;\n  const &#123; theme &#125; &#x3D; useContext(ThemeContext);\n  return &lt;span className&#x3D;&#123;theme&#125;&gt;&#123;text&#125;&lt;&#x2F;span&gt;;\n&#125;);\n\n&#x2F;&#x2F; 分离 Context 以避免不必要的重渲染\nconst ThemeProvider &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const [theme, setTheme] &#x3D; useState(&quot;light&quot;);\n  return (\n    &lt;ThemeContext.Provider value&#x3D;&#123;theme&#125;&gt;\n      &lt;ThemeUpdateContext.Provider value&#x3D;&#123;setTheme&#125;&gt;\n        &#123;children&#125;\n      &lt;&#x2F;ThemeUpdateContext.Provider&gt;\n    &lt;&#x2F;ThemeContext.Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-5\"><a href=\"#最佳实践-5\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"创建自定义-Hook\"><a href=\"#创建自定义-Hook\" class=\"headerlink\" title=\"创建自定义 Hook\"></a>创建自定义 Hook</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const useTheme &#x3D; () &#x3D;&gt; &#123;\n  const context &#x3D; useContext(ThemeContext);\n  if (context &#x3D;&#x3D;&#x3D; undefined) &#123;\n    throw new Error(&quot;useTheme must be used within a ThemeProvider&quot;);\n  &#125;\n  return context;\n&#125;;\n\n&#x2F;&#x2F; 使用自定义 Hook\nconst ThemedComponent &#x3D; () &#x3D;&gt; &#123;\n  const &#123; theme, toggleTheme &#125; &#x3D; useTheme();\n  return &lt;button onClick&#x3D;&#123;toggleTheme&#125;&gt;当前主题: &#123;theme&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"常见使用场景-2\"><a href=\"#常见使用场景-2\" class=\"headerlink\" title=\"常见使用场景\"></a>常见使用场景</h3><h4 id=\"主题切换\"><a href=\"#主题切换\" class=\"headerlink\" title=\"主题切换\"></a>主题切换</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const themes &#x3D; &#123;\n  light: &#123;\n    background: &quot;#fff&quot;,\n    color: &quot;#000&quot;,\n  &#125;,\n  dark: &#123;\n    background: &quot;#000&quot;,\n    color: &quot;#fff&quot;,\n  &#125;,\n&#125;;\n\nconst ThemeProvider &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const [theme, setTheme] &#x3D; useState(&quot;light&quot;);\n\n  return (\n    &lt;ThemeContext.Provider value&#x3D;&#123;[theme, setTheme]&#125;&gt;\n      &lt;div style&#x3D;&#123;themes[theme]&#125;&gt;&#123;children&#125;&lt;&#x2F;div&gt;\n    &lt;&#x2F;ThemeContext.Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-12\"><a href=\"#注意事项-12\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>Context 主要用于组件树中需要共享的全局数据</li>\n<li>避免过度使用 Context</li>\n<li>合理划分 Context 的粒度</li>\n<li>注意性能影响</li>\n<li>正确处理默认值</li>\n</ul>\n<h3 id=\"使用建议\"><a href=\"#使用建议\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h3><ul>\n<li>对于深层组件树的数据共享使用 Context</li>\n<li>对于局部状态管理使用 props 或 state</li>\n<li>考虑是否真的需要使用 Context</li>\n<li>合理组织 Context 的层级结构</li>\n</ul>\n<p>Context 是 React 中一个强大的特性，但应该谨慎使用，避免过度使用导致组件复用性降低。</p>\n<h2 id=\"React-中什么是受控组件和非控组件？\"><a href=\"#React-中什么是受控组件和非控组件？\" class=\"headerlink\" title=\"React 中什么是受控组件和非控组件？\"></a>React 中什么是受控组件和非控组件？</h2><h3 id=\"受控组件和非受控组件的概念\"><a href=\"#受控组件和非受控组件的概念\" class=\"headerlink\" title=\"受控组件和非受控组件的概念\"></a>受控组件和非受控组件的概念</h3><h4 id=\"受控组件\"><a href=\"#受控组件\" class=\"headerlink\" title=\"受控组件\"></a>受控组件</h4><p>表单数据由 React 组件控制，通过 state 和 onChange 事件来管理数据流。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ControlledForm &#x3D; () &#x3D;&gt; &#123;\n  const [value, setValue] &#x3D; useState(&quot;&quot;);\n\n  return &lt;input value&#x3D;&#123;value&#125; onChange&#x3D;&#123;(e) &#x3D;&gt; setValue(e.target.value)&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h4 id=\"非受控组件\"><a href=\"#非受控组件\" class=\"headerlink\" title=\"非受控组件\"></a>非受控组件</h4><p>表单数据由 DOM 本身处理，通过 ref 来获取表单值。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const UncontrolledForm &#x3D; () &#x3D;&gt; &#123;\n  const inputRef &#x3D; useRef(null);\n\n  const handleSubmit &#x3D; () &#x3D;&gt; &#123;\n    console.log(inputRef.current.value);\n  &#125;;\n\n  return &lt;input ref&#x3D;&#123;inputRef&#125; defaultValue&#x3D;&quot;默认值&quot; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"受控组件示例\"><a href=\"#受控组件示例\" class=\"headerlink\" title=\"受控组件示例\"></a>受控组件示例</h3><h4 id=\"表单处理\"><a href=\"#表单处理\" class=\"headerlink\" title=\"表单处理\"></a>表单处理</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ControlledForm &#x3D; () &#x3D;&gt; &#123;\n  const [formData, setFormData] &#x3D; useState(&#123;\n    username: &quot;&quot;,\n    email: &quot;&quot;,\n  &#125;);\n\n  const handleChange &#x3D; (e) &#x3D;&gt; &#123;\n    const &#123; name, value &#125; &#x3D; e.target;\n    setFormData((prev) &#x3D;&gt; (&#123;\n      ...prev,\n      [name]: value,\n    &#125;));\n  &#125;;\n\n  return (\n    &lt;form&gt;\n      &lt;input\n        name&#x3D;&quot;username&quot;\n        value&#x3D;&#123;formData.username&#125;\n        onChange&#x3D;&#123;handleChange&#125;\n      &#x2F;&gt;\n      &lt;input name&#x3D;&quot;email&quot; value&#x3D;&#123;formData.email&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"非受控组件示例\"><a href=\"#非受控组件示例\" class=\"headerlink\" title=\"非受控组件示例\"></a>非受控组件示例</h3><h4 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const FileUploader &#x3D; () &#x3D;&gt; &#123;\n  const fileRef &#x3D; useRef(null);\n\n  const handleSubmit &#x3D; (e) &#x3D;&gt; &#123;\n    e.preventDefault();\n    const file &#x3D; fileRef.current.files[0];\n    &#x2F;&#x2F; 处理文件上传\n  &#125;;\n\n  return (\n    &lt;form onSubmit&#x3D;&#123;handleSubmit&#125;&gt;\n      &lt;input type&#x3D;&quot;file&quot; ref&#x3D;&#123;fileRef&#125; &#x2F;&gt;\n      &lt;button type&#x3D;&quot;submit&quot;&gt;上传&lt;&#x2F;button&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"选择使用场景\"><a href=\"#选择使用场景\" class=\"headerlink\" title=\"选择使用场景\"></a>选择使用场景</h3><h4 id=\"适合使用受控组件\"><a href=\"#适合使用受控组件\" class=\"headerlink\" title=\"适合使用受控组件\"></a>适合使用受控组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 1. 即时表单验证\nconst ValidatedInput &#x3D; () &#x3D;&gt; &#123;\n  const [value, setValue] &#x3D; useState(&quot;&quot;);\n  const [error, setError] &#x3D; useState(&quot;&quot;);\n\n  const handleChange &#x3D; (e) &#x3D;&gt; &#123;\n    const newValue &#x3D; e.target.value;\n    setValue(newValue);\n\n    if (newValue.length &lt; 3) &#123;\n      setError(&quot;输入长度不能小于3&quot;);\n    &#125; else &#123;\n      setError(&quot;&quot;);\n    &#125;\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;input value&#x3D;&#123;value&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;\n      &#123;error &amp;&amp; &lt;span className&#x3D;&quot;error&quot;&gt;&#123;error&#125;&lt;&#x2F;span&gt;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"适合使用非受控组件\"><a href=\"#适合使用非受控组件\" class=\"headerlink\" title=\"适合使用非受控组件\"></a>适合使用非受控组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 1. 简单的表单提交\nconst SimpleForm &#x3D; () &#x3D;&gt; &#123;\n  const formRef &#x3D; useRef(null);\n\n  const handleSubmit &#x3D; (e) &#x3D;&gt; &#123;\n    e.preventDefault();\n    const formData &#x3D; new FormData(formRef.current);\n    &#x2F;&#x2F; 处理表单数据\n  &#125;;\n\n  return (\n    &lt;form ref&#x3D;&#123;formRef&#125; onSubmit&#x3D;&#123;handleSubmit&#125;&gt;\n      &lt;input name&#x3D;&quot;username&quot; defaultValue&#x3D;&quot;&quot; &#x2F;&gt;\n      &lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; &#x2F;&gt;\n      &lt;button type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-6\"><a href=\"#最佳实践-6\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"混合使用\"><a href=\"#混合使用\" class=\"headerlink\" title=\"混合使用\"></a>混合使用</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const HybridForm &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 受控组件用于需要即时反馈的字段\n  const [username, setUsername] &#x3D; useState(&quot;&quot;);\n  &#x2F;&#x2F; 非受控组件用于文件上传\n  const fileRef &#x3D; useRef(null);\n\n  const handleSubmit &#x3D; (e) &#x3D;&gt; &#123;\n    e.preventDefault();\n    const formData &#x3D; new FormData();\n    formData.append(&quot;username&quot;, username);\n    formData.append(&quot;file&quot;, fileRef.current.files[0]);\n  &#125;;\n\n  return (\n    &lt;form onSubmit&#x3D;&#123;handleSubmit&#125;&gt;\n      &lt;input value&#x3D;&#123;username&#125; onChange&#x3D;&#123;(e) &#x3D;&gt; setUsername(e.target.value)&#125; &#x2F;&gt;\n      &lt;input type&#x3D;&quot;file&quot; ref&#x3D;&#123;fileRef&#125; &#x2F;&gt;\n      &lt;button type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-13\"><a href=\"#注意事项-13\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>优先使用受控组件</li>\n<li>对于文件输入等特殊场景使用非受控组件</li>\n<li>避免在一个组件中混合使用两种方式</li>\n<li>注意性能影响</li>\n<li>保持代码的一致性</li>\n</ul>\n<p>选择使用受控还是非受控组件应该根据具体场景来决定，通常情况下推荐使用受控组件，因为它能提供更好的可控性和即时反馈。</p>\n<h2 id=\"React-中-ref-的作用是什么？有哪些应用场景？\"><a href=\"#React-中-ref-的作用是什么？有哪些应用场景？\" class=\"headerlink\" title=\"React 中 ref 的作用是什么？有哪些应用场景？\"></a>React 中 ref 的作用是什么？有哪些应用场景？</h2><h3 id=\"Ref-的基本概念\"><a href=\"#Ref-的基本概念\" class=\"headerlink\" title=\"Ref 的基本概念\"></a>Ref 的基本概念</h3><p>Ref 提供了一种访问 React 组件实例或 DOM 元素的方式，用于在典型的 React 数据流之外直接操作组件或元素。</p>\n<h3 id=\"创建和使用方式\"><a href=\"#创建和使用方式\" class=\"headerlink\" title=\"创建和使用方式\"></a>创建和使用方式</h3><h4 id=\"使用-useRef-Hook-1\"><a href=\"#使用-useRef-Hook-1\" class=\"headerlink\" title=\"使用 useRef Hook\"></a>使用 useRef Hook</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const TextInput &#x3D; () &#x3D;&gt; &#123;\n  const inputRef &#x3D; useRef(null);\n\n  const focusInput &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 直接访问 DOM 元素\n    inputRef.current.focus();\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;input ref&#x3D;&#123;inputRef&#125; type&#x3D;&quot;text&quot; &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;focusInput&#125;&gt;聚焦输入框&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"常见应用场景\"><a href=\"#常见应用场景\" class=\"headerlink\" title=\"常见应用场景\"></a>常见应用场景</h3><h4 id=\"1-管理焦点\"><a href=\"#1-管理焦点\" class=\"headerlink\" title=\"1. 管理焦点\"></a>1. 管理焦点</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const FocusableForm &#x3D; () &#x3D;&gt; &#123;\n  const nameRef &#x3D; useRef(null);\n  const emailRef &#x3D; useRef(null);\n\n  const handleError &#x3D; (fieldName) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 错误时自动聚焦相应字段\n    if (fieldName &#x3D;&#x3D;&#x3D; &quot;name&quot;) nameRef.current.focus();\n    if (fieldName &#x3D;&#x3D;&#x3D; &quot;email&quot;) emailRef.current.focus();\n  &#125;;\n\n  return (\n    &lt;form&gt;\n      &lt;input ref&#x3D;&#123;nameRef&#125; placeholder&#x3D;&quot;姓名&quot; &#x2F;&gt;\n      &lt;input ref&#x3D;&#123;emailRef&#125; type&#x3D;&quot;email&quot; placeholder&#x3D;&quot;邮箱&quot; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"2-媒体控制\"><a href=\"#2-媒体控制\" class=\"headerlink\" title=\"2. 媒体控制\"></a>2. 媒体控制</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const VideoPlayer &#x3D; () &#x3D;&gt; &#123;\n  const videoRef &#x3D; useRef(null);\n\n  const handlePlayPause &#x3D; () &#x3D;&gt; &#123;\n    const video &#x3D; videoRef.current;\n    video.paused ? video.play() : video.pause();\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;video ref&#x3D;&#123;videoRef&#125; src&#x3D;&#123;videoUrl&#125; &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;handlePlayPause&#125;&gt;播放&#x2F;暂停&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"3-集成第三方库\"><a href=\"#3-集成第三方库\" class=\"headerlink\" title=\"3. 集成第三方库\"></a>3. 集成第三方库</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ChartComponent &#x3D; () &#x3D;&gt; &#123;\n  const chartRef &#x3D; useRef(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 初始化第三方图表库\n    const chart &#x3D; new ThirdPartyChart(chartRef.current);\n    chart.render(data);\n\n    return () &#x3D;&gt; chart.destroy();\n  &#125;, []);\n\n  return &lt;div ref&#x3D;&#123;chartRef&#125; className&#x3D;&quot;chart-container&quot; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h3><h4 id=\"转发-Ref\"><a href=\"#转发-Ref\" class=\"headerlink\" title=\"转发 Ref\"></a>转发 Ref</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const FancyButton &#x3D; forwardRef((props, ref) &#x3D;&gt; (\n  &lt;button ref&#x3D;&#123;ref&#125; className&#x3D;&quot;fancy-btn&quot; &#123;...props&#125; &#x2F;&gt;\n));\n\n&#x2F;&#x2F; 使用转发的 ref\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const buttonRef &#x3D; useRef(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(buttonRef.current); &#x2F;&#x2F; 访问按钮 DOM 元素\n  &#125;, []);\n\n  return &lt;FancyButton ref&#x3D;&#123;buttonRef&#125;&gt;点击我&lt;&#x2F;FancyButton&gt;;\n&#125;;</code></pre>\n\n<h4 id=\"回调-Ref\"><a href=\"#回调-Ref\" class=\"headerlink\" title=\"回调 Ref\"></a>回调 Ref</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const MeasureExample &#x3D; () &#x3D;&gt; &#123;\n  const [height, setHeight] &#x3D; useState(0);\n\n  const measuredRef &#x3D; useCallback((node) &#x3D;&gt; &#123;\n    if (node !&#x3D;&#x3D; null) &#123;\n      setHeight(node.getBoundingClientRect().height);\n    &#125;\n  &#125;, []);\n\n  return (\n    &lt;&gt;\n      &lt;div ref&#x3D;&#123;measuredRef&#125;&gt;一些内容&lt;&#x2F;div&gt;\n      &lt;p&gt;这个div的高度是: &#123;height&#125;px&lt;&#x2F;p&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-7\"><a href=\"#最佳实践-7\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"合理使用-Ref\"><a href=\"#合理使用-Ref\" class=\"headerlink\" title=\"合理使用 Ref\"></a>合理使用 Ref</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Form &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 不推荐: 使用 ref 管理表单状态\n  const inputRef &#x3D; useRef();\n\n  &#x2F;&#x2F; 推荐: 使用受控组件\n  const [value, setValue] &#x3D; useState(&quot;&quot;);\n\n  return (\n    &lt;form&gt;\n      &#123;&#x2F;* 只在必要时使用 ref *&#x2F;&#125;\n      &lt;input value&#x3D;&#123;value&#125; onChange&#x3D;&#123;(e) &#x3D;&gt; setValue(e.target.value)&#125; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-14\"><a href=\"#注意事项-14\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>避免过度使用 Ref</li>\n<li>优先考虑声明式解决方案</li>\n<li>注意内存泄漏</li>\n<li>不要在渲染期间访问 Ref</li>\n<li>谨慎使用 Ref 存储可变值</li>\n</ul>\n<p>Ref 是一个强大的特性，但应该谨慎使用，主要用于必要的 DOM 操作和组件实例访问场景。</p>\n<h2 id=\"React-forwardRef-是什么？它有什么作用？\"><a href=\"#React-forwardRef-是什么？它有什么作用？\" class=\"headerlink\" title=\"React.forwardRef 是什么？它有什么作用？\"></a>React.forwardRef 是什么？它有什么作用？</h2><h3 id=\"React-forwardRef-的概念\"><a href=\"#React-forwardRef-的概念\" class=\"headerlink\" title=\"React.forwardRef 的概念\"></a>React.forwardRef 的概念</h3><p>forwardRef 是 React 提供的一个高阶组件，用于将 ref 从父组件转发到子组件的 DOM 节点或类组件实例。</p>\n<h3 id=\"基本使用-1\"><a href=\"#基本使用-1\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const FancyButton &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;\n  return (\n    &lt;button ref&#x3D;&#123;ref&#125; className&#x3D;&quot;fancy-button&quot; &#123;...props&#125;&gt;\n      &#123;props.children&#125;\n    &lt;&#x2F;button&gt;\n  );\n&#125;);\n\n&#x2F;&#x2F; 使用转发的 ref\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const buttonRef &#x3D; useRef(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 可以直接访问按钮 DOM 元素\n    buttonRef.current.focus();\n  &#125;, []);\n\n  return &lt;FancyButton ref&#x3D;&#123;buttonRef&#125;&gt;点击我&lt;&#x2F;FancyButton&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"常见应用场景-1\"><a href=\"#常见应用场景-1\" class=\"headerlink\" title=\"常见应用场景\"></a>常见应用场景</h3><h4 id=\"封装表单组件\"><a href=\"#封装表单组件\" class=\"headerlink\" title=\"封装表单组件\"></a>封装表单组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Input &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;input-wrapper&quot;&gt;\n      &lt;input ref&#x3D;&#123;ref&#125; &#123;...props&#125; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;);\n\nconst Form &#x3D; () &#x3D;&gt; &#123;\n  const inputRef &#x3D; useRef(null);\n\n  const focusInput &#x3D; () &#x3D;&gt; &#123;\n    inputRef.current.focus();\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;Input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;focusInput&#125;&gt;聚焦输入框&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"高阶组件中转发-refs\"><a href=\"#高阶组件中转发-refs\" class=\"headerlink\" title=\"高阶组件中转发 refs\"></a>高阶组件中转发 refs</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const withLogProps &#x3D; (WrappedComponent) &#x3D;&gt; &#123;\n  return forwardRef((props, ref) &#x3D;&gt; &#123;\n    useEffect(() &#x3D;&gt; &#123;\n      console.log(&quot;Props:&quot;, props);\n    &#125;);\n\n    return &lt;WrappedComponent ref&#x3D;&#123;ref&#125; &#123;...props&#125; &#x2F;&gt;;\n  &#125;);\n&#125;;\n\nconst FancyInput &#x3D; forwardRef((props, ref) &#x3D;&gt; &lt;input ref&#x3D;&#123;ref&#125; &#123;...props&#125; &#x2F;&gt;);\n\nconst EnhancedInput &#x3D; withLogProps(FancyInput);</code></pre>\n\n<h3 id=\"使用注意事项\"><a href=\"#使用注意事项\" class=\"headerlink\" title=\"使用注意事项\"></a>使用注意事项</h3><h4 id=\"命名和调试\"><a href=\"#命名和调试\" class=\"headerlink\" title=\"命名和调试\"></a>命名和调试</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const FancyButton &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 设置组件显示名称，便于调试\n  FancyButton.displayName &#x3D; &quot;FancyButton&quot;;\n\n  return &lt;button ref&#x3D;&#123;ref&#125; &#123;...props&#125; &#x2F;&gt;;\n&#125;);</code></pre>\n\n<h4 id=\"条件转发\"><a href=\"#条件转发\" class=\"headerlink\" title=\"条件转发\"></a>条件转发</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Input &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;\n  const &#123; isDisabled, ...rest &#125; &#x3D; props;\n\n  &#x2F;&#x2F; 根据条件决定是否转发 ref\n  return (\n    &lt;input ref&#x3D;&#123;isDisabled ? null : ref&#125; disabled&#x3D;&#123;isDisabled&#125; &#123;...rest&#125; &#x2F;&gt;\n  );\n&#125;);</code></pre>\n\n<h3 id=\"最佳实践-8\"><a href=\"#最佳实践-8\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组合使用\"><a href=\"#组合使用\" class=\"headerlink\" title=\"组合使用\"></a>组合使用</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const TextInput &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;\n  const &#123; label, error, ...inputProps &#125; &#x3D; props;\n\n  return (\n    &lt;div className&#x3D;&quot;input-group&quot;&gt;\n      &#123;label &amp;&amp; &lt;label&gt;&#123;label&#125;&lt;&#x2F;label&gt;&#125;\n      &lt;input ref&#x3D;&#123;ref&#125; &#123;...inputProps&#125; &#x2F;&gt;\n      &#123;error &amp;&amp; &lt;span className&#x3D;&quot;error&quot;&gt;&#123;error&#125;&lt;&#x2F;span&gt;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;);\n\n&#x2F;&#x2F; 使用组件\nconst Form &#x3D; () &#x3D;&gt; &#123;\n  const inputRef &#x3D; useRef(null);\n\n  return &lt;TextInput ref&#x3D;&#123;inputRef&#125; label&#x3D;&quot;用户名&quot; placeholder&#x3D;&quot;请输入用户名&quot; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-15\"><a href=\"#注意事项-15\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不要过度使用 ref 转发</li>\n<li>确保正确处理 null ref</li>\n<li>注意性能影响</li>\n<li>保持组件的纯函数特性</li>\n<li>合理使用 displayName</li>\n</ul>\n<p>forwardRef 是一个强大的功能，但应该谨慎使用，主要用于需要直接访问 DOM 元素或组件实例的场景。</p>\n<h2 id=\"类组件与函数组件有什么异同？\"><a href=\"#类组件与函数组件有什么异同？\" class=\"headerlink\" title=\"类组件与函数组件有什么异同？\"></a>类组件与函数组件有什么异同？</h2><h3 id=\"类组件与函数组件的主要区别\"><a href=\"#类组件与函数组件的主要区别\" class=\"headerlink\" title=\"类组件与函数组件的主要区别\"></a>类组件与函数组件的主要区别</h3><h4 id=\"语法形式\"><a href=\"#语法形式\" class=\"headerlink\" title=\"语法形式\"></a>语法形式</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 函数组件\nconst FunctionComponent &#x3D; (props) &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\n&#x2F;&#x2F; 类组件\nclass ClassComponent extends React.Component &#123;\n  state &#x3D; &#123; count: 0 &#125;;\n  render() &#123;\n    return &lt;div&gt;&#123;this.state.count&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"状态管理方式\"><a href=\"#状态管理方式\" class=\"headerlink\" title=\"状态管理方式\"></a>状态管理方式</h3><h4 id=\"函数组件使用-Hooks\"><a href=\"#函数组件使用-Hooks\" class=\"headerlink\" title=\"函数组件使用 Hooks\"></a>函数组件使用 Hooks</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Counter &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 使用 useState 管理状态\n  const [count, setCount] &#x3D; useState(0);\n\n  &#x2F;&#x2F; 使用 useEffect 处理副作用\n  useEffect(() &#x3D;&gt; &#123;\n    document.title &#x3D; &#96;点击了 $&#123;count&#125; 次&#96;;\n  &#125;, [count]);\n\n  return (\n    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount((c) &#x3D;&gt; c + 1)&#125;&gt;点击次数: &#123;count&#125;&lt;&#x2F;button&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"类组件使用-this-state\"><a href=\"#类组件使用-this-state\" class=\"headerlink\" title=\"类组件使用 this.state\"></a>类组件使用 this.state</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class Counter extends React.Component &#123;\n  state &#x3D; &#123; count: 0 &#125;;\n\n  componentDidUpdate() &#123;\n    document.title &#x3D; &#96;点击了 $&#123;this.state.count&#125; 次&#96;;\n  &#125;\n\n  handleClick &#x3D; () &#x3D;&gt; &#123;\n    this.setState((state) &#x3D;&gt; (&#123;\n      count: state.count + 1,\n    &#125;));\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;点击次数: &#123;this.state.count&#125;&lt;&#x2F;button&gt;\n    );\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"生命周期处理-1\"><a href=\"#生命周期处理-1\" class=\"headerlink\" title=\"生命周期处理\"></a>生命周期处理</h3><h4 id=\"函数组件\"><a href=\"#函数组件\" class=\"headerlink\" title=\"函数组件\"></a>函数组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const UserProfile &#x3D; () &#x3D;&gt; &#123;\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 组件挂载\n    console.log(&quot;mounted&quot;);\n    return () &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 组件卸载\n      console.log(&quot;will unmount&quot;);\n    &#125;;\n  &#125;, []);\n\n  &#x2F;&#x2F; 没有明确的生命周期方法\n  &#x2F;&#x2F; 使用 useEffect 组合实现类似功能\n  return &lt;div&gt;User Profile&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"性能优化方式\"><a href=\"#性能优化方式\" class=\"headerlink\" title=\"性能优化方式\"></a>性能优化方式</h3><h4 id=\"函数组件-1\"><a href=\"#函数组件-1\" class=\"headerlink\" title=\"函数组件\"></a>函数组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 使用 React.memo 优化\nconst MemoizedComponent &#x3D; React.memo((&#123; data &#125;) &#x3D;&gt; &#123;\n  return &lt;div&gt;&#123;data&#125;&lt;&#x2F;div&gt;;\n&#125;);\n\n&#x2F;&#x2F; 使用 useMemo 和 useCallback\nconst OptimizedComponent &#x3D; () &#x3D;&gt; &#123;\n  const memoizedValue &#x3D; useMemo(() &#x3D;&gt; computeExpensiveValue(a, b), [a, b]);\n  const memoizedCallback &#x3D; useCallback(() &#x3D;&gt; &#123;\n    doSomething(a, b);\n  &#125;, [a, b]);\n\n  return &lt;Child value&#x3D;&#123;memoizedValue&#125; onClick&#x3D;&#123;memoizedCallback&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h3><ul>\n<li>都可以接收 props 并返回 React 元素</li>\n<li>都可以使用 JSX</li>\n<li>都可以实现组件逻辑</li>\n<li>都遵循单向数据流</li>\n</ul>\n<h3 id=\"函数组件的优势-1\"><a href=\"#函数组件的优势-1\" class=\"headerlink\" title=\"函数组件的优势\"></a>函数组件的优势</h3><ul>\n<li>代码更简洁</li>\n<li>更容易测试</li>\n<li>更好的性能优化</li>\n<li>更容易理解</li>\n<li>更好的代码复用</li>\n</ul>\n<h3 id=\"最佳实践-9\"><a href=\"#最佳实践-9\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"使用函数组件和-Hooks-1\"><a href=\"#使用函数组件和-Hooks-1\" class=\"headerlink\" title=\"使用函数组件和 Hooks\"></a>使用函数组件和 Hooks</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ModernComponent &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 状态管理\n  const [data, setData] &#x3D; useState(null);\n\n  &#x2F;&#x2F; 副作用处理\n  useEffect(() &#x3D;&gt; &#123;\n    fetchData().then(setData);\n  &#125;, []);\n\n  &#x2F;&#x2F; 性能优化\n  const handleClick &#x3D; useCallback(() &#x3D;&gt; &#123;\n    console.log(data);\n  &#125;, [data]);\n\n  return data ? &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;&#123;data&#125;&lt;&#x2F;div&gt; : &lt;Loading &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-16\"><a href=\"#注意事项-16\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>优先使用函数组件</li>\n<li>合理使用 Hooks</li>\n<li>注意闭包陷阱</li>\n<li>正确设置依赖数组</li>\n<li>遵循 Hooks 规则</li>\n</ul>\n<p>在现代 React 开发中，推荐使用函数组件配合 Hooks 进行开发，它们提供了更简洁、更灵活的代码组织方式。</p>\n<h1 id=\"数据管理\"><a href=\"#数据管理\" class=\"headerlink\" title=\"数据管理\"></a>数据管理</h1><h2 id=\"React-setState-调用的原理\"><a href=\"#React-setState-调用的原理\" class=\"headerlink\" title=\"React setState 调用的原理\"></a>React setState 调用的原理</h2><h3 id=\"setState-的基本原理\"><a href=\"#setState-的基本原理\" class=\"headerlink\" title=\"setState 的基本原理\"></a>setState 的基本原理</h3><p>setState 在 React 中是一个用于更新组件状态的关键方法，它会触发重新渲染并批量处理更新。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Counter &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 1. 将更新放入更新队列\n    setCount((c) &#x3D;&gt; c + 1);\n    &#x2F;&#x2F; 2. 标记组件需要更新\n    &#x2F;&#x2F; 3. 调度更新任务\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"批量更新机制\"><a href=\"#批量更新机制\" class=\"headerlink\" title=\"批量更新机制\"></a>批量更新机制</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const BatchExample &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; React 18 自动批处理\n    setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 不会立即更新\n    setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 不会立即更新\n    &#x2F;&#x2F; 这些更新会被合并，只触发一次重渲染\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"更新优先级\"><a href=\"#更新优先级\" class=\"headerlink\" title=\"更新优先级\"></a>更新优先级</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const PriorityExample &#x3D; () &#x3D;&gt; &#123;\n  const [value, setValue] &#x3D; useState(&quot;&quot;);\n\n  &#x2F;&#x2F; 高优先级更新（用户交互）\n  const handleChange &#x3D; (e) &#x3D;&gt; &#123;\n    setValue(e.target.value);\n  &#125;;\n\n  &#x2F;&#x2F; 低优先级更新（数据获取）\n  useEffect(() &#x3D;&gt; &#123;\n    fetchData().then((data) &#x3D;&gt; &#123;\n      setValue(data);\n    &#125;);\n  &#125;, []);\n&#125;;</code></pre>\n\n<h3 id=\"内部实现机制\"><a href=\"#内部实现机制\" class=\"headerlink\" title=\"内部实现机制\"></a>内部实现机制</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; setState 的简化实现原理\nfunction enqueueSetState(component, partialState) &#123;\n  &#x2F;&#x2F; 1. 将新状态添加到更新队列\n  const queue &#x3D; getUpdateQueue(component);\n  queue.push(partialState);\n\n  &#x2F;&#x2F; 2. 请求调度更新\n  scheduleUpdate(component);\n&#125;\n\n&#x2F;&#x2F; 调度更新过程\nfunction scheduleUpdate(fiber) &#123;\n  &#x2F;&#x2F; 1. 创建更新任务\n  const update &#x3D; createUpdate();\n\n  &#x2F;&#x2F; 2. 将任务加入调度队列\n  enqueueUpdate(fiber, update);\n\n  &#x2F;&#x2F; 3. 开始调度\n  scheduleUpdateOnFiber(fiber);\n&#125;</code></pre>\n\n<h3 id=\"注意事项-17\"><a href=\"#注意事项-17\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>setState 可能是异步的</li>\n<li>多个 setState 调用会被合并</li>\n<li>状态更新可能会被批处理</li>\n<li>更新可能会被优先级系统影响</li>\n<li>应该使用函数式更新来依赖之前的状态</li>\n</ul>\n<h3 id=\"最佳实践-10\"><a href=\"#最佳实践-10\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const BestPractice &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  &#x2F;&#x2F; 使用函数式更新保证状态正确性\n  const increment &#x3D; () &#x3D;&gt; &#123;\n    setCount((prev) &#x3D;&gt; prev + 1);\n  &#125;;\n\n  &#x2F;&#x2F; 批量更新示例\n  const batchedUpdates &#x3D; () &#x3D;&gt; &#123;\n    increment(); &#x2F;&#x2F; 这些更新会被批处理\n    increment(); &#x2F;&#x2F; 合并为一次更新\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;batchedUpdates&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<p>React 18 中的 setState 实现了自动批处理，提供了更好的性能和一致性保证。理解其工作原理对于正确使用 React 和优化应用性能非常重要。</p>\n<h2 id=\"React-setState-调用之后发生了什么？是同步还是异步？\"><a href=\"#React-setState-调用之后发生了什么？是同步还是异步？\" class=\"headerlink\" title=\"React setState 调用之后发生了什么？是同步还是异步？\"></a>React setState 调用之后发生了什么？是同步还是异步？</h2><h3 id=\"setState-调用后的执行流程\"><a href=\"#setState-调用后的执行流程\" class=\"headerlink\" title=\"setState 调用后的执行流程\"></a>setState 调用后的执行流程</h3><h4 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Counter &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 1. 将更新放入队列\n    setCount((c) &#x3D;&gt; c + 1);\n    console.log(count); &#x2F;&#x2F; 仍然是旧值\n\n    &#x2F;&#x2F; 2. React 调度更新\n    &#x2F;&#x2F; 3. 触发重新渲染\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"异步更新机制\"><a href=\"#异步更新机制\" class=\"headerlink\" title=\"异步更新机制\"></a>异步更新机制</h3><h4 id=\"批处理示例\"><a href=\"#批处理示例\" class=\"headerlink\" title=\"批处理示例\"></a>批处理示例</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const BatchExample &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 进入更新队列\n    setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 进入更新队列\n    &#x2F;&#x2F; React 18 自动批处理，合并更新\n  &#125;;\n\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(&quot;count updated:&quot;, count);\n  &#125;, [count]);\n&#125;;</code></pre>\n\n<h3 id=\"同步更新场景\"><a href=\"#同步更新场景\" class=\"headerlink\" title=\"同步更新场景\"></a>同步更新场景</h3><h4 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const SyncExample &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  &#x2F;&#x2F; React 18 之前的同步更新场景\n  setTimeout(() &#x3D;&gt; &#123;\n    setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 每次调用都会触发更新\n    console.log(count); &#x2F;&#x2F; 在 React 18 中也会批处理\n  &#125;, 0);\n&#125;;</code></pre>\n\n<h3 id=\"React-18-的自动批处理\"><a href=\"#React-18-的自动批处理\" class=\"headerlink\" title=\"React 18 的自动批处理\"></a>React 18 的自动批处理</h3><h4 id=\"统一行为\"><a href=\"#统一行为\" class=\"headerlink\" title=\"统一行为\"></a>统一行为</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ModernExample &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const [flag, setFlag] &#x3D; useState(false);\n\n  const handleClick &#x3D; async () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; React 18 中所有更新都会批处理\n    setCount((c) &#x3D;&gt; c + 1);\n    setFlag((f) &#x3D;&gt; !f);\n    &#x2F;&#x2F; 只会触发一次重渲染\n\n    &#x2F;&#x2F; 即使在 Promise 中也会批处理\n    await Promise.resolve();\n    setCount((c) &#x3D;&gt; c + 1);\n    setFlag((f) &#x3D;&gt; !f);\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-11\"><a href=\"#最佳实践-11\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"状态更新\"><a href=\"#状态更新\" class=\"headerlink\" title=\"状态更新\"></a>状态更新</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const BestPractice &#x3D; () &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState(&#123; count: 0, text: &quot;&quot; &#125;);\n\n  const handleUpdate &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 使用函数式更新保证状态正确性\n    setState((prev) &#x3D;&gt; (&#123;\n      ...prev,\n      count: prev.count + 1,\n    &#125;));\n  &#125;;\n\n  &#x2F;&#x2F; 需要立即使用更新后的值\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(&quot;state updated:&quot;, state);\n  &#125;, [state]);\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-18\"><a href=\"#注意事项-18\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>React 18 中默认所有更新都是异步的</li>\n<li>状态更新会被批处理以提高性能</li>\n<li>使用 useEffect 或回调函数获取更新后的值</li>\n<li>使用函数式更新来依赖之前的状态</li>\n<li>避免直接依赖更新后的状态值</li>\n</ul>\n<p>理解 setState 的异步特性对于正确使用 React 和优化应用性能非常重要。</p>\n<h2 id=\"React-中的-setState-批量更新的过程是什么？\"><a href=\"#React-中的-setState-批量更新的过程是什么？\" class=\"headerlink\" title=\"React 中的 setState 批量更新的过程是什么？\"></a>React 中的 setState 批量更新的过程是什么？</h2><h3 id=\"setState-批量更新的工作原理\"><a href=\"#setState-批量更新的工作原理\" class=\"headerlink\" title=\"setState 批量更新的工作原理\"></a>setState 批量更新的工作原理</h3><h4 id=\"基本流程-1\"><a href=\"#基本流程-1\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Counter &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const [flag, setFlag] &#x3D; useState(false);\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; React 18 自动批处理\n    setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 第一次更新\n    setFlag((f) &#x3D;&gt; !f); &#x2F;&#x2F; 第二次更新\n    setCount((c) &#x3D;&gt; c + 1); &#x2F;&#x2F; 第三次更新\n    &#x2F;&#x2F; 这三次更新会被合并为一次渲染\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"批处理机制\"><a href=\"#批处理机制\" class=\"headerlink\" title=\"批处理机制\"></a>批处理机制</h3><h4 id=\"更新队列处理\"><a href=\"#更新队列处理\" class=\"headerlink\" title=\"更新队列处理\"></a>更新队列处理</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const BatchExample &#x3D; () &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState(&#123; count: 0, text: &quot;&quot; &#125;);\n\n  const handleUpdate &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 多个状态更新会被合并\n    setState((prev) &#x3D;&gt; (&#123; ...prev, count: prev.count + 1 &#125;));\n    setState((prev) &#x3D;&gt; (&#123; ...prev, text: &quot;updated&quot; &#125;));\n    &#x2F;&#x2F; 只会触发一次重渲染\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"React-18-的自动批处理-1\"><a href=\"#React-18-的自动批处理-1\" class=\"headerlink\" title=\"React 18 的自动批处理\"></a>React 18 的自动批处理</h3><h4 id=\"Promise-中的批处理\"><a href=\"#Promise-中的批处理\" class=\"headerlink\" title=\"Promise 中的批处理\"></a>Promise 中的批处理</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const AsyncExample &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  const handleAsync &#x3D; async () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; React 18 中异步操作也会自动批处理\n    await Promise.resolve();\n    setCount((c) &#x3D;&gt; c + 1);\n    setCount((c) &#x3D;&gt; c + 1);\n    &#x2F;&#x2F; 这些更新会被合并\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"优化策略\"><a href=\"#优化策略\" class=\"headerlink\" title=\"优化策略\"></a>优化策略</h3><h4 id=\"函数式更新\"><a href=\"#函数式更新\" class=\"headerlink\" title=\"函数式更新\"></a>函数式更新</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const OptimizedUpdates &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  const increment &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 使用函数式更新确保状态正确性\n    setCount((prev) &#x3D;&gt; prev + 1);\n    setCount((prev) &#x3D;&gt; prev + 1);\n    &#x2F;&#x2F; 最终 count 会 +2\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-19\"><a href=\"#注意事项-19\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><h4 id=\"避免直接依赖更新后的值\"><a href=\"#避免直接依赖更新后的值\" class=\"headerlink\" title=\"避免直接依赖更新后的值\"></a>避免直接依赖更新后的值</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const AntiPattern &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    setCount(count + 1);\n    console.log(count); &#x2F;&#x2F; 仍然是旧值\n\n    &#x2F;&#x2F; 正确的方式：使用 useEffect\n    useEffect(() &#x3D;&gt; &#123;\n      console.log(&quot;count updated:&quot;, count);\n    &#125;, [count]);\n  &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-12\"><a href=\"#最佳实践-12\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"合理组织更新逻辑\"><a href=\"#合理组织更新逻辑\" class=\"headerlink\" title=\"合理组织更新逻辑\"></a>合理组织更新逻辑</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const BestPractice &#x3D; () &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState(&#123;\n    count: 0,\n    data: [],\n    loading: false,\n  &#125;);\n\n  const updateState &#x3D; useCallback((updates) &#x3D;&gt; &#123;\n    setState((prev) &#x3D;&gt; (&#123;\n      ...prev,\n      ...updates,\n    &#125;));\n  &#125;, []);\n\n  const handleAction &#x3D; async () &#x3D;&gt; &#123;\n    updateState(&#123; loading: true &#125;);\n    try &#123;\n      const data &#x3D; await fetchData();\n      updateState(&#123;\n        data,\n        count: state.count + 1,\n        loading: false,\n      &#125;);\n    &#125; catch (error) &#123;\n      updateState(&#123; loading: false &#125;);\n    &#125;\n  &#125;;\n&#125;;</code></pre>\n\n<p>理解 setState 的批处理机制有助于编写更高效的 React 应用，避免不必要的渲染，提高应用性能。</p>\n<h2 id=\"React-组件的-state-和-props-有什么区别？\"><a href=\"#React-组件的-state-和-props-有什么区别？\" class=\"headerlink\" title=\"React 组件的 state 和 props 有什么区别？\"></a>React 组件的 state 和 props 有什么区别？</h2><h3 id=\"State-和-Props-的基本区别\"><a href=\"#State-和-Props-的基本区别\" class=\"headerlink\" title=\"State 和 Props 的基本区别\"></a>State 和 Props 的基本区别</h3><h4 id=\"State（内部状态）\"><a href=\"#State（内部状态）\" class=\"headerlink\" title=\"State（内部状态）\"></a>State（内部状态）</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Counter &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; state 由组件自己管理\n  const [count, setCount] &#x3D; useState(0);\n\n  return (\n    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount((c) &#x3D;&gt; c + 1)&#125;&gt;点击次数: &#123;count&#125;&lt;&#x2F;button&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"Props（外部属性）\"><a href=\"#Props（外部属性）\" class=\"headerlink\" title=\"Props（外部属性）\"></a>Props（外部属性）</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 子组件通过 props 接收数据\nconst Button &#x3D; (&#123; text, onClick &#125;) &#x3D;&gt; &#123;\n  return &lt;button onClick&#x3D;&#123;onClick&#125;&gt;&#123;text&#125;&lt;&#x2F;button&gt;;\n&#125;;\n\n&#x2F;&#x2F; 父组件传递 props\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  return &lt;Button text&#x3D;&quot;点击我&quot; onClick&#x3D;&#123;() &#x3D;&gt; console.log(&quot;clicked&quot;)&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"主要区别\"><a href=\"#主要区别\" class=\"headerlink\" title=\"主要区别\"></a>主要区别</h3><h4 id=\"1-数据控制权\"><a href=\"#1-数据控制权\" class=\"headerlink\" title=\"1. 数据控制权\"></a>1. 数据控制权</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; Props: 由父组件控制\nconst Child &#x3D; (&#123; data &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 无法修改 props\n  return &lt;div&gt;&#123;data&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\n&#x2F;&#x2F; State: 组件自己控制\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const [data, setData] &#x3D; useState(&quot;初始数据&quot;);\n  return &lt;Child data&#x3D;&#123;data&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h4 id=\"2-可变性\"><a href=\"#2-可变性\" class=\"headerlink\" title=\"2. 可变性\"></a>2. 可变性</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Example &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; State: 可以通过 setState 修改\n  const [count, setCount] &#x3D; useState(0);\n\n  &#x2F;&#x2F; Props: 只读，不能修改\n  const handleProps &#x3D; (props) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; props.value &#x3D; 123; &#x2F;&#x2F; 错误！不能直接修改 props\n  &#125;;\n\n  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"使用场景-2\"><a href=\"#使用场景-2\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><h4 id=\"State-适用场景\"><a href=\"#State-适用场景\" class=\"headerlink\" title=\"State 适用场景\"></a>State 适用场景</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Form &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 表单状态管理\n  const [values, setValues] &#x3D; useState(&#123;\n    username: &quot;&quot;,\n    password: &quot;&quot;,\n  &#125;);\n\n  const handleChange &#x3D; (e) &#x3D;&gt; &#123;\n    const &#123; name, value &#125; &#x3D; e.target;\n    setValues((prev) &#x3D;&gt; (&#123;\n      ...prev,\n      [name]: value,\n    &#125;));\n  &#125;;\n\n  return (\n    &lt;form&gt;\n      &lt;input name&#x3D;&quot;username&quot; value&#x3D;&#123;values.username&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h4 id=\"Props-适用场景\"><a href=\"#Props-适用场景\" class=\"headerlink\" title=\"Props 适用场景\"></a>Props 适用场景</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 可复用的展示组件\nconst UserCard &#x3D; (&#123; user, onEdit &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;user-card&quot;&gt;\n      &lt;img src&#x3D;&#123;user.avatar&#125; &#x2F;&gt;\n      &lt;h3&gt;&#123;user.name&#125;&lt;&#x2F;h3&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; onEdit(user.id)&#125;&gt;编辑&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-13\"><a href=\"#最佳实践-13\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"状态提升\"><a href=\"#状态提升\" class=\"headerlink\" title=\"状态提升\"></a>状态提升</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Parent &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 将共享状态提升到父组件\n  const [shared, setShared] &#x3D; useState(&quot;&quot;);\n\n  return (\n    &lt;&gt;\n      &lt;ChildA data&#x3D;&#123;shared&#125; &#x2F;&gt;\n      &lt;ChildB data&#x3D;&#123;shared&#125; onUpdate&#x3D;&#123;setShared&#125; &#x2F;&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-20\"><a href=\"#注意事项-20\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>State 的更新可能是异步的</li>\n<li>Props 的变化会触发组件重新渲染</li>\n<li>避免在 Props 中传递过多数据</li>\n<li>使用 Props 类型检查</li>\n<li>合理划分状态管理的层级</li>\n</ul>\n<p>理解 State 和 Props 的区别对于正确设计 React 组件结构和数据流非常重要。</p>\n<h2 id=\"React-中的-props-为什么是只读的？\"><a href=\"#React-中的-props-为什么是只读的？\" class=\"headerlink\" title=\"React 中的 props 为什么是只读的？\"></a>React 中的 props 为什么是只读的？</h2><h3 id=\"Props-只读性的设计原理\"><a href=\"#Props-只读性的设计原理\" class=\"headerlink\" title=\"Props 只读性的设计原理\"></a>Props 只读性的设计原理</h3><h4 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Child &#x3D; (&#123; data &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ❌ 错误：不能修改 props\n  &#x2F;&#x2F; data.value &#x3D; &#39;new value&#39;;\n\n  &#x2F;&#x2F; ✅ 正确：通过回调函数通知父组件修改\n  return &lt;div onClick&#x3D;&#123;() &#x3D;&gt; props.onChange(newValue)&#125;&gt;&#123;data&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const [value, setValue] &#x3D; useState(&quot;initial&quot;);\n  return &lt;Child data&#x3D;&#123;value&#125; onChange&#x3D;&#123;setValue&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"保证数据的可预测性\"><a href=\"#保证数据的可预测性\" class=\"headerlink\" title=\"保证数据的可预测性\"></a>保证数据的可预测性</h3><h4 id=\"避免副作用\"><a href=\"#避免副作用\" class=\"headerlink\" title=\"避免副作用\"></a>避免副作用</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 不好的做法\nconst BadComponent &#x3D; (props) &#x3D;&gt; &#123;\n  props.count +&#x3D; 1; &#x2F;&#x2F; 直接修改 props 会导致不可预测的行为\n  return &lt;div&gt;&#123;props.count&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\n&#x2F;&#x2F; 好的做法\nconst GoodComponent &#x3D; (&#123; count, onIncrement &#125;) &#x3D;&gt; &#123;\n  return &lt;div onClick&#x3D;&#123;() &#x3D;&gt; onIncrement(count + 1)&#125;&gt;&#123;count&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"提高组件的可复用性\"><a href=\"#提高组件的可复用性\" class=\"headerlink\" title=\"提高组件的可复用性\"></a>提高组件的可复用性</h3><h4 id=\"纯组件设计\"><a href=\"#纯组件设计\" class=\"headerlink\" title=\"纯组件设计\"></a>纯组件设计</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const PureDisplay &#x3D; React.memo((&#123; data &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; props 不可变保证了组件的纯度\n  return &lt;div&gt;&#123;data&#125;&lt;&#x2F;div&gt;;\n&#125;);\n\n&#x2F;&#x2F; 可以安全地在多处复用\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;&gt;\n      &lt;PureDisplay data&#x3D;&quot;A&quot; &#x2F;&gt;\n      &lt;PureDisplay data&#x3D;&quot;B&quot; &#x2F;&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"便于调试和维护\"><a href=\"#便于调试和维护\" class=\"headerlink\" title=\"便于调试和维护\"></a>便于调试和维护</h3><h4 id=\"清晰的数据流向\"><a href=\"#清晰的数据流向\" class=\"headerlink\" title=\"清晰的数据流向\"></a>清晰的数据流向</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const UserProfile &#x3D; (&#123; user, onUpdate &#125;) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 数据修改的来源清晰可追踪\n  const handleUpdate &#x3D; (field, value) &#x3D;&gt; &#123;\n    onUpdate(&#123;\n      ...user,\n      [field]: value,\n    &#125;);\n  &#125;;\n\n  return (\n    &lt;form&gt;\n      &lt;input\n        value&#x3D;&#123;user.name&#125;\n        onChange&#x3D;&#123;(e) &#x3D;&gt; handleUpdate(&quot;name&quot;, e.target.value)&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"性能优化-3\"><a href=\"#性能优化-3\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><h4 id=\"更容易实现浅比较\"><a href=\"#更容易实现浅比较\" class=\"headerlink\" title=\"更容易实现浅比较\"></a>更容易实现浅比较</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const OptimizedComponent &#x3D; React.memo(\n  (&#123; data &#125;) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; props 不可变使得浅比较更可靠\n    return &lt;ExpensiveRender data&#x3D;&#123;data&#125; &#x2F;&gt;;\n  &#125;,\n  (prevProps, nextProps) &#x3D;&gt; &#123;\n    return prevProps.data &#x3D;&#x3D;&#x3D; nextProps.data;\n  &#125;\n);</code></pre>\n\n<h3 id=\"最佳实践-14\"><a href=\"#最佳实践-14\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"状态提升-1\"><a href=\"#状态提升-1\" class=\"headerlink\" title=\"状态提升\"></a>状态提升</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Parent &#x3D; () &#x3D;&gt; &#123;\n  const [shared, setShared] &#x3D; useState(&quot;&quot;);\n\n  &#x2F;&#x2F; 状态管理集中在父组件\n  const handleChange &#x3D; (newValue) &#x3D;&gt; &#123;\n    setShared(newValue);\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;ChildA data&#x3D;&#123;shared&#125; &#x2F;&gt;\n      &lt;ChildB data&#x3D;&#123;shared&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<p>Props 的只读性是 React 单向数据流的重要保证，它有助于构建可预测和可维护的应用程序。</p>\n<h2 id=\"React-中怎么检验-props？验证-props-的目的是什么？\"><a href=\"#React-中怎么检验-props？验证-props-的目的是什么？\" class=\"headerlink\" title=\"React 中怎么检验 props？验证 props 的目的是什么？\"></a>React 中怎么检验 props？验证 props 的目的是什么？</h2><h3 id=\"Props-验证的方式\"><a href=\"#Props-验证的方式\" class=\"headerlink\" title=\"Props 验证的方式\"></a>Props 验证的方式</h3><h4 id=\"使用-PropTypes\"><a href=\"#使用-PropTypes\" class=\"headerlink\" title=\"使用 PropTypes\"></a>使用 PropTypes</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import PropTypes from &quot;prop-types&quot;;\n\nconst UserCard &#x3D; (&#123; name, age, email &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;div className&#x3D;&quot;user-card&quot;&gt;\n      &lt;h2&gt;&#123;name&#125;&lt;&#x2F;h2&gt;\n      &lt;p&gt;年龄: &#123;age&#125;&lt;&#x2F;p&gt;\n      &lt;p&gt;邮箱: &#123;email&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nUserCard.propTypes &#x3D; &#123;\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n  email: PropTypes.string,\n&#125;;</code></pre>\n\n<h3 id=\"常用的验证类型\"><a href=\"#常用的验证类型\" class=\"headerlink\" title=\"常用的验证类型\"></a>常用的验证类型</h3><h4 id=\"基础类型验证\"><a href=\"#基础类型验证\" class=\"headerlink\" title=\"基础类型验证\"></a>基础类型验证</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Component &#x3D; (&#123; props &#125;) &#x3D;&gt; &#123;\n  return &lt;div&gt;&#123;props&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\nComponent.propTypes &#x3D; &#123;\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n&#125;;</code></pre>\n\n<h3 id=\"复杂类型验证\"><a href=\"#复杂类型验证\" class=\"headerlink\" title=\"复杂类型验证\"></a>复杂类型验证</h3><h4 id=\"对象结构验证\"><a href=\"#对象结构验证\" class=\"headerlink\" title=\"对象结构验证\"></a>对象结构验证</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ProfileCard &#x3D; (&#123; user &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;&#123;user.name&#125;&lt;&#x2F;h2&gt;\n      &lt;p&gt;&#123;user.bio&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nProfileCard.propTypes &#x3D; &#123;\n  user: PropTypes.shape(&#123;\n    name: PropTypes.string.isRequired,\n    bio: PropTypes.string,\n    age: PropTypes.number,\n  &#125;).isRequired,\n&#125;;</code></pre>\n\n<h3 id=\"自定义验证器\"><a href=\"#自定义验证器\" class=\"headerlink\" title=\"自定义验证器\"></a>自定义验证器</h3><h4 id=\"复杂规则验证\"><a href=\"#复杂规则验证\" class=\"headerlink\" title=\"复杂规则验证\"></a>复杂规则验证</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Form &#x3D; (&#123; status &#125;) &#x3D;&gt; &#123;\n  return &lt;div&gt;&#123;status&#125;&lt;&#x2F;div&gt;;\n&#125;;\n\nForm.propTypes &#x3D; &#123;\n  status: (props, propName, componentName) &#x3D;&gt; &#123;\n    if (![&quot;draft&quot;, &quot;published&quot;, &quot;archived&quot;].includes(props[propName])) &#123;\n      return new Error(\n        &#96;Invalid prop $&#123;propName&#125; supplied to $&#123;componentName&#125;. \n         Expected one of: draft, published, archived&#96;\n      );\n    &#125;\n  &#125;,\n&#125;;</code></pre>\n\n<h3 id=\"Props-验证的目的\"><a href=\"#Props-验证的目的\" class=\"headerlink\" title=\"Props 验证的目的\"></a>Props 验证的目的</h3><ol>\n<li><strong>开发阶段的错误检查</strong></li>\n<li><strong>提高代码可维护性</strong></li>\n<li><strong>增强组件的可重用性</strong></li>\n<li><strong>提供组件文档</strong></li>\n</ol>\n<h3 id=\"最佳实践-15\"><a href=\"#最佳实践-15\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"默认值设置\"><a href=\"#默认值设置\" class=\"headerlink\" title=\"默认值设置\"></a>默认值设置</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Button &#x3D; (&#123; type, text &#125;) &#x3D;&gt; &#123;\n  return &lt;button className&#x3D;&#123;&#96;btn-$&#123;type&#125;&#96;&#125;&gt;&#123;text&#125;&lt;&#x2F;button&gt;;\n&#125;;\n\nButton.propTypes &#x3D; &#123;\n  type: PropTypes.oneOf([&quot;primary&quot;, &quot;secondary&quot;, &quot;danger&quot;]),\n  text: PropTypes.string.isRequired,\n&#125;;\n\nButton.defaultProps &#x3D; &#123;\n  type: &quot;primary&quot;,\n&#125;;</code></pre>\n\n<h3 id=\"常见验证场景\"><a href=\"#常见验证场景\" class=\"headerlink\" title=\"常见验证场景\"></a>常见验证场景</h3><h4 id=\"数组元素验证\"><a href=\"#数组元素验证\" class=\"headerlink\" title=\"数组元素验证\"></a>数组元素验证</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const List &#x3D; (&#123; items &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;ul&gt;\n      &#123;items.map((item) &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;;\n\nList.propTypes &#x3D; &#123;\n  items: PropTypes.arrayOf(\n    PropTypes.shape(&#123;\n      id: PropTypes.number.isRequired,\n      name: PropTypes.string.isRequired,\n    &#125;)\n  ).isRequired,\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-21\"><a href=\"#注意事项-21\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>PropTypes 仅在开发模式下进行检查</li>\n<li>生产环境会自动跳过验证以优化性能</li>\n<li>合理使用 isRequired</li>\n<li>避免过度复杂的验证规则</li>\n<li>及时更新验证规则</li>\n</ul>\n<p>Props 验证是提高 React 应用程序健壮性和可维护性的重要工具。</p>\n<h1 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h1><h2 id=\"父子组件的通信方式？\"><a href=\"#父子组件的通信方式？\" class=\"headerlink\" title=\"父子组件的通信方式？\"></a>父子组件的通信方式？</h2><h3 id=\"React-父子组件通信的主要方式\"><a href=\"#React-父子组件通信的主要方式\" class=\"headerlink\" title=\"React 父子组件通信的主要方式\"></a>React 父子组件通信的主要方式</h3><h4 id=\"1-Props-传递数据（父传子）\"><a href=\"#1-Props-传递数据（父传子）\" class=\"headerlink\" title=\"1. Props 传递数据（父传子）\"></a>1. Props 传递数据（父传子）</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 父组件传递数据给子组件\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  return &lt;Child count&#x3D;&#123;count&#125; onIncrement&#x3D;&#123;() &#x3D;&gt; setCount((c) &#x3D;&gt; c + 1)&#125; &#x2F;&gt;;\n&#125;;\n\n&#x2F;&#x2F; 子组件接收数据\nconst Child &#x3D; (&#123; count, onIncrement &#125;) &#x3D;&gt; &#123;\n  return &lt;button onClick&#x3D;&#123;onIncrement&#125;&gt;点击次数: &#123;count&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"2-回调函数（子传父）\"><a href=\"#2-回调函数（子传父）\" class=\"headerlink\" title=\"2. 回调函数（子传父）\"></a>2. 回调函数（子传父）</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Parent &#x3D; () &#x3D;&gt; &#123;\n  const handleChildData &#x3D; (data) &#x3D;&gt; &#123;\n    console.log(&quot;从子组件收到数据:&quot;, data);\n  &#125;;\n\n  return &lt;Child onDataChange&#x3D;&#123;handleChildData&#125; &#x2F;&gt;;\n&#125;;\n\nconst Child &#x3D; (&#123; onDataChange &#125;) &#x3D;&gt; &#123;\n  const sendDataToParent &#x3D; () &#x3D;&gt; &#123;\n    onDataChange(&quot;来自子组件的数据&quot;);\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;sendDataToParent&#125;&gt;发送数据&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"3-Ref-引用（父组件调用子组件方法）\"><a href=\"#3-Ref-引用（父组件调用子组件方法）\" class=\"headerlink\" title=\"3. Ref 引用（父组件调用子组件方法）\"></a>3. Ref 引用（父组件调用子组件方法）</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Child &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;\n  const childMethod &#x3D; () &#x3D;&gt; &#123;\n    console.log(&quot;子组件方法被调用&quot;);\n  &#125;;\n\n  &#x2F;&#x2F; 暴露方法给父组件\n  useImperativeHandle(ref, () &#x3D;&gt; (&#123;\n    childMethod,\n  &#125;));\n\n  return &lt;div&gt;子组件&lt;&#x2F;div&gt;;\n&#125;);\n\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const childRef &#x3D; useRef(null);\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 调用子组件方法\n    childRef.current.childMethod();\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;Child ref&#x3D;&#123;childRef&#125; &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;调用子组件方法&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"4-状态提升\"><a href=\"#4-状态提升\" class=\"headerlink\" title=\"4. 状态提升\"></a>4. 状态提升</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Parent &#x3D; () &#x3D;&gt; &#123;\n  const [sharedState, setSharedState] &#x3D; useState(&quot;&quot;);\n\n  return (\n    &lt;&gt;\n      &lt;ChildA value&#x3D;&#123;sharedState&#125; onChange&#x3D;&#123;setSharedState&#125; &#x2F;&gt;\n      &lt;ChildB value&#x3D;&#123;sharedState&#125; &#x2F;&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"5-Children-属性\"><a href=\"#5-Children-属性\" class=\"headerlink\" title=\"5. Children 属性\"></a>5. Children 属性</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Parent &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  return (\n    &lt;Container&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount((c) &#x3D;&gt; c + 1)&#125;&gt;增加&lt;&#x2F;button&gt;\n      &lt;div&gt;计数: &#123;count&#125;&lt;&#x2F;div&gt;\n    &lt;&#x2F;Container&gt;\n  );\n&#125;;\n\nconst Container &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  return &lt;div className&#x3D;&quot;container&quot;&gt;&#123;children&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-16\"><a href=\"#最佳实践-16\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组件通信封装\"><a href=\"#组件通信封装\" class=\"headerlink\" title=\"组件通信封装\"></a>组件通信封装</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Form &#x3D; (&#123; onSubmit &#125;) &#x3D;&gt; &#123;\n  const [formData, setFormData] &#x3D; useState(&#123;&#125;);\n\n  const handleFieldChange &#x3D; useCallback((name, value) &#x3D;&gt; &#123;\n    setFormData((prev) &#x3D;&gt; (&#123;\n      ...prev,\n      [name]: value,\n    &#125;));\n  &#125;, []);\n\n  return (\n    &lt;form onSubmit&#x3D;&#123;() &#x3D;&gt; onSubmit(formData)&#125;&gt;\n      &lt;FormField name&#x3D;&quot;username&quot; onChange&#x3D;&#123;handleFieldChange&#125; &#x2F;&gt;\n      &lt;FormField name&#x3D;&quot;email&quot; onChange&#x3D;&#123;handleFieldChange&#125; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-22\"><a href=\"#注意事项-22\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>避免过度使用 ref</li>\n<li>保持数据流的单向性</li>\n<li>合理使用状态提升</li>\n<li>避免 props 层级过深</li>\n<li>考虑使用状态管理工具</li>\n</ul>\n<p>父子组件通信是 React 应用中最基础的通信方式，合理使用这些方式可以构建清晰的组件层次结构。</p>\n<h2 id=\"跨级组件的通信方式？\"><a href=\"#跨级组件的通信方式？\" class=\"headerlink\" title=\"跨级组件的通信方式？\"></a>跨级组件的通信方式？</h2><h3 id=\"跨级组件通信的主要方式\"><a href=\"#跨级组件通信的主要方式\" class=\"headerlink\" title=\"跨级组件通信的主要方式\"></a>跨级组件通信的主要方式</h3><h4 id=\"1-Context-API\"><a href=\"#1-Context-API\" class=\"headerlink\" title=\"1. Context API\"></a>1. Context API</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建 Context\nconst ThemeContext &#x3D; createContext();\n\n&#x2F;&#x2F; 顶层组件提供数据\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [theme, setTheme] &#x3D; useState(&quot;light&quot;);\n\n  return (\n    &lt;ThemeContext.Provider value&#x3D;&#123;&#123; theme, setTheme &#125;&#125;&gt;\n      &lt;Header &#x2F;&gt;\n      &lt;Main &#x2F;&gt;\n    &lt;&#x2F;ThemeContext.Provider&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 深层组件消费数据\nconst ThemedButton &#x3D; () &#x3D;&gt; &#123;\n  const &#123; theme, setTheme &#125; &#x3D; useContext(ThemeContext);\n\n  return (\n    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setTheme(theme &#x3D;&#x3D;&#x3D; &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;)&#125;&gt;\n      当前主题: &#123;theme&#125;\n    &lt;&#x2F;button&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"2-自定义-Hook-封装\"><a href=\"#2-自定义-Hook-封装\" class=\"headerlink\" title=\"2. 自定义 Hook 封装\"></a>2. 自定义 Hook 封装</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建共享状态的 Hook\nconst useSharedState &#x3D; create((set) &#x3D;&gt; (&#123;\n  count: 0,\n  increment: () &#x3D;&gt; set((state) &#x3D;&gt; (&#123; count: state.count + 1 &#125;)),\n  decrement: () &#x3D;&gt; set((state) &#x3D;&gt; (&#123; count: state.count - 1 &#125;)),\n&#125;));\n\n&#x2F;&#x2F; 任意层级的组件都可以使用\nconst DeepComponent &#x3D; () &#x3D;&gt; &#123;\n  const &#123; count, increment &#125; &#x3D; useSharedState();\n  return &lt;button onClick&#x3D;&#123;increment&#125;&gt;Count: &#123;count&#125;&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"3-发布订阅模式\"><a href=\"#3-发布订阅模式\" class=\"headerlink\" title=\"3. 发布订阅模式\"></a>3. 发布订阅模式</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const eventBus &#x3D; &#123;\n  listeners: &#123;&#125;,\n\n  on(event, callback) &#123;\n    if (!this.listeners[event]) &#123;\n      this.listeners[event] &#x3D; [];\n    &#125;\n    this.listeners[event].push(callback);\n  &#125;,\n\n  emit(event, data) &#123;\n    if (this.listeners[event]) &#123;\n      this.listeners[event].forEach((callback) &#x3D;&gt; callback(data));\n    &#125;\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 组件A发送消息\nconst ComponentA &#x3D; () &#x3D;&gt; &#123;\n  const sendMessage &#x3D; () &#x3D;&gt; &#123;\n    eventBus.emit(&quot;message&quot;, &quot;Hello from A&quot;);\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;sendMessage&#125;&gt;发送消息&lt;&#x2F;button&gt;;\n&#125;;\n\n&#x2F;&#x2F; 组件B接收消息\nconst ComponentB &#x3D; () &#x3D;&gt; &#123;\n  const [message, setMessage] &#x3D; useState(&quot;&quot;);\n\n  useEffect(() &#x3D;&gt; &#123;\n    eventBus.on(&quot;message&quot;, setMessage);\n    return () &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 清理订阅\n      eventBus.listeners[&quot;message&quot;] &#x3D; eventBus.listeners[&quot;message&quot;].filter(\n        (cb) &#x3D;&gt; cb !&#x3D;&#x3D; setMessage\n      );\n    &#125;;\n  &#125;, []);\n\n  return &lt;div&gt;收到消息: &#123;message&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"4-Redux-或其他状态管理\"><a href=\"#4-Redux-或其他状态管理\" class=\"headerlink\" title=\"4. Redux 或其他状态管理\"></a>4. Redux 或其他状态管理</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建 store\nconst store &#x3D; configureStore(&#123;\n  reducer: &#123;\n    theme: themeReducer,\n    user: userReducer,\n  &#125;,\n&#125;);\n\n&#x2F;&#x2F; 任意组件都可以访问和修改状态\nconst DeepNestedComponent &#x3D; () &#x3D;&gt; &#123;\n  const theme &#x3D; useSelector((state) &#x3D;&gt; state.theme);\n  const dispatch &#x3D; useDispatch();\n\n  return &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(toggleTheme())&#125;&gt;切换主题&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-17\"><a href=\"#最佳实践-17\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"合理选择通信方式\"><a href=\"#合理选择通信方式\" class=\"headerlink\" title=\"合理选择通信方式\"></a>合理选择通信方式</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 对于主题、用户信息等全局状态，使用 Context\n  return (\n    &lt;ThemeProvider&gt;\n      &lt;UserProvider&gt;\n        &#123;&#x2F;* 对于局部共享状态，使用状态提升 *&#x2F;&#125;\n        &lt;LocalStateManager&gt;\n          &lt;ComponentTree &#x2F;&gt;\n        &lt;&#x2F;LocalStateManager&gt;\n      &lt;&#x2F;UserProvider&gt;\n    &lt;&#x2F;ThemeProvider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-23\"><a href=\"#注意事项-23\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>避免 Context 嵌套过深</li>\n<li>合理划分状态作用域</li>\n<li>注意性能优化</li>\n<li>及时清理事件监听</li>\n<li>选择合适的状态管理方案</li>\n</ul>\n<p>跨级组件通信是 React 应用中常见的需求，选择合适的通信方式对于应用的可维护性和性能都很重要。</p>\n<h2 id=\"非嵌套关系组件的通信方式？\"><a href=\"#非嵌套关系组件的通信方式？\" class=\"headerlink\" title=\"非嵌套关系组件的通信方式？\"></a>非嵌套关系组件的通信方式？</h2><h3 id=\"非嵌套关系组件通信的主要方式\"><a href=\"#非嵌套关系组件通信的主要方式\" class=\"headerlink\" title=\"非嵌套关系组件通信的主要方式\"></a>非嵌套关系组件通信的主要方式</h3><h4 id=\"1-Context-API-1\"><a href=\"#1-Context-API-1\" class=\"headerlink\" title=\"1. Context API\"></a>1. Context API</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建全局 Context\nconst AppContext &#x3D; createContext();\n\n&#x2F;&#x2F; 在共同的父组件中提供数据\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [sharedData, setSharedData] &#x3D; useState(&quot;&quot;);\n\n  return (\n    &lt;AppContext.Provider value&#x3D;&#123;&#123; sharedData, setSharedData &#125;&#125;&gt;\n      &lt;ComponentA &#x2F;&gt;\n      &lt;div&gt;\n        &lt;ComponentB &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;AppContext.Provider&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 任意位置的组件都可以访问数据\nconst ComponentA &#x3D; () &#x3D;&gt; &#123;\n  const &#123; setSharedData &#125; &#x3D; useContext(AppContext);\n  return &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setSharedData(&quot;from A&quot;)&#125;&gt;发送数据&lt;&#x2F;button&gt;;\n&#125;;\n\nconst ComponentB &#x3D; () &#x3D;&gt; &#123;\n  const &#123; sharedData &#125; &#x3D; useContext(AppContext);\n  return &lt;div&gt;接收到的数据: &#123;sharedData&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"2-状态管理工具\"><a href=\"#2-状态管理工具\" class=\"headerlink\" title=\"2. 状态管理工具\"></a>2. 状态管理工具</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 使用 Redux\nconst store &#x3D; configureStore(&#123;\n  reducer: &#123;\n    message: messageReducer,\n  &#125;,\n&#125;);\n\n&#x2F;&#x2F; 组件 A 发送数据\nconst ComponentA &#x3D; () &#x3D;&gt; &#123;\n  const dispatch &#x3D; useDispatch();\n\n  return (\n    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(sendMessage(&quot;Hello&quot;))&#125;&gt;发送消息&lt;&#x2F;button&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 组件 B 接收数据\nconst ComponentB &#x3D; () &#x3D;&gt; &#123;\n  const message &#x3D; useSelector((state) &#x3D;&gt; state.message);\n  return &lt;div&gt;收到消息: &#123;message&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"3-发布订阅模式-1\"><a href=\"#3-发布订阅模式-1\" class=\"headerlink\" title=\"3. 发布订阅模式\"></a>3. 发布订阅模式</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建事件中心\nconst eventBus &#x3D; &#123;\n  events: &#123;&#125;,\n\n  subscribe(event, callback) &#123;\n    if (!this.events[event]) &#123;\n      this.events[event] &#x3D; [];\n    &#125;\n    this.events[event].push(callback);\n\n    return () &#x3D;&gt; this.unsubscribe(event, callback);\n  &#125;,\n\n  publish(event, data) &#123;\n    if (this.events[event]) &#123;\n      this.events[event].forEach((callback) &#x3D;&gt; callback(data));\n    &#125;\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 使用自定义 Hook 封装\nconst useEventBus &#x3D; (event) &#x3D;&gt; &#123;\n  const [data, setData] &#x3D; useState(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    const unsubscribe &#x3D; eventBus.subscribe(event, setData);\n    return unsubscribe;\n  &#125;, [event]);\n\n  return [data, (newData) &#x3D;&gt; eventBus.publish(event, newData)];\n&#125;;</code></pre>\n\n<h3 id=\"4-自定义-Hooks\"><a href=\"#4-自定义-Hooks\" class=\"headerlink\" title=\"4. 自定义 Hooks\"></a>4. 自定义 Hooks</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建共享状态的 Hook\nconst useSharedState &#x3D; create((set) &#x3D;&gt; (&#123;\n  data: null,\n  setData: (newData) &#x3D;&gt; set(&#123; data: newData &#125;),\n&#125;));\n\n&#x2F;&#x2F; 在任意组件中使用\nconst ComponentA &#x3D; () &#x3D;&gt; &#123;\n  const &#123; setData &#125; &#x3D; useSharedState();\n  return &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setData(&quot;new data&quot;)&#125;&gt;更新数据&lt;&#x2F;button&gt;;\n&#125;;\n\nconst ComponentB &#x3D; () &#x3D;&gt; &#123;\n  const &#123; data &#125; &#x3D; useSharedState();\n  return &lt;div&gt;数据: &#123;data&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-18\"><a href=\"#最佳实践-18\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组合使用多种方式\"><a href=\"#组合使用多种方式\" class=\"headerlink\" title=\"组合使用多种方式\"></a>组合使用多种方式</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 全局状态管理\n  return (\n    &lt;Provider store&#x3D;&#123;store&#125;&gt;\n      &lt;ThemeContext.Provider value&#x3D;&#123;theme&#125;&gt;\n        &#123;&#x2F;* 局部状态共享 *&#x2F;&#125;\n        &lt;LocalStateProvider&gt;\n          &lt;ComponentA &#x2F;&gt;\n          &lt;ComponentB &#x2F;&gt;\n        &lt;&#x2F;LocalStateProvider&gt;\n      &lt;&#x2F;ThemeContext.Provider&gt;\n    &lt;&#x2F;Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-24\"><a href=\"#注意事项-24\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>选择合适的通信方式</li>\n<li>避免状态管理过度复杂化</li>\n<li>注意性能优化</li>\n<li>合理划分状态作用域</li>\n<li>及时清理订阅</li>\n</ul>\n<p>合理选择和使用这些通信方式，可以让组件之间的数据流更加清晰和可维护。</p>\n<h2 id=\"如何解决-props-层级过深的问题\"><a href=\"#如何解决-props-层级过深的问题\" class=\"headerlink\" title=\"如何解决 props 层级过深的问题\"></a>如何解决 props 层级过深的问题</h2><h3 id=\"解决-Props-层级过深的方法\"><a href=\"#解决-Props-层级过深的方法\" class=\"headerlink\" title=\"解决 Props 层级过深的方法\"></a>解决 Props 层级过深的方法</h3><h4 id=\"1-使用-Context-API\"><a href=\"#1-使用-Context-API\" class=\"headerlink\" title=\"1. 使用 Context API\"></a>1. 使用 Context API</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建 Context\nconst UserContext &#x3D; createContext();\n\n&#x2F;&#x2F; 顶层提供数据\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const userData &#x3D; &#123;\n    name: &quot;John&quot;,\n    theme: &quot;dark&quot;,\n  &#125;;\n\n  return (\n    &lt;UserContext.Provider value&#x3D;&#123;userData&#125;&gt;\n      &lt;PageLayout &#x2F;&gt;\n    &lt;&#x2F;UserContext.Provider&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 深层组件直接获取数据，避免逐层传递\nconst DeepComponent &#x3D; () &#x3D;&gt; &#123;\n  const &#123; name, theme &#125; &#x3D; useContext(UserContext);\n  return &lt;div className&#x3D;&#123;theme&#125;&gt;&#123;name&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"2-使用状态管理工具\"><a href=\"#2-使用状态管理工具\" class=\"headerlink\" title=\"2. 使用状态管理工具\"></a>2. 使用状态管理工具</h3><h4 id=\"Redux-示例\"><a href=\"#Redux-示例\" class=\"headerlink\" title=\"Redux 示例\"></a>Redux 示例</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 全局状态管理\nconst store &#x3D; configureStore(&#123;\n  reducer: &#123;\n    user: userReducer,\n    theme: themeReducer,\n  &#125;,\n&#125;);\n\n&#x2F;&#x2F; 任意层级组件都可以访问状态\nconst DeepNestedComponent &#x3D; () &#x3D;&gt; &#123;\n  const userData &#x3D; useSelector((state) &#x3D;&gt; state.user);\n  return &lt;UserProfile data&#x3D;&#123;userData&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"3-组件组合\"><a href=\"#3-组件组合\" class=\"headerlink\" title=\"3. 组件组合\"></a>3. 组件组合</h3><h4 id=\"使用-children-属性-1\"><a href=\"#使用-children-属性-1\" class=\"headerlink\" title=\"使用 children 属性\"></a>使用 children 属性</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Layout &#x3D; (&#123; children &#125;) &#x3D;&gt; &lt;div className&#x3D;&quot;layout&quot;&gt;&#123;children&#125;&lt;&#x2F;div&gt;;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const userData &#x3D; &#123; name: &quot;John&quot; &#125;;\n\n  return (\n    &lt;Layout&gt;\n      &lt;DeepComponent data&#x3D;&#123;userData&#125; &#x2F;&gt;\n    &lt;&#x2F;Layout&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"4-自定义-Hooks-1\"><a href=\"#4-自定义-Hooks-1\" class=\"headerlink\" title=\"4. 自定义 Hooks\"></a>4. 自定义 Hooks</h3><h4 id=\"共享逻辑和状态\"><a href=\"#共享逻辑和状态\" class=\"headerlink\" title=\"共享逻辑和状态\"></a>共享逻辑和状态</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 创建自定义 Hook\nconst useSharedData &#x3D; () &#x3D;&gt; &#123;\n  const [data, setData] &#x3D; useState(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    fetchData().then(setData);\n  &#125;, []);\n\n  return data;\n&#125;;\n\n&#x2F;&#x2F; 在任意组件中使用\nconst DeepComponent &#x3D; () &#x3D;&gt; &#123;\n  const data &#x3D; useSharedData();\n  return &lt;div&gt;&#123;data&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"5-组件拆分\"><a href=\"#5-组件拆分\" class=\"headerlink\" title=\"5. 组件拆分\"></a>5. 组件拆分</h3><h4 id=\"合理的组件结构\"><a href=\"#合理的组件结构\" class=\"headerlink\" title=\"合理的组件结构\"></a>合理的组件结构</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 将深层嵌套的组件拆分成独立的模块\nconst UserDashboard &#x3D; () &#x3D;&gt; &#123;\n  const userData &#x3D; useUserData();\n\n  return (\n    &lt;DashboardLayout&gt;\n      &lt;UserProfile data&#x3D;&#123;userData&#125; &#x2F;&gt;\n      &lt;UserSettings data&#x3D;&#123;userData&#125; &#x2F;&gt;\n    &lt;&#x2F;DashboardLayout&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 避免过度嵌套\nconst UserProfile &#x3D; (&#123; data &#125;) &#x3D;&gt; (\n  &lt;div&gt;\n    &lt;h2&gt;&#123;data.name&#125;&lt;&#x2F;h2&gt;\n    &lt;ProfileDetails &#123;...data&#125; &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n);</code></pre>\n\n<h3 id=\"最佳实践-19\"><a href=\"#最佳实践-19\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"合理使用多种方案\"><a href=\"#合理使用多种方案\" class=\"headerlink\" title=\"合理使用多种方案\"></a>合理使用多种方案</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Provider store&#x3D;&#123;store&#125;&gt;\n      &lt;ThemeContext.Provider value&#x3D;&#123;theme&#125;&gt;\n        &lt;Layout&gt;\n          &#123;&#x2F;* 组件组合 *&#x2F;&#125;\n          &lt;ComponentA&gt;\n            &lt;DeepComponent &#x2F;&gt;\n          &lt;&#x2F;ComponentA&gt;\n\n          &#123;&#x2F;* Context 消费 *&#x2F;&#125;\n          &lt;ThemedComponent &#x2F;&gt;\n\n          &#123;&#x2F;* Redux 连接 *&#x2F;&#125;\n          &lt;ConnectedComponent &#x2F;&gt;\n        &lt;&#x2F;Layout&gt;\n      &lt;&#x2F;ThemeContext.Provider&gt;\n    &lt;&#x2F;Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-25\"><a href=\"#注意事项-25\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>避免过度使用 Context</li>\n<li>合理划分状态作用域</li>\n<li>保持组件的可复用性</li>\n<li>注意性能影响</li>\n<li>维护代码可读性</li>\n</ul>\n<p>选择合适的方案来解决 props 层级过深的问题，可以让代码更加清晰和易于维护。</p>\n<h2 id=\"组件通信的方式有哪些\"><a href=\"#组件通信的方式有哪些\" class=\"headerlink\" title=\"组件通信的方式有哪些\"></a>组件通信的方式有哪些</h2><h3 id=\"React-组件通信的主要方式\"><a href=\"#React-组件通信的主要方式\" class=\"headerlink\" title=\"React 组件通信的主要方式\"></a>React 组件通信的主要方式</h3><h4 id=\"1-Props-父子通信\"><a href=\"#1-Props-父子通信\" class=\"headerlink\" title=\"1. Props 父子通信\"></a>1. Props 父子通信</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 父组件传递数据给子组件\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const [data, setData] &#x3D; useState(&quot;hello&quot;);\n\n  return &lt;Child data&#x3D;&#123;data&#125; onUpdate&#x3D;&#123;(newData) &#x3D;&gt; setData(newData)&#125; &#x2F;&gt;;\n&#125;;\n\nconst Child &#x3D; (&#123; data, onUpdate &#125;) &#x3D;&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;data&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; onUpdate(&quot;new data&quot;)&#125;&gt;更新数据&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"2-Context-跨层级通信\"><a href=\"#2-Context-跨层级通信\" class=\"headerlink\" title=\"2. Context 跨层级通信\"></a>2. Context 跨层级通信</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ThemeContext &#x3D; createContext();\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const [theme, setTheme] &#x3D; useState(&quot;light&quot;);\n\n  return (\n    &lt;ThemeContext.Provider value&#x3D;&#123;&#123; theme, setTheme &#125;&#125;&gt;\n      &lt;Header &#x2F;&gt;\n      &lt;Content &#x2F;&gt;\n    &lt;&#x2F;ThemeContext.Provider&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 深层组件直接获取数据\nconst ThemedButton &#x3D; () &#x3D;&gt; &#123;\n  const &#123; theme, setTheme &#125; &#x3D; useContext(ThemeContext);\n  return (\n    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setTheme(theme &#x3D;&#x3D;&#x3D; &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;)&#125;&gt;\n      切换主题\n    &lt;&#x2F;button&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"3-状态管理工具\"><a href=\"#3-状态管理工具\" class=\"headerlink\" title=\"3. 状态管理工具\"></a>3. 状态管理工具</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; Redux 示例\nconst store &#x3D; configureStore(&#123;\n  reducer: &#123;\n    user: userReducer,\n  &#125;,\n&#125;);\n\n&#x2F;&#x2F; 组件 A 发送数据\nconst ComponentA &#x3D; () &#x3D;&gt; &#123;\n  const dispatch &#x3D; useDispatch();\n  return (\n    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(updateUser(&#123; name: &quot;John&quot; &#125;))&#125;&gt;\n      更新用户\n    &lt;&#x2F;button&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 组件 B 接收数据\nconst ComponentB &#x3D; () &#x3D;&gt; &#123;\n  const user &#x3D; useSelector((state) &#x3D;&gt; state.user);\n  return &lt;div&gt;用户名: &#123;user.name&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"4-发布订阅模式\"><a href=\"#4-发布订阅模式\" class=\"headerlink\" title=\"4. 发布订阅模式\"></a>4. 发布订阅模式</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const eventBus &#x3D; &#123;\n  events: &#123;&#125;,\n\n  emit(event, data) &#123;\n    if (this.events[event]) &#123;\n      this.events[event].forEach((callback) &#x3D;&gt; callback(data));\n    &#125;\n  &#125;,\n\n  on(event, callback) &#123;\n    if (!this.events[event]) &#123;\n      this.events[event] &#x3D; [];\n    &#125;\n    this.events[event].push(callback);\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; 使用事件总线\nconst ComponentA &#x3D; () &#x3D;&gt; &#123;\n  const sendMessage &#x3D; () &#x3D;&gt; &#123;\n    eventBus.emit(&quot;message&quot;, &quot;Hello&quot;);\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;sendMessage&#125;&gt;发送消息&lt;&#x2F;button&gt;;\n&#125;;\n\nconst ComponentB &#x3D; () &#x3D;&gt; &#123;\n  const [message, setMessage] &#x3D; useState(&quot;&quot;);\n\n  useEffect(() &#x3D;&gt; &#123;\n    eventBus.on(&quot;message&quot;, setMessage);\n  &#125;, []);\n\n  return &lt;div&gt;收到消息: &#123;message&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"5-Ref-通信\"><a href=\"#5-Ref-通信\" class=\"headerlink\" title=\"5. Ref 通信\"></a>5. Ref 通信</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Child &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;\n  const childMethod &#x3D; () &#x3D;&gt; &#123;\n    console.log(&quot;child method called&quot;);\n  &#125;;\n\n  useImperativeHandle(ref, () &#x3D;&gt; (&#123;\n    childMethod,\n  &#125;));\n\n  return &lt;div&gt;子组件&lt;&#x2F;div&gt;;\n&#125;);\n\nconst Parent &#x3D; () &#x3D;&gt; &#123;\n  const childRef &#x3D; useRef();\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    childRef.current.childMethod();\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;Child ref&#x3D;&#123;childRef&#125; &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;调用子组件方法&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-20\"><a href=\"#最佳实践-20\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"选择合适的通信方式\"><a href=\"#选择合适的通信方式\" class=\"headerlink\" title=\"选择合适的通信方式\"></a>选择合适的通信方式</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Provider store&#x3D;&#123;store&#125;&gt;\n      &#123;&#x2F;* 全局状态 *&#x2F;&#125;\n      &lt;ThemeContext.Provider value&#x3D;&#123;theme&#125;&gt;\n        &#123;&#x2F;* 主题共享 *&#x2F;&#125;\n        &lt;Layout&gt;\n          &#123;&#x2F;* 父子通信 *&#x2F;&#125;\n          &lt;ComponentA onEvent&#x3D;&#123;handleEvent&#125;&gt;\n            &lt;ComponentB &#x2F;&gt;\n          &lt;&#x2F;ComponentA&gt;\n        &lt;&#x2F;Layout&gt;\n      &lt;&#x2F;ThemeContext.Provider&gt;\n    &lt;&#x2F;Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-26\"><a href=\"#注意事项-26\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>避免通信方式混乱</li>\n<li>合理划分组件职责</li>\n<li>注意性能优化</li>\n<li>保持数据流清晰</li>\n<li>合理使用状态管理</li>\n</ul>\n<p>选择合适的组件通信方式对于构建可维护的 React 应用至关重要。</p>\n<h1 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h1><h2 id=\"React-RouterV6-的实现原理是什么？\"><a href=\"#React-RouterV6-的实现原理是什么？\" class=\"headerlink\" title=\"React-RouterV6 的实现原理是什么？\"></a>React-RouterV6 的实现原理是什么？</h2><h3 id=\"React-Router-V6-的核心原理\"><a href=\"#React-Router-V6-的核心原理\" class=\"headerlink\" title=\"React Router V6 的核心原理\"></a>React Router V6 的核心原理</h3><h4 id=\"基于-History-API\"><a href=\"#基于-History-API\" class=\"headerlink\" title=\"基于 History API\"></a>基于 History API</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; Router 的基本实现原理\nconst Router &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const [location, setLocation] &#x3D; useState(window.location);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 监听路由变化\n    const handlePopState &#x3D; () &#x3D;&gt; &#123;\n      setLocation(window.location);\n    &#125;;\n\n    window.addEventListener(&quot;popstate&quot;, handlePopState);\n    return () &#x3D;&gt; window.removeEventListener(&quot;popstate&quot;, handlePopState);\n  &#125;, []);\n\n  return (\n    &lt;RouterContext.Provider value&#x3D;&#123;&#123; location &#125;&#125;&gt;\n      &#123;children&#125;\n    &lt;&#x2F;RouterContext.Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"主要组件实现\"><a href=\"#主要组件实现\" class=\"headerlink\" title=\"主要组件实现\"></a>主要组件实现</h3><h4 id=\"Routes-和-Route\"><a href=\"#Routes-和-Route\" class=\"headerlink\" title=\"Routes 和 Route\"></a>Routes 和 Route</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; Routes 组件的基本实现\nconst Routes &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const location &#x3D; useLocation();\n\n  &#x2F;&#x2F; 找到匹配的路由\n  const matches &#x3D; matchRoutes(children, location);\n\n  return matches.map((match) &#x3D;&gt; (\n    &lt;RouteContext.Provider\n      value&#x3D;&#123;&#123; outlet: match.route.element &#125;&#125;\n      key&#x3D;&#123;match.route.path&#125;\n    &gt;\n      &#123;match.route.element&#125;\n    &lt;&#x2F;RouteContext.Provider&gt;\n  ));\n&#125;;\n\n&#x2F;&#x2F; Route 配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125;&gt;\n        &lt;Route path&#x3D;&quot;team&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"路由匹配机制\"><a href=\"#路由匹配机制\" class=\"headerlink\" title=\"路由匹配机制\"></a>路由匹配机制</h3><h4 id=\"路径匹配\"><a href=\"#路径匹配\" class=\"headerlink\" title=\"路径匹配\"></a>路径匹配</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const matchPath &#x3D; (pattern, pathname) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 支持动态路由参数\n  const matcher &#x3D; compilePath(pattern);\n  const match &#x3D; matcher.exec(pathname);\n\n  if (!match) return null;\n\n  &#x2F;&#x2F; 提取路由参数\n  const params &#x3D; &#123;&#125;;\n  match.slice(1).forEach((value, index) &#x3D;&gt; &#123;\n    params[matcher.keys[index].name] &#x3D; value;\n  &#125;);\n\n  return &#123; params, pathname: match[0] &#125;;\n&#125;;</code></pre>\n\n<h3 id=\"导航功能\"><a href=\"#导航功能\" class=\"headerlink\" title=\"导航功能\"></a>导航功能</h3><h4 id=\"useNavigate-Hook\"><a href=\"#useNavigate-Hook\" class=\"headerlink\" title=\"useNavigate Hook\"></a>useNavigate Hook</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const useNavigate &#x3D; () &#x3D;&gt; &#123;\n  const navigate &#x3D; useCallback((to, options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n    const &#123; replace &#x3D; false, state &#125; &#x3D; options;\n\n    if (replace) &#123;\n      window.history.replaceState(state, &quot;&quot;, to);\n    &#125; else &#123;\n      window.history.pushState(state, &quot;&quot;, to);\n    &#125;\n\n    &#x2F;&#x2F; 触发路由更新\n    window.dispatchEvent(new PopStateEvent(&quot;popstate&quot;));\n  &#125;, []);\n\n  return navigate;\n&#125;;\n\n&#x2F;&#x2F; 使用示例\nconst Navigation &#x3D; () &#x3D;&gt; &#123;\n  const navigate &#x3D; useNavigate();\n\n  return &lt;button onClick&#x3D;&#123;() &#x3D;&gt; navigate(&quot;&#x2F;about&quot;)&#125;&gt;跳转到关于页面&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"嵌套路由处理\"><a href=\"#嵌套路由处理\" class=\"headerlink\" title=\"嵌套路由处理\"></a>嵌套路由处理</h3><h4 id=\"Outlet-组件\"><a href=\"#Outlet-组件\" class=\"headerlink\" title=\"Outlet 组件\"></a>Outlet 组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Outlet &#x3D; () &#x3D;&gt; &#123;\n  const &#123; outlet &#125; &#x3D; useContext(RouteContext);\n  return outlet;\n&#125;;\n\n&#x2F;&#x2F; 使用嵌套路由\nconst Layout &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;nav&gt;\n        &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;Link&gt;\n        &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;Link&gt;\n      &lt;&#x2F;nav&gt;\n      &lt;main&gt;\n        &lt;Outlet &#x2F;&gt; &#123;&#x2F;* 渲染子路由 *&#x2F;&#125;\n      &lt;&#x2F;main&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"路由守卫实现\"><a href=\"#路由守卫实现\" class=\"headerlink\" title=\"路由守卫实现\"></a>路由守卫实现</h3><h4 id=\"权限控制\"><a href=\"#权限控制\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const PrivateRoute &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const auth &#x3D; useAuth(); &#x2F;&#x2F; 自定义 hook 检查认证状态\n  const navigate &#x3D; useNavigate();\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (!auth) &#123;\n      navigate(&quot;&#x2F;login&quot;);\n    &#125;\n  &#125;, [auth, navigate]);\n\n  return auth ? children : null;\n&#125;;</code></pre>\n\n<p>React Router V6 通过这些核心机制实现了声明式的路由管理，使得路由配置和导航变得更加直观和灵活。</p>\n<h2 id=\"如何配置-React-RouterV6-实现路由切换\"><a href=\"#如何配置-React-RouterV6-实现路由切换\" class=\"headerlink\" title=\"如何配置 React-RouterV6 实现路由切换\"></a>如何配置 React-RouterV6 实现路由切换</h2><h3 id=\"React-Router-V6-的基本配置\"><a href=\"#React-Router-V6-的基本配置\" class=\"headerlink\" title=\"React Router V6 的基本配置\"></a>React Router V6 的基本配置</h3><h4 id=\"基础路由设置\"><a href=\"#基础路由设置\" class=\"headerlink\" title=\"基础路由设置\"></a>基础路由设置</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 基本路由配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;BrowserRouter&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;users&quot; element&#x3D;&#123;&lt;Users &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;*&quot; element&#x3D;&#123;&lt;NotFound &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"嵌套路由配置\"><a href=\"#嵌套路由配置\" class=\"headerlink\" title=\"嵌套路由配置\"></a>嵌套路由配置</h3><h4 id=\"使用-Outlet\"><a href=\"#使用-Outlet\" class=\"headerlink\" title=\"使用 Outlet\"></a>使用 Outlet</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 布局组件\nconst Layout &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;nav&gt;\n        &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;Link&gt;\n        &lt;Link to&#x3D;&quot;&#x2F;dashboard&quot;&gt;控制台&lt;&#x2F;Link&gt;\n      &lt;&#x2F;nav&gt;\n\n      &lt;main&gt;\n        &lt;Outlet &#x2F;&gt; &#123;&#x2F;* 子路由渲染位置 *&#x2F;&#125;\n      &lt;&#x2F;main&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 嵌套路由配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;BrowserRouter&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;\n          &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;dashboard&quot; element&#x3D;&#123;&lt;Dashboard &#x2F;&gt;&#125;&gt;\n            &lt;Route path&#x3D;&quot;profile&quot; element&#x3D;&#123;&lt;Profile &#x2F;&gt;&#125; &#x2F;&gt;\n            &lt;Route path&#x3D;&quot;settings&quot; element&#x3D;&#123;&lt;Settings &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;&#x2F;Route&gt;\n        &lt;&#x2F;Route&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"动态路由参数\"><a href=\"#动态路由参数\" class=\"headerlink\" title=\"动态路由参数\"></a>动态路由参数</h3><h4 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;users&quot; element&#x3D;&#123;&lt;Users &#x2F;&gt;&#125;&gt;\n        &lt;Route path&#x3D;&quot;:id&quot; element&#x3D;&#123;&lt;UserDetail &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 使用路由参数\nconst UserDetail &#x3D; () &#x3D;&gt; &#123;\n  const &#123; id &#125; &#x3D; useParams();\n  return &lt;div&gt;用户 ID: &#123;id&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"路由导航\"><a href=\"#路由导航\" class=\"headerlink\" title=\"路由导航\"></a>路由导航</h3><h4 id=\"Link-和-NavLink\"><a href=\"#Link-和-NavLink\" class=\"headerlink\" title=\"Link 和 NavLink\"></a>Link 和 NavLink</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Navigation &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;nav&gt;\n      &lt;NavLink to&#x3D;&quot;&#x2F;&quot; className&#x3D;&#123;(&#123; isActive &#125;) &#x3D;&gt; (isActive ? &quot;active&quot; : &quot;&quot;)&#125;&gt;\n        首页\n      &lt;&#x2F;NavLink&gt;\n\n      &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;Link&gt;\n\n      &#123;&#x2F;* 带参数的导航 *&#x2F;&#125;\n      &lt;Link to&#x3D;&quot;&#x2F;users&#x2F;123&quot; state&#x3D;&#123;&#123; from: &quot;navigation&quot; &#125;&#125;&gt;\n        用户详情\n      &lt;&#x2F;Link&gt;\n    &lt;&#x2F;nav&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h3><h4 id=\"useNavigate-Hook-1\"><a href=\"#useNavigate-Hook-1\" class=\"headerlink\" title=\"useNavigate Hook\"></a>useNavigate Hook</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const LoginPage &#x3D; () &#x3D;&gt; &#123;\n  const navigate &#x3D; useNavigate();\n\n  const handleLogin &#x3D; async (credentials) &#x3D;&gt; &#123;\n    try &#123;\n      await login(credentials);\n      navigate(&quot;&#x2F;dashboard&quot;, &#123;\n        replace: true,\n        state: &#123; from: &quot;login&quot; &#125;,\n      &#125;);\n    &#125; catch (error) &#123;\n      console.error(&quot;登录失败&quot;);\n    &#125;\n  &#125;;\n\n  return &lt;LoginForm onSubmit&#x3D;&#123;handleLogin&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h3><h4 id=\"权限控制-1\"><a href=\"#权限控制-1\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ProtectedRoute &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const auth &#x3D; useAuth();\n  const navigate &#x3D; useNavigate();\n  const location &#x3D; useLocation();\n\n  if (!auth) &#123;\n    return &lt;Navigate to&#x3D;&quot;&#x2F;login&quot; state&#x3D;&#123;&#123; from: location.pathname &#125;&#125; replace &#x2F;&gt;;\n  &#125;\n\n  return children;\n&#125;;\n\n&#x2F;&#x2F; 使用保护路由\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;login&quot; element&#x3D;&#123;&lt;Login &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route\n        path&#x3D;&quot;&#x2F;dashboard&quot;\n        element&#x3D;&#123;\n          &lt;ProtectedRoute&gt;\n            &lt;Dashboard &#x2F;&gt;\n          &lt;&#x2F;ProtectedRoute&gt;\n        &#125;\n      &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-21\"><a href=\"#最佳实践-21\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"路由配置文件\"><a href=\"#路由配置文件\" class=\"headerlink\" title=\"路由配置文件\"></a>路由配置文件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; routes.js\nconst routes &#x3D; [\n  &#123;\n    path: &quot;&#x2F;&quot;,\n    element: &lt;Layout &#x2F;&gt;,\n    children: [\n      &#123; index: true, element: &lt;Home &#x2F;&gt; &#125;,\n      &#123;\n        path: &quot;dashboard&quot;,\n        element: &lt;Dashboard &#x2F;&gt;,\n        children: [\n          &#123; path: &quot;profile&quot;, element: &lt;Profile &#x2F;&gt; &#125;,\n          &#123; path: &quot;settings&quot;, element: &lt;Settings &#x2F;&gt; &#125;,\n        ],\n      &#125;,\n    ],\n  &#125;,\n];\n\n&#x2F;&#x2F; App.js\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;BrowserRouter&gt;\n      &lt;Routes&gt;&#123;useRoutes(routes)&#125;&lt;&#x2F;Routes&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-27\"><a href=\"#注意事项-27\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>正确使用 index 路由</li>\n<li>合理组织路由结构</li>\n<li>处理 404 页面</li>\n<li>管理路由状态</li>\n<li>优化路由性能</li>\n</ul>\n<p>React Router V6 提供了更简洁和声明式的路由配置方式，使得路由管理变得更加直观和易于维护。</p>\n<h2 id=\"React-RouterV6-怎么设置重定向？\"><a href=\"#React-RouterV6-怎么设置重定向？\" class=\"headerlink\" title=\"React-RouterV6 怎么设置重定向？\"></a>React-RouterV6 怎么设置重定向？</h2><h3 id=\"React-Router-V6-重定向的实现方式\"><a href=\"#React-Router-V6-重定向的实现方式\" class=\"headerlink\" title=\"React Router V6 重定向的实现方式\"></a>React Router V6 重定向的实现方式</h3><h4 id=\"1-使用-Navigate-组件\"><a href=\"#1-使用-Navigate-组件\" class=\"headerlink\" title=\"1. 使用 Navigate 组件\"></a>1. 使用 Navigate 组件</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 基本重定向\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;old-page&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;&#x2F;new-page&quot; &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;new-page&quot; element&#x3D;&#123;&lt;NewPage &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"条件重定向\"><a href=\"#条件重定向\" class=\"headerlink\" title=\"条件重定向\"></a>条件重定向</h3><h4 id=\"根据状态重定向\"><a href=\"#根据状态重定向\" class=\"headerlink\" title=\"根据状态重定向\"></a>根据状态重定向</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const PrivateRoute &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const auth &#x3D; useAuth(); &#x2F;&#x2F; 自定义 hook 检查认证状态\n\n  if (!auth) &#123;\n    &#x2F;&#x2F; 未认证时重定向到登录页\n    return &lt;Navigate to&#x3D;&quot;&#x2F;login&quot; state&#x3D;&#123;&#123; from: location.pathname &#125;&#125; replace &#x2F;&gt;;\n  &#125;\n\n  return children;\n&#125;;\n\n&#x2F;&#x2F; 使用示例\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;login&quot; element&#x3D;&#123;&lt;Login &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route\n        path&#x3D;&quot;&#x2F;dashboard&quot;\n        element&#x3D;&#123;\n          &lt;PrivateRoute&gt;\n            &lt;Dashboard &#x2F;&gt;\n          &lt;&#x2F;PrivateRoute&gt;\n        &#125;\n      &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"编程式重定向\"><a href=\"#编程式重定向\" class=\"headerlink\" title=\"编程式重定向\"></a>编程式重定向</h3><h4 id=\"使用-useNavigate-Hook\"><a href=\"#使用-useNavigate-Hook\" class=\"headerlink\" title=\"使用 useNavigate Hook\"></a>使用 useNavigate Hook</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const LoginPage &#x3D; () &#x3D;&gt; &#123;\n  const navigate &#x3D; useNavigate();\n\n  const handleLogin &#x3D; async (credentials) &#x3D;&gt; &#123;\n    try &#123;\n      await login(credentials);\n      &#x2F;&#x2F; 登录成功后重定向\n      navigate(&quot;&#x2F;dashboard&quot;, &#123; replace: true &#125;);\n    &#125; catch (error) &#123;\n      console.error(&quot;登录失败&quot;);\n    &#125;\n  &#125;;\n\n  return &lt;LoginForm onSubmit&#x3D;&#123;handleLogin&#125; &#x2F;&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"默认路由重定向\"><a href=\"#默认路由重定向\" class=\"headerlink\" title=\"默认路由重定向\"></a>默认路由重定向</h3><h4 id=\"使用-index-属性\"><a href=\"#使用-index-属性\" class=\"headerlink\" title=\"使用 index 属性\"></a>使用 index 属性</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;\n        &#123;&#x2F;* 默认子路由 *&#x2F;&#125;\n        &lt;Route index element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;&#x2F;home&quot; &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;home&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"404-页面重定向\"><a href=\"#404-页面重定向\" class=\"headerlink\" title=\"404 页面重定向\"></a>404 页面重定向</h3><h4 id=\"通配符路由\"><a href=\"#通配符路由\" class=\"headerlink\" title=\"通配符路由\"></a>通配符路由</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n      &#123;&#x2F;* 处理未匹配的路由 *&#x2F;&#125;\n      &lt;Route path&#x3D;&quot;*&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;&#x2F;&quot; replace &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-22\"><a href=\"#最佳实践-22\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组合使用多种重定向方式\"><a href=\"#组合使用多种重定向方式\" class=\"headerlink\" title=\"组合使用多种重定向方式\"></a>组合使用多种重定向方式</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &#123;&#x2F;* 默认重定向 *&#x2F;&#125;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;&#x2F;dashboard&quot; replace &#x2F;&gt;&#125; &#x2F;&gt;\n\n      &#123;&#x2F;* 受保护的路由 *&#x2F;&#125;\n      &lt;Route\n        path&#x3D;&quot;&#x2F;dashboard&#x2F;*&quot;\n        element&#x3D;&#123;\n          &lt;PrivateRoute&gt;\n            &lt;DashboardRoutes &#x2F;&gt;\n          &lt;&#x2F;PrivateRoute&gt;\n        &#125;\n      &#x2F;&gt;\n\n      &#123;&#x2F;* 登录路由 *&#x2F;&#125;\n      &lt;Route path&#x3D;&quot;&#x2F;login&quot; element&#x3D;&#123;&lt;Login &#x2F;&gt;&#125; &#x2F;&gt;\n\n      &#123;&#x2F;* 404 重定向 *&#x2F;&#125;\n      &lt;Route path&#x3D;&quot;*&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;&#x2F;&quot; replace &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-28\"><a href=\"#注意事项-28\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>使用 replace 属性避免浏览历史堆积</li>\n<li>合理传递状态信息</li>\n<li>处理重定向循环</li>\n<li>考虑用户体验</li>\n<li>保持路由结构清晰</li>\n</ul>\n<p>React Router V6 提供了多种灵活的重定向方式，可以根据具体需求选择合适的实现方式。</p>\n<h2 id=\"react-routerV6-里的-Link-标签和-a-标签的区别\"><a href=\"#react-routerV6-里的-Link-标签和-a-标签的区别\" class=\"headerlink\" title=\"react-routerV6 里的 Link 标签和 a 标签的区别\"></a>react-routerV6 里的 Link 标签和 a 标签的区别</h2><h3 id=\"Link-标签和-a-标签的主要区别\"><a href=\"#Link-标签和-a-标签的主要区别\" class=\"headerlink\" title=\"Link 标签和 a 标签的主要区别\"></a>Link 标签和 a 标签的主要区别</h3><h4 id=\"1-路由行为不同\"><a href=\"#1-路由行为不同\" class=\"headerlink\" title=\"1. 路由行为不同\"></a>1. 路由行为不同</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; Link 标签 - 不会触发页面刷新\nconst Navigation &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;nav&gt;\n      &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;Link&gt;\n\n      &#123;&#x2F;* a 标签会触发页面刷新 *&#x2F;&#125;\n      &lt;a href&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;a&gt;\n    &lt;&#x2F;nav&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"2-事件处理机制\"><a href=\"#2-事件处理机制\" class=\"headerlink\" title=\"2. 事件处理机制\"></a>2. 事件处理机制</h3><h4 id=\"Link-的内部实现\"><a href=\"#Link-的内部实现\" class=\"headerlink\" title=\"Link 的内部实现\"></a>Link 的内部实现</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const CustomLink &#x3D; (&#123; to, children &#125;) &#x3D;&gt; &#123;\n  const navigate &#x3D; useNavigate();\n\n  const handleClick &#x3D; (e) &#x3D;&gt; &#123;\n    e.preventDefault(); &#x2F;&#x2F; 阻止默认行为\n    navigate(to); &#x2F;&#x2F; 使用 history API 进行导航\n  &#125;;\n\n  return (\n    &lt;a href&#x3D;&#123;to&#125; onClick&#x3D;&#123;handleClick&#125;&gt;\n      &#123;children&#125;\n    &lt;&#x2F;a&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"3-状态保持\"><a href=\"#3-状态保持\" class=\"headerlink\" title=\"3. 状态保持\"></a>3. 状态保持</h3><h4 id=\"Link-保持应用状态\"><a href=\"#Link-保持应用状态\" class=\"headerlink\" title=\"Link 保持应用状态\"></a>Link 保持应用状态</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;计数: &#123;count&#125;&lt;&#x2F;h1&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount((c) &#x3D;&gt; c + 1)&#125;&gt;增加&lt;&#x2F;button&gt;\n\n      &#123;&#x2F;* Link 跳转不会丢失状态 *&#x2F;&#125;\n      &lt;Link to&#x3D;&quot;&#x2F;other&quot;&gt;其他页面&lt;&#x2F;Link&gt;\n\n      &#123;&#x2F;* a 标签跳转会丢失状态 *&#x2F;&#125;\n      &lt;a href&#x3D;&quot;&#x2F;other&quot;&gt;其他页面&lt;&#x2F;a&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"4-路由参数传递\"><a href=\"#4-路由参数传递\" class=\"headerlink\" title=\"4. 路由参数传递\"></a>4. 路由参数传递</h3><h4 id=\"Link-的高级用法\"><a href=\"#Link-的高级用法\" class=\"headerlink\" title=\"Link 的高级用法\"></a>Link 的高级用法</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Navigation &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;nav&gt;\n      &#123;&#x2F;* Link 可以传递状态 *&#x2F;&#125;\n      &lt;Link to&#x3D;&quot;&#x2F;user&#x2F;123&quot; state&#x3D;&#123;&#123; from: &quot;navigation&quot; &#125;&#125;&gt;\n        用户详情\n      &lt;&#x2F;Link&gt;\n\n      &#123;&#x2F;* a 标签需要通过 URL 参数传递数据 *&#x2F;&#125;\n      &lt;a href&#x3D;&quot;&#x2F;user&#x2F;123?from&#x3D;navigation&quot;&gt;用户详情&lt;&#x2F;a&gt;\n    &lt;&#x2F;nav&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"5-路由匹配和激活状态\"><a href=\"#5-路由匹配和激活状态\" class=\"headerlink\" title=\"5. 路由匹配和激活状态\"></a>5. 路由匹配和激活状态</h3><h4 id=\"NavLink-的使用\"><a href=\"#NavLink-的使用\" class=\"headerlink\" title=\"NavLink 的使用\"></a>NavLink 的使用</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const Navigation &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;nav&gt;\n      &lt;NavLink to&#x3D;&quot;&#x2F;&quot; className&#x3D;&#123;(&#123; isActive &#125;) &#x3D;&gt; (isActive ? &quot;active&quot; : &quot;&quot;)&#125;&gt;\n        首页\n      &lt;&#x2F;NavLink&gt;\n\n      &#123;&#x2F;* a 标签需要手动处理激活状态 *&#x2F;&#125;\n      &lt;a href&#x3D;&quot;&#x2F;&quot; className&#x3D;&#123;window.location.pathname &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ? &quot;active&quot; : &quot;&quot;&#125;&gt;\n        首页\n      &lt;&#x2F;a&gt;\n    &lt;&#x2F;nav&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-23\"><a href=\"#最佳实践-23\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组合使用-1\"><a href=\"#组合使用-1\" class=\"headerlink\" title=\"组合使用\"></a>组合使用</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;nav&gt;\n      &#123;&#x2F;* 内部导航使用 Link *&#x2F;&#125;\n      &lt;Link to&#x3D;&quot;&#x2F;dashboard&quot;&gt;控制台&lt;&#x2F;Link&gt;\n\n      &#123;&#x2F;* 外部链接使用 a 标签 *&#x2F;&#125;\n      &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener noreferrer&quot;&gt;\n        外部链接\n      &lt;&#x2F;a&gt;\n    &lt;&#x2F;nav&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-29\"><a href=\"#注意事项-29\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>Link 仅用于应用内部导航</li>\n<li>外部链接使用 a 标签</li>\n<li>正确处理路由状态</li>\n<li>合理使用 NavLink</li>\n<li>注意性能影响</li>\n</ul>\n<p>Link 组件是 React Router 提供的声明式导航方式，相比 a 标签具有更好的路由控制和状态管理能力。</p>\n<h2 id=\"React-RouterV6-如何获取-URL-的参数和历史对象？\"><a href=\"#React-RouterV6-如何获取-URL-的参数和历史对象？\" class=\"headerlink\" title=\"React-RouterV6 如何获取 URL 的参数和历史对象？\"></a>React-RouterV6 如何获取 URL 的参数和历史对象？</h2><h3 id=\"React-Router-V6-获取-URL-参数和历史对象\"><a href=\"#React-Router-V6-获取-URL-参数和历史对象\" class=\"headerlink\" title=\"React Router V6 获取 URL 参数和历史对象\"></a>React Router V6 获取 URL 参数和历史对象</h3><h4 id=\"1-使用-useParams-获取-URL-参数\"><a href=\"#1-使用-useParams-获取-URL-参数\" class=\"headerlink\" title=\"1. 使用 useParams 获取 URL 参数\"></a>1. 使用 useParams 获取 URL 参数</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 路由配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;users&#x2F;:id&quot; element&#x3D;&#123;&lt;UserDetail &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 获取参数\nconst UserDetail &#x3D; () &#x3D;&gt; &#123;\n  const &#123; id &#125; &#x3D; useParams();\n  return &lt;div&gt;用户ID: &#123;id&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"2-使用-useSearchParams-获取查询参数\"><a href=\"#2-使用-useSearchParams-获取查询参数\" class=\"headerlink\" title=\"2. 使用 useSearchParams 获取查询参数\"></a>2. 使用 useSearchParams 获取查询参数</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const SearchPage &#x3D; () &#x3D;&gt; &#123;\n  const [searchParams, setSearchParams] &#x3D; useSearchParams();\n\n  &#x2F;&#x2F; 获取查询参数\n  const query &#x3D; searchParams.get(&quot;q&quot;);\n  const page &#x3D; searchParams.get(&quot;page&quot;);\n\n  &#x2F;&#x2F; 更新查询参数\n  const handleSearch &#x3D; (newQuery) &#x3D;&gt; &#123;\n    setSearchParams(&#123; q: newQuery, page: &quot;1&quot; &#125;);\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;input\n        value&#x3D;&#123;query || &quot;&quot;&#125;\n        onChange&#x3D;&#123;(e) &#x3D;&gt; handleSearch(e.target.value)&#125;\n      &#x2F;&gt;\n      &lt;p&gt;当前页: &#123;page&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"3-使用-useLocation-获取当前位置\"><a href=\"#3-使用-useLocation-获取当前位置\" class=\"headerlink\" title=\"3. 使用 useLocation 获取当前位置\"></a>3. 使用 useLocation 获取当前位置</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const PageComponent &#x3D; () &#x3D;&gt; &#123;\n  const location &#x3D; useLocation();\n\n  console.log(&#123;\n    pathname: location.pathname,\n    search: location.search,\n    hash: location.hash,\n    state: location.state,\n  &#125;);\n\n  return &lt;div&gt;当前路径: &#123;location.pathname&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"4-使用-useNavigate-进行导航\"><a href=\"#4-使用-useNavigate-进行导航\" class=\"headerlink\" title=\"4. 使用 useNavigate 进行导航\"></a>4. 使用 useNavigate 进行导航</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const NavigationComponent &#x3D; () &#x3D;&gt; &#123;\n  const navigate &#x3D; useNavigate();\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 导航到新页面\n    navigate(&quot;&#x2F;new-page&quot;);\n\n    &#x2F;&#x2F; 带参数导航\n    navigate(&quot;&#x2F;user&#x2F;123?tab&#x3D;profile&quot;);\n\n    &#x2F;&#x2F; 带状态导航\n    navigate(&quot;&#x2F;dashboard&quot;, &#123;\n      state: &#123; from: &quot;navigation&quot; &#125;,\n      replace: true,\n    &#125;);\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;导航&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-24\"><a href=\"#最佳实践-24\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组合使用多个-hooks\"><a href=\"#组合使用多个-hooks\" class=\"headerlink\" title=\"组合使用多个 hooks\"></a>组合使用多个 hooks</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const UserProfile &#x3D; () &#x3D;&gt; &#123;\n  const &#123; id &#125; &#x3D; useParams();\n  const [searchParams] &#x3D; useSearchParams();\n  const location &#x3D; useLocation();\n  const navigate &#x3D; useNavigate();\n\n  const tab &#x3D; searchParams.get(&quot;tab&quot;);\n  const &#123; state &#125; &#x3D; location;\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 可以访问所有路由相关信息\n    console.log(&#123;\n      userId: id,\n      activeTab: tab,\n      navigationState: state,\n    &#125;);\n  &#125;, [id, tab, state]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;用户资料&lt;&#x2F;h1&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; navigate(-1)&#125;&gt;返回&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"处理嵌套路由参数\"><a href=\"#处理嵌套路由参数\" class=\"headerlink\" title=\"处理嵌套路由参数\"></a>处理嵌套路由参数</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const NestedRoute &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 获取所有匹配的路由参数\n  const params &#x3D; useParams();\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;参数列表:&lt;&#x2F;h2&gt;\n      &lt;pre&gt;&#123;JSON.stringify(params, null, 2)&#125;&lt;&#x2F;pre&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 路由配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;users&#x2F;:userId&quot; element&#x3D;&#123;&lt;UserLayout &#x2F;&gt;&#125;&gt;\n        &lt;Route path&#x3D;&quot;posts&#x2F;:postId&quot; element&#x3D;&#123;&lt;NestedRoute &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-30\"><a href=\"#注意事项-30\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>正确处理参数类型转换</li>\n<li>处理参数不存在的情况</li>\n<li>注意 URL 编码解码</li>\n<li>合理使用路由状态</li>\n<li>处理历史记录堆栈</li>\n</ul>\n<p>React Router V6 提供了丰富的 hooks API 来访问和操作路由相关的信息，使得路由处理变得更加简单和直观。</p>\n<h2 id=\"React-RouterV6-怎样在路由变化时重新渲染同一个组件？\"><a href=\"#React-RouterV6-怎样在路由变化时重新渲染同一个组件？\" class=\"headerlink\" title=\"React-RouterV6 怎样在路由变化时重新渲染同一个组件？\"></a>React-RouterV6 怎样在路由变化时重新渲染同一个组件？</h2><h3 id=\"React-Router-V6-获取-URL-参数和历史对象-1\"><a href=\"#React-Router-V6-获取-URL-参数和历史对象-1\" class=\"headerlink\" title=\"React Router V6 获取 URL 参数和历史对象\"></a>React Router V6 获取 URL 参数和历史对象</h3><h4 id=\"1-使用-useParams-获取-URL-参数-1\"><a href=\"#1-使用-useParams-获取-URL-参数-1\" class=\"headerlink\" title=\"1. 使用 useParams 获取 URL 参数\"></a>1. 使用 useParams 获取 URL 参数</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 路由配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;users&#x2F;:id&quot; element&#x3D;&#123;&lt;UserDetail &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 获取参数\nconst UserDetail &#x3D; () &#x3D;&gt; &#123;\n  const &#123; id &#125; &#x3D; useParams();\n  return &lt;div&gt;用户ID: &#123;id&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"2-使用-useSearchParams-获取查询参数-1\"><a href=\"#2-使用-useSearchParams-获取查询参数-1\" class=\"headerlink\" title=\"2. 使用 useSearchParams 获取查询参数\"></a>2. 使用 useSearchParams 获取查询参数</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const SearchPage &#x3D; () &#x3D;&gt; &#123;\n  const [searchParams, setSearchParams] &#x3D; useSearchParams();\n\n  &#x2F;&#x2F; 获取查询参数\n  const query &#x3D; searchParams.get(&quot;q&quot;);\n  const page &#x3D; searchParams.get(&quot;page&quot;);\n\n  &#x2F;&#x2F; 更新查询参数\n  const handleSearch &#x3D; (newQuery) &#x3D;&gt; &#123;\n    setSearchParams(&#123; q: newQuery, page: &quot;1&quot; &#125;);\n  &#125;;\n\n  return (\n    &lt;div&gt;\n      &lt;input\n        value&#x3D;&#123;query || &quot;&quot;&#125;\n        onChange&#x3D;&#123;(e) &#x3D;&gt; handleSearch(e.target.value)&#125;\n      &#x2F;&gt;\n      &lt;p&gt;当前页: &#123;page&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"3-使用-useLocation-获取当前位置-1\"><a href=\"#3-使用-useLocation-获取当前位置-1\" class=\"headerlink\" title=\"3. 使用 useLocation 获取当前位置\"></a>3. 使用 useLocation 获取当前位置</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const PageComponent &#x3D; () &#x3D;&gt; &#123;\n  const location &#x3D; useLocation();\n\n  console.log(&#123;\n    pathname: location.pathname,\n    search: location.search,\n    hash: location.hash,\n    state: location.state,\n  &#125;);\n\n  return &lt;div&gt;当前路径: &#123;location.pathname&#125;&lt;&#x2F;div&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"4-使用-useNavigate-进行导航-1\"><a href=\"#4-使用-useNavigate-进行导航-1\" class=\"headerlink\" title=\"4. 使用 useNavigate 进行导航\"></a>4. 使用 useNavigate 进行导航</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const NavigationComponent &#x3D; () &#x3D;&gt; &#123;\n  const navigate &#x3D; useNavigate();\n\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 导航到新页面\n    navigate(&quot;&#x2F;new-page&quot;);\n\n    &#x2F;&#x2F; 带参数导航\n    navigate(&quot;&#x2F;user&#x2F;123?tab&#x3D;profile&quot;);\n\n    &#x2F;&#x2F; 带状态导航\n    navigate(&quot;&#x2F;dashboard&quot;, &#123;\n      state: &#123; from: &quot;navigation&quot; &#125;,\n      replace: true,\n    &#125;);\n  &#125;;\n\n  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;导航&lt;&#x2F;button&gt;;\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-25\"><a href=\"#最佳实践-25\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"组合使用多个-hooks-1\"><a href=\"#组合使用多个-hooks-1\" class=\"headerlink\" title=\"组合使用多个 hooks\"></a>组合使用多个 hooks</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const UserProfile &#x3D; () &#x3D;&gt; &#123;\n  const &#123; id &#125; &#x3D; useParams();\n  const [searchParams] &#x3D; useSearchParams();\n  const location &#x3D; useLocation();\n  const navigate &#x3D; useNavigate();\n\n  const tab &#x3D; searchParams.get(&quot;tab&quot;);\n  const &#123; state &#125; &#x3D; location;\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 可以访问所有路由相关信息\n    console.log(&#123;\n      userId: id,\n      activeTab: tab,\n      navigationState: state,\n    &#125;);\n  &#125;, [id, tab, state]);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;用户资料&lt;&#x2F;h1&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; navigate(-1)&#125;&gt;返回&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"处理嵌套路由参数-1\"><a href=\"#处理嵌套路由参数-1\" class=\"headerlink\" title=\"处理嵌套路由参数\"></a>处理嵌套路由参数</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const NestedRoute &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 获取所有匹配的路由参数\n  const params &#x3D; useParams();\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;参数列表:&lt;&#x2F;h2&gt;\n      &lt;pre&gt;&#123;JSON.stringify(params, null, 2)&#125;&lt;&#x2F;pre&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 路由配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;users&#x2F;:userId&quot; element&#x3D;&#123;&lt;UserLayout &#x2F;&gt;&#125;&gt;\n        &lt;Route path&#x3D;&quot;posts&#x2F;:postId&quot; element&#x3D;&#123;&lt;NestedRoute &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-31\"><a href=\"#注意事项-31\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>正确处理参数类型转换</li>\n<li>处理参数不存在的情况</li>\n<li>注意 URL 编码解码</li>\n<li>合理使用路由状态</li>\n<li>处理历史记录堆栈</li>\n</ul>\n<p>React Router V6 提供了丰富的 hooks API 来访问和操作路由相关的信息，使得路由处理变得更加简单和直观。</p>\n<h2 id=\"React-RouterV6-的路由有几种模式？\"><a href=\"#React-RouterV6-的路由有几种模式？\" class=\"headerlink\" title=\"React-RouterV6 的路由有几种模式？\"></a>React-RouterV6 的路由有几种模式？</h2><h3 id=\"React-Router-V6-的路由模式\"><a href=\"#React-Router-V6-的路由模式\" class=\"headerlink\" title=\"React Router V6 的路由模式\"></a>React Router V6 的路由模式</h3><h4 id=\"1-BrowserRouter（History-模式）\"><a href=\"#1-BrowserRouter（History-模式）\" class=\"headerlink\" title=\"1. BrowserRouter（History 模式）\"></a>1. BrowserRouter（History 模式）</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 基于 HTML5 History API\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;BrowserRouter&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 生成的 URL 形式：\n&#x2F;&#x2F; https:&#x2F;&#x2F;example.com&#x2F;about</code></pre>\n\n<h3 id=\"2-HashRouter（Hash-模式）\"><a href=\"#2-HashRouter（Hash-模式）\" class=\"headerlink\" title=\"2. HashRouter（Hash 模式）\"></a>2. HashRouter（Hash 模式）</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 基于 URL hash\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;HashRouter&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;HashRouter&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 生成的 URL 形式：\n&#x2F;&#x2F; https:&#x2F;&#x2F;example.com&#x2F;#&#x2F;about</code></pre>\n\n<h3 id=\"3-MemoryRouter（内存模式）\"><a href=\"#3-MemoryRouter（内存模式）\" class=\"headerlink\" title=\"3. MemoryRouter（内存模式）\"></a>3. MemoryRouter（内存模式）</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 将历史记录保存在内存中\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;MemoryRouter&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;MemoryRouter&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"各模式特点比较\"><a href=\"#各模式特点比较\" class=\"headerlink\" title=\"各模式特点比较\"></a>各模式特点比较</h3><h4 id=\"BrowserRouter\"><a href=\"#BrowserRouter\" class=\"headerlink\" title=\"BrowserRouter\"></a>BrowserRouter</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 需要服务器配置支持\nconst server &#x3D; express();\n\n&#x2F;&#x2F; 服务器需要处理所有路由\nserver.get(&quot;*&quot;, (req, res) &#x3D;&gt; &#123;\n  res.sendFile(path.resolve(__dirname, &quot;index.html&quot;));\n&#125;);\n\n&#x2F;&#x2F; 客户端配置\nconst App &#x3D; () &#x3D;&gt; (\n  &lt;BrowserRouter&gt;\n    &lt;Nav &#x2F;&gt;\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;*&quot; element&#x3D;&#123;&lt;MainContent &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  &lt;&#x2F;BrowserRouter&gt;\n);</code></pre>\n\n<h4 id=\"HashRouter\"><a href=\"#HashRouter\" class=\"headerlink\" title=\"HashRouter\"></a>HashRouter</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 不需要服务器配置，但 URL 不够美观\nconst App &#x3D; () &#x3D;&gt; (\n  &lt;HashRouter&gt;\n    &lt;Nav &#x2F;&gt;\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;*&quot; element&#x3D;&#123;&lt;MainContent &#x2F;&gt;&#125; &#x2F;&gt;\n    &lt;&#x2F;Routes&gt;\n  &lt;&#x2F;HashRouter&gt;\n);</code></pre>\n\n<h3 id=\"最佳实践-26\"><a href=\"#最佳实践-26\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"选择合适的路由模式\"><a href=\"#选择合适的路由模式\" class=\"headerlink\" title=\"选择合适的路由模式\"></a>选择合适的路由模式</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 生产环境推荐使用 BrowserRouter\nconst Router &#x3D;\n  process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;production&quot; ? BrowserRouter : HashRouter;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;\n          &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;*&quot; element&#x3D;&#123;&lt;NotFound &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;&#x2F;Route&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;Router&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-32\"><a href=\"#注意事项-32\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>BrowserRouter 需要服务器配置支持</li>\n<li>HashRouter 兼容性更好但不够美观</li>\n<li>MemoryRouter 主要用于测试环境</li>\n<li>考虑 SEO 需求选择路由模式</li>\n<li>注意浏览器兼容性问题</li>\n</ul>\n<p>选择合适的路由模式对于应用的可访问性和用户体验都很重要。</p>\n<h2 id=\"React-RouterV6-如何实现动态路由？\"><a href=\"#React-RouterV6-如何实现动态路由？\" class=\"headerlink\" title=\"React-RouterV6 如何实现动态路由？\"></a>React-RouterV6 如何实现动态路由？</h2><h3 id=\"React-Router-V6-动态路由实现\"><a href=\"#React-Router-V6-动态路由实现\" class=\"headerlink\" title=\"React Router V6 动态路由实现\"></a>React Router V6 动态路由实现</h3><h4 id=\"1-基本动态路由配置\"><a href=\"#1-基本动态路由配置\" class=\"headerlink\" title=\"1. 基本动态路由配置\"></a>1. 基本动态路由配置</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 基础动态路由\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;\n        &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;users&#x2F;:id&quot; element&#x3D;&#123;&lt;UserProfile &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;posts&#x2F;:postId&#x2F;*&quot; element&#x3D;&#123;&lt;PostDetails &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"2-嵌套动态路由\"><a href=\"#2-嵌套动态路由\" class=\"headerlink\" title=\"2. 嵌套动态路由\"></a>2. 嵌套动态路由</h3><h4 id=\"使用-Outlet-1\"><a href=\"#使用-Outlet-1\" class=\"headerlink\" title=\"使用 Outlet\"></a>使用 Outlet</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 父级路由组件\nconst UserLayout &#x3D; () &#x3D;&gt; &#123;\n  const &#123; id &#125; &#x3D; useParams();\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;用户 &#123;id&#125; 的空间&lt;&#x2F;h1&gt;\n      &lt;nav&gt;\n        &lt;Link to&#x3D;&quot;profile&quot;&gt;个人资料&lt;&#x2F;Link&gt;\n        &lt;Link to&#x3D;&quot;posts&quot;&gt;文章列表&lt;&#x2F;Link&gt;\n      &lt;&#x2F;nav&gt;\n      &lt;Outlet &#x2F;&gt; &#123;&#x2F;* 渲染子路由 *&#x2F;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\n&#x2F;&#x2F; 路由配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;users&#x2F;:id&quot; element&#x3D;&#123;&lt;UserLayout &#x2F;&gt;&#125;&gt;\n        &lt;Route path&#x3D;&quot;profile&quot; element&#x3D;&#123;&lt;Profile &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;posts&quot; element&#x3D;&#123;&lt;Posts &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"3-动态生成路由\"><a href=\"#3-动态生成路由\" class=\"headerlink\" title=\"3. 动态生成路由\"></a>3. 动态生成路由</h3><h4 id=\"基于数据生成路由\"><a href=\"#基于数据生成路由\" class=\"headerlink\" title=\"基于数据生成路由\"></a>基于数据生成路由</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const routes &#x3D; [\n  &#123;\n    path: &quot;&#x2F;&quot;,\n    element: &lt;Layout &#x2F;&gt;,\n    children: [\n      &#123; index: true, element: &lt;Home &#x2F;&gt; &#125;,\n      &#123;\n        path: &quot;products&#x2F;:category&quot;,\n        element: &lt;ProductList &#x2F;&gt;,\n        children: [&#123; path: &quot;:id&quot;, element: &lt;ProductDetail &#x2F;&gt; &#125;],\n      &#125;,\n    ],\n  &#125;,\n];\n\n&#x2F;&#x2F; 使用 useRoutes hook\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const element &#x3D; useRoutes(routes);\n  return element;\n&#125;;</code></pre>\n\n<h3 id=\"4-条件路由\"><a href=\"#4-条件路由\" class=\"headerlink\" title=\"4. 条件路由\"></a>4. 条件路由</h3><h4 id=\"基于权限的动态路由\"><a href=\"#基于权限的动态路由\" class=\"headerlink\" title=\"基于权限的动态路由\"></a>基于权限的动态路由</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ProtectedRoute &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const auth &#x3D; useAuth();\n  const location &#x3D; useLocation();\n\n  if (!auth.user) &#123;\n    return &lt;Navigate to&#x3D;&quot;&#x2F;login&quot; state&#x3D;&#123;&#123; from: location &#125;&#125; replace &#x2F;&gt;;\n  &#125;\n\n  return children;\n&#125;;\n\n&#x2F;&#x2F; 动态路由配置\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const &#123; user &#125; &#x3D; useAuth();\n\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;\n        &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &#123;user &amp;&amp; (\n          &lt;Route\n            path&#x3D;&quot;dashboard&quot;\n            element&#x3D;&#123;\n              &lt;ProtectedRoute&gt;\n                &lt;Dashboard &#x2F;&gt;\n              &lt;&#x2F;ProtectedRoute&gt;\n            &#125;\n          &#x2F;&gt;\n        )&#125;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"5-动态加载组件\"><a href=\"#5-动态加载组件\" class=\"headerlink\" title=\"5. 动态加载组件\"></a>5. 动态加载组件</h3><h4 id=\"使用-React-lazy\"><a href=\"#使用-React-lazy\" class=\"headerlink\" title=\"使用 React.lazy\"></a>使用 React.lazy</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const ProductDetail &#x3D; React.lazy(() &#x3D;&gt; import(&quot;.&#x2F;pages&#x2F;ProductDetail&quot;));\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;Routes&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;\n        &lt;Route\n          path&#x3D;&quot;products&#x2F;:id&quot;\n          element&#x3D;&#123;\n            &lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n              &lt;ProductDetail &#x2F;&gt;\n            &lt;&#x2F;Suspense&gt;\n          &#125;\n        &#x2F;&gt;\n      &lt;&#x2F;Route&gt;\n    &lt;&#x2F;Routes&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"最佳实践-27\"><a href=\"#最佳实践-27\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><h4 id=\"路由配置管理\"><a href=\"#路由配置管理\" class=\"headerlink\" title=\"路由配置管理\"></a>路由配置管理</h4><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; routes.js\nconst generateRoutes &#x3D; (permissions) &#x3D;&gt; &#123;\n  return [\n    &#123;\n      path: &quot;&#x2F;&quot;,\n      element: &lt;Layout &#x2F;&gt;,\n      children: [\n        &#123;\n          path: &quot;admin&quot;,\n          element: permissions.includes(&quot;admin&quot;) ? (\n            &lt;AdminDashboard &#x2F;&gt;\n          ) : (\n            &lt;Navigate to&#x3D;&quot;&#x2F;unauthorized&quot; &#x2F;&gt;\n          ),\n        &#125;,\n      ],\n    &#125;,\n  ];\n&#125;;\n\n&#x2F;&#x2F; App.js\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const permissions &#x3D; usePermissions();\n  const routes &#x3D; generateRoutes(permissions);\n\n  return useRoutes(routes);\n&#125;;</code></pre>\n\n<h3 id=\"注意事项-33\"><a href=\"#注意事项-33\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>合理组织路由结构</li>\n<li>处理动态路由参数</li>\n<li>注意权限控制</li>\n<li>优化加载性能</li>\n<li>处理 404 情况</li>\n</ul>\n<p>动态路由可以让应用更灵活，但需要合理管理路由配置和状态。</p>\n<h2 id=\"React-RouterV6-路由懒加载有哪些方式？\"><a href=\"#React-RouterV6-路由懒加载有哪些方式？\" class=\"headerlink\" title=\"React-RouterV6 路由懒加载有哪些方式？\"></a>React-RouterV6 路由懒加载有哪些方式？</h2><h3 id=\"React-RouterV6-路由懒加载有哪些方式？-1\"><a href=\"#React-RouterV6-路由懒加载有哪些方式？-1\" class=\"headerlink\" title=\"React-RouterV6 路由懒加载有哪些方式？\"></a>React-RouterV6 路由懒加载有哪些方式？</h3><h4 id=\"使用-React-lazy-和-Suspense-1\"><a href=\"#使用-React-lazy-和-Suspense-1\" class=\"headerlink\" title=\"使用 React.lazy 和 Suspense\"></a>使用 <code>React.lazy</code> 和 <code>Suspense</code></h4><p>React 提供了 <code>React.lazy</code> 函数来动态导入组件，结合 <code>Suspense</code> 可以实现路由懒加载。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React, &#123; Suspense, lazy &#125; from &quot;react&quot;;\nimport &#123; BrowserRouter as Router, Routes, Route &#125; from &quot;react-router-dom&quot;;\n\nconst HomePage &#x3D; lazy(() &#x3D;&gt; import(&quot;.&#x2F;HomePage&quot;));\nconst AboutPage &#x3D; lazy(() &#x3D;&gt; import(&quot;.&#x2F;AboutPage&quot;));\n\nfunction App() &#123;\n  return (\n    &lt;Router&gt;\n      &lt;Suspense fallback&#x3D;&#123;&lt;div&gt;加载中...&lt;&#x2F;div&gt;&#125;&gt;\n        &lt;Routes&gt;\n          &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;HomePage &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;AboutPage &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;&#x2F;Routes&gt;\n      &lt;&#x2F;Suspense&gt;\n    &lt;&#x2F;Router&gt;\n  );\n&#125;</code></pre>\n\n<h4 id=\"使用-loadable-库\"><a href=\"#使用-loadable-库\" class=\"headerlink\" title=\"使用 loadable 库\"></a>使用 <code>loadable</code> 库</h4><p><code>loadable</code> 是一个第三方库，也可以用来实现组件的懒加载。它提供了更多的配置选项，比如加载失败时的降级方案。</p>\n<p>首先需要安装 <code>@loadable/component</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @loadable&#x2F;component</code></pre>\n\n<p>然后在你的路由配置中使用它：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React from &quot;react&quot;;\nimport &#123; BrowserRouter as Router, Routes, Route &#125; from &quot;react-router-dom&quot;;\nimport Loadable from &quot;@loadable&#x2F;component&quot;;\n\nconst HomePage &#x3D; Loadable(() &#x3D;&gt; import(&quot;.&#x2F;HomePage&quot;));\nconst AboutPage &#x3D; Loadable(() &#x3D;&gt; import(&quot;.&#x2F;AboutPage&quot;));\n\nfunction App() &#123;\n  return (\n    &lt;Router&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;HomePage &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;AboutPage &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;Router&gt;\n  );\n&#125;</code></pre>\n\n<h2 id=\"React-RouterV6-如何实现权限控制？\"><a href=\"#React-RouterV6-如何实现权限控制？\" class=\"headerlink\" title=\"React-RouterV6 如何实现权限控制？\"></a>React-RouterV6 如何实现权限控制？</h2><h4 id=\"创建-Route-组件\"><a href=\"#创建-Route-组件\" class=\"headerlink\" title=\"创建 Route 组件\"></a>创建 Route 组件</h4><p>在应用程序的根组件中创建一个<code>Routes</code>组件，并添加子组件。子组件是<code>Route</code>组件，用于定义应用程序中的路由。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123; Routes, Route, Navigate &#125; from &quot;react-router-dom&quot;;\nfunction App() &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;dashboard&quot; element&#x3D;&#123;&lt;Dashboard &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;logout&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;</code></pre>\n\n<h4 id=\"添加路由拦截\"><a href=\"#添加路由拦截\" class=\"headerlink\" title=\"添加路由拦截\"></a>添加路由拦截</h4><p>为了实现路由拦截，我们需要创建一个函数来检查用户是否已登录，并根据检查结果决定是否允许访问受保护的页面。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123; useNavigate &#125; from &quot;react-router-dom&quot;;\nfunction ProtectedRoute(&#123; children &#125;) &#123;\n  const navigate &#x3D; useNavigate();\n  const isAuthenticated &#x3D; checkAuthentication();\n  if (!isAuthenticated) &#123;\n    navigate(&quot;&#x2F;login&quot;);\n    return null;\n  &#125;\n  return children;\n&#125;\nfunction checkAuthentication() &#123;\n  &#x2F;&#x2F; 这里可以添加你的认证逻辑，例如检查localStorage或sessionStorage中的token\n  return localStorage.getItem(&quot;userToken&quot;) ? true : false;\n&#125;</code></pre>\n\n<p>然后，我们将<code>ProtectedRoute</code>组件包裹在需要保护的<code>Route</code>组件中：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">function App() &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;login&quot; element&#x3D;&#123;&lt;Login &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route\n          path&#x3D;&quot;&#x2F;dashboard&quot;\n          element&#x3D;&#123;\n            &lt;ProtectedRoute&gt;\n              &lt;Dashboard &#x2F;&gt;\n            &lt;&#x2F;ProtectedRoute&gt;\n          &#125;\n        &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;logout&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;</code></pre>\n\n<h4 id=\"权限控制-2\"><a href=\"#权限控制-2\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h4><p>除了基本的路由拦截，我们还可以实现更细粒度的权限控制。例如，某些页面可能只有特定角色的用户才能访问。</p>\n<p>首先，定义一个权限检查函数：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">function checkPermissions(userRole, requiredRole) &#123;\n  return userRole &#x3D;&#x3D;&#x3D; requiredRole;\n&#125;</code></pre>\n\n<p>然后，在<code>ProtectedRoute</code>组件中添加权限检查逻辑：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">function ProtectedRoute(&#123; children, requiredRole &#125;) &#123;\n  const navigate &#x3D; useNavigate();\n  const isAuthenticated &#x3D; checkAuthentication();\n  const userRole &#x3D; getUserRole();\n  if (!isAuthenticated) &#123;\n    navigate(&quot;&#x2F;login&quot;);\n    return null;\n  &#125;\n  if (!checkPermissions(userRole, requiredRole)) &#123;\n    navigate(&quot;&#x2F;unauthorized&quot;);\n    return null;\n  &#125;\n  return children;\n&#125;\nfunction getUserRole() &#123;\n  &#x2F;&#x2F; 这里可以添加你的角色获取逻辑，例如从localStorage或sessionStorage中获取\n  return localStorage.getItem(&quot;userRole&quot;);\n&#125;</code></pre>\n\n<p>使用<code>ProtectedRoute</code>时，传递<code>requiredRole</code>属性：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">function App() &#123;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;Routes&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;login&quot; element&#x3D;&#123;&lt;Login &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route\n          path&#x3D;&quot;&#x2F;dashboard&quot;\n          element&#x3D;&#123;\n            &lt;ProtectedRoute requiredRole&#x3D;&quot;admin&quot;&gt;\n              &lt;Dashboard &#x2F;&gt;\n            &lt;&#x2F;ProtectedRoute&gt;\n          &#125;\n        &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;logout&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;&#x2F;&quot; &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;Route path&#x3D;&quot;&#x2F;unauthorized&quot; element&#x3D;&#123;&lt;Unauthorized &#x2F;&gt;&#125; &#x2F;&gt;\n      &lt;&#x2F;Routes&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;</code></pre>\n\n<h2 id=\"React-RouterV7-新特性有哪些？\"><a href=\"#React-RouterV7-新特性有哪些？\" class=\"headerlink\" title=\"React-RouterV7 新特性有哪些？\"></a>React-RouterV7 新特性有哪些？</h2><h3 id=\"React-Router-V7-新特性\"><a href=\"#React-Router-V7-新特性\" class=\"headerlink\" title=\"React-Router V7 新特性\"></a>React-Router V7 新特性</h3><p>React Router V7 引入了许多新特性和改进，进一步提升了开发者的体验和应用性能。以下是一些主要的新特性：</p>\n<h4 id=\"Remix-集成\"><a href=\"#Remix-集成\" class=\"headerlink\" title=\"Remix 集成\"></a>Remix 集成</h4><p>React Router V7 将 Remix 框架的许多特性整合到自身中，使得开发者可以直接使用 Remix 的功能。这标志着 React Router 从一个路由库进化为一个现代化的全栈框架。</p>\n<ul>\n<li><strong>服务端渲染（SSR）和静态站点生成（SSG）</strong>：支持在服务器端生成完整的 HTML 页面，提升应用的性能和用户体验。</li>\n<li><strong>跨环境运行</strong>：支持在 Web 浏览器、Cloudflare Workers、Serverless 或 Node.js 等多种环境中运行。</li>\n<li><strong>嵌套路由</strong>：支持文件即路由、动态路由、嵌套路由、资源路由等，使得路由管理更加灵活。</li>\n<li><strong>预加载和并行数据获取</strong>：支持预加载页面资源，数据在服务端并行获取，生成完整的 HTML 文档。</li>\n<li><strong>自动代码拆分</strong>：提高应用程序的性能，只加载当前页面所需的代码。</li>\n<li><strong>静态导出和部署</strong>：支持静态导出，可以将应用程序导出为静态 HTML 文件，并部署到各种静态主机。</li>\n</ul>\n<h4 id=\"基于-Vite-的编译器\"><a href=\"#基于-Vite-的编译器\" class=\"headerlink\" title=\"基于 Vite 的编译器\"></a>基于 Vite 的编译器</h4><p>React Router V7 引入了基于 Vite 的编译器，这一编译器具有极高的编译速度和优化的代码分割能力。通过集成 Vite，React Router V7 能够在进行开发构建时快速响应文件更改，并在最终生产打包时优化文件大小。</p>\n<h4 id=\"大幅改进的类型安全\"><a href=\"#大幅改进的类型安全\" class=\"headerlink\" title=\"大幅改进的类型安全\"></a>大幅改进的类型安全</h4><p>React Router V7 大幅改进了类型安全性，使用 TypeScript 的开发者可以显著受益。类型安全是指在编译时检查结果集中是否存在任何类型错误，从而提高代码的可靠性和可维护性。</p>\n<h4 id=\"支持-HMR-的开发环境\"><a href=\"#支持-HMR-的开发环境\" class=\"headerlink\" title=\"支持 HMR 的开发环境\"></a>支持 HMR 的开发环境</h4><p>React Router V7 提供了一个支持热模块替换（HMR）的开发环境，这一特性可以显著提升开发体验。HMR 是一种在开发过程中实时更新代码的技术，开发者可以在不刷新页面的情况下看到代码更改的效果，从而提高开发效率。</p>\n<h4 id=\"新的-API-和改进的文档\"><a href=\"#新的-API-和改进的文档\" class=\"headerlink\" title=\"新的 API 和改进的文档\"></a>新的 API 和改进的文档</h4><p>React Router V7 引入了全新的 API，让路由配置更加灵活，使用起来更加轻松。不仅如此，新版本还增强了对静态路由的支持，让页面加载速度更快，用户体验更好。</p>\n<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>以下是一个简单的示例，展示如何使用 React Router V7 的一些新特性：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import &#123; BrowserRouter as Router, Routes, Route, Link &#125; from &quot;react-router-dom&quot;;\nimport &#123; Suspense, lazy &#125; from &quot;react&quot;;\n\nconst Home &#x3D; lazy(() &#x3D;&gt; import(&quot;.&#x2F;pages&#x2F;Home&quot;));\nconst About &#x3D; lazy(() &#x3D;&gt; import(&quot;.&#x2F;pages&#x2F;About&quot;));\n\nfunction App() &#123;\n  return (\n    &lt;Router&gt;\n      &lt;nav&gt;\n        &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;Link&gt;\n        &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;Link&gt;\n      &lt;&#x2F;nav&gt;\n      &lt;Suspense fallback&#x3D;&#123;&lt;div&gt;Loading...&lt;&#x2F;div&gt;&#125;&gt;\n        &lt;Routes&gt;\n          &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;\n          &lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;\n        &lt;&#x2F;Routes&gt;\n      &lt;&#x2F;Suspense&gt;\n    &lt;&#x2F;Router&gt;\n  );\n&#125;\n\nexport default App;</code></pre>\n\n<p>通过以上示例代码，你可以看到如何使用 React Router V7 的新特性来配置路由和实现代码分割。</p>\n<h1 id=\"Redux-Toolkit\"><a href=\"#Redux-Toolkit\" class=\"headerlink\" title=\"Redux-Toolkit\"></a>Redux-Toolkit</h1><h2 id=\"对-Redux-Toolkit-的理解，主要解决什么问题\"><a href=\"#对-Redux-Toolkit-的理解，主要解决什么问题\" class=\"headerlink\" title=\"对 Redux-Toolkit 的理解，主要解决什么问题\"></a>对 Redux-Toolkit 的理解，主要解决什么问题</h2><p>Redux-Toolkit（RTK）是官方推荐的 Redux 辅助库，旨在简化 Redux 应用程序的开发。它提供了一套更简洁、更易于维护的 API，帮助开发者以更少的代码完成更多的工作。以下是 Redux-Toolkit 主要解决的问题：</p>\n<h4 id=\"1-配置复杂性\"><a href=\"#1-配置复杂性\" class=\"headerlink\" title=\"1. 配置复杂性\"></a>1. 配置复杂性</h4><p>传统的 Redux 需要开发者手动编写许多样板代码，如创建 Redux 存储（store）、reducers、actions 和中间件等。Redux-Toolkit 通过提供 <code>configureStore()</code> 函数来简化这一过程，使得配置 Redux 存储变得更加简单。</p>\n<h4 id=\"2-Reducer-和-Action-的样板代码\"><a href=\"#2-Reducer-和-Action-的样板代码\" class=\"headerlink\" title=\"2. Reducer 和 Action 的样板代码\"></a>2. Reducer 和 Action 的样板代码</h4><p>在 Redux 中，每个 action 类型都需要一个对应的 reducer 函数来处理。Redux-Toolkit 提供了 <code>createReducer()</code> 函数，可以自动生成 reducer 逻辑，减少了编写样板代码的工作量。</p>\n<h4 id=\"3-异步逻辑处理\"><a href=\"#3-异步逻辑处理\" class=\"headerlink\" title=\"3. 异步逻辑处理\"></a>3. 异步逻辑处理</h4><p>Redux-Toolkit 提供了 <code>createAsyncThunk</code> 函数，用于处理异步操作。它简化了异步 action 的创建，并且自动处理了 action 的 pending、fulfilled 和 rejected 状态，使得异步流程管理更加直观和简单。</p>\n<h4 id=\"4-状态管理的可读性和可维护性\"><a href=\"#4-状态管理的可读性和可维护性\" class=\"headerlink\" title=\"4. 状态管理的可读性和可维护性\"></a>4. 状态管理的可读性和可维护性</h4><p>Redux-Toolkit 鼓励使用 slice 模式来组织代码，每个 slice 包含一个 reducer、actions 和 state。这种模式提高了代码的模块化，使得状态管理更加清晰和易于维护。</p>\n<h4 id=\"5-性能优化\"><a href=\"#5-性能优化\" class=\"headerlink\" title=\"5. 性能优化\"></a>5. 性能优化</h4><p>Redux-Toolkit 内置了一些性能优化措施，如使用 <code>createReducer()</code> 自动生成的 reducer 可以自动处理不可变更新，以及 <code>createSelector()</code> 函数可以创建 memoized selectors，提高性能。</p>\n<h4 id=\"6-开发者体验\"><a href=\"#6-开发者体验\" class=\"headerlink\" title=\"6. 开发者体验\"></a>6. 开发者体验</h4><p>Redux-Toolkit 提供了更好的开发者体验，例如通过 <code>createEntityAdapter</code> 创建 CRUD 操作的适配器，以及通过 <code>createSlice</code> 一次性定义 reducer、actions 和初始状态。这些工具使得开发 Redux 应用更加快速和愉悦。</p>\n<h4 id=\"7-TypeScript-支持\"><a href=\"#7-TypeScript-支持\" class=\"headerlink\" title=\"7. TypeScript 支持\"></a>7. TypeScript 支持</h4><p>Redux-Toolkit 提供了对 TypeScript 的良好支持，使得在 TypeScript 项目中使用 Redux 变得更加简单和类型安全。</p>\n<h3 id=\"示例代码-1\"><a href=\"#示例代码-1\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><p>以下是使用 Redux-Toolkit 的一个简单示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; configureStore &#125; from &quot;@reduxjs&#x2F;toolkit&quot;;\nimport &#123; reducer as formReducer &#125; from &quot;redux-form&quot;;\nimport userSlice from &quot;.&#x2F;userSlice&quot;;\n\nconst store &#x3D; configureStore(&#123;\n  reducer: &#123;\n    user: userSlice.reducer,\n    form: formReducer,\n  &#125;,\n&#125;);\n\nexport default store;</code></pre>\n\n<p>在这个示例中，<code>configureStore</code> 用于配置 Redux 存储，<code>userSlice</code> 是一个使用 <code>createSlice</code> 创建的 slice，包含了 reducer、actions 和初始状态。</p>\n<h2 id=\"Redux-Toolkit-原理及工作流程\"><a href=\"#Redux-Toolkit-原理及工作流程\" class=\"headerlink\" title=\"Redux-Toolkit 原理及工作流程\"></a>Redux-Toolkit 原理及工作流程</h2><h3 id=\"Redux-Toolkit-原理及工作流程-1\"><a href=\"#Redux-Toolkit-原理及工作流程-1\" class=\"headerlink\" title=\"Redux-Toolkit 原理及工作流程\"></a>Redux-Toolkit 原理及工作流程</h3><p>Redux-Toolkit（简称 RTK）是 Redux 的官方工具集，旨在简化 Redux 的使用和开发流程。以下是 RTK 的核心原理和工作流程：</p>\n<h4 id=\"1-核心原理\"><a href=\"#1-核心原理\" class=\"headerlink\" title=\"1. 核心原理\"></a>1. 核心原理</h4><ul>\n<li><strong>简化配置</strong>：RTK 提供 <code>configureStore()</code> 方法，简化了 Redux store 的配置过程，自动合并 reducers，并集成了常用的中间件（如 redux-thunk），同时默认支持 Redux DevTools Extension。</li>\n<li><strong>简化 Reducer 编写</strong>：通过 <code>createReducer()</code> 方法，RTK 允许开发者以对象的方式配置 reducer，而不是传统的 switch-case 语句，同时内部使用 Immer 库来处理不可变更新。</li>\n<li><strong>集成 Immer</strong>：RTK 集成了 Immer 库，使得在 reducer 中创建不可变数据变得简单，开发者可以使用类似可变的代码风格编写逻辑。</li>\n<li><strong>创建 Selector</strong>：RTK 提供 <code>createSelector()</code> 方法，用于创建可记忆的 selector 函数，优化性能。</li>\n<li><strong>集成 Redux 中间件</strong>：RTK 允许添加任意中间件，并且内置了 redux-thunk 中间件。</li>\n</ul>\n<h4 id=\"2-工作流程\"><a href=\"#2-工作流程\" class=\"headerlink\" title=\"2. 工作流程\"></a>2. 工作流程</h4><ul>\n<li><strong>创建 Slice</strong>：使用 <code>createSlice()</code> 方法创建一个 Redux 的 slice，它包含了 reducer 逻辑和 action creators。Slice 是 Redux 状态树的一部分，通常对应应用的一个功能。</li>\n<li><strong>定义 Reducer 和 Actions</strong>：在 slice 中定义 reducer 函数和初始状态。RTK 允许你编写类似可变的更新逻辑，而实际上通过 Immer 库来保证状态的不可变性。</li>\n<li><strong>配置 Store</strong>：使用 <code>configureStore()</code> 方法配置 Redux store，传入 reducers 配置对象，自动处理中间件和 enhancers。</li>\n<li><strong>连接 React</strong>：在 React 应用中，使用 <code>&lt;Provider&gt;</code> 组件将 store 传递给整个应用，使得组件可以访问到 Redux store。</li>\n<li><strong>使用 Hooks</strong>：在组件中使用 <code>useSelector</code> 和 <code>useDispatch</code> hooks 来访问 state 和 dispatch actions。</li>\n<li><strong>处理异步逻辑</strong>：RTK 提供 <code>createAsyncThunk</code> 方法来处理异步操作，自动生成 pending&#x2F;fulfilled&#x2F;rejected 动作类型。</li>\n<li><strong>管理规范化数据</strong>：通过 <code>createEntityAdapter</code> 方法，RTK 提供了一组可重用的 reducers 和 selectors，用于管理规范化数据。</li>\n</ul>\n<p>通过上述原理和工作流程，Redux-Toolkit 极大地简化了 Redux 的使用，使得状态管理更加直观和高效。开发者可以专注于业务逻辑的实现，而不必深陷于 Redux 的复杂配置和样板代码中。</p>\n<h2 id=\"Redux-Toolkit-中异步的请求怎么处理\"><a href=\"#Redux-Toolkit-中异步的请求怎么处理\" class=\"headerlink\" title=\"Redux-Toolkit 中异步的请求怎么处理\"></a>Redux-Toolkit 中异步的请求怎么处理</h2><h3 id=\"Redux-Toolkit-中异步请求处理\"><a href=\"#Redux-Toolkit-中异步请求处理\" class=\"headerlink\" title=\"Redux-Toolkit 中异步请求处理\"></a>Redux-Toolkit 中异步请求处理</h3><p>Redux-Toolkit (RTK) 通过 <code>createAsyncThunk</code> 函数简化了异步请求的处理。以下是其工作原理和步骤：</p>\n<h4 id=\"1-创建异步-Thunk\"><a href=\"#1-创建异步-Thunk\" class=\"headerlink\" title=\"1. 创建异步 Thunk\"></a>1. 创建异步 Thunk</h4><p><code>createAsyncThunk</code> 用于创建处理异步逻辑的 thunk action creator。它自动处理派发不同阶段的 action（如 pending、fulfilled、rejected）。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createAsyncThunk &#125; from &quot;@reduxjs&#x2F;toolkit&quot;;\nimport axios from &quot;axios&quot;;\n\nconst fetchUserById &#x3D; createAsyncThunk(\n  &quot;users&#x2F;fetchById&quot;, &#x2F;&#x2F; action type 的基础名称\n  async (userId, thunkAPI) &#x3D;&gt; &#123;\n    try &#123;\n      const response &#x3D; await axios.get(&#96;&#x2F;api&#x2F;users&#x2F;$&#123;userId&#125;&#96;);\n      return response.data;\n    &#125; catch (error) &#123;\n      return thunkAPI.rejectWithValue(error.message); &#x2F;&#x2F; 错误处理\n    &#125;\n  &#125;\n);</code></pre>\n\n<h4 id=\"2-在-Slice-中使用-extraReducers\"><a href=\"#2-在-Slice-中使用-extraReducers\" class=\"headerlink\" title=\"2. 在 Slice 中使用 extraReducers\"></a>2. 在 Slice 中使用 extraReducers</h4><p>在创建的 slice 中，通过 <code>extraReducers</code> 属性来监听异步 action 的状态变化，并根据这些变化更新 state。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createSlice &#125; from &quot;@reduxjs&#x2F;toolkit&quot;;\n\nconst userSlice &#x3D; createSlice(&#123;\n  name: &quot;user&quot;,\n  initialState: &#123;\n    data: null,\n    status: &quot;idle&quot;,\n    error: null,\n  &#125;,\n  extraReducers: (builder) &#x3D;&gt; &#123;\n    builder\n      .addCase(fetchUserById.pending, (state) &#x3D;&gt; &#123;\n        state.status &#x3D; &quot;loading&quot;;\n      &#125;)\n      .addCase(fetchUserById.fulfilled, (state, action) &#x3D;&gt; &#123;\n        state.status &#x3D; &quot;succeeded&quot;;\n        state.data &#x3D; action.payload;\n      &#125;)\n      .addCase(fetchUserById.rejected, (state, action) &#x3D;&gt; &#123;\n        state.status &#x3D; &quot;failed&quot;;\n        state.error &#x3D; action.error.message;\n      &#125;);\n  &#125;,\n&#125;);\n\nexport default userSlice.reducer;</code></pre>\n\n<h4 id=\"3-在组件中分派异步-action\"><a href=\"#3-在组件中分派异步-action\" class=\"headerlink\" title=\"3. 在组件中分派异步 action\"></a>3. 在组件中分派异步 action</h4><p>在 React 组件中，使用 <code>useDispatch</code> 和 <code>useSelector</code> hooks 来分派异步 action，并根据 state 变化进行相应的 UI 更新。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;\nimport &#123; fetchUserById &#125; from &quot;.&#x2F;userSlice&quot;;\n\nfunction UserDetail(&#123; userId &#125;) &#123;\n  const dispatch &#x3D; useDispatch();\n  const user &#x3D; useSelector((state) &#x3D;&gt; state.user.data);\n  const status &#x3D; useSelector((state) &#x3D;&gt; state.user.status);\n\n  useEffect(() &#x3D;&gt; &#123;\n    if (status &#x3D;&#x3D;&#x3D; &quot;idle&quot;) &#123;\n      dispatch(fetchUserById(userId));\n    &#125;\n  &#125;, [status, dispatch, userId]);\n&#125;</code></pre>\n\n<h4 id=\"4-处理异步请求的结果\"><a href=\"#4-处理异步请求的结果\" class=\"headerlink\" title=\"4. 处理异步请求的结果\"></a>4. 处理异步请求的结果</h4><p><code>createAsyncThunk</code> 在内部处理了所有错误，并且 Redux Toolkit 提供了 <code>unwrapResult</code> 工具函数，用于处理异步请求的成功和失败。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const onSavePostClicked &#x3D; async () &#x3D;&gt; &#123;\n  if (canSave) &#123;\n    try &#123;\n      setAddRequestStatus(&quot;pending&quot;);\n      await dispatch(addNewPost(&#123; title, content, user: userId &#125;)).unwrap();\n      setTitle(&quot;&quot;);\n      setContent(&quot;&quot;);\n      setUserId(&quot;&quot;);\n    &#125; catch (err) &#123;\n      console.error(&quot;Failed to save the post: &quot;, err);\n    &#125; finally &#123;\n      setAddRequestStatus(&quot;idle&quot;);\n    &#125;\n  &#125;\n&#125;;</code></pre>\n\n<h2 id=\"Redux-Toolkit-状态管理器和变量挂载到-window-中有什么区别\"><a href=\"#Redux-Toolkit-状态管理器和变量挂载到-window-中有什么区别\" class=\"headerlink\" title=\"Redux-Toolkit 状态管理器和变量挂载到 window 中有什么区别\"></a>Redux-Toolkit 状态管理器和变量挂载到 window 中有什么区别</h2><p>Redux-Toolkit 是一个官方支持的 Redux 辅助库，旨在简化 Redux 的使用和提高开发效率。将变量挂载到 <code>window</code> 对象是一种简单的全局状态管理方式，但这种方式与 Redux-Toolkit 状态管理器有显著的区别：</p>\n<ol>\n<li><p><strong>全局状态管理</strong>：</p>\n<ul>\n<li><strong>Redux-Toolkit</strong>：提供了一个单一的全局状态管理器，用于存储整个应用的状态。状态的更新是通过派发 actions 到 reducers 来完成的，这个过程是可预测和可追踪的。</li>\n<li>**变量挂载到 <code>window</code>**：直接将变量挂载到 <code>window</code> 对象上，这种方式虽然可以实现全局访问，但缺乏集中式管理和状态更新的跟踪。</li>\n</ul>\n</li>\n<li><p><strong>状态更新的可预测性</strong>：</p>\n<ul>\n<li><strong>Redux-Toolkit</strong>：状态更新是通过 reducer 函数来管理的，这些函数是纯函数，保证了状态更新的一致性和可预测性。</li>\n<li>**变量挂载到 <code>window</code>**：不同部分的代码可能直接修改这些变量，导致潜在的命名冲突和不可预测的状态变化。</li>\n</ul>\n</li>\n<li><p><strong>订阅和响应状态变化</strong>：</p>\n<ul>\n<li><strong>Redux-Toolkit</strong>：提供了订阅机制，允许组件监听状态的变化，并在状态更新时得到通知，这是通过 <code>useSelector</code> 和 <code>useDispatch</code> 等 React hooks 实现的。</li>\n<li>**变量挂载到 <code>window</code>**：没有内置的订阅和通知机制，任何状态的变化都需要手动管理，这在大型应用中是不可行的。</li>\n</ul>\n</li>\n<li><p><strong>代码组织和维护</strong>：</p>\n<ul>\n<li><strong>Redux-Toolkit</strong>：通过规定的方式处理状态更新，可以更好地组织代码，使得状态管理更加模块化和可维护。</li>\n<li>**变量挂载到 <code>window</code>**：依赖于全局变量，可能导致代码难以维护，尤其是在大型应用中，全局状态的管理会变得复杂和混乱。</li>\n</ul>\n</li>\n<li><p><strong>开发工具和调试</strong>：</p>\n<ul>\n<li><strong>Redux-Toolkit</strong>：与 Redux DevTools 集成，提供了时间旅行调试、状态快照等强大的调试功能。</li>\n<li>**变量挂载到 <code>window</code>**：没有这样的工具支持，调试状态变化会更加困难。</li>\n</ul>\n</li>\n<li><p><strong>中间件和异步处理</strong>：</p>\n<ul>\n<li><strong>Redux-Toolkit</strong>：支持中间件，可以轻松处理异步逻辑，如 <code>createAsyncThunk</code> 用于处理异步请求。</li>\n<li>**变量挂载到 <code>window</code>**：处理异步逻辑需要手动编写额外的代码，没有内置的解决方案。</li>\n</ul>\n</li>\n</ol>\n<p>总结来说，Redux-Toolkit 提供了一种结构化和可预测的方式来管理应用状态，而将变量挂载到 <code>window</code> 对象是一种简单但缺乏结构和可维护性的方法。在现代前端开发中，Redux-Toolkit 因其强大的功能和易用性而成为首选的状态管理解决方案。</p>\n<h2 id=\"mobox-和-zustand-和-redux-toolkit-有什么区别？\"><a href=\"#mobox-和-zustand-和-redux-toolkit-有什么区别？\" class=\"headerlink\" title=\"mobox 和 zustand 和 redux-toolkit 有什么区别？\"></a>mobox 和 zustand 和 redux-toolkit 有什么区别？</h2><p>mobox（MobX）、zustand 和 redux-toolkit（Redux-Toolkit）是三个不同的状态管理库，它们在设计理念、使用方式和适用场景上有所区别：</p>\n<ol>\n<li><p><strong>设计理念和 API 复杂度</strong>：</p>\n<ul>\n<li><strong>MobX</strong>：提供了一个更高级和复杂的 API，包括 observables、computed values 和 actions 等，允许对状态管理过程进行细粒度控制。</li>\n<li><strong>Zustand</strong>：以简洁著称，提供了最小化的 API，使得开发者更容易理解和使用。</li>\n<li><strong>Redux-Toolkit</strong>：作为 Redux 的官方工具集，它提供了一套有指导性的工具和规范，强调可预测性、可扩展性和可维护性。</li>\n</ul>\n</li>\n<li><p><strong>性能优化</strong>：</p>\n<ul>\n<li><strong>MobX</strong>：内置了依赖追踪和自动重新渲染组件的优化，采用反应式编程模型高效更新必要的组件。</li>\n<li><strong>Zustand</strong>：作为一个更简单的方案，没有内置的性能增强，但在小型应用中表现良好。</li>\n<li><strong>Redux-Toolkit</strong>：通过<code>createSlice</code>函数等优化，最小化不必要的重渲染，提高性能。</li>\n</ul>\n</li>\n<li><p><strong>集成和框架兼容性</strong>：</p>\n<ul>\n<li><strong>MobX</strong>：设计上可以无缝集成到 React、Angular 和 Vue 等多种框架中，提供官方绑定。</li>\n<li><strong>Zustand</strong>：与框架无关，可以用于任何 JavaScript 框架或库，轻量级且易于融入不同项目设置。</li>\n<li><strong>Redux-Toolkit</strong>：作为 Redux 的扩展，与 React 生态紧密集成，特别是通过 React-Redux 库。</li>\n</ul>\n</li>\n<li><p><strong>开发者体验和社区支持</strong>：</p>\n<ul>\n<li><strong>MobX</strong>：拥有更大的社区和更广泛的文档支持，对于开发者来说，获取支持和学习资源可能更容易。</li>\n<li><strong>Zustand</strong>：相对较新，社区和文档资源可能较少，但提供了更集中和简化的方法。</li>\n<li><strong>Redux-Toolkit</strong>：Redux 拥有成熟和强大的生态系统，提供了大量的中间件、增强器和第三方库。</li>\n</ul>\n</li>\n<li><p><strong>向后兼容性</strong>：</p>\n<ul>\n<li><strong>MobX</strong>：存在时间较长，版本历史稳定，支持旧版本的 JavaScript 和广泛的浏览器兼容性。</li>\n<li><strong>Zustand</strong>：作为新库，可能在向后兼容性上没有太多保证，可能需要使用现代 JavaScript 语言特性和最新浏览器版本。</li>\n</ul>\n</li>\n<li><p><strong>包大小</strong>：</p>\n<ul>\n<li><strong>MobX</strong>：由于提供额外的特性和优化，包大小相对较大。</li>\n<li><strong>Zustand</strong>：作为一个最小化库，拥有更小的包大小，对于对文件大小或性能有严格要求的项目可能是优势。</li>\n</ul>\n</li>\n</ol>\n<p>总结来说，MobX 提供了一个功能丰富、响应式的状态管理解决方案；Zustand 以其简洁性和易用性著称，适合需要快速上手和轻量级状态管理的项目；Redux-Toolkit 则提供了一个结构化和可预测的状态管理方式，适合大型和复杂的应用场景。开发者可以根据项目需求和个人喜好选择合适的状态管理库。</p>\n<h1 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h1><h2 id=\"对-React-Hook-的理解，它的实现原理是什么\"><a href=\"#对-React-Hook-的理解，它的实现原理是什么\" class=\"headerlink\" title=\"对 React Hook 的理解，它的实现原理是什么\"></a>对 React Hook 的理解，它的实现原理是什么</h2><h3 id=\"React-Hook-的理解\"><a href=\"#React-Hook-的理解\" class=\"headerlink\" title=\"React Hook 的理解\"></a>React Hook 的理解</h3><p>React Hooks 是 React 16.8 版本引入的一种新特性，它允许在不编写类组件的情况下使用 state 和其他 React 特性。Hooks 提供了一种更简洁和更一致的方式来复用状态逻辑，使得函数组件能够拥有与类组件相似的能力。</p>\n<h4 id=\"主要-Hooks\"><a href=\"#主要-Hooks\" class=\"headerlink\" title=\"主要 Hooks\"></a>主要 Hooks</h4><ul>\n<li><code>useState</code>：用于在函数组件中添加局部状态。</li>\n<li><code>useEffect</code>：用于在函数组件中执行副作用操作，类似于类组件的生命周期方法。</li>\n<li><code>useContext</code>：用于在组件树中传递上下文，而不必在每个层级手动传递 props。</li>\n<li><code>useReducer</code>：用于在函数组件中管理复杂的状态逻辑。</li>\n<li><code>useCallback</code>：用于返回一个 memoized 回调函数，防止函数在每次渲染时都被重新创建。</li>\n<li><code>useMemo</code>：用于对计算进行 memoization，仅在依赖项改变时重新计算。</li>\n<li><code>useRef</code>：用于创建一个可访问其.current 属性的引用对象。</li>\n</ul>\n<h3 id=\"Hooks-的实现原理\"><a href=\"#Hooks-的实现原理\" class=\"headerlink\" title=\"Hooks 的实现原理\"></a>Hooks 的实现原理</h3><p>Hooks 的实现依赖于 React 团队对 React 内部的重构。以下是 Hooks 实现的一些关键点：</p>\n<h4 id=\"1-Render-Phase-and-Commit-Phase\"><a href=\"#1-Render-Phase-and-Commit-Phase\" class=\"headerlink\" title=\"1. Render Phase and Commit Phase\"></a>1. Render Phase and Commit Phase</h4><p>React 将组件的生命周期分为两个阶段：Render Phase（渲染阶段）和 Commit Phase（提交阶段）。Hooks 的实现主要在 Render Phase。</p>\n<h4 id=\"2-Double-Buffering-Technique\"><a href=\"#2-Double-Buffering-Technique\" class=\"headerlink\" title=\"2. Double-Buffering Technique\"></a>2. Double-Buffering Technique</h4><p>React 使用双缓冲技术（Double-Buffering Technique）来实现 Hooks 的状态持久化。在 Render Phase，React 会为每个组件创建两个 fiber 节点，一个用于当前的渲染，另一个用于下一次的渲染。这两个 fiber 节点共享同一个 memoized state，这个 state 在组件的整个渲染过程中保持不变。</p>\n<h4 id=\"3-Hook-Array\"><a href=\"#3-Hook-Array\" class=\"headerlink\" title=\"3. Hook Array\"></a>3. Hook Array</h4><p>React 为每个函数组件维护一个 Hook 数组，这个数组包含了该组件使用的所有 Hooks 的状态和副作用。当组件重新渲染时，React 会重用这个数组，并更新其中的值。</p>\n<h4 id=\"4-Hook-Order\"><a href=\"#4-Hook-Order\" class=\"headerlink\" title=\"4. Hook Order\"></a>4. Hook Order</h4><p>Hooks 的执行顺序是严格按照代码中出现的顺序。React 确保每个 Hook 在每次渲染时都以相同的顺序被调用，这样可以保证状态的一致性。</p>\n<h4 id=\"5-useState-和-useEffect\"><a href=\"#5-useState-和-useEffect\" class=\"headerlink\" title=\"5. useState 和 useEffect\"></a>5. useState 和 useEffect</h4><ul>\n<li><code>useState</code>：React 通过在 Hook 数组中添加一个包含状态值和更新函数的对象来实现 <code>useState</code>。</li>\n<li><code>useEffect</code>：React 通过在 Hook 数组中添加一个包含副作用函数和清理函数的对象来实现 <code>useEffect</code>。副作用函数仅在组件挂载和卸载时执行，或者在依赖项发生变化时执行。</li>\n</ul>\n<h4 id=\"6-闭包陷阱\"><a href=\"#6-闭包陷阱\" class=\"headerlink\" title=\"6. 闭包陷阱\"></a>6. 闭包陷阱</h4><p>Hooks 通过闭包来保存状态和函数，这可能会导致闭包陷阱，即在循环或条件语句中创建的函数可能会引用旧的状态。为了避免这种情况，React 提供了 <code>useCallback</code> 和 <code>useMemo</code> 来帮助开发者优化性能和避免闭包陷阱。</p>\n<p>总的来说，React Hooks 提供了一种更简洁和更一致的方式来编写组件逻辑，而其背后的实现原理涉及到 React 内部的双缓冲技术和 Hook 数组，这些技术确保了 Hooks 的状态和副作用能够在组件的渲染过程中保持一致。</p>\n<h2 id=\"为什么-useState-要使用数组而不是对象\"><a href=\"#为什么-useState-要使用数组而不是对象\" class=\"headerlink\" title=\"为什么 useState 要使用数组而不是对象\"></a>为什么 useState 要使用数组而不是对象</h2><h3 id=\"为什么-useState-返回数组而不是对象\"><a href=\"#为什么-useState-返回数组而不是对象\" class=\"headerlink\" title=\"为什么 useState 返回数组而不是对象\"></a>为什么 <code>useState</code> 返回数组而不是对象</h3><p>在 React Hooks 中，<code>useState</code> 钩子返回一个包含两个元素的数组，而不是一个对象。这种设计选择有几个原因：</p>\n<h4 id=\"1-避免闭包问题\"><a href=\"#1-避免闭包问题\" class=\"headerlink\" title=\"1. 避免闭包问题\"></a>1. 避免闭包问题</h4><p>在 JavaScript 中，循环中创建的函数会捕获循环变量的当前值，这被称为闭包陷阱。如果 <code>useState</code> 返回一个对象，开发者可能会在循环中错误地使用它，导致所有状态更新函数捕获同一个状态值。使用数组可以避免这个问题，因为数组的索引可以作为循环的迭代器，确保每个状态更新函数都绑定到正确的状态值。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 错误的使用对象的方式\nconst [state, setState] &#x3D; useState(&#123; count: 0 &#125;);\nfor (let i &#x3D; 0; i &lt; 10; i++) &#123;\n  useEffect(() &#x3D;&gt; &#123;\n    setState(&#123; count: i &#125;); &#x2F;&#x2F; 这将导致所有的 setState 都设置相同的状态值\n  &#125;, []);\n&#125;\n\n&#x2F;&#x2F; 正确的使用数组的方式\nconst [state, setState] &#x3D; useState(0);\nfor (let i &#x3D; 0; i &lt; 10; i++) &#123;\n  useEffect(() &#x3D;&gt; &#123;\n    setState(i); &#x2F;&#x2F; 每个 setState 都设置不同的状态值\n  &#125;, [i]); &#x2F;&#x2F; 注意这里的依赖项 i\n&#125;</code></pre>\n\n<h4 id=\"2-提供一个明确的更新函数\"><a href=\"#2-提供一个明确的更新函数\" class=\"headerlink\" title=\"2. 提供一个明确的更新函数\"></a>2. 提供一个明确的更新函数</h4><p>返回数组允许 <code>useState</code> 提供一个明确的更新函数作为第二个元素，这使得代码更清晰易读。如果返回一个对象，更新函数可能会被隐藏在对象的某个属性中，这可能会让代码的可读性降低。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 使用数组\nconst [count, setCount] &#x3D; useState(0);\n\n&#x2F;&#x2F; 使用对象\nconst state &#x3D; useState(&#123; count: 0 &#125;);\nconst setCount &#x3D; state.setState;</code></pre>\n\n<h4 id=\"3-保持-Hook-调用的一致性\"><a href=\"#3-保持-Hook-调用的一致性\" class=\"headerlink\" title=\"3. 保持 Hook 调用的一致性\"></a>3. 保持 Hook 调用的一致性</h4><p>React Hooks 的规则之一是在同一函数组件中调用 Hooks 的顺序必须是一致的。如果 <code>useState</code> 返回一个对象，开发者可能会在不同的渲染中以不同的顺序设置状态，这会违反 Hooks 的规则。数组结构强制开发者以相同的顺序设置状态，这有助于保持代码的一致性。</p>\n<h4 id=\"4-避免对象属性的冲突\"><a href=\"#4-避免对象属性的冲突\" class=\"headerlink\" title=\"4. 避免对象属性的冲突\"></a>4. 避免对象属性的冲突</h4><p>如果 <code>useState</code> 返回一个对象，并且开发者在多个地方使用它来创建不同的状态，可能会不小心使用相同的键名，导致状态值冲突。数组结构通过索引来区分不同的状态，避免了这种冲突。</p>\n<h4 id=\"5-与-useReducer-的兼容性\"><a href=\"#5-与-useReducer-的兼容性\" class=\"headerlink\" title=\"5. 与 useReducer 的兼容性\"></a>5. 与 <code>useReducer</code> 的兼容性</h4><p><code>useState</code> 返回数组的设计也与 <code>useReducer</code> 钩子兼容。<code>useReducer</code> 钩子返回一个包含状态和派发函数的数组，这种设计模式允许开发者在 <code>useState</code> 和 <code>useReducer</code> 之间无缝切换。</p>\n<p>总的来说，<code>useState</code> 返回数组而不是对象的设计，是为了提高代码的可读性、避免闭包陷阱、保持 Hook 调用的一致性、避免对象属性冲突，并与 <code>useReducer</code> 提供一致的 API 设计。这种设计使得 Hooks 更加强大和灵活，同时也更易于理解和使用。</p>\n<h2 id=\"React-Hooks-解决了哪些问题？\"><a href=\"#React-Hooks-解决了哪些问题？\" class=\"headerlink\" title=\"React Hooks 解决了哪些问题？\"></a>React Hooks 解决了哪些问题？</h2><p>React Hooks 解决了以下主要问题：</p>\n<h3 id=\"1-状态管理在函数组件中的问题\"><a href=\"#1-状态管理在函数组件中的问题\" class=\"headerlink\" title=\"1. 状态管理在函数组件中的问题\"></a>1. 状态管理在函数组件中的问题</h3><p>在 Hooks 出现之前，React 状态管理只能通过类组件的 <code>this.state</code> 和 <code>this.setState</code> 方法实现。这限制了函数组件的使用，因为函数组件无法访问这些状态管理功能。Hooks 通过 <code>useState</code> 使得函数组件也能拥有状态管理的能力。</p>\n<h3 id=\"2-代码复用和逻辑重构\"><a href=\"#2-代码复用和逻辑重构\" class=\"headerlink\" title=\"2. 代码复用和逻辑重构\"></a>2. 代码复用和逻辑重构</h3><p>类组件中，如果多个组件需要共享相同的逻辑，通常需要将逻辑提取到混合（mixins）或高阶组件（HOCs）中。这些模式使得代码重构变得复杂，并且容易引发问题。Hooks 提供了 <code>useCallback</code>、<code>useMemo</code> 和 <code>useReducer</code> 等，使得逻辑可以更简单地在组件间复用。</p>\n<h3 id=\"3-生命周期方法的复杂性\"><a href=\"#3-生命周期方法的复杂性\" class=\"headerlink\" title=\"3. 生命周期方法的复杂性\"></a>3. 生命周期方法的复杂性</h3><p>类组件的生命周期方法（如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>）使得状态管理和副作用处理变得复杂，尤其是当多个生命周期方法需要执行相似的逻辑时。<code>useEffect</code> Hook 提供了一种统一的方式来处理副作用，简化了代码。</p>\n<h3 id=\"4-组件性能优化\"><a href=\"#4-组件性能优化\" class=\"headerlink\" title=\"4. 组件性能优化\"></a>4. 组件性能优化</h3><p>在类组件中，为了避免不必要的渲染，开发者需要使用 <code>PureComponent</code> 或手动实现 <code>shouldComponentUpdate</code>。Hooks 提供了 <code>React.memo</code> 和 <code>useMemo</code> 来帮助开发者优化性能，减少不必要的渲染。</p>\n<h3 id=\"5-上下文（Context）传递的复杂性\"><a href=\"#5-上下文（Context）传递的复杂性\" class=\"headerlink\" title=\"5. 上下文（Context）传递的复杂性\"></a>5. 上下文（Context）传递的复杂性</h3><p>在没有 Hooks 的情况下，传递上下文（Context）需要通过层层传递 <code>props</code>，这在深层嵌套的组件树中非常繁琐。<code>useContext</code> Hook 允许组件直接订阅上下文的变化，无需通过 <code>props</code> 链逐级传递。</p>\n<h3 id=\"6-代码组织和可读性\"><a href=\"#6-代码组织和可读性\" class=\"headerlink\" title=\"6. 代码组织和可读性\"></a>6. 代码组织和可读性</h3><p>Hooks 使得组件逻辑更加模块化，开发者可以将相关的 Hooks 组合在一起，使得代码更加清晰和易于维护。这种模块化也使得代码的组织更加直观。</p>\n<h3 id=\"7-避免“this”关键字的问题\"><a href=\"#7-避免“this”关键字的问题\" class=\"headerlink\" title=\"7. 避免“this”关键字的问题\"></a>7. 避免“this”关键字的问题</h3><p>在类组件中，使用“this”关键字可能会导致在回调函数中丢失上下文的问题，特别是在异步操作中。Hooks 提供了一种不依赖“this”的解决方案，使得代码更加简洁和易于理解。</p>\n<h3 id=\"8-函数组件的生态和库的支持\"><a href=\"#8-函数组件的生态和库的支持\" class=\"headerlink\" title=\"8. 函数组件的生态和库的支持\"></a>8. 函数组件的生态和库的支持</h3><p>随着函数组件的流行，许多第三方库开始支持函数式 API。Hooks 的引入使得这些库可以提供与 React Hooks 兼容的解决方案，进一步扩展了 React 生态系统。</p>\n<p>总的来说，React Hooks 提供了一种更简单、更直观的方式来编写组件，使得代码更加模块化、易于理解和维护，同时也提高了开发效率和应用性能。</p>\n<h2 id=\"React-Hook-的使用限制有哪些？\"><a href=\"#React-Hook-的使用限制有哪些？\" class=\"headerlink\" title=\"React Hook 的使用限制有哪些？\"></a>React Hook 的使用限制有哪些？</h2><p>React Hooks 提供了许多强大的功能，但也有一些使用限制和规则需要遵守。以下是 React Hooks 的一些主要使用限制：</p>\n<h3 id=\"1-只能在函数组件中使用\"><a href=\"#1-只能在函数组件中使用\" class=\"headerlink\" title=\"1. 只能在函数组件中使用\"></a>1. 只能在函数组件中使用</h3><p>Hooks 只能在函数组件内部使用，不能在类组件、直接调用的函数或其他 JavaScript 函数中使用。</p>\n<h3 id=\"2-避免在循环、条件语句和嵌套函数中调用-Hooks\"><a href=\"#2-避免在循环、条件语句和嵌套函数中调用-Hooks\" class=\"headerlink\" title=\"2. 避免在循环、条件语句和嵌套函数中调用 Hooks\"></a>2. 避免在循环、条件语句和嵌套函数中调用 Hooks</h3><p>React 要求 Hooks 的调用顺序在每次渲染中都是相同的。因此，不能在循环、条件语句或嵌套函数中调用 Hooks，因为这会导致 Hooks 的调用顺序在不同的渲染中不一致。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 错误：在循环中调用 Hooks\nfor (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  useState(arr[i]);\n&#125;\n\n&#x2F;&#x2F; 错误：在条件语句中调用 Hooks\nif (condition) &#123;\n  useState();\n&#125;</code></pre>\n\n<h3 id=\"3-只能在调用栈顶部调用-Hooks\"><a href=\"#3-只能在调用栈顶部调用-Hooks\" class=\"headerlink\" title=\"3. 只能在调用栈顶部调用 Hooks\"></a>3. 只能在调用栈顶部调用 Hooks</h3><p>Hooks 必须在组件函数或自定义 Hooks 的顶层调用，不能在内部函数中调用。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 错误：在内部函数中调用 Hooks\nfunction MyComponent() &#123;\n  function handleClick() &#123;\n    useState();\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-不能在浏览器的-DevTools-中观察到-Hooks-的变化\"><a href=\"#4-不能在浏览器的-DevTools-中观察到-Hooks-的变化\" class=\"headerlink\" title=\"4. 不能在浏览器的 DevTools 中观察到 Hooks 的变化\"></a>4. 不能在浏览器的 DevTools 中观察到 Hooks 的变化</h3><p>React DevTools 可以观察组件的状态和属性，但 Hooks 的状态不是以相同的方式暴露的。需要使用 <code>useDebugValue</code> 或 <code>useId</code> 来帮助调试 Hooks。</p>\n<h3 id=\"5-自定义-Hooks-的参数应该是稳定的\"><a href=\"#5-自定义-Hooks-的参数应该是稳定的\" class=\"headerlink\" title=\"5. 自定义 Hooks 的参数应该是稳定的\"></a>5. 自定义 Hooks 的参数应该是稳定的</h3><p>自定义 Hooks 的参数不应该在组件的渲染之间改变，否则可能会导致性能问题或不一致的行为。</p>\n<h3 id=\"6-避免在-useEffect-中执行长时间运行的操作\"><a href=\"#6-避免在-useEffect-中执行长时间运行的操作\" class=\"headerlink\" title=\"6. 避免在 useEffect 中执行长时间运行的操作\"></a>6. 避免在 <code>useEffect</code> 中执行长时间运行的操作</h3><p><code>useEffect</code> 中执行的副作用操作应该尽快完成，以避免阻塞浏览器的渲染。如果需要执行长时间运行的操作，应该考虑使用 Web Workers 或其他异步解决方案。</p>\n<h3 id=\"7-useEffect-的清理函数\"><a href=\"#7-useEffect-的清理函数\" class=\"headerlink\" title=\"7. useEffect 的清理函数\"></a>7. <code>useEffect</code> 的清理函数</h3><p>在 <code>useEffect</code> 中返回的清理函数必须小心处理，确保在组件卸载时正确清理副作用，如定时器、订阅等。</p>\n<h3 id=\"8-useEffect-的依赖项列表\"><a href=\"#8-useEffect-的依赖项列表\" class=\"headerlink\" title=\"8. useEffect 的依赖项列表\"></a>8. <code>useEffect</code> 的依赖项列表</h3><p><code>useEffect</code> 的依赖项列表必须包含所有外部作用域中用于副作用中的变量，否则可能会导致副作用在依赖项变化时不重新运行。</p>\n<h3 id=\"9-useReducer-的性能考虑\"><a href=\"#9-useReducer-的性能考虑\" class=\"headerlink\" title=\"9. useReducer 的性能考虑\"></a>9. <code>useReducer</code> 的性能考虑</h3><p>对于复杂的状态逻辑，<code>useReducer</code> 可能是更好的选择，因为它可以避免不必要的状态更新。但如果 reducer 函数中的逻辑过于简单，使用 <code>useState</code> 可能更合适。</p>\n<h3 id=\"10-useContext-的性能优化\"><a href=\"#10-useContext-的性能优化\" class=\"headerlink\" title=\"10. useContext 的性能优化\"></a>10. <code>useContext</code> 的性能优化</h3><p><code>useContext</code> 可以简化上下文的传递，但如果不正确使用，如在组件树中过度使用，可能会导致性能问题。应确保只在需要访问上下文的组件中使用 <code>useContext</code>。</p>\n<p>遵守这些规则和限制，可以帮助你更有效地使用 React Hooks，并避免潜在的问题。</p>\n<h2 id=\"useEffect-与-useLayoutEffect-的区别\"><a href=\"#useEffect-与-useLayoutEffect-的区别\" class=\"headerlink\" title=\"useEffect 与 useLayoutEffect 的区别\"></a>useEffect 与 useLayoutEffect 的区别</h2><p><code>useEffect</code> 和 <code>useLayoutEffect</code> 是 React 提供的两个用于处理副作用的 Hook，它们的主要区别在于何时执行副作用函数：</p>\n<h3 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h3><ul>\n<li><code>useEffect</code> 是异步执行的，它不会阻塞浏览器的渲染过程。这意味着 <code>useEffect</code> 中的代码会在浏览器完成布局和绘制之后、在所有组件的渲染都完成后执行。因此，<code>useEffect</code> 不会影响同步布局。</li>\n<li><code>useEffect</code> 会在组件渲染后和浏览器空闲时执行，这有助于避免性能问题，因为它允许浏览器完成必要的渲染工作，减少用户的感知延迟。</li>\n<li><code>useEffect</code> 也用于处理组件卸载时的清理工作。</li>\n</ul>\n<h3 id=\"useLayoutEffect\"><a href=\"#useLayoutEffect\" class=\"headerlink\" title=\"useLayoutEffect\"></a>useLayoutEffect</h3><ul>\n<li><code>useLayoutEffect</code> 与 <code>useEffect</code> 类似，但它是同步执行的，即在 DOM 更新后、在浏览器绘制之前立即执行。这意味着 <code>useLayoutEffect</code> 中的代码会阻塞视觉更新，因为它在浏览器绘制之前运行。</li>\n<li><code>useLayoutEffect</code> 通常用于那些需要在读取 DOM 后立即执行的操作，比如测量 DOM 元素的尺寸或位置。</li>\n<li>由于 <code>useLayoutEffect</code> 会阻塞渲染，它可能会导致性能问题，特别是在大型应用中，因此应该谨慎使用。</li>\n</ul>\n<h3 id=\"性能影响\"><a href=\"#性能影响\" class=\"headerlink\" title=\"性能影响\"></a>性能影响</h3><ul>\n<li>使用 <code>useEffect</code> 时，React 可以更有效地安排副作用的执行，因为它允许浏览器在执行副作用之前完成所有必要的渲染工作。</li>\n<li>使用 <code>useLayoutEffect</code> 可能会导致性能问题，因为它阻塞了浏览器的渲染过程，尤其是在复杂的应用中，可能会引起连锁反应，导致多个组件连续重新渲染。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>如果你的副作用逻辑不依赖于 DOM 的当前状态，或者不需要立即同步执行，那么 <code>useEffect</code> 是更好的选择。</li>\n<li>如果你需要在 DOM 更新后立即执行操作，比如测量尺寸或重新定位元素，并且这些操作不会阻塞用户的交互，那么可以使用 <code>useLayoutEffect</code>。</li>\n</ul>\n<p>在大多数情况下，<code>useEffect</code> 是首选的副作用 Hook，因为它提供了更好的性能和更灵活的副作用处理。<code>useLayoutEffect</code> 应该在确实需要同步执行副作用时才使用。</p>\n<h1 id=\"虚拟-DOM\"><a href=\"#虚拟-DOM\" class=\"headerlink\" title=\"虚拟 DOM\"></a>虚拟 DOM</h1><h2 id=\"对虚拟-DOM-的理解？虚拟-DOM-主要做了什么？虚拟-DOM-本身是什么？\"><a href=\"#对虚拟-DOM-的理解？虚拟-DOM-主要做了什么？虚拟-DOM-本身是什么？\" class=\"headerlink\" title=\"对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？\"></a>对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？</h2><h3 id=\"虚拟-DOM-的理解\"><a href=\"#虚拟-DOM-的理解\" class=\"headerlink\" title=\"虚拟 DOM 的理解\"></a>虚拟 DOM 的理解</h3><p>虚拟 DOM（Virtual DOM）是一种编程概念，用于提高 Web 应用的性能。它的核心思想是使用 JavaScript 对象来模拟 DOM 树的结构和状态，以此来减少直接操作真实 DOM 的次数，从而提高性能。</p>\n<h3 id=\"虚拟-DOM-本身是什么\"><a href=\"#虚拟-DOM-本身是什么\" class=\"headerlink\" title=\"虚拟 DOM 本身是什么\"></a>虚拟 DOM 本身是什么</h3><p>虚拟 DOM 本身是一个 JavaScript 对象，它表示了一个轻量级的 DOM 树。这个对象包含了构建真实 DOM 节点所需的所有信息，例如：</p>\n<ul>\n<li>节点类型（元素、文本、组件等）</li>\n<li>节点属性（如 <code>className</code>、<code>id</code>、<code>style</code> 等）</li>\n<li>子节点（子元素或文本）</li>\n<li>关联的组件状态和 props</li>\n</ul>\n<p>例如，一个简单的虚拟 DOM 对象可能如下所示：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const vnode &#x3D; &#123;\n  type: &quot;div&quot;,\n  props: &#123;\n    className: &quot;my-div&quot;,\n    children: [\n      &#123;\n        type: &quot;span&quot;,\n        props: &#123;\n          children: &quot;Hello, World!&quot;,\n        &#125;,\n      &#125;,\n    ],\n  &#125;,\n&#125;;</code></pre>\n\n<h3 id=\"虚拟-DOM-主要做了什么\"><a href=\"#虚拟-DOM-主要做了什么\" class=\"headerlink\" title=\"虚拟 DOM 主要做了什么\"></a>虚拟 DOM 主要做了什么</h3><ol>\n<li><p><strong>性能优化</strong>：</p>\n<ul>\n<li>虚拟 DOM 通过减少直接操作真实 DOM 的次数来提高性能。当组件的状态发生变化时，React 会生成一个新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行比较（diffing）。</li>\n</ul>\n</li>\n<li><p><strong>跨平台渲染</strong>：</p>\n<ul>\n<li>由于虚拟 DOM 是用 JavaScript 表示的，它不依赖于浏览器的原生 DOM API。这意味着 React 可以使用虚拟 DOM 在不同的环境中渲染，如服务器端（服务器端渲染，SSR）和原生移动应用（React Native）。</li>\n</ul>\n</li>\n<li><p><strong>批量更新和批量 DOM 操作</strong>：</p>\n<ul>\n<li>虚拟 DOM 允许 React 收集所有状态变化，并在单个重绘（repaint）和重排（reflow）周期内统一更新 DOM。这减少了浏览器的重绘和重排次数，提高了性能。</li>\n</ul>\n</li>\n<li><p><strong>DOM diffing 和 patching</strong>：</p>\n<ul>\n<li>React 通过比较新旧虚拟 DOM 树来生成一个最小化的变更列表（patch），然后只对这些变更应用到真实 DOM 上。这个过程称为 diffing 和 patching。</li>\n</ul>\n</li>\n<li><p><strong>状态管理</strong>：</p>\n<ul>\n<li>虚拟 DOM 允许 React 跟踪组件的状态，当状态更新时，React 可以重新渲染组件并更新虚拟 DOM，而不是手动操作 DOM。</li>\n</ul>\n</li>\n<li><p><strong>可预测性</strong>：</p>\n<ul>\n<li>虚拟 DOM 提供了一种可预测的方式来更新 UI，因为所有的 DOM 更新都是通过比较虚拟 DOM 树来确定的，而不是直接操作 DOM。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，虚拟 DOM 是 React 核心特性之一，它通过在内存中模拟 DOM 结构和状态，提供了一种高效、可预测的方式来构建和更新用户界面。</p>\n<h2 id=\"React-diff-算法的原理是什么？\"><a href=\"#React-diff-算法的原理是什么？\" class=\"headerlink\" title=\"React diff 算法的原理是什么？\"></a>React diff 算法的原理是什么？</h2><h3 id=\"React-Diff-算法的原理\"><a href=\"#React-Diff-算法的原理\" class=\"headerlink\" title=\"React Diff 算法的原理\"></a>React Diff 算法的原理</h3><p>React 的 diff 算法是 React 在更新 DOM 时的核心算法，用于决定如何以最小的代价更新 DOM 树。当组件的状态或 props 发生变化时，React 会重新渲染组件，生成一个新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行比较，找出差异，然后仅对这些差异进行实际的 DOM 更新。</p>\n<p>以下是 React diff 算法的一些关键原理：</p>\n<h4 id=\"1-组件比较\"><a href=\"#1-组件比较\" class=\"headerlink\" title=\"1. 组件比较\"></a>1. 组件比较</h4><ul>\n<li><strong>类型相同</strong>：如果两个组件的类型相同，React 会将它们视为相同的组件，并继续比较它们的子组件或属性。</li>\n<li><strong>类型不同</strong>：如果两个组件的类型不同，React 会直接卸载旧组件并挂载新组件。</li>\n</ul>\n<h4 id=\"2-元素比较\"><a href=\"#2-元素比较\" class=\"headerlink\" title=\"2. 元素比较\"></a>2. 元素比较</h4><ul>\n<li><strong>DOM 元素类型相同</strong>：如果两个元素的类型和属性相同，React 会将它们视为相同的元素，并继续比较它们的子节点。</li>\n<li><strong>DOM 元素类型不同</strong>：如果两个元素的类型不同，React 会直接替换旧元素。</li>\n</ul>\n<h4 id=\"3-子节点比较（递归）\"><a href=\"#3-子节点比较（递归）\" class=\"headerlink\" title=\"3. 子节点比较（递归）\"></a>3. 子节点比较（递归）</h4><ul>\n<li><strong>只比较同一层级的节点</strong>：React 只在同一层级的子节点之间进行比较，不会跨层级比较。</li>\n<li><strong>使用 key 属性</strong>：如果列表中的元素有 key 属性，React 会使用 key 来识别哪些元素是保持不变的，哪些是新加入的，哪些是被移除的。</li>\n</ul>\n<h4 id=\"4-优化策略\"><a href=\"#4-优化策略\" class=\"headerlink\" title=\"4. 优化策略\"></a>4. 优化策略</h4><ul>\n<li><strong>多个子节点</strong>：如果一个元素有多个子节点，React 会尝试只对发生变化的部分进行更新，而不是整个子树。</li>\n<li><strong>Component 浅比较</strong>：对于组件，React 会进行浅比较，比较 props 是否有变化，如果没有变化，则不会重新渲染组件。</li>\n<li><strong>文本节点</strong>：对于文本节点，React 只会比较文本内容。</li>\n</ul>\n<h4 id=\"5-限制\"><a href=\"#5-限制\" class=\"headerlink\" title=\"5. 限制\"></a>5. 限制</h4><ul>\n<li><strong>不跨组件类型比较子节点</strong>：如果两个组件的子节点中包含不同类型的组件，React 不会跨组件类型比较子节点。</li>\n<li><strong>不递归比较函数组件的 props</strong>：对于函数组件，React 不会递归比较它们的 props，而是只比较 props 的引用是否相等。</li>\n</ul>\n<h4 id=\"6-启发式算法\"><a href=\"#6-启发式算法\" class=\"headerlink\" title=\"6. 启发式算法\"></a>6. 启发式算法</h4><p>React 的 diff 算法是一个启发式算法，它基于一些假设和经验法则来减少比较的次数，提高效率。它不是完美的，但在大多数情况下都能提供很好的性能。</p>\n<p>总的来说，React 的 diff 算法通过比较新旧虚拟 DOM 树，找出最小的更新集，然后应用到实际的 DOM 上，以此来实现高效的 UI 更新。这个算法是 React 性能优化的关键部分，它使得 React 能够在保持声明式 UI 的同时，还能有高效的 DOM 更新性能。</p>\n<h2 id=\"React-key-是什么-为什么要加？key-主要是解决哪一类问题的\"><a href=\"#React-key-是什么-为什么要加？key-主要是解决哪一类问题的\" class=\"headerlink\" title=\"React key 是什么 为什么要加？key 主要是解决哪一类问题的\"></a>React key 是什么 为什么要加？key 主要是解决哪一类问题的</h2><h3 id=\"React-key-是什么\"><a href=\"#React-key-是什么\" class=\"headerlink\" title=\"React key 是什么\"></a>React key 是什么</h3><p>React 中的 <code>key</code> 属性是一个特殊的属性，用于帮助 React 识别哪些元素在变化、添加或删除。它是一个字符串或数字，通常用作在数组中对元素进行唯一标识。</p>\n<h3 id=\"为什么要加-key\"><a href=\"#为什么要加-key\" class=\"headerlink\" title=\"为什么要加 key\"></a>为什么要加 key</h3><ol>\n<li><p><strong>提高性能和优化用户体验</strong>：<code>key</code> 属性帮助 React 识别每个元素的唯一性。React 通过 <code>key</code> 属性来判断新旧元素对比时，哪些元素需要更新、哪些元素需要重新渲染，从而提高渲染性能。</p>\n</li>\n<li><p><strong>提高重排性能</strong>：在列表或循环生成组件的场景中，如果没有为每个元素指定 <code>key</code> 属性，React 在进行 diff 算法比较时，会采用遍历比对的方式，导致性能下降。而指定了 <code>key</code> 属性后，React 会通过 <code>key</code> 值快速定位到新旧元素之间的差异，从而减少不必要的重排操作。</p>\n</li>\n<li><p><strong>组件状态保持</strong>：当组件在重新渲染时，React 会优先复用具有相同 <code>key</code> 值的组件实例，而不是销毁并重新创建一个新的组件实例。这使得在动态列表或条件渲染中保持组件状态成为可能。</p>\n</li>\n<li><p><strong>避免错误</strong>：正确使用 <code>key</code> 可以避免在列表渲染中出现的错误，如元素错误地移动或消失。</p>\n</li>\n<li><p><strong>优化 Diff 算法</strong>：<code>key</code> 属性使得 React 能够通过 <code>key</code> 快速识别新旧元素，提高 diff 算法的效率。</p>\n</li>\n</ol>\n<h3 id=\"key-主要是解决哪一类问题\"><a href=\"#key-主要是解决哪一类问题\" class=\"headerlink\" title=\"key 主要是解决哪一类问题\"></a>key 主要是解决哪一类问题</h3><p><code>key</code> 主要解决的是列表渲染中的性能问题和组件状态管理问题：</p>\n<ul>\n<li><strong>列表渲染性能问题</strong>：通过提供 <code>key</code>，React 能够更高效地识别和处理列表中元素的变化，减少不必要的 DOM 操作，从而提高渲染效率。</li>\n<li><strong>组件状态管理问题</strong>：<code>key</code> 有助于 React 关联元素与状态，确保状态更新时能正确渲染元素。这对于保持组件状态的连续性尤为重要。</li>\n<li><strong>避免潜在的渲染错误</strong>：使用不当的 <code>key</code> 可能会导致潜在问题。例如，使用数组索引作为 <code>key</code> 在一些情况下可能导致不必要的重渲染，特别是在列表项可排序或动态变化时。</li>\n</ul>\n<p>总结来说，<code>key</code> 是 React 中用于标识和区分组件的重要属性，通常用于渲染列表或多个组件。正确使用 <code>key</code> 可以提高性能、确保组件的稳定性，并帮助 React 在更新时正确处理组件。</p>\n<h2 id=\"虚拟-DOM-的引入与直接操作原生-DOM-相比，哪一个效率更高，为什么\"><a href=\"#虚拟-DOM-的引入与直接操作原生-DOM-相比，哪一个效率更高，为什么\" class=\"headerlink\" title=\"虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么\"></a>虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么</h2><p>虚拟 DOM 的引入相比于直接操作原生 DOM，通常能提供更高的效率，原因如下：</p>\n<h3 id=\"1-减少直接操作-DOM-的次数\"><a href=\"#1-减少直接操作-DOM-的次数\" class=\"headerlink\" title=\"1. 减少直接操作 DOM 的次数\"></a>1. 减少直接操作 DOM 的次数</h3><p>直接操作 DOM 是一个昂贵的操作，因为浏览器需要解析 HTML、更新渲染树、计算布局（回流）以及进行绘制。虚拟 DOM 通过在内存中模拟 DOM 的结构，只在必要时才将变化应用到真实的 DOM 上，从而减少了直接操作 DOM 的次数。</p>\n<h3 id=\"2-批量更新\"><a href=\"#2-批量更新\" class=\"headerlink\" title=\"2. 批量更新\"></a>2. 批量更新</h3><p>虚拟 DOM 允许批量更新，React 会收集所有的状态变化，然后一次性地更新虚拟 DOM 树，最后只对实际变化的部分进行 DOM 更新。这种方式比逐个直接操作 DOM 更为高效。</p>\n<h3 id=\"3-跨平台能力\"><a href=\"#3-跨平台能力\" class=\"headerlink\" title=\"3. 跨平台能力\"></a>3. 跨平台能力</h3><p>虚拟 DOM 提供了跨平台的能力，使得 React 不仅可以在 Web 浏览器中运行，还可以在其他环境中（如 React Native）渲染，而直接操作 DOM 是与浏览器环境紧密绑定的。</p>\n<h3 id=\"4-避免不必要的重绘和回流\"><a href=\"#4-避免不必要的重绘和回流\" class=\"headerlink\" title=\"4. 避免不必要的重绘和回流\"></a>4. 避免不必要的重绘和回流</h3><p>虚拟 DOM 通过比较前后两个虚拟 DOM 树的差异，计算出最小的更新范围，然后只对这部分进行实际的 DOM 更新，这样可以避免不必要的重绘和回流。</p>\n<h3 id=\"5-优化性能\"><a href=\"#5-优化性能\" class=\"headerlink\" title=\"5. 优化性能\"></a>5. 优化性能</h3><p>虚拟 DOM 的 diff 算法（差异比较算法）会尽量复用已有的 DOM 元素，而不是每次都重新创建元素，这样可以减少内存占用和提升性能。</p>\n<h3 id=\"6-可预测性\"><a href=\"#6-可预测性\" class=\"headerlink\" title=\"6. 可预测性\"></a>6. 可预测性</h3><p>虚拟 DOM 提供了一种可预测的方式来更新 UI，因为所有的 DOM 更新都是通过比较虚拟 DOM 树来确定的，而不是直接操作 DOM 时可能出现的不确定因素。</p>\n<h3 id=\"7-简化状态管理\"><a href=\"#7-简化状态管理\" class=\"headerlink\" title=\"7. 简化状态管理\"></a>7. 简化状态管理</h3><p>虚拟 DOM 使得状态管理变得更加简单，因为所有的状态变化都会映射到虚拟 DOM 的更新上，而不需要手动操作 DOM 来反映状态变化。</p>\n<h3 id=\"8-代码可维护性\"><a href=\"#8-代码可维护性\" class=\"headerlink\" title=\"8. 代码可维护性\"></a>8. 代码可维护性</h3><p>使用虚拟 DOM 可以让代码更加模块化和可维护，因为开发者不需要关心 DOM 的细节，只需要关心组件的状态和行为。</p>\n<p>总的来说，虚拟 DOM 的引入通过减少直接操作 DOM 的次数、批量更新、跨平台渲染、避免不必要的重绘和回流等方式，提高了应用的性能和开发效率。虽然在某些极端情况下，直接操作 DOM 可能会更快（例如，对于非常简单的 DOM 更新），但在大多数现代 Web 应用中，虚拟 DOM 提供的性能和开发优势是直接操作 DOM 所无法比拟的。</p>\n<h2 id=\"React-与-Vue-的-diff-算法有何不同？\"><a href=\"#React-与-Vue-的-diff-算法有何不同？\" class=\"headerlink\" title=\"React 与 Vue 的 diff 算法有何不同？\"></a>React 与 Vue 的 diff 算法有何不同？</h2><p>React 和 Vue 的 diff 算法在实现和性能优化策略上有一些关键的不同之处：</p>\n<h3 id=\"1-性能优化策略\"><a href=\"#1-性能优化策略\" class=\"headerlink\" title=\"1. 性能优化策略\"></a>1. 性能优化策略</h3><ul>\n<li><strong>Vue</strong>：Vue 的优化策略包括静态节点的标记和依赖追踪。在编译模板时，Vue 会标记出静态节点，这样在更新时可以跳过不需要变化的部分，从而减少计算量。Vue 使用基于依赖追踪的响应式系统，只有数据变化时才会重新渲染相关组件。</li>\n<li><strong>React</strong>：React 的优化策略包括树的分层更新和 <code>shouldComponentUpdate</code> 方法。React 通过将虚拟 DOM 树分层次进行比较，以减少更新范围。同时，React 允许开发者通过 <code>shouldComponentUpdate</code> 方法手动控制组件是否需要更新，从而避免不必要的 diff 计算。</li>\n</ul>\n<h3 id=\"2-实现方式\"><a href=\"#2-实现方式\" class=\"headerlink\" title=\"2. 实现方式\"></a>2. 实现方式</h3><ul>\n<li><strong>Vue</strong>：Vue 的 diff 算法采用双端比较策略，从新旧虚拟 DOM 的两端同时开始比较，遇到不相同的节点时再进行具体处理。Vue 通过一些快速路径优化来处理常见的列表操作，如添加、删除、移动等，进一步提高 diff 算法的效率。</li>\n<li><strong>React</strong>：React 的 diff 算法采用逐层比较策略，从根节点开始逐层进行比较，遇到不同的节点时再进行具体处理。React 要求列表中的每个元素都有唯一的 key 值，以便更高效地找到变化的节点并进行更新。</li>\n</ul>\n<h3 id=\"3-更新机制\"><a href=\"#3-更新机制\" class=\"headerlink\" title=\"3. 更新机制\"></a>3. 更新机制</h3><ul>\n<li><strong>Vue</strong>：Vue 通过响应式系统和模板编译自动更新组件。</li>\n<li><strong>React</strong>：React 通过手动触发更新和生命周期方法控制组件的更新过程。</li>\n</ul>\n<h3 id=\"4-算法实现\"><a href=\"#4-算法实现\" class=\"headerlink\" title=\"4. 算法实现\"></a>4. 算法实现</h3><ul>\n<li><strong>Vue</strong>：Vue 的 diff 算法采用了双端比较的策略，即从两端同时遍历虚拟 DOM 树，尽量减少比较的次数。</li>\n<li><strong>React</strong>：React 的 diff 算法采用了单端比较的策略，即从顶部开始比较虚拟 DOM 树的节点，直到找到不同的节点为止。</li>\n</ul>\n<h3 id=\"5-key-的处理\"><a href=\"#5-key-的处理\" class=\"headerlink\" title=\"5. key 的处理\"></a>5. key 的处理</h3><ul>\n<li><strong>Vue</strong>：在列表渲染时，Vue 要求每个子元素都有一个唯一的 key 属性，以便更高效地更新和重用元素。</li>\n<li><strong>React</strong>：React 也推荐使用 key 来提高性能，但如果没有提供 key，React 会采用一种默认的 diff 算法来更新列表。</li>\n</ul>\n<p>总的来说，Vue 和 React 在虚拟 DOM 的 diff 算法上有一些区别，但目标都是为了提高性能和减少 DOM 操作的次数。选择使用哪个框架取决于具体的需求和个人偏好。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"React-组件命名推荐的方式是哪个？\"><a href=\"#React-组件命名推荐的方式是哪个？\" class=\"headerlink\" title=\"React 组件命名推荐的方式是哪个？\"></a>React 组件命名推荐的方式是哪个？</h2><p>React 组件的命名推荐遵循以下方式：</p>\n<h3 id=\"1-大写开头的帕斯卡命名法（PascalCase）\"><a href=\"#1-大写开头的帕斯卡命名法（PascalCase）\" class=\"headerlink\" title=\"1. 大写开头的帕斯卡命名法（PascalCase）\"></a>1. 大写开头的帕斯卡命名法（PascalCase）</h3><p>对于 React 组件，社区中最普遍接受的命名约定是使用帕斯卡命名法（PascalCase），即每个单词的首字母大写，不使用下划线或连字符。这种方式适用于所有类型的组件，无论是函数组件还是类组件。</p>\n<ul>\n<li><p><strong>函数组件</strong>：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">function MyComponent() &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre>\n</li>\n<li><p><strong>类组件</strong>：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class MyComponent extends React.Component &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"2-避免缩写\"><a href=\"#2-避免缩写\" class=\"headerlink\" title=\"2. 避免缩写\"></a>2. 避免缩写</h3><p>在命名组件时，应尽量避免使用缩写，除非该缩写是广为人知的。清晰的命名有助于其他开发者理解组件的用途。</p>\n<h3 id=\"3-描述性命名\"><a href=\"#3-描述性命名\" class=\"headerlink\" title=\"3. 描述性命名\"></a>3. 描述性命名</h3><p>组件的名称应该是描述性的，能够清楚地表明组件的用途或功能。</p>\n<h3 id=\"4-文件命名\"><a href=\"#4-文件命名\" class=\"headerlink\" title=\"4. 文件命名\"></a>4. 文件命名</h3><p>组件的文件名应与其组件名相匹配，也使用帕斯卡命名法。如果组件名为 <code>MyComponent</code>，则文件名应为 <code>MyComponent.js</code> 或 <code>MyComponent.jsx</code>。</p>\n<h3 id=\"5-组件的可复用性\"><a href=\"#5-组件的可复用性\" class=\"headerlink\" title=\"5. 组件的可复用性\"></a>5. 组件的可复用性</h3><p>如果你的组件是为了复用而设计的，那么它的命名应该反映出它的功能或特性，而不是特定的使用场景。</p>\n<h3 id=\"6-避免使用-HTML-元素名称\"><a href=\"#6-避免使用-HTML-元素名称\" class=\"headerlink\" title=\"6. 避免使用 HTML 元素名称\"></a>6. 避免使用 HTML 元素名称</h3><p>避免使用基本 HTML 元素的名称（如 <code>div</code>、<code>span</code>、<code>p</code> 等）作为组件名，除非你的组件确实是对这些元素的直接扩展。</p>\n<h3 id=\"7-避免使用过长的名称\"><a href=\"#7-避免使用过长的名称\" class=\"headerlink\" title=\"7. 避免使用过长的名称\"></a>7. 避免使用过长的名称</h3><p>尽管描述性很重要，但也应避免使用过长的组件名称。简洁而具有描述性的名称更易于阅读和维护。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总的来说，React 组件命名推荐使用大写开头的帕斯卡命名法，名称应该是描述性的、易于理解的，并且能够清晰地反映出组件的功能。这种方式有助于保持代码的一致性和可读性，使得其他开发者能够快速理解你的组件。</p>\n<h2 id=\"React-组建的设计原则或者设计思路是什么\"><a href=\"#React-组建的设计原则或者设计思路是什么\" class=\"headerlink\" title=\"React 组建的设计原则或者设计思路是什么\"></a>React 组建的设计原则或者设计思路是什么</h2><p>React 组件的设计原则和思路主要围绕以下几个核心概念：</p>\n<h3 id=\"1-单一职责原则（Single-Responsibility-Principle）\"><a href=\"#1-单一职责原则（Single-Responsibility-Principle）\" class=\"headerlink\" title=\"1. 单一职责原则（Single Responsibility Principle）\"></a>1. 单一职责原则（Single Responsibility Principle）</h3><p>每个组件应该只有一个引起它变化的原因。这意味着每个组件应该只负责页面的一小部分功能。</p>\n<h3 id=\"2-可复用性（Reusability）\"><a href=\"#2-可复用性（Reusability）\" class=\"headerlink\" title=\"2. 可复用性（Reusability）\"></a>2. 可复用性（Reusability）</h3><p>设计组件时，应该考虑到它们是否可以在不同的上下文中复用，以减少代码重复并提高开发效率。</p>\n<h3 id=\"3-封装性（Encapsulation）\"><a href=\"#3-封装性（Encapsulation）\" class=\"headerlink\" title=\"3. 封装性（Encapsulation）\"></a>3. 封装性（Encapsulation）</h3><p>组件应该封装自己的状态和行为，不应该让外部组件直接访问其内部状态，除非是通过明确的接口（如 props 和回调函数）。</p>\n<h3 id=\"4-组件分解（Component-Decomposition）\"><a href=\"#4-组件分解（Component-Decomposition）\" class=\"headerlink\" title=\"4. 组件分解（Component Decomposition）\"></a>4. 组件分解（Component Decomposition）</h3><p>将复杂的 UI 拆分成更小、更易管理的组件。这有助于降低复杂性，提高代码的可维护性。</p>\n<h3 id=\"5-保持简单（Keep-It-Simple）\"><a href=\"#5-保持简单（Keep-It-Simple）\" class=\"headerlink\" title=\"5. 保持简单（Keep It Simple）\"></a>5. 保持简单（Keep It Simple）</h3><p>尽量保持组件简单，避免在一个组件中做太多事情。简单的组件更容易理解、测试和维护。</p>\n<h3 id=\"6-可组合性（Composability）\"><a href=\"#6-可组合性（Composability）\" class=\"headerlink\" title=\"6. 可组合性（Composability）\"></a>6. 可组合性（Composability）</h3><p>设计组件时，应该考虑到它们如何与其他组件组合。组件应该是可组合的，以便可以轻松地将它们嵌套和组合，构建更复杂的 UI。</p>\n<h3 id=\"7-提高性能（Performance-Optimization）\"><a href=\"#7-提高性能（Performance-Optimization）\" class=\"headerlink\" title=\"7. 提高性能（Performance Optimization）\"></a>7. 提高性能（Performance Optimization）</h3><p>在设计组件时，考虑性能优化，例如避免不必要的渲染、使用 <code>React.memo</code>、<code>useMemo</code> 和 <code>useCallback</code> 来记忆计算结果和回调函数。</p>\n<h3 id=\"8-可访问性（Accessibility）\"><a href=\"#8-可访问性（Accessibility）\" class=\"headerlink\" title=\"8. 可访问性（Accessibility）\"></a>8. 可访问性（Accessibility）</h3><p>在设计组件时，确保它们是可访问的，遵循 WCAG 指南，使所有用户都能使用你的应用。</p>\n<h3 id=\"9-状态提升（Lifting-State-Up）\"><a href=\"#9-状态提升（Lifting-State-Up）\" class=\"headerlink\" title=\"9. 状态提升（Lifting State Up）\"></a>9. 状态提升（Lifting State Up）</h3><p>当多个组件需要共享状态时，将状态提升到这些组件的最近共同父组件中。</p>\n<h3 id=\"10-函数式组件和-Hooks\"><a href=\"#10-函数式组件和-Hooks\" class=\"headerlink\" title=\"10. 函数式组件和 Hooks\"></a>10. 函数式组件和 Hooks</h3><p>利用函数式组件和 Hooks 来管理状态和其他副作用，这使得组件更加简洁和易于理解。</p>\n<h3 id=\"11-Context-API\"><a href=\"#11-Context-API\" class=\"headerlink\" title=\"11. Context API\"></a>11. Context API</h3><p>对于深层次的组件树，使用 Context API 来避免逐层传递 props，特别是在需要跨组件共享数据时。</p>\n<h3 id=\"12-遵循-React-原则\"><a href=\"#12-遵循-React-原则\" class=\"headerlink\" title=\"12. 遵循 React 原则\"></a>12. 遵循 React 原则</h3><p>遵循 React 的原则，如避免直接操作 DOM，使用虚拟 DOM 来管理 UI 的变化。</p>\n<h3 id=\"13-清晰的数据流\"><a href=\"#13-清晰的数据流\" class=\"headerlink\" title=\"13. 清晰的数据流\"></a>13. 清晰的数据流</h3><p>确保组件之间的数据流是清晰的，通常通过 props 从父组件流向子组件，状态更新应该向上抛或通过上下文进行。</p>\n<h3 id=\"14-测试性（Testability）\"><a href=\"#14-测试性（Testability）\" class=\"headerlink\" title=\"14. 测试性（Testability）\"></a>14. 测试性（Testability）</h3><p>设计组件时，考虑到它们的测试性，编写可测试的组件可以简化测试过程，提高代码质量。</p>\n<p>通过遵循这些设计原则和思路，你可以创建出结构清晰、易于维护和复用的 React 组件。</p>\n<h2 id=\"react-19-版本解决了什么问题，增加了哪些东西\"><a href=\"#react-19-版本解决了什么问题，增加了哪些东西\" class=\"headerlink\" title=\"react 19 版本解决了什么问题，增加了哪些东西\"></a>react 19 版本解决了什么问题，增加了哪些东西</h2><p>React 19 版本带来了一系列重要的更新和改进，主要解决了以下问题并增加了以下特性：</p>\n<ol>\n<li><p><strong>Actions 异步操作的革命性改进</strong>：</p>\n<ul>\n<li>React 19 引入了 Actions，通过支持异步函数来管理数据变更、加载状态、错误处理和乐观更新，使复杂逻辑的处理变得更加简单。</li>\n</ul>\n</li>\n<li><p><strong>原生支持 Document Metadata</strong>：</p>\n<ul>\n<li>React 19 原生支持 <code>&lt;title&gt;</code>、<code>&lt;meta&gt;</code> 和 <code>&lt;link&gt;</code> 等文档元数据标签。这些标签可直接在组件中声明，React 会自动将它们提升至 <code>&lt;head&gt;</code>，并确保与服务端渲染和客户端渲染兼容。</li>\n</ul>\n</li>\n<li><p><strong>支持样式表优先级管理</strong>：</p>\n<ul>\n<li>通过指定 <code>precedence</code> 属性，React 19 可以动态调整样式表的插入顺序，确保正确的样式覆盖。</li>\n</ul>\n</li>\n<li><p><strong>Server Components 的稳定支持</strong>：</p>\n<ul>\n<li>Server Components 提供了一种全新的组件渲染模式，在服务器上提前渲染，减少了客户端的渲染负担。React 19 将此功能推向稳定，并引入了相关的 API 和最佳实践。</li>\n</ul>\n</li>\n<li><p><strong>更好的错误展示系统</strong>：</p>\n<ul>\n<li>React 19 改进了错误日志系统，减少了重复日志，并添加了更详细的调试信息。例如，对于 SSR 和客户端渲染不匹配的问题，提供了差异化日志。</li>\n</ul>\n</li>\n<li><p><strong>支持 <code>&lt;Context&gt;</code> 简写</strong>：</p>\n<ul>\n<li>React 19 引入了更简洁的 Context 写法，现在可以直接使用 <code>&lt;Context&gt;</code> 代替 <code>&lt;Context.Provider&gt;</code>。</li>\n</ul>\n</li>\n<li><p><strong>Async 脚本和资源预加载支持</strong>：</p>\n<ul>\n<li>React 19 为 <code>&lt;script&gt;</code> 标签添加了异步加载支持，同时优化了资源的预加载和预初始化功能。</li>\n</ul>\n</li>\n<li><p><strong>use API</strong>：</p>\n<ul>\n<li>React 19 引入了全新的 <code>use</code> API，用于在渲染期间读取资源。这种模式允许条件调用，并与 Suspense 结合使用，支持读取 Promise 或 Context。</li>\n</ul>\n</li>\n<li><p><strong>改进的错误处理</strong>：</p>\n<ul>\n<li>React 19 改进了错误处理机制，消除了重复错误记录，并提供了处理捕获和未捕获错误的选项。</li>\n</ul>\n</li>\n<li><p><strong>自定义元素支持</strong>：</p>\n<ul>\n<li>React 19 增加了对自定义元素的全面支持，并通过了 Custom Elements Everywhere 的所有测试，确保了 React 组件与 Web Components 标准无缝集成。</li>\n</ul>\n</li>\n</ol>\n<p>这些更新和改进显著提升了开发者的体验和应用的性能，使得 React 19 成为一个值得关注的版本。</p>\n<h2 id=\"react-实现一个全局的-dialog\"><a href=\"#react-实现一个全局的-dialog\" class=\"headerlink\" title=\"react 实现一个全局的 dialog\"></a>react 实现一个全局的 dialog</h2><p>在 React 中实现一个全局的对话框（Dialog）通常涉及到几个步骤：创建对话框组件、管理对话框的显示状态以及在需要时触发对话框。以下是一个简单的实现方案：</p>\n<h3 id=\"1-创建对话框组件\"><a href=\"#1-创建对话框组件\" class=\"headerlink\" title=\"1. 创建对话框组件\"></a>1. 创建对话框组件</h3><p>首先，创建一个对话框组件，它接收必要的 props 来控制显示和关闭对话框，以及传递需要显示的内容。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; Dialog.js\nimport React from &quot;react&quot;;\n\nconst Dialog &#x3D; (&#123; isOpen, onClose, children &#125;) &#x3D;&gt; &#123;\n  if (!isOpen) return null;\n\n  return (\n    &lt;div className&#x3D;&quot;dialog-overlay&quot;&gt;\n      &lt;div className&#x3D;&quot;dialog&quot;&gt;\n        &#123;children&#125;\n        &lt;button onClick&#x3D;&#123;onClose&#125;&gt;Close&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nexport default Dialog;</code></pre>\n\n<h3 id=\"2-创建上下文和钩子\"><a href=\"#2-创建上下文和钩子\" class=\"headerlink\" title=\"2. 创建上下文和钩子\"></a>2. 创建上下文和钩子</h3><p>使用 React 的 Context API 创建一个上下文来管理对话框的状态，并创建一个钩子来方便地触发对话框。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; DialogContext.js\nimport React, &#123; useState, useContext &#125; from &quot;react&quot;;\n\nconst DialogContext &#x3D; React.createContext();\n\nexport const useDialog &#x3D; () &#x3D;&gt; useContext(DialogContext);\n\nexport const DialogProvider &#x3D; (&#123; children &#125;) &#x3D;&gt; &#123;\n  const [isOpen, setIsOpen] &#x3D; useState(false);\n\n  const openDialog &#x3D; () &#x3D;&gt; setIsOpen(true);\n  const closeDialog &#x3D; () &#x3D;&gt; setIsOpen(false);\n\n  return (\n    &lt;DialogContext.Provider value&#x3D;&#123;&#123; isOpen, openDialog, closeDialog &#125;&#125;&gt;\n      &#123;children&#125;\n      &lt;Dialog isOpen&#x3D;&#123;isOpen&#125; onClose&#x3D;&#123;closeDialog&#125; &#x2F;&gt;\n    &lt;&#x2F;DialogContext.Provider&gt;\n  );\n&#125;;</code></pre>\n\n<h3 id=\"3-包裹应用的根组件\"><a href=\"#3-包裹应用的根组件\" class=\"headerlink\" title=\"3. 包裹应用的根组件\"></a>3. 包裹应用的根组件</h3><p>在你的应用的根组件中使用 <code>DialogProvider</code> 来包裹整个应用，这样任何组件都可以访问对话框的上下文。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; index.js 或 App.js\nimport React from &quot;react&quot;;\nimport &#123; DialogProvider &#125; from &quot;.&#x2F;DialogContext&quot;;\nimport App from &quot;.&#x2F;App&quot;;\n\nconst Root &#x3D; () &#x3D;&gt; (\n  &lt;DialogProvider&gt;\n    &lt;App &#x2F;&gt;\n  &lt;&#x2F;DialogProvider&gt;\n);\n\nexport default Root;</code></pre>\n\n<h3 id=\"4-在任何组件中触发对话框\"><a href=\"#4-在任何组件中触发对话框\" class=\"headerlink\" title=\"4. 在任何组件中触发对话框\"></a>4. 在任何组件中触发对话框</h3><p>现在，在任何组件中，你可以使用 <code>useDialog</code> 钩子来控制对话框的显示。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; AnyComponent.js\nimport React from &quot;react&quot;;\nimport &#123; useDialog &#125; from &quot;.&#x2F;DialogContext&quot;;\n\nconst AnyComponent &#x3D; () &#x3D;&gt; &#123;\n  const &#123; openDialog &#125; &#x3D; useDialog();\n\n  return (\n    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; openDialog(&quot;Hello, this is a dialog!&quot;)&#125;&gt;\n      Open Dialog\n    &lt;&#x2F;button&gt;\n  );\n&#125;;\n\nexport default AnyComponent;</code></pre>\n\n<h3 id=\"5-样式\"><a href=\"#5-样式\" class=\"headerlink\" title=\"5. 样式\"></a>5. 样式</h3><p>你可能需要为对话框添加一些基本样式，以确保它看起来像一个模态框，并能够覆盖页面的其他部分。</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">&#x2F;* styles.css *&#x2F;\n.dialog-overlay &#123;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n&#125;\n\n.dialog &#123;\n  background: white;\n  padding: 20px;\n  border-radius: 5px;\n&#125;</code></pre>\n\n<p>确保引入这些样式到你的项目中。</p>\n<p>通过以上步骤，你可以在 React 应用中实现一个全局可访问的对话框组件，它可以在任何地方被触发，并能够统一管理对话框的状态。</p>\n<h2 id=\"对-React-和-Vue-的理解，它们的异同\"><a href=\"#对-React-和-Vue-的理解，它们的异同\" class=\"headerlink\" title=\"对 React 和 Vue 的理解，它们的异同\"></a>对 React 和 Vue 的理解，它们的异同</h2><p>React 和 Vue 都是流行的前端 JavaScript 框架，用于构建用户界面和单页应用（SPA）。它们有许多共同点，但也存在一些关键的差异。以下是对 React 和 Vue 的理解和它们的异同：</p>\n<h3 id=\"共同点：\"><a href=\"#共同点：\" class=\"headerlink\" title=\"共同点：\"></a>共同点：</h3><ol>\n<li><p><strong>组件化</strong>：</p>\n<ul>\n<li>两者都支持组件化开发，允许开发者将 UI 分解成可复用的独立组件。</li>\n</ul>\n</li>\n<li><p><strong>响应式数据绑定</strong>：</p>\n<ul>\n<li>React 和 Vue 都提供了响应式数据绑定，当数据变化时，视图会自动更新。</li>\n</ul>\n</li>\n<li><p><strong>虚拟 DOM</strong>：</p>\n<ul>\n<li>两者都使用虚拟 DOM 来提高性能，通过比较虚拟 DOM 树来最小化实际 DOM 的操作。</li>\n</ul>\n</li>\n<li><p><strong>现代 JavaScript</strong>：</p>\n<ul>\n<li>它们都支持现代 JavaScript（ES6+）特性，如箭头函数、解构赋值等。</li>\n</ul>\n</li>\n<li><p><strong>社区和生态系统</strong>：</p>\n<ul>\n<li>React 和 Vue 都有庞大的社区和生态系统，提供了大量的第三方库和工具。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"差异：\"><a href=\"#差异：\" class=\"headerlink\" title=\"差异：\"></a>差异：</h3><ol>\n<li><p><strong>API 设计</strong>：</p>\n<ul>\n<li><strong>Vue</strong> 提供了更简单直观的 API，特别是对于初学者来说，Vue 的模板语法和易用性是一个优势。</li>\n<li><strong>React</strong> 有一个更陡峭的学习曲线，API 设计更倾向于函数式编程和 JSX，这对于一些开发者来说可能需要时间适应。</li>\n</ul>\n</li>\n<li><p><strong>模板与 JSX</strong>：</p>\n<ul>\n<li><strong>Vue</strong> 使用基于 HTML 的模板语法，可以更容易地与现有的 HTML 和 CSS 集成。</li>\n<li><strong>React</strong> 使用 JSX，这是一种看起来像 HTML 的 JavaScript 语法扩展，需要转换步骤（如使用 Babel）。</li>\n</ul>\n</li>\n<li><p><strong>响应式系统</strong>：</p>\n<ul>\n<li><strong>Vue</strong> 提供了更丰富的响应式系统，包括计算属性、侦听器和 watchers。</li>\n<li><strong>React</strong> 通过状态提升和上下文（Context）API 来处理跨组件的状态共享。</li>\n</ul>\n</li>\n<li><p><strong>服务器端渲染（SSR）</strong>：</p>\n<ul>\n<li><strong>Vue</strong> 通过 Nuxt.js 提供了一个完整的 SSR 解决方案。</li>\n<li><strong>React</strong> 通过 Next.js 提供了 SSR 支持，但 React 本身也支持 SSR。</li>\n</ul>\n</li>\n<li><p><strong>状态管理</strong>：</p>\n<ul>\n<li><strong>Vue</strong> 提供了 Vuex 作为官方的状态管理解决方案。</li>\n<li><strong>React</strong> 有 Redux，虽然不是官方的，但它是 React 社区中最流行的状态管理库。</li>\n</ul>\n</li>\n<li><p><strong>性能优化</strong>：</p>\n<ul>\n<li><strong>Vue</strong> 提供了如<code>v-if</code>、<code>v-show</code>和<code>v-memo</code>等指令来进行性能优化。</li>\n<li><strong>React</strong> 提供了<code>React.memo</code>、<code>useMemo</code>和<code>useCallback</code>等 Hooks 来进行性能优化。</li>\n</ul>\n</li>\n<li><p><strong>类型支持</strong>：</p>\n<ul>\n<li><strong>Vue</strong> 3 改进了对 TypeScript 的支持，但社区中 TypeScript 的使用不如 React 广泛。</li>\n<li><strong>React</strong> 从 Facebook 起源，Facebook 对 TypeScript 的支持使得 React 社区中 TypeScript 的使用更为普遍。</li>\n</ul>\n</li>\n<li><p><strong>扩展性</strong>：</p>\n<ul>\n<li><strong>Vue</strong> 提供了如指令、混入、过滤器等扩展机制。</li>\n<li><strong>React</strong> 通过 Hooks 和高阶组件（HOCs）提供了扩展性。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，React 和 Vue 都是强大的前端框架，选择哪一个取决于项目需求、团队熟悉度和个人偏好。Vue 通常被认为更简单易学，而 React 提供了更灵活的 API 和广泛的生态系统。两者都能胜任构建复杂的前端应用。</p>\n<h2 id=\"在-React-中页面重新加载时怎样保留数据？\"><a href=\"#在-React-中页面重新加载时怎样保留数据？\" class=\"headerlink\" title=\"在 React 中页面重新加载时怎样保留数据？\"></a>在 React 中页面重新加载时怎样保留数据？</h2><p>在 React 中，页面重新加载时保留数据可以通过以下几种方法实现：</p>\n<h3 id=\"1-使用浏览器的-localStorage-或-sessionStorage\"><a href=\"#1-使用浏览器的-localStorage-或-sessionStorage\" class=\"headerlink\" title=\"1. 使用浏览器的 localStorage 或 sessionStorage\"></a>1. 使用浏览器的 <code>localStorage</code> 或 <code>sessionStorage</code></h3><p><code>localStorage</code> 和 <code>sessionStorage</code> 提供了一种在浏览器端存储数据的方式。数据存储在其中可以跨会话（<code>localStorage</code>）或仅在单个会话中（<code>sessionStorage</code>）保持。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 存储数据\nlocalStorage.setItem(&quot;myData&quot;, JSON.stringify(someData));\n\n&#x2F;&#x2F; 读取数据\nconst storedData &#x3D; JSON.parse(localStorage.getItem(&quot;myData&quot;));</code></pre>\n\n<h3 id=\"2-使用-cookies\"><a href=\"#2-使用-cookies\" class=\"headerlink\" title=\"2. 使用 cookies\"></a>2. 使用 <code>cookies</code></h3><p>Cookies 可以用于存储少量数据，并在页面加载时读取。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 设置 cookie\ndocument.cookie &#x3D; &#96;myData&#x3D;$&#123;encodeURIComponent(\n  JSON.stringify(someData)\n)&#125;; path&#x3D;&#x2F;&#96;;\n\n&#x2F;&#x2F; 读取 cookie\nconst cookies &#x3D; document.cookie;\nconst myDataCookie &#x3D; cookies\n  .split(&quot;; &quot;)\n  .find((row) &#x3D;&gt; row.startsWith(&quot;myData&#x3D;&quot;));\nconst myData &#x3D; myDataCookie\n  ? JSON.parse(decodeURIComponent(myDataCookie.split(&quot;&#x3D;&quot;)[1]))\n  : null;</code></pre>\n\n<h3 id=\"3-使用-IndexedDB\"><a href=\"#3-使用-IndexedDB\" class=\"headerlink\" title=\"3. 使用 IndexedDB\"></a>3. 使用 <code>IndexedDB</code></h3><p>对于更复杂的数据存储需求，可以使用 <code>IndexedDB</code>。这是一个运行在浏览器中的非关系型数据库。</p>\n<h3 id=\"4-使用-redux-persist-或其他状态持久化库\"><a href=\"#4-使用-redux-persist-或其他状态持久化库\" class=\"headerlink\" title=\"4. 使用 redux-persist 或其他状态持久化库\"></a>4. 使用 <code>redux-persist</code> 或其他状态持久化库</h3><p>如果你使用 Redux 来管理应用状态，可以使用 <code>redux-persist</code> 这样的库来自动将 Redux 状态树持久化到 <code>localStorage</code> 或 <code>IndexedDB</code>。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; createStore &#125; from &quot;redux&quot;;\nimport &#123; persistStore, persistReducer &#125; from &quot;redux-persist&quot;;\nimport storage from &quot;redux-persist&#x2F;lib&#x2F;storage&quot;; &#x2F;&#x2F; defaults to localStorage for web\n\nconst persistConfig &#x3D; &#123;\n  key: &quot;root&quot;,\n  storage,\n&#125;;\n\nconst persistedReducer &#x3D; persistReducer(persistConfig, reducer);\n\nexport const store &#x3D; createStore(persistedReducer);\nexport const persistor &#x3D; persistStore(store);</code></pre>\n\n<h3 id=\"5-使用-window-name\"><a href=\"#5-使用-window-name\" class=\"headerlink\" title=\"5. 使用 window.name\"></a>5. 使用 <code>window.name</code></h3><p><code>window.name</code> 可以用于在相同域的不同页面加载之间传递数据。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 设置 window.name\nwindow.name &#x3D; JSON.stringify(someData);\n\n&#x2F;&#x2F; 在新页面中读取 window.name\nconst storedData &#x3D; JSON.parse(window.name);</code></pre>\n\n<h3 id=\"6-使用服务器端存储\"><a href=\"#6-使用服务器端存储\" class=\"headerlink\" title=\"6. 使用服务器端存储\"></a>6. 使用服务器端存储</h3><p>如果数据敏感或需要跨多个设备共享，可以将数据存储在服务器端。当页面加载时，从服务器获取数据。</p>\n<h3 id=\"7-使用-URL-参数\"><a href=\"#7-使用-URL-参数\" class=\"headerlink\" title=\"7. 使用 URL 参数\"></a>7. 使用 URL 参数</h3><p>对于小量数据，可以将数据编码后附加到 URL 参数中。这适用于页面间的直接传递，但不适用于页面刷新。</p>\n<h3 id=\"注意事项-34\"><a href=\"#注意事项-34\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>存储在浏览器端的数据（如 <code>localStorage</code>、<code>sessionStorage</code>、<code>cookies</code>）有大小限制，通常为 5MB 左右。</li>\n<li>存储在客户端的数据（如 <code>localStorage</code>）容易被用户清除，且安全性不如服务器端存储。</li>\n<li>对于敏感数据，始终考虑安全性和加密。</li>\n</ul>\n<p>根据你的具体需求和数据的敏感性，选择最合适的方法来在页面重新加载时保留数据。</p>\n<h2 id=\"React-必须使用-JSX-吗？\"><a href=\"#React-必须使用-JSX-吗？\" class=\"headerlink\" title=\"React 必须使用 JSX 吗？\"></a>React 必须使用 JSX 吗？</h2><p>React <strong>不是必须的</strong>使用 JSX，但它是 React 开发中最常用的语法。JSX 提供了一种编写 React 组件的方式，它允许你在 JavaScript 中直接编写类似 HTML 的标记。JSX 最终会被编译成 JavaScript 对象，这些对象描述了你想要渲染的 UI。</p>\n<h3 id=\"为什么使用-JSX？\"><a href=\"#为什么使用-JSX？\" class=\"headerlink\" title=\"为什么使用 JSX？\"></a>为什么使用 JSX？</h3><ol>\n<li><strong>可读性</strong>：JSX 提供了一种更直观的方式来描述 UI，特别是对于有 HTML 背景的开发者来说。</li>\n<li><strong>组件重用</strong>：JSX 使得在组件中嵌套和重用其他组件变得简单。</li>\n<li><strong>集成 HTML 和 JavaScript</strong>：JSX 允许你将 HTML 结构和 JavaScript 逻辑结合在一起，这使得状态和 UI 的管理更加集中。</li>\n</ol>\n<h3 id=\"不使用-JSX\"><a href=\"#不使用-JSX\" class=\"headerlink\" title=\"不使用 JSX\"></a>不使用 JSX</h3><p>如果你更喜欢不使用 JSX，React 也允许你使用纯 JavaScript 来编写组件。你可以使用 <code>React.createElement()</code> 方法来创建元素，这是一种不使用 JSX 的替代方法。</p>\n<p>下面是一个不使用 JSX 的 React 组件示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import React from &quot;react&quot;;\n\nfunction App() &#123;\n  return React.createElement(\n    &quot;div&quot;,\n    &#123; className: &quot;app&quot; &#125;,\n    React.createElement(&quot;h1&quot;, null, &quot;Hello, world!&quot;)\n  );\n&#125;\n\nexport default App;</code></pre>\n\n<p>在这个例子中，<code>React.createElement()</code> 方法接受三个参数：要创建的元素类型、元素的属性（如 <code>className</code>），以及子元素。</p>\n<h3 id=\"使用-React-createElement-的优缺点\"><a href=\"#使用-React-createElement-的优缺点\" class=\"headerlink\" title=\"使用 React.createElement 的优缺点\"></a>使用 <code>React.createElement</code> 的优缺点</h3><p><strong>优点</strong>：</p>\n<ul>\n<li><strong>兼容性</strong>：在一些环境（如某些服务器环境）中，可能不支持 JSX，这时使用 <code>React.createElement</code> 是一个好选择。</li>\n<li><strong>清晰度</strong>：对于某些开发者来说，使用 <code>React.createElement</code> 可能更清晰地展示了 React 的组件化本质。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>可读性</strong>：对于习惯了 HTML 的开发者来说，<code>React.createElement</code> 的可读性不如 JSX。</li>\n<li><strong>代码量</strong>：使用 <code>React.createElement</code> 通常会导致更多的样板代码。</li>\n</ul>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>虽然 React 不强制使用 JSX，但在大多数开发场景中，JSX 提供了一种更高效和直观的方式来构建 React 应用。如果你出于某种原因选择不使用 JSX，React 也提供了替代方案，但大多数情况下，JSX 是 React 开发中的主流选择。</p>\n<h2 id=\"为什么使用-jsx-的组件中没有看到使用-react-却需要引入-react？\"><a href=\"#为什么使用-jsx-的组件中没有看到使用-react-却需要引入-react？\" class=\"headerlink\" title=\"为什么使用 jsx 的组件中没有看到使用 react 却需要引入 react？\"></a>为什么使用 jsx 的组件中没有看到使用 react 却需要引入 react？</h2><p>在 JSX 中使用组件时，尽管代码看起来像是在直接使用 HTML 标签，但实际上 JSX 最终会被编译成 JavaScript 对象和函数调用。这就是为什么即使在 JSX 中没有显式地写出 <code>React</code>，也需要引入 <code>React</code> 的原因。</p>\n<p>以下是几个关键点解释为什么需要引入 <code>React</code>：</p>\n<h3 id=\"1-JSX-编译过程\"><a href=\"#1-JSX-编译过程\" class=\"headerlink\" title=\"1. JSX 编译过程\"></a>1. JSX 编译过程</h3><p>JSX 本质上是一种语法糖，它需要被编译成 JavaScript 代码。Babel 是一个常用的工具，用来将 JSX 代码转换为普通的 JavaScript 代码。在编译过程中，JSX 标签会被转换成 <code>React.createElement</code> 函数调用。</p>\n<p>例如，以下 JSX 代码：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React from &quot;react&quot;;\n\nconst element &#x3D; &lt;div className&#x3D;&quot;my-div&quot;&gt;Hello, World!&lt;&#x2F;div&gt;;</code></pre>\n\n<p>会被 Babel 编译成：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import React from &quot;react&quot;;\n\nconst element &#x3D; React.createElement(\n  &quot;div&quot;,\n  &#123; className: &quot;my-div&quot; &#125;,\n  &quot;Hello, World!&quot;\n);</code></pre>\n\n<p>在这个编译过程中，<code>React.createElement</code> 函数是必需的，因此需要引入 <code>React</code>。</p>\n<h3 id=\"2-JSX-表达式\"><a href=\"#2-JSX-表达式\" class=\"headerlink\" title=\"2. JSX 表达式\"></a>2. JSX 表达式</h3><p>在 JSX 中，你可以像在 JavaScript 中一样使用表达式。这些表达式需要在编译后的代码中被正确地处理，这通常涉及到 <code>React</code> 的其他功能，如 <code>React.Component</code>、<code>React.Fragment</code> 等。</p>\n<h3 id=\"3-JSX-与-React-特性\"><a href=\"#3-JSX-与-React-特性\" class=\"headerlink\" title=\"3. JSX 与 React 特性\"></a>3. JSX 与 React 特性</h3><p>JSX 代码中经常使用到 React 的特性，如组件、状态（state）、属性（props）等。这些特性在 JSX 中的使用都是基于 <code>React</code> 的 API 实现的。</p>\n<h3 id=\"4-组件和钩子（Hooks）\"><a href=\"#4-组件和钩子（Hooks）\" class=\"headerlink\" title=\"4. 组件和钩子（Hooks）\"></a>4. 组件和钩子（Hooks）</h3><p>如果你在 JSX 中使用自定义组件或 React 的钩子（如 <code>useState</code>、<code>useEffect</code>），这些都需要 <code>React</code> 的支持。自定义组件本质上是函数或类，它们调用 <code>React.createElement</code> 来渲染子组件。钩子则是函数调用，它们依赖于 <code>React</code> 的内部状态和副作用管理机制。</p>\n<h3 id=\"5-兼容性和环境要求\"><a href=\"#5-兼容性和环境要求\" class=\"headerlink\" title=\"5. 兼容性和环境要求\"></a>5. 兼容性和环境要求</h3><p>在某些环境（如 Node.js 服务器环境）中，可能默认不支持 JSX。在这些环境中运行 JSX 代码之前，需要确保 <code>React</code> 被引入，并且 JSX 代码被正确编译。</p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>即使在 JSX 代码中没有直接使用 <code>React</code>，<code>React</code> 也是必需的，因为它提供了 JSX 编译、组件生命周期、状态管理、钩子等核心功能。引入 <code>React</code> 是为了确保 JSX 代码能够被正确编译和执行，以及访问 React 提供的各种特性和 API。</p>\n<h2 id=\"React-中的高阶组件运用了什么设计模式？\"><a href=\"#React-中的高阶组件运用了什么设计模式？\" class=\"headerlink\" title=\"React 中的高阶组件运用了什么设计模式？\"></a>React 中的高阶组件运用了什么设计模式？</h2><p>React 中的高阶组件（HOC）运用了几种设计模式，主要包括：</p>\n<h3 id=\"1-函数式编程理念\"><a href=\"#1-函数式编程理念\" class=\"headerlink\" title=\"1. 函数式编程理念\"></a>1. 函数式编程理念</h3><p>HOC 的核心思想来自于函数式编程中的“高阶函数”概念。在函数式编程中，高阶函数可以接受一个函数作为参数或返回一个新的函数。HOC 将这个概念应用到组件上，接收一个组件作为参数，通过包装和增强后返回一个新的组件。</p>\n<h3 id=\"2-装饰器模式\"><a href=\"#2-装饰器模式\" class=\"headerlink\" title=\"2. 装饰器模式\"></a>2. 装饰器模式</h3><p>HOC 是 React 中装饰器模式的一个应用。装饰器模式允许在不修改原有对象的情况下，通过包装的方式动态地为对象添加新功能。HOC 通过创建一个外层组件，包装传入的组件，为其提供额外的功能。</p>\n<h3 id=\"3-组件抽象与逻辑复用\"><a href=\"#3-组件抽象与逻辑复用\" class=\"headerlink\" title=\"3. 组件抽象与逻辑复用\"></a>3. 组件抽象与逻辑复用</h3><p>HOC 允许将组件的某些功能抽象出来，形成可复用的函数，从而避免重复编写相似的代码。这种模式使得组件的扩展和复用变得更加灵活和方便。</p>\n<h3 id=\"4-属性代理模式\"><a href=\"#4-属性代理模式\" class=\"headerlink\" title=\"4. 属性代理模式\"></a>4. 属性代理模式</h3><p>HOC 可以将 props 从父组件传递到子组件，并可以添加、修改或删除 props。这种模式允许动态地改变组件的属性和行为。</p>\n<h3 id=\"5-控制反转模式\"><a href=\"#5-控制反转模式\" class=\"headerlink\" title=\"5. 控制反转模式\"></a>5. 控制反转模式</h3><p>HOC 可以控制其子组件的渲染过程，决定何时以及如何渲染。这种模式允许在不改变组件内部逻辑的情况下，对组件的渲染进行更细粒度的控制。</p>\n<p>总结来说，React 的高阶组件（HOC）主要运用了函数式编程理念、装饰器模式、组件抽象与逻辑复用等设计模式，以实现代码的复用和组件功能的扩展。这些模式使得 HOC 成为 React 中一个强大的工具，用于提升组件的复用性和功能的扩展性。</p>\n","feature":true,"text":"组件基础React 事件机制 新的事件委托机制： &#x2F;&#x2F; React 18+ 的事件绑定示例 const App &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 事件处理器 const handleClick &#x3D; (e...","link":"","photos":[],"count_time":{"symbolsCount":"169k","symbolsTime":"2:33"},"categories":[{"name":"interview","slug":"interview","count":5,"path":"api/categories/interview.json"}],"tags":[{"name":"react","slug":"react","count":1,"path":"api/tags/react.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">组件基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">React 事件机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84-HTML-%E4%BA%8B%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">React 的事件和普通的 HTML 事件有什么不同？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E4%BA%8B%E4%BB%B6%E4%B8%8E-HTML-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">React 事件与 HTML 事件的主要区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%80%8E%E4%B9%88%E5%81%9A%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%9F%E5%AE%83%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">React 组件中怎么做事件代理？它的原理是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">事件代理的实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">实现方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">工作流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8A%BF%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">优势特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">最佳实践</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9-React-Fiber-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">对 React-Fiber 的理解，它解决了什么问题？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fiber-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">Fiber 架构的本质</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">解决的核心问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">渲染阻塞</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">优先级调度</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fiber-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Fiber 的工作原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83%E5%88%87%E7%89%87\"><span class=\"toc-text\">工作单元切片</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">主要特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">实际应用优势</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%B5%81%E7%95%85%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">更流畅的用户体验</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B\"><span class=\"toc-text\">未来展望</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E7%BA%AF%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">React 纯组件是什么，有什么作用？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%AF%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">纯组件的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">基本使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">主要作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">性能优化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B1%95%E7%A4%BA%E5%9E%8B%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">展示型组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E9%A1%B9%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">列表项组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2\"><span class=\"toc-text\">注意事项</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E5%86%85%E8%81%94%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">避免内联对象和函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">性能比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6-vs-%E7%BA%AF%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">普通组件 vs 纯组件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Component-Element-Instance-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F\"><span class=\"toc-text\">Component, Element, Instance 之间有什么区别和联系？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Component%E3%80%81Element-%E5%92%8C-Instance-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Component、Element 和 Instance 的基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Component%EF%BC%88%E7%BB%84%E4%BB%B6%EF%BC%89\"><span class=\"toc-text\">Component（组件）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Element%EF%BC%88%E5%85%83%E7%B4%A0%EF%BC%89\"><span class=\"toc-text\">Element（元素）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Instance%EF%BC%88%E5%AE%9E%E4%BE%8B%EF%BC%89\"><span class=\"toc-text\">Instance（实例）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">三者之间的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">创建过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7\"><span class=\"toc-text\">函数组件的特殊性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">使用场景的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Component-%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Component 的使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Element-%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Element 的使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Instance-%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">Instance 的应用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%92%8C%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E9%80%82%E7%94%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">React 高阶组件是什么，和普通组件有什么区别，适用什么场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">高阶组件的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">基本实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">与普通组件的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA\"><span class=\"toc-text\">功能增强</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">适用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">条件渲染</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">数据获取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">属性代理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA-HOC\"><span class=\"toc-text\">组合多个 HOC</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BC%9A%E8%A7%A6%E5%8F%91-React-%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%EF%BC%9F%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93-render-%E4%BC%9A%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">触发重新渲染的方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#State-%E6%9B%B4%E6%96%B0%E8%A7%A6%E5%8F%91\"><span class=\"toc-text\">State 更新触发</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Props-%E5%8F%98%E5%8C%96%E8%A7%A6%E5%8F%91\"><span class=\"toc-text\">Props 变化触发</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Context-%E6%9B%B4%E6%96%B0%E8%A7%A6%E5%8F%91\"><span class=\"toc-text\">Context 更新触发</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">重渲染过程中的工作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%B0%83%E5%92%8C%E9%98%B6%E6%AE%B5-Reconciliation\"><span class=\"toc-text\">1. 调和阶段(Reconciliation)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%8F%90%E4%BA%A4%E9%98%B6%E6%AE%B5-Commit\"><span class=\"toc-text\">2. 提交阶段(Commit)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">3. 渲染优化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">React 如何判断什么时候重新渲染组件？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E5%88%A4%E6%96%AD%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">React 判断重新渲染的机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E7%9A%84%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">触发重新渲染的条件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E7%9A%84%E6%B8%B2%E6%9F%93%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">默认的渲染行为</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">性能优化方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-React-memo\"><span class=\"toc-text\">使用 React.memo</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-useMemo\"><span class=\"toc-text\">使用 useMemo</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-useCallback\"><span class=\"toc-text\">使用 useCallback</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E6%B8%B2%E6%9F%93%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">避免不必要渲染的最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87%E5%92%8C%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86\"><span class=\"toc-text\">状态提升和组件拆分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-children-prop\"><span class=\"toc-text\">使用 children prop</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E5%A3%B0%E6%98%8E%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">React 声明组件有哪几种方法，有什么不同？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">React 组件声明的主要方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89\"><span class=\"toc-text\">函数组件（推荐）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">类组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">两种方式的主要区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">状态管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86\"><span class=\"toc-text\">生命周期处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">函数组件的优势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8C-Hooks\"><span class=\"toc-text\">使用函数组件和 Hooks</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">对有状态组件和无状态组件的理解及使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">有状态组件和无状态组件的基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%88%E5%B1%95%E7%A4%BA%E5%9E%8B%E7%BB%84%E4%BB%B6%EF%BC%89\"><span class=\"toc-text\">无状态组件（展示型组件）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%88%E5%AE%B9%E5%99%A8%E5%9E%8B%E7%BB%84%E4%BB%B6%EF%BC%89\"><span class=\"toc-text\">有状态组件（容器型组件）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1\"><span class=\"toc-text\">使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">无状态组件适用场景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">有状态组件适用场景</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-3\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">组件拆分原则</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9-React-%E4%B8%AD-Fragment-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">对 React 中 Fragment 的理解，它的使用场景是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fragment-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Fragment 的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">基本使用方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">主要使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">返回多个元素</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93-1\"><span class=\"toc-text\">条件渲染</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">列表渲染</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%A6-key-%E7%9A%84-Fragment\"><span class=\"toc-text\">带 key 的 Fragment</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1\"><span class=\"toc-text\">性能优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-8\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E5%AF%B9%E5%BA%94%E7%9A%84-DOM-%E5%85%83%E7%B4%A0%EF%BC%9F\"><span class=\"toc-text\">React 如何获取组件对应的 DOM 元素？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E8%8E%B7%E5%8F%96-DOM-%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">React 获取 DOM 元素的方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-useRef-Hook\"><span class=\"toc-text\">使用 useRef Hook</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E8%B0%83-Refs\"><span class=\"toc-text\">回调 Refs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E5%8F%91-Refs\"><span class=\"toc-text\">转发 Refs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA-Refs-%E7%9A%84%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">多个 Refs 的管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">常见使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E5%8D%95%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">表单操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AA%92%E4%BD%93%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">媒体控制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-9\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9-React-%E7%9A%84%E6%8F%92%E6%A7%BD-Portals-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">对 React 的插槽(Portals)的理解，如何使用，有哪些使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Portals-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Portals 的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-1\"><span class=\"toc-text\">基本使用方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1\"><span class=\"toc-text\">常见使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A8%A1%E6%80%81%E6%A1%86\"><span class=\"toc-text\">1. 模态框</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%8F%90%E7%A4%BA%E6%A1%86%E5%92%8C%E9%80%9A%E7%9F%A5\"><span class=\"toc-text\">2. 提示框和通知</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%82%AC%E6%B5%AE%E6%8F%90%E7%A4%BA\"><span class=\"toc-text\">3. 悬浮提示</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%A4%84%E7%90%86\"><span class=\"toc-text\">事件冒泡处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-10\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-4\"><span class=\"toc-text\">最佳实践</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8-React-%E4%B8%AD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-render%EF%BC%9F\"><span class=\"toc-text\">在 React 中如何避免不必要的 render？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-React-memo-%E4%BC%98%E5%8C%96%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">使用 React.memo 优化函数组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-useMemo-%E7%BC%93%E5%AD%98%E8%AE%A1%E7%AE%97%E5%80%BC\"><span class=\"toc-text\">使用 useMemo 缓存计算值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-useCallback-%E7%BC%93%E5%AD%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">使用 useCallback 缓存函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%90%86%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">合理拆分组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-children-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">使用 children 属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">使用状态管理工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E5%86%85%E8%81%94%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0-1\"><span class=\"toc-text\">避免内联对象和函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-React-lazy-%E5%92%8C-Suspense\"><span class=\"toc-text\">使用 React.lazy 和 Suspense</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-11\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9-React-context-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对 React context 的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Context 的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-2\"><span class=\"toc-text\">基本使用方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81-Context\"><span class=\"toc-text\">动态 Context</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-2\"><span class=\"toc-text\">性能优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-5\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89-Hook\"><span class=\"toc-text\">创建自定义 Hook</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2\"><span class=\"toc-text\">常见使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">主题切换</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-12\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE\"><span class=\"toc-text\">使用建议</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">React 中什么是受控组件和非控组件？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">受控组件和非受控组件的概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">受控组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">非受控组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">受控组件示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86\"><span class=\"toc-text\">表单处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">非受控组件示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\"><span class=\"toc-text\">文件上传</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">选择使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">适合使用受控组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">适合使用非受控组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-6\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">混合使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-13\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%B8%AD-ref-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\"><span class=\"toc-text\">React 中 ref 的作用是什么？有哪些应用场景？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ref-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Ref 的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建和使用方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-useRef-Hook-1\"><span class=\"toc-text\">使用 useRef Hook</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">常见应用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%AE%A1%E7%90%86%E7%84%A6%E7%82%B9\"><span class=\"toc-text\">1. 管理焦点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AA%92%E4%BD%93%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">2. 媒体控制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\"><span class=\"toc-text\">3. 集成第三方库</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">高级用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BD%AC%E5%8F%91-Ref\"><span class=\"toc-text\">转发 Ref</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E8%B0%83-Ref\"><span class=\"toc-text\">回调 Ref</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-7\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8-Ref\"><span class=\"toc-text\">合理使用 Ref</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-14\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-forwardRef-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">React.forwardRef 是什么？它有什么作用？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-forwardRef-%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">React.forwardRef 的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-1\"><span class=\"toc-text\">基本使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1\"><span class=\"toc-text\">常见应用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">封装表单组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%BD%AC%E5%8F%91-refs\"><span class=\"toc-text\">高阶组件中转发 refs</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">使用注意事项</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E5%92%8C%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">命名和调试</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E8%BD%AC%E5%8F%91\"><span class=\"toc-text\">条件转发</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-8\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">组合使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-15\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">类组件与函数组件有什么异同？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">类组件与函数组件的主要区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">语法形式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">状态管理方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8-Hooks\"><span class=\"toc-text\">函数组件使用 Hooks</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8-this-state\"><span class=\"toc-text\">类组件使用 this.state</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86-1\"><span class=\"toc-text\">生命周期处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">函数组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">性能优化方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-1\"><span class=\"toc-text\">函数组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">共同点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8A%BF-1\"><span class=\"toc-text\">函数组件的优势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-9\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8C-Hooks-1\"><span class=\"toc-text\">使用函数组件和 Hooks</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-16\"><span class=\"toc-text\">注意事项</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">数据管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-setState-%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">React setState 调用的原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#setState-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">setState 的基本原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">执行流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">批量更新机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">更新优先级</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">内部实现机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-17\"><span class=\"toc-text\">注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-10\"><span class=\"toc-text\">最佳实践</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-setState-%E8%B0%83%E7%94%A8%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%EF%BC%9F\"><span class=\"toc-text\">React setState 调用之后发生了什么？是同步还是异步？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#setState-%E8%B0%83%E7%94%A8%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">setState 调用后的执行流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">基本流程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">异步更新机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%B9%E5%A4%84%E7%90%86%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">批处理示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">同步更新场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5\"><span class=\"toc-text\">特殊情况</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-18-%E7%9A%84%E8%87%AA%E5%8A%A8%E6%89%B9%E5%A4%84%E7%90%86\"><span class=\"toc-text\">React 18 的自动批处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%9F%E4%B8%80%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">统一行为</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-11\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">状态更新</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-18\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%B8%AD%E7%9A%84-setState-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">React 中的 setState 批量更新的过程是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#setState-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">setState 批量更新的工作原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B-1\"><span class=\"toc-text\">基本流程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%B9%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">批处理机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97%E5%A4%84%E7%90%86\"><span class=\"toc-text\">更新队列处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-18-%E7%9A%84%E8%87%AA%E5%8A%A8%E6%89%B9%E5%A4%84%E7%90%86-1\"><span class=\"toc-text\">React 18 的自动批处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Promise-%E4%B8%AD%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86\"><span class=\"toc-text\">Promise 中的批处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">优化策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">函数式更新</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-19\"><span class=\"toc-text\">注意事项</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E7%9B%B4%E6%8E%A5%E4%BE%9D%E8%B5%96%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%80%BC\"><span class=\"toc-text\">避免直接依赖更新后的值</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-12\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%90%86%E7%BB%84%E7%BB%87%E6%9B%B4%E6%96%B0%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">合理组织更新逻辑</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E7%BB%84%E4%BB%B6%E7%9A%84-state-%E5%92%8C-props-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">React 组件的 state 和 props 有什么区别？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#State-%E5%92%8C-Props-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">State 和 Props 的基本区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#State%EF%BC%88%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%EF%BC%89\"><span class=\"toc-text\">State（内部状态）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Props%EF%BC%88%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">Props（外部属性）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">主要区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E6%9D%83\"><span class=\"toc-text\">1. 数据控制权</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8F%AF%E5%8F%98%E6%80%A7\"><span class=\"toc-text\">2. 可变性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2\"><span class=\"toc-text\">使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#State-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">State 适用场景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Props-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">Props 适用场景</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-13\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">状态提升</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-20\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%B8%AD%E7%9A%84-props-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AA%E8%AF%BB%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">React 中的 props 为什么是只读的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Props-%E5%8F%AA%E8%AF%BB%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Props 只读性的设计原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81\"><span class=\"toc-text\">单向数据流</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%A2%84%E6%B5%8B%E6%80%A7\"><span class=\"toc-text\">保证数据的可预测性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E5%89%AF%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">避免副作用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%90%E9%AB%98%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7\"><span class=\"toc-text\">提高组件的可复用性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%AF%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">纯组件设计</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%BF%E4%BA%8E%E8%B0%83%E8%AF%95%E5%92%8C%E7%BB%B4%E6%8A%A4\"><span class=\"toc-text\">便于调试和维护</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B8%85%E6%99%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91\"><span class=\"toc-text\">清晰的数据流向</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-3\"><span class=\"toc-text\">性能优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E5%AE%B9%E6%98%93%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">更容易实现浅比较</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-14\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87-1\"><span class=\"toc-text\">状态提升</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%B8%AD%E6%80%8E%E4%B9%88%E6%A3%80%E9%AA%8C-props%EF%BC%9F%E9%AA%8C%E8%AF%81-props-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">React 中怎么检验 props？验证 props 的目的是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Props-%E9%AA%8C%E8%AF%81%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">Props 验证的方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-PropTypes\"><span class=\"toc-text\">使用 PropTypes</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%AA%8C%E8%AF%81%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">常用的验证类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">基础类型验证</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">复杂类型验证</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">对象结构验证</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E5%99%A8\"><span class=\"toc-text\">自定义验证器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E8%A7%84%E5%88%99%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">复杂规则验证</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Props-%E9%AA%8C%E8%AF%81%E7%9A%84%E7%9B%AE%E7%9A%84\"><span class=\"toc-text\">Props 验证的目的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-15\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">默认值设置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E9%AA%8C%E8%AF%81%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">常见验证场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">数组元素验证</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-21\"><span class=\"toc-text\">注意事项</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">组件通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">父子组件的通信方式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">React 父子组件通信的主要方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Props-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%EF%BC%88%E7%88%B6%E4%BC%A0%E5%AD%90%EF%BC%89\"><span class=\"toc-text\">1. Props 传递数据（父传子）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%88%E5%AD%90%E4%BC%A0%E7%88%B6%EF%BC%89\"><span class=\"toc-text\">2. 回调函数（子传父）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Ref-%E5%BC%95%E7%94%A8%EF%BC%88%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">3. Ref 引用（父组件调用子组件方法）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">4. 状态提升</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Children-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">5. Children 属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-16\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">组件通信封装</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-22\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E7%BA%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">跨级组件的通信方式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E7%BA%A7%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">跨级组件通信的主要方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Context-API\"><span class=\"toc-text\">1. Context API</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%87%AA%E5%AE%9A%E4%B9%89-Hook-%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">2. 自定义 Hook 封装</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3. 发布订阅模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Redux-%E6%88%96%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4. Redux 或其他状态管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-17\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%90%86%E9%80%89%E6%8B%A9%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">合理选择通信方式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-23\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%B5%8C%E5%A5%97%E5%85%B3%E7%B3%BB%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">非嵌套关系组件的通信方式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%B5%8C%E5%A5%97%E5%85%B3%E7%B3%BB%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">非嵌套关系组件通信的主要方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Context-API-1\"><span class=\"toc-text\">1. Context API</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">2. 状态管理工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F-1\"><span class=\"toc-text\">3. 发布订阅模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%87%AA%E5%AE%9A%E4%B9%89-Hooks\"><span class=\"toc-text\">4. 自定义 Hooks</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-18\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">组合使用多种方式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-24\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-props-%E5%B1%82%E7%BA%A7%E8%BF%87%E6%B7%B1%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">如何解决 props 层级过深的问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3-Props-%E5%B1%82%E7%BA%A7%E8%BF%87%E6%B7%B1%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">解决 Props 层级过深的方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-Context-API\"><span class=\"toc-text\">1. 使用 Context API</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">2. 使用状态管理工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Redux-%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">Redux 示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%BB%84%E4%BB%B6%E7%BB%84%E5%90%88\"><span class=\"toc-text\">3. 组件组合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-children-%E5%B1%9E%E6%80%A7-1\"><span class=\"toc-text\">使用 children 属性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%87%AA%E5%AE%9A%E4%B9%89-Hooks-1\"><span class=\"toc-text\">4. 自定义 Hooks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B1%E4%BA%AB%E9%80%BB%E8%BE%91%E5%92%8C%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">共享逻辑和状态</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86\"><span class=\"toc-text\">5. 组件拆分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%90%86%E7%9A%84%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">合理的组件结构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-19\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">合理使用多种方案</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-25\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">组件通信的方式有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">React 组件通信的主要方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Props-%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">1. Props 父子通信</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Context-%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">2. Context 跨层级通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">3. 状态管理工具</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4. 发布订阅模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Ref-%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">5. Ref 通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-20\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">选择合适的通信方式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-26\"><span class=\"toc-text\">注意事项</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">路由</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV6-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">React-RouterV6 的实现原理是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-V6-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">React Router V6 的核心原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E-History-API\"><span class=\"toc-text\">基于 History API</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">主要组件实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Routes-%E5%92%8C-Route\"><span class=\"toc-text\">Routes 和 Route</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">路由匹配机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">路径匹配</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E8%88%AA%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">导航功能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#useNavigate-Hook\"><span class=\"toc-text\">useNavigate Hook</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86\"><span class=\"toc-text\">嵌套路由处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Outlet-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">Outlet 组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">路由守卫实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">权限控制</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-React-RouterV6-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">如何配置 React-RouterV6 实现路由切换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-V6-%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">React Router V6 的基本配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">基础路由设置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">嵌套路由配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Outlet\"><span class=\"toc-text\">使用 Outlet</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">动态路由参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">参数配置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA\"><span class=\"toc-text\">路由导航</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Link-%E5%92%8C-NavLink\"><span class=\"toc-text\">Link 和 NavLink</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA\"><span class=\"toc-text\">编程式导航</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#useNavigate-Hook-1\"><span class=\"toc-text\">useNavigate Hook</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB\"><span class=\"toc-text\">路由守卫</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6-1\"><span class=\"toc-text\">权限控制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-21\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">路由配置文件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-27\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV6-%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9F\"><span class=\"toc-text\">React-RouterV6 怎么设置重定向？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-V6-%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">React Router V6 重定向的实现方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-Navigate-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">1. 使用 Navigate 组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">条件重定向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%8D%AE%E7%8A%B6%E6%80%81%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">根据状态重定向</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E5%BC%8F%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">编程式重定向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-useNavigate-Hook\"><span class=\"toc-text\">使用 useNavigate Hook</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">默认路由重定向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-index-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">使用 index 属性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#404-%E9%A1%B5%E9%9D%A2%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">404 页面重定向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%85%8D%E7%AC%A6%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">通配符路由</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-22\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">组合使用多种重定向方式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-28\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-routerV6-%E9%87%8C%E7%9A%84-Link-%E6%A0%87%E7%AD%BE%E5%92%8C-a-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">react-routerV6 里的 Link 标签和 a 标签的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Link-%E6%A0%87%E7%AD%BE%E5%92%8C-a-%E6%A0%87%E7%AD%BE%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Link 标签和 a 标签的主要区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%B7%AF%E7%94%B1%E8%A1%8C%E4%B8%BA%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">1. 路由行为不同</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2. 事件处理机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Link-%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Link 的内部实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81\"><span class=\"toc-text\">3. 状态保持</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Link-%E4%BF%9D%E6%8C%81%E5%BA%94%E7%94%A8%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">Link 保持应用状态</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">4. 路由参数传递</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Link-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">Link 的高级用法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E5%92%8C%E6%BF%80%E6%B4%BB%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">5. 路由匹配和激活状态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#NavLink-%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">NavLink 的使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-23\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8-1\"><span class=\"toc-text\">组合使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-29\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV6-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-URL-%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E5%8E%86%E5%8F%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">React-RouterV6 如何获取 URL 的参数和历史对象？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-V6-%E8%8E%B7%E5%8F%96-URL-%E5%8F%82%E6%95%B0%E5%92%8C%E5%8E%86%E5%8F%B2%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">React Router V6 获取 URL 参数和历史对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-useParams-%E8%8E%B7%E5%8F%96-URL-%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">1. 使用 useParams 获取 URL 参数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8-useSearchParams-%E8%8E%B7%E5%8F%96%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2. 使用 useSearchParams 获取查询参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8-useLocation-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">3. 使用 useLocation 获取当前位置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8-useNavigate-%E8%BF%9B%E8%A1%8C%E5%AF%BC%E8%88%AA\"><span class=\"toc-text\">4. 使用 useNavigate 进行导航</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-24\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-hooks\"><span class=\"toc-text\">组合使用多个 hooks</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">处理嵌套路由参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-30\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV6-%E6%80%8E%E6%A0%B7%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%8F%98%E5%8C%96%E6%97%B6%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%EF%BC%9F\"><span class=\"toc-text\">React-RouterV6 怎样在路由变化时重新渲染同一个组件？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-V6-%E8%8E%B7%E5%8F%96-URL-%E5%8F%82%E6%95%B0%E5%92%8C%E5%8E%86%E5%8F%B2%E5%AF%B9%E8%B1%A1-1\"><span class=\"toc-text\">React Router V6 获取 URL 参数和历史对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-useParams-%E8%8E%B7%E5%8F%96-URL-%E5%8F%82%E6%95%B0-1\"><span class=\"toc-text\">1. 使用 useParams 获取 URL 参数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8-useSearchParams-%E8%8E%B7%E5%8F%96%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0-1\"><span class=\"toc-text\">2. 使用 useSearchParams 获取查询参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8-useLocation-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE-1\"><span class=\"toc-text\">3. 使用 useLocation 获取当前位置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8-useNavigate-%E8%BF%9B%E8%A1%8C%E5%AF%BC%E8%88%AA-1\"><span class=\"toc-text\">4. 使用 useNavigate 进行导航</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-25\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-hooks-1\"><span class=\"toc-text\">组合使用多个 hooks</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0-1\"><span class=\"toc-text\">处理嵌套路由参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-31\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV6-%E7%9A%84%E8%B7%AF%E7%94%B1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">React-RouterV6 的路由有几种模式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-V6-%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">React Router V6 的路由模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-BrowserRouter%EF%BC%88History-%E6%A8%A1%E5%BC%8F%EF%BC%89\"><span class=\"toc-text\">1. BrowserRouter（History 模式）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-HashRouter%EF%BC%88Hash-%E6%A8%A1%E5%BC%8F%EF%BC%89\"><span class=\"toc-text\">2. HashRouter（Hash 模式）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-MemoryRouter%EF%BC%88%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F%EF%BC%89\"><span class=\"toc-text\">3. MemoryRouter（内存模式）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%84%E6%A8%A1%E5%BC%8F%E7%89%B9%E7%82%B9%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">各模式特点比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#BrowserRouter\"><span class=\"toc-text\">BrowserRouter</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#HashRouter\"><span class=\"toc-text\">HashRouter</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-26\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">选择合适的路由模式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-32\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV6-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F\"><span class=\"toc-text\">React-RouterV6 如何实现动态路由？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-V6-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">React Router V6 动态路由实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E6%9C%AC%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1. 基本动态路由配置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B5%8C%E5%A5%97%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">2. 嵌套动态路由</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Outlet-1\"><span class=\"toc-text\">使用 Outlet</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">3. 动态生成路由</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">基于数据生成路由</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%9D%A1%E4%BB%B6%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">4. 条件路由</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E6%9D%83%E9%99%90%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">基于权限的动态路由</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">5. 动态加载组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-React-lazy\"><span class=\"toc-text\">使用 React.lazy</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-27\"><span class=\"toc-text\">最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">路由配置管理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-33\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV6-%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">React-RouterV6 路由懒加载有哪些方式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-RouterV6-%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F-1\"><span class=\"toc-text\">React-RouterV6 路由懒加载有哪些方式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-React-lazy-%E5%92%8C-Suspense-1\"><span class=\"toc-text\">使用 React.lazy 和 Suspense</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-loadable-%E5%BA%93\"><span class=\"toc-text\">使用 loadable 库</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV6-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">React-RouterV6 如何实现权限控制？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA-Route-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">创建 Route 组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA\"><span class=\"toc-text\">添加路由拦截</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6-2\"><span class=\"toc-text\">权限控制</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-RouterV7-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">React-RouterV7 新特性有哪些？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Router-V7-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">React-Router V7 新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Remix-%E9%9B%86%E6%88%90\"><span class=\"toc-text\">Remix 集成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E-Vite-%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8\"><span class=\"toc-text\">基于 Vite 的编译器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E5%B9%85%E6%94%B9%E8%BF%9B%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">大幅改进的类型安全</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%94%AF%E6%8C%81-HMR-%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">支持 HMR 的开发环境</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%9A%84-API-%E5%92%8C%E6%94%B9%E8%BF%9B%E7%9A%84%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">新的 API 和改进的文档</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">示例代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Redux-Toolkit\"><span class=\"toc-text\">Redux-Toolkit</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9-Redux-Toolkit-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">对 Redux-Toolkit 的理解，主要解决什么问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%85%8D%E7%BD%AE%E5%A4%8D%E6%9D%82%E6%80%A7\"><span class=\"toc-text\">1. 配置复杂性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Reducer-%E5%92%8C-Action-%E7%9A%84%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2. Reducer 和 Action 的样板代码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%BC%82%E6%AD%A5%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86\"><span class=\"toc-text\">3. 异步逻辑处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7%E5%92%8C%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7\"><span class=\"toc-text\">4. 状态管理的可读性和可维护性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">5. 性能优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E5%BC%80%E5%8F%91%E8%80%85%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">6. 开发者体验</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-TypeScript-%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">7. TypeScript 支持</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">示例代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redux-Toolkit-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Redux-Toolkit 原理及工作流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redux-Toolkit-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-1\"><span class=\"toc-text\">Redux-Toolkit 原理及工作流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1. 核心原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">2. 工作流程</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redux-Toolkit-%E4%B8%AD%E5%BC%82%E6%AD%A5%E7%9A%84%E8%AF%B7%E6%B1%82%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86\"><span class=\"toc-text\">Redux-Toolkit 中异步的请求怎么处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redux-Toolkit-%E4%B8%AD%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86\"><span class=\"toc-text\">Redux-Toolkit 中异步请求处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5-Thunk\"><span class=\"toc-text\">1. 创建异步 Thunk</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9C%A8-Slice-%E4%B8%AD%E4%BD%BF%E7%94%A8-extraReducers\"><span class=\"toc-text\">2. 在 Slice 中使用 extraReducers</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%88%86%E6%B4%BE%E5%BC%82%E6%AD%A5-action\"><span class=\"toc-text\">3. 在组件中分派异步 action</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">4. 处理异步请求的结果</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Redux-Toolkit-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8C%E5%8F%98%E9%87%8F%E6%8C%82%E8%BD%BD%E5%88%B0-window-%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Redux-Toolkit 状态管理器和变量挂载到 window 中有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mobox-%E5%92%8C-zustand-%E5%92%8C-redux-toolkit-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">mobox 和 zustand 和 redux-toolkit 有什么区别？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Hooks\"><span class=\"toc-text\">Hooks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9-React-Hook-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">对 React Hook 的理解，它的实现原理是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Hook-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">React Hook 的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81-Hooks\"><span class=\"toc-text\">主要 Hooks</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hooks-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Hooks 的实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Render-Phase-and-Commit-Phase\"><span class=\"toc-text\">1. Render Phase and Commit Phase</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Double-Buffering-Technique\"><span class=\"toc-text\">2. Double-Buffering Technique</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Hook-Array\"><span class=\"toc-text\">3. Hook Array</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Hook-Order\"><span class=\"toc-text\">4. Hook Order</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-useState-%E5%92%8C-useEffect\"><span class=\"toc-text\">5. useState 和 useEffect</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1\"><span class=\"toc-text\">6. 闭包陷阱</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-useState-%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">为什么 useState 要使用数组而不是对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-useState-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">为什么 useState 返回数组而不是对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%81%BF%E5%85%8D%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. 避免闭包问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E6%98%8E%E7%A1%AE%E7%9A%84%E6%9B%B4%E6%96%B0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2. 提供一个明确的更新函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BF%9D%E6%8C%81-Hook-%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7\"><span class=\"toc-text\">3. 保持 Hook 调用的一致性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E9%81%BF%E5%85%8D%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">4. 避免对象属性的冲突</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E4%B8%8E-useReducer-%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7\"><span class=\"toc-text\">5. 与 useReducer 的兼容性</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-Hooks-%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">React Hooks 解决了哪些问题？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%9C%A8%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. 状态管理在函数组件中的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E5%92%8C%E9%80%BB%E8%BE%91%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">2. 代码复用和逻辑重构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7\"><span class=\"toc-text\">3. 生命周期方法的复杂性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">4. 组件性能优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Context%EF%BC%89%E4%BC%A0%E9%80%92%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7\"><span class=\"toc-text\">5. 上下文（Context）传递的复杂性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E5%92%8C%E5%8F%AF%E8%AF%BB%E6%80%A7\"><span class=\"toc-text\">6. 代码组织和可读性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E9%81%BF%E5%85%8D%E2%80%9Cthis%E2%80%9D%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">7. 避免“this”关键字的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E6%80%81%E5%92%8C%E5%BA%93%E7%9A%84%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">8. 函数组件的生态和库的支持</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-Hook-%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">React Hook 的使用限制有哪些？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1. 只能在函数组件中使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%81%BF%E5%85%8D%E5%9C%A8%E5%BE%AA%E7%8E%AF%E3%80%81%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-Hooks\"><span class=\"toc-text\">2. 避免在循环、条件语句和嵌套函数中调用 Hooks</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8F%AA%E8%83%BD%E5%9C%A8%E8%B0%83%E7%94%A8%E6%A0%88%E9%A1%B6%E9%83%A8%E8%B0%83%E7%94%A8-Hooks\"><span class=\"toc-text\">3. 只能在调用栈顶部调用 Hooks</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%B8%8D%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84-DevTools-%E4%B8%AD%E8%A7%82%E5%AF%9F%E5%88%B0-Hooks-%E7%9A%84%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">4. 不能在浏览器的 DevTools 中观察到 Hooks 的变化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E8%87%AA%E5%AE%9A%E4%B9%89-Hooks-%E7%9A%84%E5%8F%82%E6%95%B0%E5%BA%94%E8%AF%A5%E6%98%AF%E7%A8%B3%E5%AE%9A%E7%9A%84\"><span class=\"toc-text\">5. 自定义 Hooks 的参数应该是稳定的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E9%81%BF%E5%85%8D%E5%9C%A8-useEffect-%E4%B8%AD%E6%89%A7%E8%A1%8C%E9%95%BF%E6%97%B6%E9%97%B4%E8%BF%90%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">6. 避免在 useEffect 中执行长时间运行的操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-useEffect-%E7%9A%84%E6%B8%85%E7%90%86%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">7. useEffect 的清理函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-useEffect-%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">8. useEffect 的依赖项列表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-useReducer-%E7%9A%84%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91\"><span class=\"toc-text\">9. useReducer 的性能考虑</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-useContext-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">10. useContext 的性能优化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#useEffect-%E4%B8%8E-useLayoutEffect-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">useEffect 与 useLayoutEffect 的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect\"><span class=\"toc-text\">useEffect</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useLayoutEffect\"><span class=\"toc-text\">useLayoutEffect</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">性能影响</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F-DOM\"><span class=\"toc-text\">虚拟 DOM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E8%99%9A%E6%8B%9F-DOM-%E4%B8%BB%E8%A6%81%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%E8%99%9A%E6%8B%9F-DOM-%E6%9C%AC%E8%BA%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">虚拟 DOM 的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F-DOM-%E6%9C%AC%E8%BA%AB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">虚拟 DOM 本身是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F-DOM-%E4%B8%BB%E8%A6%81%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">虚拟 DOM 主要做了什么</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-diff-%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">React diff 算法的原理是什么？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-Diff-%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">React Diff 算法的原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BB%84%E4%BB%B6%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">1. 组件比较</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%85%83%E7%B4%A0%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">2. 元素比较</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AD%90%E8%8A%82%E7%82%B9%E6%AF%94%E8%BE%83%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89\"><span class=\"toc-text\">3. 子节点比较（递归）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4. 优化策略</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E9%99%90%E5%88%B6\"><span class=\"toc-text\">5. 限制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">6. 启发式算法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-key-%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%EF%BC%9Fkey-%E4%B8%BB%E8%A6%81%E6%98%AF%E8%A7%A3%E5%86%B3%E5%93%AA%E4%B8%80%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84\"><span class=\"toc-text\">React key 是什么 为什么要加？key 主要是解决哪一类问题的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-key-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">React key 是什么</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0-key\"><span class=\"toc-text\">为什么要加 key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key-%E4%B8%BB%E8%A6%81%E6%98%AF%E8%A7%A3%E5%86%B3%E5%93%AA%E4%B8%80%E7%B1%BB%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">key 主要是解决哪一类问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E5%BC%95%E5%85%A5%E4%B8%8E%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%94%9F-DOM-%E7%9B%B8%E6%AF%94%EF%BC%8C%E5%93%AA%E4%B8%80%E4%B8%AA%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%87%8F%E5%B0%91%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C-DOM-%E7%9A%84%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">1. 减少直接操作 DOM 的次数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">2. 批量更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">3. 跨平台能力</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81\"><span class=\"toc-text\">4. 避免不必要的重绘和回流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">5. 优化性能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%8F%AF%E9%A2%84%E6%B5%8B%E6%80%A7\"><span class=\"toc-text\">6. 可预测性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E7%AE%80%E5%8C%96%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">7. 简化状态管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E4%BB%A3%E7%A0%81%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7\"><span class=\"toc-text\">8. 代码可维护性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%B8%8E-Vue-%E7%9A%84-diff-%E7%AE%97%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">React 与 Vue 的 diff 算法有何不同？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">1. 性能优化策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2. 实现方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">3. 更新机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4. 算法实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-key-%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">5. key 的处理</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E7%BB%84%E4%BB%B6%E5%91%BD%E5%90%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F\"><span class=\"toc-text\">React 组件命名推荐的方式是哪个？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%A4%A7%E5%86%99%E5%BC%80%E5%A4%B4%E7%9A%84%E5%B8%95%E6%96%AF%E5%8D%A1%E5%91%BD%E5%90%8D%E6%B3%95%EF%BC%88PascalCase%EF%BC%89\"><span class=\"toc-text\">1. 大写开头的帕斯卡命名法（PascalCase）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%81%BF%E5%85%8D%E7%BC%A9%E5%86%99\"><span class=\"toc-text\">2. 避免缩写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%8F%8F%E8%BF%B0%E6%80%A7%E5%91%BD%E5%90%8D\"><span class=\"toc-text\">3. 描述性命名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D\"><span class=\"toc-text\">4. 文件命名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7\"><span class=\"toc-text\">5. 组件的可复用性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-HTML-%E5%85%83%E7%B4%A0%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">6. 避免使用 HTML 元素名称</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%BF%87%E9%95%BF%E7%9A%84%E5%90%8D%E7%A7%B0\"><span class=\"toc-text\">7. 避免使用过长的名称</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E7%BB%84%E5%BB%BA%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%88%96%E8%80%85%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">React 组建的设计原则或者设计思路是什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88Single-Responsibility-Principle%EF%BC%89\"><span class=\"toc-text\">1. 单一职责原则（Single Responsibility Principle）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%EF%BC%88Reusability%EF%BC%89\"><span class=\"toc-text\">2. 可复用性（Reusability）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%88Encapsulation%EF%BC%89\"><span class=\"toc-text\">3. 封装性（Encapsulation）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E4%BB%B6%E5%88%86%E8%A7%A3%EF%BC%88Component-Decomposition%EF%BC%89\"><span class=\"toc-text\">4. 组件分解（Component Decomposition）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BF%9D%E6%8C%81%E7%AE%80%E5%8D%95%EF%BC%88Keep-It-Simple%EF%BC%89\"><span class=\"toc-text\">5. 保持简单（Keep It Simple）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7%EF%BC%88Composability%EF%BC%89\"><span class=\"toc-text\">6. 可组合性（Composability）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%88Performance-Optimization%EF%BC%89\"><span class=\"toc-text\">7. 提高性能（Performance Optimization）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%EF%BC%88Accessibility%EF%BC%89\"><span class=\"toc-text\">8. 可访问性（Accessibility）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87%EF%BC%88Lifting-State-Up%EF%BC%89\"><span class=\"toc-text\">9. 状态提升（Lifting State Up）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E5%92%8C-Hooks\"><span class=\"toc-text\">10. 函数式组件和 Hooks</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-Context-API\"><span class=\"toc-text\">11. Context API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E9%81%B5%E5%BE%AA-React-%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">12. 遵循 React 原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E6%B8%85%E6%99%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81\"><span class=\"toc-text\">13. 清晰的数据流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E6%B5%8B%E8%AF%95%E6%80%A7%EF%BC%88Testability%EF%BC%89\"><span class=\"toc-text\">14. 测试性（Testability）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-19-%E7%89%88%E6%9C%AC%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF\"><span class=\"toc-text\">react 19 版本解决了什么问题，增加了哪些东西</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#react-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E7%9A%84-dialog\"><span class=\"toc-text\">react 实现一个全局的 dialog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">1. 创建对话框组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E9%92%A9%E5%AD%90\"><span class=\"toc-text\">2. 创建上下文和钩子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8C%85%E8%A3%B9%E5%BA%94%E7%94%A8%E7%9A%84%E6%A0%B9%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3. 包裹应用的根组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%9C%A8%E4%BB%BB%E4%BD%95%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%A7%A6%E5%8F%91%E5%AF%B9%E8%AF%9D%E6%A1%86\"><span class=\"toc-text\">4. 在任何组件中触发对话框</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%A0%B7%E5%BC%8F\"><span class=\"toc-text\">5. 样式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9-React-%E5%92%8C-Vue-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BC%82%E5%90%8C\"><span class=\"toc-text\">对 React 和 Vue 的理解，它们的异同</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E5%90%8C%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">共同点：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%AE%E5%BC%82%EF%BC%9A\"><span class=\"toc-text\">差异：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8-React-%E4%B8%AD%E9%A1%B5%E9%9D%A2%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%80%8E%E6%A0%B7%E4%BF%9D%E7%95%99%E6%95%B0%E6%8D%AE%EF%BC%9F\"><span class=\"toc-text\">在 React 中页面重新加载时怎样保留数据？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84-localStorage-%E6%88%96-sessionStorage\"><span class=\"toc-text\">1. 使用浏览器的 localStorage 或 sessionStorage</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8-cookies\"><span class=\"toc-text\">2. 使用 cookies</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8-IndexedDB\"><span class=\"toc-text\">3. 使用 IndexedDB</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8-redux-persist-%E6%88%96%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E5%BA%93\"><span class=\"toc-text\">4. 使用 redux-persist 或其他状态持久化库</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BD%BF%E7%94%A8-window-name\"><span class=\"toc-text\">5. 使用 window.name</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">6. 使用服务器端存储</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E4%BD%BF%E7%94%A8-URL-%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">7. 使用 URL 参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-34\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-JSX-%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">React 必须使用 JSX 吗？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-JSX%EF%BC%9F\"><span class=\"toc-text\">为什么使用 JSX？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E4%BD%BF%E7%94%A8-JSX\"><span class=\"toc-text\">不使用 JSX</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-React-createElement-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">使用 React.createElement 的优缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-jsx-%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%B2%A1%E6%9C%89%E7%9C%8B%E5%88%B0%E4%BD%BF%E7%94%A8-react-%E5%8D%B4%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5-react%EF%BC%9F\"><span class=\"toc-text\">为什么使用 jsx 的组件中没有看到使用 react 却需要引入 react？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-JSX-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">1. JSX 编译过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-JSX-%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">2. JSX 表达式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-JSX-%E4%B8%8E-React-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">3. JSX 与 React 特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E4%BB%B6%E5%92%8C%E9%92%A9%E5%AD%90%EF%BC%88Hooks%EF%BC%89\"><span class=\"toc-text\">4. 组件和钩子（Hooks）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">5. 兼容性和环境要求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-2\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E8%BF%90%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">React 中的高阶组件运用了什么设计模式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%90%86%E5%BF%B5\"><span class=\"toc-text\">1. 函数式编程理念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2. 装饰器模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1%E4%B8%8E%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">3. 组件抽象与逻辑复用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%B1%9E%E6%80%A7%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4. 属性代理模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5. 控制反转模式</span></a></li></ol></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"computer-network","uid":"69f67c9618e4f6aaa1fdf4000b651c72","slug":"computer-network","date":"2024-12-29T06:16:28.000Z","updated":"2024-12-29T07:08:36.451Z","comments":true,"path":"api/articles/computer-network.json","keywords":null,"cover":"/images/interview-computer-network/cover.png","text":"HTTP 协议GET 和 POST 的请求的区别GET 和 POST 是 HTTP 协议中最常见的两种请求方法，它们在用途、安全性、数据大小限制等方面有显著的区别。下面用表格的形式来展示它们的主要差异： 特性 GET POST 用途 用于请求服务器发送特定资源。 用于向服务器发送...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[{"name":"interview","slug":"interview","count":5,"path":"api/categories/interview.json"}],"tags":[{"name":"computer-network","slug":"computer-network","count":1,"path":"api/tags/computer-network.json"}],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"interview-javascript","uid":"cf0441f16ce9f9e8f078668d5a3bf9e5","slug":"interview-javascript","date":"2024-12-28T06:44:24.000Z","updated":"2024-12-29T06:07:32.266Z","comments":true,"path":"api/articles/interview-javascript.json","keywords":null,"cover":"/images/interview-javascript/cover.png","text":"数据类型JavaScript 有哪些数据类型，它们的区别？在 JavaScript 中，数据类型主要分为两大类：基本数据类型（Primitive Types）和 引用数据类型（Reference Types）。以下是详细的分类和它们的区别： 1. 基本数据类型（Primitive...","link":"","photos":[],"count_time":{"symbolsCount":"150k","symbolsTime":"2:17"},"categories":[{"name":"interview","slug":"interview","count":5,"path":"api/categories/interview.json"}],"tags":[{"name":"javascript","slug":"javascript","count":1,"path":"api/tags/javascript.json"}],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}