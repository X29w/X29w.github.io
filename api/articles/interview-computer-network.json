{"title":"interview-computer-network","uid":"888bd5308fbcbb0b07f6bb2fddc55ca5","slug":"interview-computer-network","date":"2024-05-30T15:00:54.000Z","updated":"2024-06-10T10:05:39.455Z","comments":true,"path":"api/articles/interview-computer-network.json","keywords":null,"cover":null,"content":"<h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h2 id=\"GET和POST的请求的区别\"><a href=\"#GET和POST的请求的区别\" class=\"headerlink\" title=\"GET和POST的请求的区别\"></a>GET和POST的请求的区别</h2><ul>\n<li><strong>数据位置</strong>：GET请求将参数附加在URL中，作为查询字符串；POST请求将参数放在请求体（request body）中。</li>\n<li><strong>数据大小</strong>：GET请求受URL长度限制，不适合传输大量数据；POST请求理论上无大小限制，更适合大数据量传输。</li>\n<li><strong>幂等性</strong>：GET请求是幂等的，多次请求结果相同，不会改变服务器状态；POST请求不是幂等的，可能产生不同的副作用。</li>\n<li><strong>安全性</strong>：由于GET请求参数在URL中，易于被截取，相对不安全；POST请求相对更安全，但并非绝对安全，因为HTTP协议本身不加密。</li>\n<li><strong>缓存</strong>：GET请求可被浏览器缓存，POST请求不会被缓存，除非手动设置。</li>\n</ul>\n<h2 id=\"POST和PUT请求的区别\"><a href=\"#POST和PUT请求的区别\" class=\"headerlink\" title=\"POST和PUT请求的区别\"></a>POST和PUT请求的区别</h2><ul>\n<li><strong>目的</strong>：POST用于创建新资源，或在不确定资源是否存在时发送数据；PUT用于替换已有资源，要求资源已知且具有唯一标识。</li>\n<li><strong>幂等性</strong>：PUT是幂等的，多次执行具有相同效果，不会产生额外资源；POST不是幂等的，多次请求可能创建多个资源。</li>\n<li><strong>请求体</strong>：两者都通过请求体传递数据，但PUT请求要求携带完整的资源表示，而POST可以传递部分更新或新增数据。</li>\n</ul>\n<h2 id=\"常见的HTTP请求头和响应头\"><a href=\"#常见的HTTP请求头和响应头\" class=\"headerlink\" title=\"常见的HTTP请求头和响应头\"></a>常见的HTTP请求头和响应头</h2><p><strong>请求头</strong>：</p>\n<ul>\n<li><code>Accept</code>: 客户端能接受的响应内容类型。</li>\n<li><code>Content-Type</code>: 请求体的数据类型。</li>\n<li><code>Host</code>: 请求的主机名和端口号。</li>\n<li><code>User-Agent</code>: 发起请求的浏览器信息。</li>\n</ul>\n<p><strong>响应头</strong>：</p>\n<ul>\n<li><code>Content-Type</code>: 响应内容的MIME类型。</li>\n<li><code>Server</code>: 服务器软件的信息。</li>\n<li><code>Set-Cookie</code>: 服务器设置的Cookie信息。</li>\n<li><code>Location</code>: 重定向时的URL。</li>\n</ul>\n<h2 id=\"HTTP状态码304是多好还是少好\"><a href=\"#HTTP状态码304是多好还是少好\" class=\"headerlink\" title=\"HTTP状态码304是多好还是少好\"></a>HTTP状态码304是多好还是少好</h2><p>304状态码表示“未修改”，表示请求的资源未发生变化，可以直接使用缓存副本。从性能角度，304状态码多表明缓存机制工作良好，减少了不必要的数据传输，提升了效率。然而，如果过于频繁，可能意味着服务器端未正确设置缓存控制策略，导致不必要的验证请求。理想情况下，应当平衡缓存的有效期和验证频率，以达到最佳性能。</p>\n<h2 id=\"常见的HTTP请求方法\"><a href=\"#常见的HTTP请求方法\" class=\"headerlink\" title=\"常见的HTTP请求方法\"></a>常见的HTTP请求方法</h2><ul>\n<li>GET：请求指定资源。</li>\n<li>POST：提交数据，用于创建或更新资源。</li>\n<li>PUT：替换现有资源或创建新资源。</li>\n<li>DELETE：删除指定资源。</li>\n<li>HEAD：类似GET，但只返回头部信息，不返回主体内容。</li>\n<li>OPTIONS：请求服务器支持的HTTP方法。</li>\n<li>PATCH：部分更新资源。</li>\n</ul>\n<h2 id=\"put和patch的区别\"><a href=\"#put和patch的区别\" class=\"headerlink\" title=\"put和patch的区别\"></a>put和patch的区别</h2><p>PUT和PATCH都是HTTP协议中的方法，用于资源的更新，但它们之间存在几个关键区别：</p>\n<ol>\n<li><p><strong>更新范围</strong>:</p>\n<ul>\n<li><strong>PUT</strong>: 该方法用于替换整个资源。当你发送一个PUT请求时，你需要提供资源的所有字段，即使你只想修改其中的一部分。服务器会用请求中的数据完全替换现有资源的表示。如果某些字段没有在请求体中提供，服务器可能会将其视为应该被清除或设为默认值。</li>\n<li><strong>PATCH</strong>: 此方法用于对资源的部分属性进行更新。它允许客户端仅发送需要修改的那部分数据，而不是整个资源。服务器只会应用这些特定的更改，保持其它未提及属性不变。</li>\n</ul>\n</li>\n<li><p><strong>幂等性</strong>:</p>\n<ul>\n<li><strong>PUT</strong>: 是幂等的，意味着无论你执行多少次相同的PUT请求，资源的状态将保持一致。多次执行同一PUT请求，服务器上的资源状态不会有所不同，这使得PUT非常适合用于更新操作，因为它提供了可预见的结果。</li>\n<li><strong>PATCH</strong>: 不是严格的幂等操作。虽然PATCH请求可以被设计成幂等的，但实际上取决于实现。如果PATCH请求包含逻辑错误或条件判断，多次执行可能导致资源状态的不同变化，因此PATCH的幂等性依赖于具体的应用逻辑。</li>\n</ul>\n</li>\n<li><p><strong>安全性</strong>:</p>\n<ul>\n<li>两者都被认为是非安全方法，因为它们都可以改变服务器上的资源状态，但这在HTTP语境中指的是它们可能会产生副作用，而不是通常意义上的“不安全”。</li>\n</ul>\n</li>\n<li><p><strong>使用场景</strong>:</p>\n<ul>\n<li><strong>PUT</strong>通常用于更新整个资源，如替换一个用户的全部信息。</li>\n<li><strong>PATCH</strong>则更适合做增量更新，比如只修改用户的电话号码而不影响其他信息。</li>\n</ul>\n</li>\n</ol>\n<p>在选择使用PUT还是PATCH时，应考虑是否需要更新资源的全部属性，以及幂等性的需求。如果只需要更新资源的部分属性，使用PATCH会更加精确和高效；而如果需要替换整个资源，或幂等性是重要考量，则应使用PUT。</p>\n<h2 id=\"OPTIONS请求方法及使用场景\"><a href=\"#OPTIONS请求方法及使用场景\" class=\"headerlink\" title=\"OPTIONS请求方法及使用场景\"></a>OPTIONS请求方法及使用场景</h2><p>OPTIONS方法用于请求服务器告知其支持的所有HTTP方法及其它通信选项。常用于 CORS（跨源资源共享）预检请求，浏览器在正式发起跨域请求前，先发送一个OPTIONS请求来询问服务器是否允许特定的HTTP方法和头部信息。</p>\n<h2 id=\"HTTP-1-0-和-HTTP-1-1-之间的区别\"><a href=\"#HTTP-1-0-和-HTTP-1-1-之间的区别\" class=\"headerlink\" title=\"HTTP 1.0 和 HTTP 1.1 之间的区别\"></a>HTTP 1.0 和 HTTP 1.1 之间的区别</h2><ul>\n<li><strong>持久连接</strong>：HTTP 1.1引入了持久连接，允许复用TCP连接发送多个请求，减少连接建立和关闭的开销。</li>\n<li><strong>管道化</strong>：HTTP 1.1支持请求管道化，客户端可以在收到前一个请求的响应之前发送下一个请求。</li>\n<li><strong>Host头</strong>：HTTP 1.1引入了Host头字段，支持在同一IP上托管多个虚拟主机。</li>\n<li><strong>错误码和原因短语</strong>：HTTP 1.1扩展了状态码和原因短语。</li>\n</ul>\n<h2 id=\"HTTP-1-1-和-HTTP-2-0-的区别\"><a href=\"#HTTP-1-1-和-HTTP-2-0-的区别\" class=\"headerlink\" title=\"HTTP 1.1 和 HTTP 2.0 的区别\"></a>HTTP 1.1 和 HTTP 2.0 的区别</h2><ul>\n<li><strong>二进制分帧</strong>：HTTP&#x2F;2采用二进制格式而非文本，更高效地传输数据。</li>\n<li><strong>多路复用</strong>：同一连接上可以同时处理多个请求和响应，无需等待。</li>\n<li><strong>服务器推送</strong>：服务器可主动推送客户端未请求的资源。</li>\n<li><strong>头部压缩</strong>：HPACK算法压缩头部，减少带宽消耗。</li>\n<li><strong>优先级</strong>：支持请求优先级，优化资源加载顺序。</li>\n</ul>\n<h2 id=\"HTTP和HTTPS协议的区别\"><a href=\"#HTTP和HTTPS协议的区别\" class=\"headerlink\" title=\"HTTP和HTTPS协议的区别\"></a>HTTP和HTTPS协议的区别</h2><ul>\n<li><strong>安全性</strong>：HTTPS基于SSL&#x2F;TLS协议，对HTTP数据进行加密，提供了数据的安全传输。</li>\n<li><strong>端口</strong>：HTTP默认端口为80，HTTPS默认端口为443。</li>\n<li><strong>证书</strong>：HTTPS需要服务器配置证书，验证服务器身份，增强信任度。</li>\n</ul>\n<h2 id=\"GET方法URL长度限制的原因\"><a href=\"#GET方法URL长度限制的原因\" class=\"headerlink\" title=\"GET方法URL长度限制的原因\"></a>GET方法URL长度限制的原因</h2><p>GET方法的URL长度受限于浏览器和服务器对URL的最大长度处理能力，通常是因为历史原因和协议设计限制。过长的URL可能导致解析错误、缓存问题、日志记录问题或中间件不兼容。RFC规范建议但不强制最大长度，实际限制通常在2048到8192个字符之间。</p>\n<h2 id=\"当在浏览器中输入-Google-com-并按下回车之后发生了什么？\"><a href=\"#当在浏览器中输入-Google-com-并按下回车之后发生了什么？\" class=\"headerlink\" title=\"当在浏览器中输入 Google.com 并按下回车之后发生了什么？\"></a>当在浏览器中输入 Google.com 并按下回车之后发生了什么？</h2><ol>\n<li><strong>域名解析</strong>：浏览器查询DNS服务器，将域名解析为IP地址。</li>\n<li><strong>建立连接</strong>：使用TCP三次握手与服务器建立连接。</li>\n<li><strong>发送HTTP请求</strong>：浏览器构造并发送GET请求至服务器。</li>\n<li><strong>服务器处理</strong>：服务器处理请求，返回响应（HTML页面）。</li>\n<li><strong>浏览器解析</strong>：浏览器解析HTML，构建DOM树，加载CSS和执行JavaScript。</li>\n<li><strong>渲染页面</strong>：根据解析结果，渲染最终的可视化页面。</li>\n</ol>\n<h2 id=\"TCP的三次握手和四次挥手\"><a href=\"#TCP的三次握手和四次挥手\" class=\"headerlink\" title=\"TCP的三次握手和四次挥手\"></a>TCP的三次握手和四次挥手</h2><p>TCP（三次握手和四次挥手）是传输控制协议的两个重要过程，分别用于建立和终止连接。它们确保了数据传输的可靠性和准确性。以下是对这两个过程的详细解释：</p>\n<h3 id=\"三次握手（Three-Way-Handshake）\"><a href=\"#三次握手（Three-Way-Handshake）\" class=\"headerlink\" title=\"三次握手（Three-Way Handshake）\"></a>三次握手（Three-Way Handshake）</h3><p>三次握手是 TCP 建立连接的过程，涉及客户端和服务器之间的三个步骤。</p>\n<ol>\n<li><p><strong>第一次握手（SYN）</strong></p>\n<ul>\n<li>客户端向服务器发送一个 SYN（同步序列号）包，表示请求建立连接。该包包含一个初始序列号（Sequence Number）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Client: SYN, Seq &#x3D; X</code></pre>\n</li>\n<li><p><strong>第二次握手（SYN-ACK）</strong></p>\n<ul>\n<li>服务器收到 SYN 包后，回应一个 SYN-ACK 包。SYN 表示服务器同意建立连接，并且 ACK 表示确认收到客户端的 SYN 包。该包包含服务器的初始序列号（Seq &#x3D; Y）和对客户端序列号的确认（Ack &#x3D; X + 1）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Server: SYN, ACK, Seq &#x3D; Y, Ack &#x3D; X + 1</code></pre>\n</li>\n<li><p><strong>第三次握手（ACK）</strong></p>\n<ul>\n<li>客户端收到服务器的 SYN-ACK 包后，发送一个 ACK 包给服务器，表示确认收到服务器的 SYN-ACK 包，并且连接建立成功。该包的确认号是服务器的序列号加 1（Ack &#x3D; Y + 1）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Client: ACK, Seq &#x3D; X + 1, Ack &#x3D; Y + 1</code></pre></li>\n</ol>\n<p>完成三次握手后，客户端和服务器之间的连接就建立起来了，接下来可以进行数据传输。</p>\n<h3 id=\"四次挥手（Four-Way-Handshake）\"><a href=\"#四次挥手（Four-Way-Handshake）\" class=\"headerlink\" title=\"四次挥手（Four-Way Handshake）\"></a>四次挥手（Four-Way Handshake）</h3><p>四次挥手是 TCP 断开连接的过程，涉及客户端和服务器之间的四个步骤。</p>\n<ol>\n<li><p><strong>第一次挥手（FIN）</strong></p>\n<ul>\n<li>客户端发送一个 FIN（结束序列号）包，表示不再发送数据，但仍然可以接收数据。该包包含一个序列号（Seq &#x3D; U）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Client: FIN, Seq &#x3D; U</code></pre>\n</li>\n<li><p><strong>第二次挥手（ACK）</strong></p>\n<ul>\n<li>服务器收到 FIN 包后，回应一个 ACK 包，表示确认收到客户端的 FIN 包。该包的确认号是客户端的序列号加 1（Ack &#x3D; U + 1）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Server: ACK, Seq &#x3D; V, Ack &#x3D; U + 1</code></pre>\n</li>\n<li><p><strong>第三次挥手（FIN）</strong></p>\n<ul>\n<li>服务器发送一个 FIN 包，表示不再发送数据。该包包含一个序列号（Seq &#x3D; W）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Server: FIN, Seq &#x3D; W</code></pre>\n</li>\n<li><p><strong>第四次挥手（ACK）</strong></p>\n<ul>\n<li>客户端收到服务器的 FIN 包后，回应一个 ACK 包，表示确认收到服务器的 FIN 包，并且连接终止。该包的确认号是服务器的序列号加 1（Ack &#x3D; W + 1）。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Client: ACK, Seq &#x3D; U + 1, Ack &#x3D; W + 1</code></pre></li>\n</ol>\n<p>完成四次挥手后，客户端和服务器之间的连接就断开了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>三次握手</strong>用于建立可靠的 TCP 连接，确保双方都准备好进行数据传输。</li>\n<li><strong>四次挥手</strong>用于优雅地关闭 TCP 连接，确保双方都同意断开连接，并且所有数据都已正确接收。</li>\n</ul>\n<p>理解三次握手和四次挥手对于掌握 TCP 协议和网络编程至关重要，能够帮助你更好地处理网络连接问题和优化网络通信。</p>\n<h2 id=\"对keep-alive的理解\"><a href=\"#对keep-alive的理解\" class=\"headerlink\" title=\"对keep-alive的理解\"></a>对keep-alive的理解</h2><p>Keep-Alive是HTTP协议中的一种连接复用机制，允许在一个TCP连接上发送多个HTTP请求和响应，而不是每个请求-响应对都新建连接。这减少了TCP连接建立和断开的开销，提升了网页加载速度。默认情况下，HTTP&#x2F;1.1启用Keep-Alive，可通过<code>Connection</code>头部字段关闭。</p>\n<h2 id=\"页面有多张图片，HTTP是怎样的加载表现？\"><a href=\"#页面有多张图片，HTTP是怎样的加载表现？\" class=\"headerlink\" title=\"页面有多张图片，HTTP是怎样的加载表现？\"></a>页面有多张图片，HTTP是怎样的加载表现？</h2><ul>\n<li><strong>HTTP&#x2F;1.1</strong>：如果没有使用pipelining（管道化），图片会按顺序加载，每个图片请求需等待前一个请求的响应结束。使用pipelining，虽可同时发送多个请求，但仍需顺序接收响应。</li>\n<li><strong>HTTP&#x2F;2</strong>：由于多路复用，所有图片请求几乎同时发出，服务器并行处理并返回数据片段，显著加快页面加载速度。</li>\n</ul>\n<h2 id=\"HTTP2的头部压缩算法是怎样的？\"><a href=\"#HTTP2的头部压缩算法是怎样的？\" class=\"headerlink\" title=\"HTTP2的头部压缩算法是怎样的？\"></a>HTTP2的头部压缩算法是怎样的？</h2><p>HTTP&#x2F;2使用HPACK压缩算法压缩头部，通过静态和动态表来减少头部字段的传输大小。静态表包含了一些常用的头部字段及其编码，动态表则是通信过程中双方协商的，用于存储之前发送过的字段。通过索引、差异编码、哈夫曼编码等技术，大大减少了头部的字节开销。</p>\n<h2 id=\"HTTP请求报文的是什么样的？\"><a href=\"#HTTP请求报文的是什么样的？\" class=\"headerlink\" title=\"HTTP请求报文的是什么样的？\"></a>HTTP请求报文的是什么样的？</h2><p>一个典型的HTTP请求报文结构包括：</p>\n<ul>\n<li><strong>请求行</strong>：方法、URL、协议版本。</li>\n<li><strong>请求头</strong>：多个键值对，描述客户端信息和请求参数。</li>\n<li><strong>空行</strong>：分割请求头和请求体的CRLF。</li>\n<li><strong>请求体</strong>：可选，POST等方法时包含数据。</li>\n</ul>\n<h2 id=\"HTTP响应报文的是什么样的？\"><a href=\"#HTTP响应报文的是什么样的？\" class=\"headerlink\" title=\"HTTP响应报文的是什么样的？\"></a>HTTP响应报文的是什么样的？</h2><p>HTTP响应报文结构包括：</p>\n<ul>\n<li><strong>状态行</strong>：协议版本、状态码、原因短语。</li>\n<li><strong>响应头</strong>：多个键值对，描述响应信息。</li>\n<li><strong>空行</strong>：分割响应头和响应体的CRLF。</li>\n<li><strong>响应体</strong>：可选，具体响应数据，如HTML页面。</li>\n</ul>\n<h2 id=\"HTTP协议的优点和缺点\"><a href=\"#HTTP协议的优点和缺点\" class=\"headerlink\" title=\"HTTP协议的优点和缺点\"></a>HTTP协议的优点和缺点</h2><p><strong>优点</strong>：</p>\n<ul>\n<li>简单快速：易于理解，客户端与服务器通信简单高效。</li>\n<li>灵活：支持多种类型的数据传输。</li>\n<li>无状态：降低服务器负担，易于扩展。</li>\n<li>支持缓存：减少网络传输，提高响应速度。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>明文传输（HTTP）：安全性低，易被窃听和篡改。</li>\n<li>无状态特性：每次请求都需要重新认证，增加了复杂度。</li>\n<li>连接无复用（HTTP&#x2F;1.0）：效率较低，尤其是高延迟网络。</li>\n<li>队头阻塞（HTTP&#x2F;1.x）：一个请求响应慢会影响后面请求的处理。</li>\n</ul>\n<h2 id=\"说一下HTTP-3-0\"><a href=\"#说一下HTTP-3-0\" class=\"headerlink\" title=\"说一下HTTP 3.0\"></a>说一下HTTP 3.0</h2><p>HTTP&#x2F;3是HTTP协议的最新版本，基于QUIC（Quick UDP Internet Connections）协议，而非传统的TCP。QUIC利用UDP来提供更低的延迟和更好的安全性：</p>\n<ul>\n<li><strong>多路复用</strong>：改进的多路复用机制，解决了HTTP&#x2F;2中的队头阻塞问题。</li>\n<li><strong>连接迁移</strong>：在不同网络间无缝切换，保持连接状态，提升用户体验。</li>\n<li><strong>0-RTT</strong>：首次连接可利用之前缓存的密钥快速握手，减少延迟。</li>\n<li><strong>加密</strong>：全连接加密，安全性提升，内置TLS 1.3。</li>\n</ul>\n<p>HTTP（Hypertext Transfer Protocol）是用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础。从最初的简单设计到如今的高性能标准，HTTP经历了多个版本的演进。以下是HTTP各主要版本的详细介绍：</p>\n<h2 id=\"HTTP各个版本\"><a href=\"#HTTP各个版本\" class=\"headerlink\" title=\"HTTP各个版本\"></a>HTTP各个版本</h2><h3 id=\"1-HTTP-x2F-0-9-1991\"><a href=\"#1-HTTP-x2F-0-9-1991\" class=\"headerlink\" title=\"1. HTTP&#x2F;0.9 (1991)\"></a>1. HTTP&#x2F;0.9 (1991)</h3><ul>\n<li><strong>简介</strong>：HTTP的原始版本，极其简单，仅支持GET方法，用于请求HTML文档。</li>\n<li><strong>特点</strong>：<ul>\n<li><strong>功能单一</strong>：只能传输HTML格式的文本，不支持请求头、响应头和状态码。</li>\n<li><strong>无协议头</strong>：导致协议功能极为有限，不支持多媒体内容或其他复杂交互。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-HTTP-x2F-1-0-1996\"><a href=\"#2-HTTP-x2F-1-0-1996\" class=\"headerlink\" title=\"2. HTTP&#x2F;1.0 (1996)\"></a>2. HTTP&#x2F;1.0 (1996)</h3><ul>\n<li><strong>简介</strong>：首次正式发布的HTTP版本，引入了许多关键特性和概念。</li>\n<li><strong>特点</strong>：<ul>\n<li><strong>请求和响应结构</strong>：增加了请求头和响应头，支持GET、POST、HEAD等方法，以及状态码。</li>\n<li><strong>持久连接</strong>：支持Keep-Alive选项，减少连接建立和关闭的开销，但默认情况下每个请求后仍会关闭连接。</li>\n<li><strong>内容类型多样化</strong>：可以传输多种类型的资源，如图片、音频等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-HTTP-x2F-1-1-1997\"><a href=\"#3-HTTP-x2F-1-1-1997\" class=\"headerlink\" title=\"3. HTTP&#x2F;1.1 (1997)\"></a>3. HTTP&#x2F;1.1 (1997)</h3><ul>\n<li><strong>简介</strong>：目前使用最为广泛的HTTP版本，对1.0做了显著的性能和效率提升。</li>\n<li><strong>特点</strong>：<ul>\n<li><strong>持久连接默认开启</strong>：减少了多次请求的连接成本。</li>\n<li><strong>管道化请求</strong>：允许客户端在收到前一个请求的响应之前发送多个请求。</li>\n<li><strong>虚拟主机支持</strong>：同一IP地址可服务于多个域名。</li>\n<li><strong>内容编码和压缩</strong>：支持数据压缩，减少传输量。</li>\n<li><strong>缓存控制</strong>：增强了缓存机制，改善了网络效率。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-HTTP-x2F-2-2015\"><a href=\"#4-HTTP-x2F-2-2015\" class=\"headerlink\" title=\"4. HTTP&#x2F;2 (2015)\"></a>4. HTTP&#x2F;2 (2015)</h3><ul>\n<li><strong>简介</strong>：基于SPDY协议，对HTTP&#x2F;1.1进行了重大改进，旨在解决性能瓶颈。</li>\n<li><strong>特点</strong>：<ul>\n<li><strong>二进制分帧层</strong>：所有数据以二进制格式传输，提高了效率和解析速度。</li>\n<li><strong>多路复用</strong>：在一个TCP连接上并行处理多个请求和响应，解决了队头阻塞问题。</li>\n<li><strong>头部压缩</strong>：HPACK算法压缩请求和响应头，减少网络传输量。</li>\n<li><strong>服务器推送</strong>：服务器可主动推送客户端可能需要的资源。</li>\n<li><strong>优先级和流控</strong>：客户端可以设置请求优先级，服务器根据优先级处理请求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-HTTP-x2F-3-发布于2019年，但普及程度仍在增长\"><a href=\"#5-HTTP-x2F-3-发布于2019年，但普及程度仍在增长\" class=\"headerlink\" title=\"5. HTTP&#x2F;3 (发布于2019年，但普及程度仍在增长)\"></a>5. HTTP&#x2F;3 (发布于2019年，但普及程度仍在增长)</h3><ul>\n<li><strong>简介</strong>：基于QUIC协议，使用UDP而非TCP作为传输层协议。</li>\n<li><strong>特点</strong>：<ul>\n<li><strong>QUIC基础</strong>：提供更快的连接建立时间，减少延迟。</li>\n<li><strong>多路复用</strong>：继承自HTTP&#x2F;2，但在UDP上实现，进一步优化。</li>\n<li><strong>加密</strong>：所有通信默认加密，提高安全性。</li>\n<li><strong>更好地处理包丢失和重排序</strong>：由于QUIC的内置机制，能更高效地处理网络问题。</li>\n</ul>\n</li>\n</ul>\n<p>每个版本的HTTP都是对前一版本的改进，反映了互联网发展和技术进步的需求，特别是在性能、安全性和用户体验方面。随着网络环境的不断变化，HTTP协议也在持续进化，以满足日益增长的网络应用需求。</p>\n<h2 id=\"HTTP协议的性能怎么样\"><a href=\"#HTTP协议的性能怎么样\" class=\"headerlink\" title=\"HTTP协议的性能怎么样\"></a>HTTP协议的性能怎么样</h2><p>HTTP协议的性能取决于版本和具体的使用环境：</p>\n<ul>\n<li><strong>HTTP&#x2F;1.1</strong>：性能受限于连接数限制和队头阻塞问题。</li>\n<li><strong>HTTP&#x2F;2</strong>：通过多路复用和头部压缩显著提升了性能，但依然可能遇到TCP的拥塞控制问题。</li>\n<li><strong>HTTP&#x2F;3</strong>：基于QUIC的HTTP&#x2F;3进一步降低了延迟，增强了连接可靠性，提高了整体性能。</li>\n</ul>\n<h2 id=\"URL有哪些组成部分\"><a href=\"#URL有哪些组成部分\" class=\"headerlink\" title=\"URL有哪些组成部分\"></a>URL有哪些组成部分</h2><p>URL（统一资源定位符）通常包括：</p>\n<ul>\n<li><strong>协议</strong>：如http、https。</li>\n<li><strong>域名</strong>：服务器的标识，如example.com。</li>\n<li><strong>端口号</strong>：可选，如80或443，默认可省略。</li>\n<li><strong>路径</strong>：资源路径，如&#x2F;path&#x2F;to&#x2F;resource。</li>\n<li><strong>查询字符串</strong>：GET请求参数，如?key&#x3D;value&amp;another&#x3D;value。</li>\n</ul>\n<h2 id=\"与缓存相关的HTTP请求头有哪些\"><a href=\"#与缓存相关的HTTP请求头有哪些\" class=\"headerlink\" title=\"与缓存相关的HTTP请求头有哪些\"></a>与缓存相关的HTTP请求头有哪些</h2><ul>\n<li><strong>Cache-Control</strong>：指示请求或响应的缓存策略。</li>\n<li><strong>ETag</strong>：资源的实体标签，用于验证资源是否改变。</li>\n<li><strong>If-Modified-Since</strong>：客户端上次获取资源的时间，用于判断资源是否更新。</li>\n<li><strong>If-None-Match</strong>：与ETag一起使用，验证资源是否未被修改。</li>\n<li><strong>Last-Modified</strong>：资源最后修改的时间。</li>\n<li><strong>Expires</strong>：资源过期时间，HTTP&#x2F;1.0中的缓存控制方式。</li>\n<li><strong>Pragma</strong>：HTTP&#x2F;1.0中的兼容性头，与Cache-Control:no-cache等效。</li>\n</ul>\n<h2 id=\"什么是HTTPS协议？\"><a href=\"#什么是HTTPS协议？\" class=\"headerlink\" title=\"什么是HTTPS协议？\"></a>什么是HTTPS协议？</h2><p>HTTPS（Hypertext Transfer Protocol Secure）是一种基于HTTP协议的、通过SSL&#x2F;TLS协议进行加密的安全通信协议。它旨在为Web通信提供安全的环境，保护数据的机密性和完整性，防止数据在传输过程中被窃取或篡改。HTTPS通过在HTTP下层加入SSL&#x2F;TLS加密层，确保了客户端与服务器之间的数据交换是加密的，从而保护了用户的隐私和敏感信息，如登录凭据、信用卡号等。</p>\n<h2 id=\"TLS-x2F-SSL的工作原理\"><a href=\"#TLS-x2F-SSL的工作原理\" class=\"headerlink\" title=\"TLS&#x2F;SSL的工作原理\"></a>TLS&#x2F;SSL的工作原理</h2><p>TLS（Transport Layer Security）和其前身SSL（Secure Sockets Layer）是一套用于保障网络通信安全的协议，它们的工作原理概括如下：</p>\n<ol>\n<li><p><strong>握手协议</strong>：通信开始时，客户端与服务器通过一系列消息交换，协商加密套件（包括加密算法、散列函数、密钥交换算法等）、交换密钥，并验证对方身份。</p>\n</li>\n<li><p><strong>密钥交换</strong>：在握手过程中，使用非对称加密（如RSA）来安全地交换对称密钥。此密钥仅双方知道，后续通信将使用这个密钥进行对称加密。</p>\n</li>\n<li><p><strong>数据加密</strong>：一旦密钥交换完成，双方开始使用对称加密算法（如AES）对实际数据进行加密，保证数据传输的机密性。</p>\n</li>\n<li><p><strong>消息认证码（MAC）</strong>：为了保证数据完整性，每条消息还会附带一个MAC，它是消息的哈希值，接收方可以用共享密钥验证数据未被篡改。</p>\n</li>\n<li><p><strong>会话恢复</strong>：为了提高效率，TLS支持会话缓存，允许在后续连接中重用之前的密钥材料，跳过耗时的密钥交换步骤。</p>\n</li>\n</ol>\n<h2 id=\"数字证书是什么？\"><a href=\"#数字证书是什么？\" class=\"headerlink\" title=\"数字证书是什么？\"></a>数字证书是什么？</h2><p>数字证书是一种电子文档，由权威的第三方机构（称为证书颁发机构，CA）签发，用来证明某个实体（如网站服务器）的身份。它包含了实体的公钥、实体的名称、证书有效期、颁发机构的名称及该证书的数字签名等信息。在HTTPS通信中，服务器向客户端发送自己的数字证书，客户端通过验证证书上的数字签名来确认证书的真实性和有效性，进而信任证书中包含的公钥，用于后续的密钥交换。</p>\n<h2 id=\"HTTPS通信（握手）过程\"><a href=\"#HTTPS通信（握手）过程\" class=\"headerlink\" title=\"HTTPS通信（握手）过程\"></a>HTTPS通信（握手）过程</h2><p>HTTPS握手过程简述如下：</p>\n<ol>\n<li><p><strong>客户端发起请求</strong>：客户端发送一个“Client Hello”消息，包含它支持的SSL&#x2F;TLS版本、加密套件列表等信息。</p>\n</li>\n<li><p><strong>服务器响应</strong>：服务器选择最合适的加密套件，并回复“Server Hello”消息，包含选定的加密套件、服务器随机数等。</p>\n</li>\n<li><p><strong>证书交换</strong>：服务器发送其数字证书给客户端，证明自己的身份。</p>\n</li>\n<li><p><strong>密钥交换与验证</strong>：客户端验证证书后，发送一个“Client Key Exchange”消息，内含一个使用服务器公钥加密的预主密钥。同时发送“Change Cipher Spec”和“Finished”消息，表示后续消息将使用协商好的密钥和算法加密。</p>\n</li>\n<li><p><strong>服务器确认</strong>：服务器解密得到预主密钥，计算出会话密钥，并同样发送“Change Cipher Spec”和“Finished”消息。</p>\n</li>\n</ol>\n<p>至此，双方建立了安全的通信通道，可以进行加密的数据传输。</p>\n<h2 id=\"HTTPS的特点\"><a href=\"#HTTPS的特点\" class=\"headerlink\" title=\"HTTPS的特点\"></a>HTTPS的特点</h2><ul>\n<li><strong>安全性</strong>：通过加密数据传输，保护数据免遭窃听和篡改。</li>\n<li><strong>身份验证</strong>：数字证书确保了服务器身份的可信度，防止中间人攻击。</li>\n<li><strong>兼容性</strong>：基于HTTP标准，广泛支持各类Web应用和服务。</li>\n<li><strong>性能影响</strong>：加密处理增加了计算负载，可能影响传输速度，但现代优化技术（如会话缓存、HTTP&#x2F;2）减轻了这种影响。</li>\n</ul>\n<h2 id=\"HTTPS是如何保证安全的？\"><a href=\"#HTTPS是如何保证安全的？\" class=\"headerlink\" title=\"HTTPS是如何保证安全的？\"></a>HTTPS是如何保证安全的？</h2><p>HTTPS通过以下方式确保通信安全：</p>\n<ul>\n<li><strong>加密传输</strong>：使用对称加密算法对数据进行加密，确保传输过程中数据的保密性。</li>\n<li><strong>身份验证</strong>：通过数字证书和CA体系验证服务器身份，防止假冒服务器。</li>\n<li><strong>数据完整性</strong>：MAC和数字签名技术确保数据在传输过程中未被篡改。</li>\n<li><strong>密钥交换安全</strong>：利用非对称加密技术安全地交换对称密钥，避免密钥泄露风险。</li>\n<li><strong>防中间人攻击</strong>：上述机制结合使用，使得第三方难以在不被察觉的情况下拦截或篡改数据。</li>\n</ul>\n<h2 id=\"常见的状态码\"><a href=\"#常见的状态码\" class=\"headerlink\" title=\"常见的状态码\"></a>常见的状态码</h2><ul>\n<li><strong>301 Moved Permanently</strong>: 永久重定向。表示请求的资源已经永久移动到了新的URL，浏览器会自动将请求重新指向新的位置，并且以后的请求也会直接使用新URL。</li>\n<li><strong>302 Found</strong>: 临时重定向。与301相似，但这里的重定向是临时的，意味着未来请求仍应使用原始URL。浏览器同样会自动重定向，但不会更改书签或后续请求的地址。</li>\n<li><strong>303 See Other</strong>: 表示请求的响应可以在另一个URI中找到，且应使用GET方法获取。主要用于POST请求之后的重定向，强制浏览器使用GET方法请求新的位置。</li>\n<li><strong>307 Temporary Redirect</strong>: 类似于302，不同之处在于307会保持请求方法不变，即如果原始请求是POST，重定向后仍然是POST请求。</li>\n<li><strong>308 Permanent Redirect</strong>: 类似于301，但同样保持请求方法不变，适用于永久重定向且需要保持请求方法的情况。</li>\n</ul>\n<h2 id=\"DNS-协议\"><a href=\"#DNS-协议\" class=\"headerlink\" title=\"DNS 协议\"></a>DNS 协议</h2><p>DNS（Domain Name System）协议是一种用于将人类可读的域名转换为IP地址的互联网标准。它通过分布在全球的DNS服务器层级结构，提供了一种分布式数据库系统来管理这些转换。</p>\n<h2 id=\"DNS同时使用TCP和UDP协议？\"><a href=\"#DNS同时使用TCP和UDP协议？\" class=\"headerlink\" title=\"DNS同时使用TCP和UDP协议？\"></a>DNS同时使用TCP和UDP协议？</h2><p>是的，DNS主要使用UDP协议进行查询，因为UDP较轻量级，适合DNS查询的快速响应特性。但当回复超过UDP的最大数据包大小（512字节）时，会自动切换到TCP，以确保大块数据的完整传输。</p>\n<h2 id=\"DNS完整的查询过程\"><a href=\"#DNS完整的查询过程\" class=\"headerlink\" title=\"DNS完整的查询过程\"></a>DNS完整的查询过程</h2><ol>\n<li><strong>递归查询</strong>：客户端向本地DNS服务器发起查询请求，如果本地DNS服务器不知道答案，它会递归地向其他DNS服务器查询，直到找到结果并返回给客户端。</li>\n<li><strong>迭代查询</strong>：DNS服务器如果不能直接回答查询，会指向其他可能知道答案的DNS服务器，客户端再向这些服务器发送查询，这称为迭代查询。</li>\n</ol>\n<h2 id=\"TCP-x2F-IP五层协议与TCP、UDP\"><a href=\"#TCP-x2F-IP五层协议与TCP、UDP\" class=\"headerlink\" title=\"TCP&#x2F;IP五层协议与TCP、UDP\"></a>TCP&#x2F;IP五层协议与TCP、UDP</h2><p>TCP&#x2F;IP模型分为应用层、传输层、网络层、数据链路层和物理层。其中，传输层包括TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）两种协议。</p>\n<ul>\n<li><strong>TCP</strong>特点：面向连接的、可靠的、基于字节流、有流量控制、拥塞控制、确认机制和重传机制，适合需要高可靠性传输的应用。</li>\n<li><strong>UDP</strong>特点：无连接的、不可靠的、基于数据报、速度快、无拥塞控制，适用于对实时性要求高、能容忍一定丢包的应用。</li>\n</ul>\n<h2 id=\"TCP和UDP的使用场景\"><a href=\"#TCP和UDP的使用场景\" class=\"headerlink\" title=\"TCP和UDP的使用场景\"></a>TCP和UDP的使用场景</h2><ul>\n<li><strong>TCP</strong>常用于Web浏览、电子邮件、文件传输等需要保证数据完整性和顺序的应用。</li>\n<li><strong>UDP</strong>适用于视频流、在线游戏、DNS查询等对速度敏感且能容忍少量数据丢失的场景。</li>\n</ul>\n<h2 id=\"UDP协议为什么不可靠？\"><a href=\"#UDP协议为什么不可靠？\" class=\"headerlink\" title=\"UDP协议为什么不可靠？\"></a>UDP协议为什么不可靠？</h2><p>UDP不提供确认、序列号、错误检测等机制，数据包一旦发出，不关心是否到达目的地，也不进行重传，因此被认为是不可靠的。</p>\n<h2 id=\"TCP的特性\"><a href=\"#TCP的特性\" class=\"headerlink\" title=\"TCP的特性\"></a>TCP的特性</h2><ul>\n<li><strong>重传机制</strong>：通过序列号和ACK确认，未收到确认的数据包会被重传。</li>\n<li><strong>拥塞控制</strong>：通过慢启动、拥塞避免、快速重传和快速恢复等算法动态调整发送速率，防止过多的数据涌入网络导致拥塞。</li>\n<li><strong>流量控制</strong>：利用滑动窗口机制，接收方告知发送方其接收缓冲区的大小，以此限制发送速率。</li>\n<li><strong>可靠传输</strong>：通过确认、超时重传、错误校验等机制确保数据正确无误地传输。</li>\n<li><strong>三次握手和四次挥手</strong>：建立连接时需要三次握手确认，断开连接时则需要四次挥手过程。</li>\n</ul>\n<h2 id=\"TCP粘包处理\"><a href=\"#TCP粘包处理\" class=\"headerlink\" title=\"TCP粘包处理\"></a>TCP粘包处理</h2><ul>\n<li><strong>定长消息</strong>：每个消息固定长度，接收端按长度拆分。</li>\n<li><strong>包头标识</strong>：在每个包前加包头，包含消息长度等信息，接收端根据包头解析。</li>\n<li><strong>分隔符</strong>：在消息间加入特定分隔符，接收端根据分隔符拆分。</li>\n</ul>\n<h2 id=\"UDP为何不会粘包\"><a href=\"#UDP为何不会粘包\" class=\"headerlink\" title=\"UDP为何不会粘包\"></a>UDP为何不会粘包</h2><p>UDP作为无连接的协议，每次发送都是独立的数据报，接收端根据UDP数据报的边界自然分离，不存在TCP中的数据流合并问题，因此不会发生粘包现象。</p>\n<h2 id=\"对-WebSocket-的理解\"><a href=\"#对-WebSocket-的理解\" class=\"headerlink\" title=\"对 WebSocket 的理解\"></a>对 WebSocket 的理解</h2><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。它允许服务端主动向客户端推送数据，而无需客户端先发起请求，从而实现了低延迟的双向通信。WebSocket 通过握手协议升级从初始的 HTTP 连接转换为持久化的连接状态，提供了更轻量、高效的实时数据传输方式，广泛应用于在线聊天、游戏、协同编辑、实时交易等场景。</p>\n<h3 id=\"即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-之间的区别\"><a href=\"#即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-之间的区别\" class=\"headerlink\" title=\"即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 之间的区别\"></a>即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 之间的区别</h3><h4 id=\"短轮询-Short-Polling\"><a href=\"#短轮询-Short-Polling\" class=\"headerlink\" title=\"短轮询 (Short Polling)\"></a>短轮询 (Short Polling)</h4><ul>\n<li><strong>概念</strong>：客户端以固定时间间隔向服务器发送请求，询问是否有新数据。服务器如果有更新，就立即响应；如果没有，则返回空数据或者特定的无更新标志。</li>\n<li><strong>优点</strong>：实现简单，兼容所有浏览器。</li>\n<li><strong>缺点</strong>：频繁的请求造成资源浪费，延迟较高，不适合实时性要求高的应用。</li>\n</ul>\n<h4 id=\"长轮询-Long-Polling-x2F-Comet\"><a href=\"#长轮询-Long-Polling-x2F-Comet\" class=\"headerlink\" title=\"长轮询 (Long Polling &#x2F; Comet)\"></a>长轮询 (Long Polling &#x2F; Comet)</h4><ul>\n<li><strong>概念</strong>：客户端发起请求后，如果服务器没有新数据，会暂时挂起请求，直到有数据更新时才响应。客户端收到响应后立即再次发起请求，形成循环。</li>\n<li><strong>优点</strong>：相较于短轮询减少了无效请求，提高了效率，能较好地实现实时性。</li>\n<li><strong>缺点</strong>：服务器需要为每个连接维持资源，容易造成资源消耗，且在高并发下压力较大。</li>\n</ul>\n<h4 id=\"Server-Sent-Events-SSE\"><a href=\"#Server-Sent-Events-SSE\" class=\"headerlink\" title=\"Server-Sent Events (SSE)\"></a>Server-Sent Events (SSE)</h4><ul>\n<li><strong>概念</strong>：一种基于HTTP的轻量级服务器到客户端的单向通信技术。客户端发起请求后，服务器通过<code>text/event-stream</code>内容类型持续发送数据，直至连接关闭。</li>\n<li><strong>优点</strong>：简化了客户端逻辑，支持自动重新连接，适合推送通知、实时新闻等场景。</li>\n<li><strong>缺点</strong>：仅支持服务器到客户端的单向通信，不支持客户端向服务器发送数据。</li>\n</ul>\n<h4 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h4><ul>\n<li><strong>概念</strong>：提供了一个持久化的连接，允许全双工通信，即客户端和服务器都可以随时发送数据。</li>\n<li><strong>优点</strong>：<ul>\n<li>实现真正的实时双向通信。</li>\n<li>减少了不必要的网络延迟和带宽消耗。</li>\n<li>适合需要高频率、低延迟交互的应用。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：<ul>\n<li>需要服务器支持WebSocket协议。</li>\n<li>对一些老旧浏览器可能不完全兼容。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>短轮询</strong>适合对实时性要求不高的场景，实现简单但效率较低。</li>\n<li><strong>长轮询</strong>提高了效率，适合中等实时性需求，但在高并发下服务器资源消耗大。</li>\n<li><strong>SSE</strong>适用于单向数据流的场景，如实时通知，实现简单且节省资源。</li>\n<li><strong>WebSocket</strong>提供了最佳的实时双向通信体验，特别适合即时通讯、在线游戏等对实时性要求极高的应用，但需要专门的服务器支持。</li>\n</ul>\n<h2 id=\"WebSocket-1\"><a href=\"#WebSocket-1\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h2><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。与传统的 HTTP 协议相比，WebSocket 提供了更高效、实时的双向通信方式，使得客户端（如浏览器）和服务器之间的数据交换变得更加灵活和即时。以下是关于 WebSocket 的一些关键点和相关概念：</p>\n<h3 id=\"核心特点\"><a href=\"#核心特点\" class=\"headerlink\" title=\"核心特点\"></a>核心特点</h3><ol>\n<li><p><strong>持久连接</strong>：一旦WebSocket连接建立，客户端和服务器之间的连接会持续存在，直到任意一方主动关闭连接。这避免了HTTP中需要频繁建立和销毁连接的开销。</p>\n</li>\n<li><p><strong>全双工通信</strong>：WebSocket 允许数据同时在客户端和服务器之间自由流动，无需等待对方的响应，非常适合实时聊天、在线游戏、协同编辑、实时推送通知等应用场景。</p>\n</li>\n<li><p><strong>低延迟</strong>：相比轮询和长轮询技术，WebSocket 减少了不必要的网络请求，降低了数据传输的延迟。</p>\n</li>\n<li><p><strong>轻量级</strong>：WebSocket 协议本身非常精简，只有两个字节的头部，大大减少了数据传输的开销。</p>\n</li>\n</ol>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><ol>\n<li><p><strong>握手</strong>：WebSocket 连接初始化时，客户端首先通过HTTP请求发起连接，请求中包含升级到WebSocket协议的特殊字段，服务器响应确认协议升级，随后双方进入WebSocket状态。</p>\n</li>\n<li><p><strong>数据帧传输</strong>：连接建立后，数据以“帧”的形式进行传输。每个帧包含帧头（包含操作码指示数据类型）、负载数据和可选的掩码及长度字段。</p>\n</li>\n<li><p><strong>心跳维护</strong>：为了检测连接是否活跃，WebSocket 实现通常会发送心跳帧，即空数据帧或特定控制帧，以维持连接状态。</p>\n</li>\n</ol>\n<h3 id=\"相关技术与挑战\"><a href=\"#相关技术与挑战\" class=\"headerlink\" title=\"相关技术与挑战\"></a>相关技术与挑战</h3><ul>\n<li><p><strong>跨域问题</strong>：WebSocket 支持跨域连接，但需要服务器设置合适的CORS（跨源资源共享）策略。</p>\n</li>\n<li><p><strong>安全性</strong>：WebSocket 可以通过WSS（WebSocket Secure）使用TLS&#x2F;SSL加密通信，保障数据传输的安全性。</p>\n</li>\n<li><p><strong>兼容性</strong>：现代浏览器普遍支持WebSocket，但在一些较旧的浏览器或特定环境下可能需要降级方案。</p>\n</li>\n<li><p><strong>库与框架</strong>：为简化WebSocket的使用，有许多库和框架提供高级抽象，如 Socket.io、WebSocket-Node（Node.js环境）、SignalR（.NET环境）等，它们通常提供了自动重连、消息队列、房间（分组）管理等功能。</p>\n</li>\n</ul>\n<p>总之，WebSocket 是现代Web开发中实现低延迟、实时交互应用的关键技术之一，它极大地增强了用户体验，特别是在需要实时数据交换的场景中。</p>\n","text":"计算机网络GET和POST的请求的区别 数据位置：GET请求将参数附加在URL中，作为查询字符串；POST请求将参数放在请求体（request body）中。 数据大小：GET请求受URL长度限制，不适合传输大量数据；POST请求理论上无大小限制，更适合大数据量传输。 幂等性：G...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">计算机网络</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GET%E5%92%8CPOST%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">GET和POST的请求的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#POST%E5%92%8CPUT%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">POST和PUT请求的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4\"><span class=\"toc-text\">常见的HTTP请求头和响应头</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP%E7%8A%B6%E6%80%81%E7%A0%81304%E6%98%AF%E5%A4%9A%E5%A5%BD%E8%BF%98%E6%98%AF%E5%B0%91%E5%A5%BD\"><span class=\"toc-text\">HTTP状态码304是多好还是少好</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">常见的HTTP请求方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#put%E5%92%8Cpatch%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">put和patch的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OPTIONS%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">OPTIONS请求方法及使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-1-0-%E5%92%8C-HTTP-1-1-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">HTTP 1.0 和 HTTP 1.1 之间的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-1-1-%E5%92%8C-HTTP-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">HTTP 1.1 和 HTTP 2.0 的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">HTTP和HTTPS协议的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GET%E6%96%B9%E6%B3%95URL%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">GET方法URL长度限制的原因</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BD%93%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-Google-com-%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">当在浏览器中输入 Google.com 并按下回车之后发生了什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">TCP的三次握手和四次挥手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88Three-Way-Handshake%EF%BC%89\"><span class=\"toc-text\">三次握手（Three-Way Handshake）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88Four-Way-Handshake%EF%BC%89\"><span class=\"toc-text\">四次挥手（Four-Way Handshake）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对keep-alive的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8CHTTP%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%A1%A8%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">页面有多张图片，HTTP是怎样的加载表现？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP2%E7%9A%84%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">HTTP2的头部压缩算法是怎样的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">HTTP请求报文的是什么样的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">HTTP响应报文的是什么样的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">HTTP协议的优点和缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E4%B8%80%E4%B8%8BHTTP-3-0\"><span class=\"toc-text\">说一下HTTP 3.0</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">HTTP各个版本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-HTTP-x2F-0-9-1991\"><span class=\"toc-text\">1. HTTP&#x2F;0.9 (1991)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-HTTP-x2F-1-0-1996\"><span class=\"toc-text\">2. HTTP&#x2F;1.0 (1996)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-HTTP-x2F-1-1-1997\"><span class=\"toc-text\">3. HTTP&#x2F;1.1 (1997)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-HTTP-x2F-2-2015\"><span class=\"toc-text\">4. HTTP&#x2F;2 (2015)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-HTTP-x2F-3-%E5%8F%91%E5%B8%83%E4%BA%8E2019%E5%B9%B4%EF%BC%8C%E4%BD%86%E6%99%AE%E5%8F%8A%E7%A8%8B%E5%BA%A6%E4%BB%8D%E5%9C%A8%E5%A2%9E%E9%95%BF\"><span class=\"toc-text\">5. HTTP&#x2F;3 (发布于2019年，但普及程度仍在增长)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%A7%E8%83%BD%E6%80%8E%E4%B9%88%E6%A0%B7\"><span class=\"toc-text\">HTTP协议的性能怎么样</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#URL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">URL有哪些组成部分</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">与缓存相关的HTTP请求头有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%E5%8D%8F%E8%AE%AE%EF%BC%9F\"><span class=\"toc-text\">什么是HTTPS协议？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TLS-x2F-SSL%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">TLS&#x2F;SSL的工作原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">数字证书是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTPS%E9%80%9A%E4%BF%A1%EF%BC%88%E6%8F%A1%E6%89%8B%EF%BC%89%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">HTTPS通信（握手）过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTPS%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">HTTPS的特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">HTTPS是如何保证安全的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">常见的状态码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DNS-%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">DNS 协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DNS%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%EF%BC%9F\"><span class=\"toc-text\">DNS同时使用TCP和UDP协议？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DNS%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">DNS完整的查询过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP-x2F-IP%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%B8%8ETCP%E3%80%81UDP\"><span class=\"toc-text\">TCP&#x2F;IP五层协议与TCP、UDP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E5%92%8CUDP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">TCP和UDP的使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UDP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E9%9D%A0%EF%BC%9F\"><span class=\"toc-text\">UDP协议为什么不可靠？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E7%9A%84%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">TCP的特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86\"><span class=\"toc-text\">TCP粘包处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UDP%E4%B8%BA%E4%BD%95%E4%B8%8D%E4%BC%9A%E7%B2%98%E5%8C%85\"><span class=\"toc-text\">UDP为何不会粘包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9-WebSocket-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对 WebSocket 的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81SSE-%E5%92%8C-WebSocket-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 之间的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9F%AD%E8%BD%AE%E8%AF%A2-Short-Polling\"><span class=\"toc-text\">短轮询 (Short Polling)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%95%BF%E8%BD%AE%E8%AF%A2-Long-Polling-x2F-Comet\"><span class=\"toc-text\">长轮询 (Long Polling &#x2F; Comet)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Server-Sent-Events-SSE\"><span class=\"toc-text\">Server-Sent Events (SSE)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#WebSocket\"><span class=\"toc-text\">WebSocket</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WebSocket-1\"><span class=\"toc-text\">WebSocket</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">核心特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">工作流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%8C%91%E6%88%98\"><span class=\"toc-text\">相关技术与挑战</span></a></li></ol></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"interview-browser-principles","uid":"7dfa44f5bf9784913186c2660b6488c1","slug":"interview-browser-principles","date":"2024-05-30T15:01:58.000Z","updated":"2024-06-10T10:05:13.442Z","comments":true,"path":"api/articles/interview-browser-principles.json","keywords":null,"cover":null,"text":"浏览器原理什么是 XSS 攻击？XSS（Cross-Site Scripting）攻击，即跨站脚本攻击，是指攻击者通过在目标网站上注入恶意脚本，当用户浏览该页面时，恶意脚本会在用户的浏览器上执行，从而盗取用户信息、篡改网页内容、进行钓鱼攻击等。 如何防御 XSS 攻击？ 输入验证...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"interview-react","uid":"315f9f443ae2dc302897ea2ae6c37f7e","slug":"interview-react","date":"2024-05-30T14:59:54.000Z","updated":"2024-06-05T14:53:57.758Z","comments":true,"path":"api/articles/interview-react.json","keywords":null,"cover":null,"text":"ReactReact 事件机制React 使用自己的事件系统，它是对浏览器原生事件系统的一个轻量级封装，旨在提高性能并提供更好的跨浏览器兼容性。下面是React事件机制的核心特点和工作原理： 事件命名约定 驼峰命名：React 使用驼峰命名法（camelCase）来命名事件处理器...","link":"","photos":[],"count_time":{"symbolsCount":"35k","symbolsTime":"32 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}}}