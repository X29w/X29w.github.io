{"title":"React","uid":"d9e53d39e48f5c5aa42bf2e7c031bcd1","slug":"react","date":"2023-03-22T14:07:08.000Z","updated":"2023-03-22T14:20:32.544Z","comments":true,"path":"api/articles/react.json","keywords":null,"cover":"https://wallpaperaccess.com/full/3949089.jpg","content":"<h2 id=\"React-入门\"><a href=\"#React-入门\" class=\"headerlink\" title=\"React 入门\"></a>React 入门</h2><p><a href=\"https://reactjs.org/\" title=\"英文网站\" target=\"_blank\">点我去官网</a></p>\n<h3 id=\"React-的基本使用\"><a href=\"#React-的基本使用\" class=\"headerlink\" title=\"React 的基本使用\"></a>React 的基本使用</h3><h3 id=\"需要的相关依赖文件\"><a href=\"#需要的相关依赖文件\" class=\"headerlink\" title=\"需要的相关依赖文件\"></a>需要的相关依赖文件</h3><ul>\n<li><code>react.js</code>：React 核心库。</li>\n<li><code>react-dom.js</code>：提供操作 DOM 的 react 扩展库。</li>\n<li><code>babel.min.js</code>：解析 JSX 语法代码转为 JS 代码的库</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>引入顺序为：<br>1.react.js<br>2.react-dom.js<br>3.babel.min.js</p></blockquote>\n<h3 id=\"创建虚拟-DOM-的两种方式\"><a href=\"#创建虚拟-DOM-的两种方式\" class=\"headerlink\" title=\"创建虚拟 DOM 的两种方式\"></a>创建虚拟 DOM 的两种方式</h3><ul>\n<li>纯 JS 方式(一般不用)</li>\n<li>JSX 方式</li>\n</ul>\n<h3 id=\"虚拟-DOM-与真实-DOM\"><a href=\"#虚拟-DOM-与真实-DOM\" class=\"headerlink\" title=\"虚拟 DOM 与真实 DOM\"></a>虚拟 DOM 与真实 DOM</h3><ul>\n<li>React 提供了一些 API 来创建一种 “特别” 的一般 js 对象<ul>\n<li><code>const VDOM = React.createElement(&#39;xx&#39;,&#123;id:&#39;xx&#39;&#125;,&#39;xx&#39;)</code></li>\n<li>上面创建的就是一个简单的虚拟 DOM 对象</li>\n</ul>\n</li>\n<li>虚拟 DOM 对象最终都会被 React 转换为真实的 DOM</li>\n<li>我们编码时基本只需要操作 react 的虚拟 DOM 相关数据, react 会转换为真实 DOM 变化而更新界。</li>\n</ul>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><h3 id=\"JSX-1\"><a href=\"#JSX-1\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><ul>\n<li><p>全称: JavaScript XML</p>\n</li>\n<li><p>react 定义的一种类似于 XML 的 JS 扩展语法: JS + XML 本质是 React.createElement(component, props, …children)方法的语法糖</p>\n</li>\n<li><p>作用: 用来简化创建虚拟 DOM</p>\n<ul>\n<li>写法：<code>var ele = &lt;h1&gt;Hello JSX!&lt;/h1&gt;</code></li>\n<li>注意 1：它不是字符串, 也不是 HTML&#x2F;XML 标签</li>\n<li>注意 2：它最终产生的就是一个 JS 对象</li>\n</ul>\n</li>\n<li><p>标签名任意: HTML 标签或其它标签</p>\n</li>\n<li><p>标签属性任意: HTML 标签属性或其它</p>\n</li>\n<li><p>基本语法规则</p>\n<ul>\n<li>遇到 <code>&lt;</code>开头的代码, 以标签的语法解析: html 同名标签转换为 html 同名元素, 其它标签需要特别解析</li>\n<li>遇到以<code>&#123;</code> 开头的代码，以 JS 语法解析: 标签中的 js 表达式必须用<code>&#123; &#125;</code>包含</li>\n</ul>\n</li>\n<li><p>babel.js 的作用</p>\n<ul>\n<li>浏览器不能直接解析 JSX 代码, 需要 babel 转译为纯 JS 的代码才能运行</li>\n<li>只要用了 JSX，都要加上<em>type&#x3D;”text&#x2F;babel”</em>, 声明需要 babel 来处理</li>\n</ul>\n<h3 id=\"渲染虚拟-DOM（元素）\"><a href=\"#渲染虚拟-DOM（元素）\" class=\"headerlink\" title=\"渲染虚拟 DOM（元素）\"></a>渲染虚拟 DOM（元素）</h3></li>\n<li><p>语法: ReactDOM.render(virtualDOM, containerDOM)</p>\n</li>\n<li><p>作用: 将虚拟 DOM 元素渲染到页面中的真实容器 DOM 中显示</p>\n</li>\n<li><p>参数说明</p>\n<ul>\n<li>参数一: 纯 js 或 jsx 创建的虚拟 dom 对象</li>\n<li>参数二: 用来包含虚拟 DOM 元素的真实 dom 元素对象（一般是个<code>&lt;div&gt;&lt;/div&gt;</code>）</li>\n</ul>\n</li>\n<li><p><em>Example:</em> <code>ReactDOM.render(&lt;Test /&gt;,document.getElementById(&#39;root&#39;))</code></p>\n</li>\n</ul>\n<h3 id=\"JSX-语法\"><a href=\"#JSX-语法\" class=\"headerlink\" title=\"JSX 语法\"></a>JSX 语法</h3><ul>\n<li>定义虚拟 DOM，不能使用<code>“”</code></li>\n<li>标签中混入 JS 表达式的时候使用<code>&#123;&#125;</code></li>\n<li><code>id = &#123;myId.toUpperCase()&#125;</code></li>\n<li>样式的类名指定不能使用<code>class</code>，使用<code>className</code></li>\n<li>内敛样式要使用<code>&#123;&#123;&#125;&#125;</code>包裹</li>\n<li><code>style=&#123;&#123;color:'skyblue',fontSize:'24px'&#125;&#125;</code></li>\n<li>不能有多个根标签，只能有一个根标签</li>\n<li>标签必须闭合，自闭合也行</li>\n<li>如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错；如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错</li>\n</ul>\n<h3 id=\"注释写法\"><a href=\"#注释写法\" class=\"headerlink\" title=\"注释写法\"></a>注释写法</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><div class=\"caption\"><span>写在大括号里</span></div><code class=\"language-jsx\">ReactDOM.render(\n  &lt;div&gt;\n    &lt;h1&gt;小丞&lt;&#x2F;h1&gt;\n    &#123;&#x2F;*注释...*&#x2F;&#125;\n  &lt;&#x2F;div&gt;,\n  document.getElementById(&quot;example&quot;)\n);</code></pre>\n\n<h3 id=\"数组插入并遍历\"><a href=\"#数组插入并遍历\" class=\"headerlink\" title=\"数组插入并遍历\"></a>数组插入并遍历</h3><ul>\n<li>JSX 允许在模板中插入数组，数组自动展开全部成员</li>\n</ul>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">var arr &#x3D; [&lt;h1&gt;小丞&lt;&#x2F;h1&gt;, &lt;h2&gt;同学&lt;&#x2F;h2&gt;];\nReactDOM.render(&lt;div&gt;&#123;arr&#125;&lt;&#x2F;div&gt;, document.getElementById(&quot;example&quot;));</code></pre>\n\n<ul>\n<li>根据动态数据生成 <li></li></li>\n</ul>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const data &#x3D; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\nconst VDOM &#x3D; (\n  &lt;div&gt;\n    &lt;ul&gt;\n      &#123;data.map((item, index) &#x3D;&gt; &#123;\n        return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;;\n      &#125;)&#125;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;div&gt;\n);\nReactDOM.render(VDOM, document.querySelector(&quot;.test&quot;));</code></pre>\n\n<h2 id=\"React-面向组件编程\"><a href=\"#React-面向组件编程\" class=\"headerlink\" title=\"React 面向组件编程\"></a>React 面向组件编程</h2><h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ul>\n<li>组件名必须首字母大写</li>\n<li>虚拟 DOM 元素只能有一个根元素</li>\n<li>虚拟 DOM 元素必须有结束标签</li>\n</ul>\n<h3 id=\"渲染类组件标签的基本流程\"><a href=\"#渲染类组件标签的基本流程\" class=\"headerlink\" title=\"渲染类组件标签的基本流程\"></a>渲染类组件标签的基本流程</h3><ul>\n<li>React 内部会创建组件实例对象</li>\n<li>调用 render()得到虚拟 DOM, 并解析为真实 DOM</li>\n<li>插入到指定的页面元素内部</li>\n</ul>\n<h3 id=\"函数式组件\"><a href=\"#函数式组件\" class=\"headerlink\" title=\"函数式组件\"></a>函数式组件</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F;1.先创建函数，函数可以有参数，也可以没有，但是必须要有返回值 返回一个虚拟DOM\nfunction Welcome(props) &#123;\n  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;\n&#125;\n&#x2F;&#x2F;2.进行渲染\nReactDOM.Render(&lt;Welcom name&#x3D;&quot;ljc&quot; &#x2F;&gt;, document.getElementById(&quot;div&quot;));</code></pre>\n\n<h3 id=\"类式组件\"><a href=\"#类式组件\" class=\"headerlink\" title=\"类式组件\"></a>类式组件</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class MyComponent extends React.Component &#123;\n  state &#x3D; &#123; isHot: false &#125;;\n  render() &#123;\n    const &#123; isHot &#125; &#x3D; this.state;\n    return (\n      &lt;h1 onClick&#x3D;&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;&lt;&#x2F;h1&gt;\n    );\n  &#125;\n  changeWeather &#x3D; () &#x3D;&gt; &#123;\n    const isHot &#x3D; this.state.isHot;\n    this.setState(&#123; isHot: !isHot &#125;);\n  &#125;;\n&#125;\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.querySelector(&quot;.test&quot;));</code></pre>\n\n<ul>\n<li>组件中的 render 方法中的 this 为组件实例对象</li>\n<li>组件自定义方法中由于开启了严格模式，this 指向 undefined 如何解决<ul>\n<li>通过 bind 改变 this 指向</li>\n<li>推荐采用箭头函数，箭头函数的 this 指向</li>\n</ul>\n</li>\n<li>state 数据不能直接修改或者更新</li>\n</ul>\n<h3 id=\"组件实例三大属性\"><a href=\"#组件实例三大属性\" class=\"headerlink\" title=\"组件实例三大属性\"></a>组件实例三大属性</h3><h4 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h4><p>React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class Weather extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n  &#125;\n  state &#x3D; &#123;\n    weather: &quot;炎热&quot;,\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;当前季节为：&#123;this.state.weather&#125;&lt;&#x2F;h2&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li>使用的时候通过<code>this.state</code>调用 state 里面的值</li>\n<li>修改 state 里面的值通过调用<code>this.setState(partialState, [callback])</code><ul>\n<li><code>partialState</code>: 需要更新的状态的部分对象</li>\n<li><code>callback</code>: 更新完状态后的回调函数&#x2F;直接要修改的值</li>\n<li><code>setState</code> 是一种合并操作，不是替换操作</li>\n<li>在执行 <code>setState</code> <code>操作后，React</code> 会自动调用一次 <code>render()</code></li>\n<li><code>render()</code> 的执行次数是 <em>1+n</em> (1 为初始化时的自动调用，n 为状态更新的次数)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h4><p>与<code>state</code>不同，<code>state</code>是组件自身的状态，而<code>props</code>则是外部传入的数据</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class Person extends React.Component &#123;\n  render() &#123;\n    return (\n      &lt;ul&gt;\n        &lt;li&gt;&#123;this.props.name&#125;&lt;&#x2F;li&gt;\n        &lt;li&gt;&#123;this.props.age&#125;&lt;&#x2F;li&gt;\n        &lt;li&gt;&#123;this.props.sex&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    );\n  &#125;\n  &#x2F;&#x2F; 对 props传过来的数据进行数据类型的限制\n  static propTypes &#x3D; &#123;\n    name: propTypes.string.isRequired,\n    sex: PropTypes.string,\n    speak: PropTypes.func,\n  &#125;;\n  &#x2F;&#x2F; 对没有传的数据进行一个默认的填充\n  static defaultProps &#x3D; &#123;\n    sex: &quot;male&quot;,\n    age: 18,\n  &#125;;\n&#125;\n    const p &#x3D;&#123;\n        name:&quot;Lisa&quot;,\n        age:&#123;19&#125; ,\n        sex:&quot;female&quot;\n    &#125;\n\nReactDOM.render(\n  &lt;Person &#123;...p&#125;&#x2F;&gt;,document.getElementById(&quot;root&quot;)\n);</code></pre>\n\n<ul>\n<li>在使用的时候可以通过 this.props 来获取值 类式组件的 props:<ul>\n<li>通过在组件标签上传递值，在组件中就可以获取到所传递的值</li>\n<li>在构造器里的 props 参数里可以获取到 props</li>\n<li>可以分别设置 propTypes 和 defaultProps 两个属性来分别操作 props 的规范和默认值，两者都是直接添加在类式组件的原型对象上的（所以需要添加 static）</li>\n<li>同时可以通过…运算符来简化</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Refs\"><a href=\"#Refs\" class=\"headerlink\" title=\"Refs\"></a>Refs</h4><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p>\n<ul>\n<li>有三种操作 refs 的方法，分别为：<ul>\n<li>字符串形式</li>\n<li>回调形式</li>\n<li>createRef 形式</li>\n</ul>\n</li>\n</ul>\n<p><strong>字符串形式 refs</strong></p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">()&#x3D;&gt;&#123;\n    alert(this.refs.inp1)\n&#125;\nrender()&#123;return(&lt;input ref&#x3D;&quot;inp1&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;)&#125;</code></pre>\n\n<p><strong>回调形式的 refs</strong><br>组件实例的 ref 属性传递一个回调函数 c &#x3D;&gt; this.input1 &#x3D; c （箭头函数简写），这样会在实例的属性中存储对 DOM 节点的引用，使用时可通过 this.input1 来使用</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&lt;input\n  ref&#x3D;&#123;(c) &#x3D;&gt; (this.input1 &#x3D; c)&#125;\n  type&#x3D;&quot;text&quot;\n  placeholder&#x3D;&quot;点击按钮提示数据&quot;\n&#x2F;&gt;</code></pre>\n\n<p><strong>createRef 形式</strong><br>React 给我们提供了一个相应的 API，它会自动的将该 DOM 元素放入实例对象中</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><div class=\"caption\"><span>DOM</span></div><code class=\"language-jsx\">&lt;input ref&#x3D;&#123;this.MyRef&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;\n&lt;input ref&#x3D;&#123;this.MyRef1&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;</code></pre>\n\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">MyRef &#x3D; React.createRef();\nMyRef1 &#x3D; React.createRef();</code></pre>\n\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><div class=\"caption\"><span>使用</span></div><code class=\"language-jsx\">&#x2F;&#x2F;调用\nbtnOnClick &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F;创建之后，将自身节点，传入current中\n  console.log(this.MyRef.current.value);\n&#125;;</code></pre>\n\n<p><strong>高阶函数及函数的柯里化</strong><br>以下例子即可知道，只可意会不可言传</p>\n<details class=\"custom-details\">\n<summary>函数柯里化</summary>\n<p><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class MyComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    username: &quot;&quot;,\n    password: &quot;&quot;,\n  &#125;;\n  saveFormInformation &#x3D; (dataType) &#x3D;&gt; &#123;\n    return (event) &#x3D;&gt; &#123;\n      console.log(dataType, event.target.value);\n      this.setState(&#123; [dataType]: event.target.value &#125;);\n    &#125;;\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;函数柯里化Example&lt;&#x2F;h1&gt;\n        &lt;form&gt;\n          &lt;div&gt;\n            &lt;input\n              onChange&#x3D;&#123;this.saveFormInformation(&quot;username&quot;)&#125;\n              type&#x3D;&quot;text&quot;\n              placeholder&#x3D;&quot;请输入用户名&quot;\n            &#x2F;&gt;\n            &lt;br &#x2F;&gt;\n            &lt;br &#x2F;&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div&gt;\n            &lt;input\n              onChange&#x3D;&#123;this.saveFormInformation(&quot;password&quot;)&#125;\n              type&#x3D;&quot;password&quot;\n              placeholder&#x3D;&quot;请输入密码&quot;\n            &#x2F;&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;form&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.getElementById(&quot;test&quot;));</code></pre>\n\n</p>\n</details>\n<details class=\"custom-details\">\n<summary>避免函数柯里化</summary>\n<p><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">class MyComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    username: &quot;&quot;,\n    password: &quot;&quot;,\n  &#125;;\n  saveInfomation &#x3D; (name, value) &#x3D;&gt; &#123;\n    this.setState(&#123; [name]: value &#125;);\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;div&gt;\n          &lt;input\n            onChange&#x3D;&#123;(event) &#x3D;&gt; &#123;\n              this.saveInfomation(&quot;username&quot;, event.target.value);\n            &#125;&#125;\n            type&#x3D;&quot;text&quot;\n            placeholder&#x3D;&quot;请输入用户名&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n        &lt;br &#x2F;&gt;\n        &lt;br &#x2F;&gt;\n        &lt;div&gt;\n          &lt;input\n            onChange&#x3D;&#123;(event) &#x3D;&gt; &#123;\n              this.saveInfomation(&quot;password&quot;, event.target.value);\n            &#125;&#125;\n            type&#x3D;&quot;password&quot;\n            placeholder&#x3D;&quot;请输入密码&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.getElementById(&quot;test&quot;));</code></pre>\n\n</p>\n</details>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>React 生命周期主要包括三个阶段：初始化阶段，更新阶段，销毁阶段</p>\n<h3 id=\"旧的生命周期流程\"><a href=\"#旧的生命周期流程\" class=\"headerlink\" title=\"旧的生命周期流程\"></a>旧的生命周期流程</h3><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e12b2e35c8444f19b795b27e38f4c149~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" />\n\n<ul>\n<li>初始化阶段: 由 <code>ReactDOM.render()</code>触发—初次渲染<ul>\n<li>constructor()</li>\n<li>componentWillMount()</li>\n<li>render()</li>\n<li>componentDidMount()</li>\n</ul>\n</li>\n<li>更新阶段: 由组件内部 <code>this.setSate()</code>或父组件重新 render 触发<ul>\n<li>shouldComponentUpdate()</li>\n<li>componentWillUpdate()</li>\n<li>render()</li>\n<li>componentDidUpdate()</li>\n</ul>\n</li>\n<li>卸载组件: 由<code>ReactDOM.unmountComponentAtNode()</code>触发<ul>\n<li>componentWillUnmount</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"新的生命周期流程\"><a href=\"#新的生命周期流程\" class=\"headerlink\" title=\"新的生命周期流程\"></a>新的生命周期流程</h3><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7d8676f379d4d96bbf0ebd9a8528594~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" />\n\n<ul>\n<li>初始化阶段: 由 ReactDOM.render()触发—初次渲染<ul>\n<li>constructor()</li>\n<li>getDerivedStateFromProps</li>\n<li>render()</li>\n<li>componentDidMount()</li>\n</ul>\n</li>\n<li>更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发<ul>\n<li>getDerivedStateFromProps</li>\n<li>shouldComponentUpdate()</li>\n<li>render()</li>\n<li>getSnapshotBeforeUpdate</li>\n<li>componentDidUpdate()</li>\n</ul>\n</li>\n<li>卸载组件: 由 ReactDOM.unmountComponentAtNode()触发<ul>\n<li>componentWillUnmount()</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"重要的钩子\"><a href=\"#重要的钩子\" class=\"headerlink\" title=\"重要的钩子\"></a>重要的钩子</h3><ul>\n<li>render：初始化渲染或更新渲染调用</li>\n<li>componentDidMount：开启监听, 发送 ajax 请求</li>\n<li>componentWillUnmount：做一些收尾工作, 如: 清理定时器</li>\n</ul>\n<h3 id=\"废弃的钩子\"><a href=\"#废弃的钩子\" class=\"headerlink\" title=\"废弃的钩子\"></a>废弃的钩子</h3><ul>\n<li>componentWillMount</li>\n<li>componentWillReceiveProps</li>\n<li>componentWillUpdate</li>\n</ul>\n<h2 id=\"React-脚手架\"><a href=\"#React-脚手架\" class=\"headerlink\" title=\"React 脚手架\"></a>React 脚手架</h2><h3 id=\"安装脚手架\"><a href=\"#安装脚手架\" class=\"headerlink\" title=\"安装脚手架\"></a>安装脚手架</h3><p><strong>WebPack</strong></p>\n<ul>\n<li>第一步：全局安装<code>create-react-app</code> <code>npm install create-react-app -g</code></li>\n<li>第二步：创建项目<code>create-react-app hello-react</code></li>\n</ul>\n<p><strong>Vite</strong></p>\n<ul>\n<li><code>npm init vite</code>照着提示一步一步来就行</li>\n</ul>\n<h3 id=\"脚手架项目结构\"><a href=\"#脚手架项目结构\" class=\"headerlink\" title=\"脚手架项目结构\"></a>脚手架项目结构</h3><p><strong>WebPack</strong></p>\n<ul>\n<li>hello-react<ul>\n<li>.gitignore <em>自动创建本地仓库</em></li>\n<li>package.json <em>相关配置文件</em></li>\n<li>public <em>公共资源</em><ul>\n<li>favicon.ico <em>浏览器顶部的 icon 图标</em></li>\n<li>index.html <em>应用的 index.html 入口</em></li>\n<li>logo192.png <em>在 manifest 中使用的 logo 图</em></li>\n<li>logo512.png <em>同上</em></li>\n<li>manifest.json <em>应用加壳的配置文件</em></li>\n<li>robots.txt <em>爬虫的协议文件</em></li>\n</ul>\n</li>\n<li>src <em>源码文件夹</em><ul>\n<li>App.css &#x2F;&#x2F; <em>pp 组件的样式</em></li>\n<li>App.js <em>App 组件</em></li>\n<li>App.test.js <em>用于给 APP 做测试</em></li>\n<li>index.css <em>样式</em></li>\n<li>index.js <em>入口文件</em></li>\n<li>logo.svg <em>logo 图</em></li>\n<li>reportWebVitals.js <em>页面性能分析文件</em></li>\n<li>setupTests.js <em>组件单元测试文件</em></li>\n</ul>\n</li>\n<li>yarn.lock</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"消息订阅与发布\"><a href=\"#消息订阅与发布\" class=\"headerlink\" title=\"消息订阅与发布\"></a>消息订阅与发布</h2><p>解决兄弟组件之间需要<code>&lt;App/&gt;</code>帮助的问题</p>\n<ul>\n<li>首先安装 <code>pubsub-js</code><ul>\n<li><code>yarn add pubsub-js</code></li>\n<li><code>npm install pubsub-js</code></li>\n</ul>\n</li>\n<li>引入<ul>\n<li><code>import PubSub from &#39;pubsub-js&#39;</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"订阅消息\"><a href=\"#订阅消息\" class=\"headerlink\" title=\"订阅消息\"></a>订阅消息</h3><p>我们通过 <code>subscribe</code> 来订阅消息，它接收两个参数，第一个参数是消息的名称，第二个是消息成功的回调，回调中也接受两个参数，一个是消息名称，一个是返回的数据</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">PubSub.subscribe(&quot;search&quot;, (msg, data) &#x3D;&gt; &#123;\n  console.log(msg, data);\n&#125;);</code></pre>\n\n<h3 id=\"发布消息\"><a href=\"#发布消息\" class=\"headerlink\" title=\"发布消息\"></a>发布消息</h3><p>我们采用 <code>publish</code> 来发布消息</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 之前的写法\nthis.props.updateAppState(&#123; isFirst: false, isLoading: true &#125;);\n&#x2F;&#x2F; 改为发布订阅方式\nPubSub.publish(&quot;search&quot;, &#123; isFirst: false, isLoading: true &#125;);</code></pre>\n\n<p>这样我们就能成功的在请求之前发送消息，我们只需要在 List 组件中订阅一下这个消息即可，并将返回的数据用于更新状态即可</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">PubSub.subscribe(&quot;search&quot;, (msg, stateObj) &#x3D;&gt; &#123;\n  this.setState(stateObj);\n&#125;);</code></pre>\n\n<p>同时上面的代码会返回一个 token ，这个就类似于定时器的编号的存在，我们可以通过这个 token 值，来取消对应的订阅</p>\n<p>通过 unsubscribe 来取消指定的订阅</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">PubSub.unsubscribe(this.token);</code></pre>\n\n\n","feature":true,"text":"React 入门点我去官网 React 的基本使用需要的相关依赖文件 react.js：React 核心库。 react-dom.js：提供操作 DOM 的 react 扩展库。 babel.min.js：解析 JSX 语法代码转为 JS 代码的库 引入顺序为：1.react.j...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Tecnology","slug":"Tecnology","count":7,"path":"api/categories/Tecnology.json"},{"name":"React","slug":"Tecnology/React","count":2,"path":"api/categories/Tecnology/React.json"}],"tags":[{"name":"tecnology","slug":"tecnology","count":7,"path":"api/tags/tecnology.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">React 入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#React-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">React 的基本使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9C%80%E8%A6%81%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">需要的相关依赖文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建虚拟 DOM 的两种方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F-DOM-%E4%B8%8E%E7%9C%9F%E5%AE%9E-DOM\"><span class=\"toc-text\">虚拟 DOM 与真实 DOM</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JSX\"><span class=\"toc-text\">JSX</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JSX-1\"><span class=\"toc-text\">JSX</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E8%99%9A%E6%8B%9F-DOM%EF%BC%88%E5%85%83%E7%B4%A0%EF%BC%89\"><span class=\"toc-text\">渲染虚拟 DOM（元素）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JSX-%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">JSX 语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E9%87%8A%E5%86%99%E6%B3%95\"><span class=\"toc-text\">注释写法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E5%B9%B6%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">数组插入并遍历</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">React 面向组件编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Tips\"><span class=\"toc-text\">Tips</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">渲染类组件标签的基本流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">函数式组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">类式组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">组件实例三大属性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#State\"><span class=\"toc-text\">State</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Props\"><span class=\"toc-text\">Props</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Refs\"><span class=\"toc-text\">Refs</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">生命周期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A7%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">旧的生命周期流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">新的生命周期流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E7%9A%84%E9%92%A9%E5%AD%90\"><span class=\"toc-text\">重要的钩子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%9F%E5%BC%83%E7%9A%84%E9%92%A9%E5%AD%90\"><span class=\"toc-text\">废弃的钩子</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-%E8%84%9A%E6%89%8B%E6%9E%B6\"><span class=\"toc-text\">React 脚手架</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85%E8%84%9A%E6%89%8B%E6%9E%B6\"><span class=\"toc-text\">安装脚手架</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">脚手架项目结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83\"><span class=\"toc-text\">消息订阅与发布</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">订阅消息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">发布消息</span></a></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React-Router-Dom","uid":"1b063f23855641c095e348bf57d4f4f2","slug":"react-router-dom","date":"2023-03-22T14:10:34.000Z","updated":"2023-03-22T14:19:53.884Z","comments":true,"path":"api/articles/react-router-dom.json","keywords":null,"cover":"https://blog.mycode.website/wp-content/uploads/2017/10/complex-layouts.jpg","text":"React-Router-Dom 5查看印记中文网站关于 React-Router-Dom 的介绍 路由的基本使用index.js&#x2F;index.ts 入口文件中 ReactDOM.render( &lt;React.StrictMode&gt; &#123;&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"Tecnology","slug":"Tecnology","count":7,"path":"api/categories/Tecnology.json"},{"name":"React","slug":"Tecnology/React","count":2,"path":"api/categories/Tecnology/React.json"}],"tags":[{"name":"tecnology","slug":"tecnology","count":7,"path":"api/tags/tecnology.json"}],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Vuex","uid":"d5f81ad13155fc328e81b1032965290d","slug":"vuex","date":"2023-03-21T15:29:07.000Z","updated":"2023-03-22T14:20:09.764Z","comments":true,"path":"api/articles/vuex.json","keywords":null,"cover":"https://developer.johncayde.com/img/tech/vuex.png","text":"Vuex介绍What’s the Vuex? 概念：专门在Vue中实现集中式状态（数据）管理的一个Vue插，对Vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信 核心流程 store： 每一个Vuex应用的核心就是...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"Tecnology","slug":"Tecnology","count":7,"path":"api/categories/Tecnology.json"},{"name":"Vue","slug":"Tecnology/Vue","count":3,"path":"api/categories/Tecnology/Vue.json"},{"name":"Gadgets","slug":"Tecnology/Vue/Gadgets","count":1,"path":"api/categories/Tecnology/Vue/Gadgets.json"}],"tags":[{"name":"tecnology","slug":"tecnology","count":7,"path":"api/tags/tecnology.json"}],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}