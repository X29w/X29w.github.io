{"title":"interview-mobx","uid":"4cdce0b942af62337249f099a631de6a","slug":"interview-mobx","date":"2024-06-04T06:32:54.000Z","updated":"2024-06-04T06:36:50.710Z","comments":true,"path":"api/articles/interview-mobx.json","keywords":null,"cover":null,"content":"<h1 id=\"Mobx\"><a href=\"#Mobx\" class=\"headerlink\" title=\"Mobx\"></a>Mobx</h1><p>好的，作为“面试官”，我会从基础知识到进阶原理来设计一些关于MobX的面试问题，并提供相应的详细答案。MobX是一个非常受欢迎的状态管理库，用于JavaScript应用，特别是React应用中，它通过透明的函数式编程和自动追踪依赖关系简化了状态管理。</p>\n<h2 id=\"Mobx的原理是什么，为什么选择Mobx作为状态管理工具\"><a href=\"#Mobx的原理是什么，为什么选择Mobx作为状态管理工具\" class=\"headerlink\" title=\"Mobx的原理是什么，为什么选择Mobx作为状态管理工具\"></a>Mobx的原理是什么，为什么选择Mobx作为状态管理工具</h2><p>MobX 的原理主要是基于观察者模式（Observer Pattern）和函数响应式编程（Functional Reactive Programming, FRP）。</p>\n<h3 id=\"核心机制可以简化为以下几个关键点：\"><a href=\"#核心机制可以简化为以下几个关键点：\" class=\"headerlink\" title=\"核心机制可以简化为以下几个关键点：\"></a>核心机制可以简化为以下几个关键点：</h3><ol>\n<li><p>**可观察性 (Observability)**：MobX 通过使用 <code>defineProperty()</code> 或在较新版本中使用 <code>Proxy</code> API，使存储在状态管理中的数据变得可观察。这意味着当数据变化时，MobX 能够自动追踪到这一变化。</p>\n</li>\n<li><p>**自动衍生 (Derivation)**：当数据被观察时，MobX 会自动跟踪哪些组件或计算值依赖于这些数据。当数据发生变化时，MobX 能够自动重新计算依赖这些数据的派生值，并通知相关的组件更新。</p>\n</li>\n<li><p>**动作 (Actions)**：MobX 中的状态改变必须通过所谓的“动作”（actions）来进行。这些动作会告知 MobX 系统状态即将发生改变，从而使 MobX 能够有效地管理这些变化并触发相应的更新。</p>\n</li>\n<li><p>**反应式计算 (Reactive Computations)**：类似于 React 中的 <code>useEffect</code> 或 Vue 中的计算属性，MobX 允许定义自动更新的计算值。当依赖的可观测状态改变时，这些计算值会自动重新计算。</p>\n</li>\n</ol>\n<h3 id=\"选择-MobX-作为状态管理工具的原因包括：\"><a href=\"#选择-MobX-作为状态管理工具的原因包括：\" class=\"headerlink\" title=\"选择 MobX 作为状态管理工具的原因包括：\"></a>选择 MobX 作为状态管理工具的原因包括：</h3><ul>\n<li><p><strong>易用性</strong>：MobX 的 API 设计简洁，上手快，使得状态管理变得更加直观，不需要像 Redux 那样编写大量的 Action 和 Reducer 函数。</p>\n</li>\n<li><p><strong>自动同步</strong>：开发者不需要手动管理数据流动和组件更新，MobX 自动处理数据变化到UI的同步，减少了开发者需要编写的样板代码。</p>\n</li>\n<li><p><strong>性能</strong>：通过追踪依赖关系和最小化不必要的重新渲染，MobX 能够高效地管理状态变更，提高应用的性能。</p>\n</li>\n<li><p><strong>面向对象风格</strong>：与 Redux 的函数式编程风格相比，MobX 更倾向于面向对象编程，允许直接修改状态，这对于习惯面向对象思维的开发者来说更为自然。</p>\n</li>\n<li><p><strong>轻量级</strong>：相比 Redux 的中间件和复杂配置，MobX 更轻量，启动成本低，特别适合中小型项目或者需要快速迭代的项目。</p>\n</li>\n</ul>\n<p>综上所述，MobX 因其简单、高效、自动化的状态管理方式，成为了许多开发者偏爱的状态管理工具，尤其是在需要快速开发、追求开发效率和代码简洁度的场景下。</p>\n<h2 id=\"请简述什么是MobX及其主要特点？\"><a href=\"#请简述什么是MobX及其主要特点？\" class=\"headerlink\" title=\"请简述什么是MobX及其主要特点？\"></a>请简述什么是MobX及其主要特点？</h2><p><strong>答案:</strong> MobX是一个用于简化复杂用户界面状态管理的库。它通过透明地应用函数响应式编程，自动追踪数据变化并触发UI更新，从而让状态管理变得简单直观。其主要特点包括：</p>\n<ul>\n<li><strong>可观察性：</strong> 自动追踪数据变化，无需手动管理何时何地更新UI。</li>\n<li><strong>简洁性：</strong> 通过装饰器或明确的API，轻松定义可观察的数据和计算值。</li>\n<li><strong>反应性：</strong> UI自动响应状态变更，开发者只需关注状态和视图。</li>\n<li><strong>性能高效：</strong> 仅当数据真正变化时才执行最小必要的更新。</li>\n</ul>\n<h2 id=\"如何在MobX中创建一个可观察的状态（observable-state）？\"><a href=\"#如何在MobX中创建一个可观察的状态（observable-state）？\" class=\"headerlink\" title=\"如何在MobX中创建一个可观察的状态（observable state）？\"></a>如何在MobX中创建一个可观察的状态（observable state）？</h2><p><strong>答案:</strong> 在MobX中，可以通过<code>makeObservable</code>方法或使用装饰器来创建可观察的状态。以下是两种方式的示例：</p>\n<p>使用装饰器（需先导入<code>makeObservable</code>和<code>observable</code>）:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; makeObservable, observable &#125; from &quot;mobx&quot;;\n\nclass Store &#123;\n  @observable count &#x3D; 0;\n\n  constructor() &#123;\n    makeObservable(this);\n  &#125;\n&#125;</code></pre>\n\n<p>或不使用装饰器:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; observable &#125; from &quot;mobx&quot;;\n\nclass Store &#123;\n  count &#x3D; observable(0);\n&#125;</code></pre>\n\n\n<h2 id=\"解释一下MobX中的计算值（computed-values）是如何工作的？\"><a href=\"#解释一下MobX中的计算值（computed-values）是如何工作的？\" class=\"headerlink\" title=\"解释一下MobX中的计算值（computed values）是如何工作的？\"></a>解释一下MobX中的计算值（computed values）是如何工作的？</h2><p><strong>答案:</strong> 计算值（Computed Values）是MobX中的一个核心概念，它们是基于其他状态（可观察状态）计算得出的值，且当依赖的状态发生变化时，计算值会自动重新计算。这使得UI能够自动响应这些变化而无需额外的手动更新逻辑。</p>\n<p>创建计算值通常使用<code>@computed</code>装饰器或<code>computed</code>函数：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; makeObservable, observable, computed &#125; from &quot;mobx&quot;;\n\nclass Store &#123;\n  @observable count &#x3D; 0;\n  \n  @computed get doubleCount() &#123;\n    &#x2F;&#x2F; 当count改变时，此函数会自动重新计算\n    return this.count * 2;\n  &#125;\n\n  constructor() &#123;\n    makeObservable(this);\n  &#125;\n&#125;</code></pre>\n<p>在这个例子中，<code>doubleCount</code>就是一个计算值，它依赖于<code>count</code>。每当<code>count</code>的值变化时，MobX会自动重新计算<code>doubleCount</code>。</p>\n<h2 id=\"MobX中的action是什么？为什么在修改状态时推荐使用它？\"><a href=\"#MobX中的action是什么？为什么在修改状态时推荐使用它？\" class=\"headerlink\" title=\"MobX中的action是什么？为什么在修改状态时推荐使用它？\"></a>MobX中的<code>action</code>是什么？为什么在修改状态时推荐使用它？</h2><p><strong>答案:</strong> 在MobX中，<code>action</code>是用来修改状态的一个关键概念。它本质上是一个函数，用于包裹那些会改变应用状态的操作。使用<code>action</code>有几个重要的原因：</p>\n<ul>\n<li><strong>可预测性与调试：</strong> <code>action</code>使得状态变更行为更加清晰，便于理解和调试。</li>\n<li><strong>事务性：</strong> 确保一系列状态变更作为一个整体被处理，中间状态不会被外界观察到。</li>\n<li><strong>副作用控制：</strong> MobX可以更好地管理副作用，比如在actions外部禁止状态变更，以避免不一致的状态。</li>\n<li><strong>历史记录与时间旅行调试：</strong> 配合MobX的额外工具，可以记录actions序列，支持时间旅行调试。</li>\n</ul>\n<p>使用<code>action</code>的例子：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; makeObservable, observable, action &#125; from &quot;mobx&quot;;\n\nclass Store &#123;\n  @observable count &#x3D; 0;\n\n  constructor() &#123;\n    makeObservable(this, &#123;\n      count: observable,\n      increment: action,\n    &#125;);\n  &#125;\n\n  increment() &#123;\n    this.count++; &#x2F;&#x2F; 这里对count的修改被action包裹\n  &#125;\n&#125;</code></pre>\n<p>通过这些基础和进阶的问题，可以很好地评估面试者对于MobX的理解程度以及他们在实际项目中应用这些知识的能力。</p>\n","feature":true,"text":"Mobx好的，作为“面试官”，我会从基础知识到进阶原理来设计一些关于MobX的面试问题，并提供相应的详细答案。MobX是一个非常受欢迎的状态管理库，用于JavaScript应用，特别是React应用中，它通过透明的函数式编程和自动追踪依赖关系简化了状态管理。 Mobx的原理是什么...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Mobx\"><span class=\"toc-text\">Mobx</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Mobx%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Mobx%E4%BD%9C%E4%B8%BA%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">Mobx的原理是什么，为什么选择Mobx作为状态管理工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8C%96%E4%B8%BA%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">核心机制可以简化为以下几个关键点：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9-MobX-%E4%BD%9C%E4%B8%BA%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8C%85%E6%8B%AC%EF%BC%9A\"><span class=\"toc-text\">选择 MobX 作为状态管理工具的原因包括：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AFMobX%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">请简述什么是MobX及其主要特点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%9C%A8MobX%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%88observable-state%EF%BC%89%EF%BC%9F\"><span class=\"toc-text\">如何在MobX中创建一个可观察的状态（observable state）？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BMobX%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E5%80%BC%EF%BC%88computed-values%EF%BC%89%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">解释一下MobX中的计算值（computed values）是如何工作的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MobX%E4%B8%AD%E7%9A%84action%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%E6%97%B6%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F\"><span class=\"toc-text\">MobX中的action是什么？为什么在修改状态时推荐使用它？</span></a></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"interview-typescript","uid":"b868df7e10c8c1094284a225631a6d16","slug":"interview-typescript","date":"2024-06-04T06:31:14.000Z","updated":"2024-06-04T06:32:11.859Z","comments":true,"path":"api/articles/interview-typescript.json","keywords":null,"cover":null,"text":"TypeScript为什么要使用 TypeScript?TypeScript 是 JavaScript 的一个超集，它在 JS 的基础上添加了静态类型系统和其他一些增强功能，旨在提高代码的可维护性、可读性和开发效率。使用 TypeScript 的主要优势包括： 静态类型检查：在编...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}