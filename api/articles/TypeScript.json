{"title":"TypeScript","uid":"0aaa27c48e7b40c2bc96b31fb70803da","slug":"TypeScript","date":"2023-03-05T04:07:57.000Z","updated":"2023-03-22T14:20:26.175Z","comments":true,"path":"api/articles/TypeScript.json","keywords":null,"cover":"https://static.frontendmasters.com/resources/2017-09-15-typescript/thumb.jpg","content":"<h2 id=\"TS-简介\"><a href=\"#TS-简介\" class=\"headerlink\" title=\"TS 简介\"></a>TS 简介</h2><ul>\n<li>TypeScript 是 JavaScript 的超集。</li>\n<li>它对 JS 进行了扩展，向 JS 中引入了类型的概念，并添加了许多新的特性。</li>\n<li>TS 代码需要通过编译器编译为 JS，然后再交由 JS 解析器执行。</li>\n<li>TS 完全兼容 JS，换言之，任何的 JS 代码都可以直接当成 JS 使用。</li>\n<li>相较于 JS 而言，TS 拥有了静态类型，更加严格的语法，更强大的功能；TS 可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS 代码可以编译为任意版本的 JS 代码，可有效解决不同 JS 运行环境的兼容问题；同样的功能，TS 的代码量要大于 JS，但由于 TS 的代码结构更加清晰，变量类型更加明确，在后期代码的维护中 TS 却远远胜于 JS。</li>\n</ul>\n<h2 id=\"开发环境搭建\"><a href=\"#开发环境搭建\" class=\"headerlink\" title=\"开发环境搭建\"></a>开发环境搭建</h2><h3 id=\"单文件\"><a href=\"#单文件\" class=\"headerlink\" title=\"单文件\"></a>单文件</h3><ol>\n<li><p>下载 Node.js<br>○ 64 位：<a href=\"https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi\">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</a><br>○ 32 位：<a href=\"https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi\">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</a></p>\n</li>\n<li><p>安装 Node.js</p>\n</li>\n<li><p>使用 npm 全局安装 typescript<br>○ 进入命令行<br>○ 输入：npm i -g typescript</p>\n</li>\n<li><p>创建一个 ts 文件</p>\n</li>\n<li><p>使用 tsc 对 ts 文件进行编译<br>○ 进入命令行<br>○ 进入 ts 文件所在目录<br>○ 执行命令：tsc xxx.ts</p>\n</li>\n</ol>\n<h4 id=\"脚手架\"><a href=\"#脚手架\" class=\"headerlink\" title=\"脚手架\"></a>脚手架</h4><p>直接内置，无需多管</p>\n<h2 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h2><h3 id=\"类型声明\"><a href=\"#类型声明\" class=\"headerlink\" title=\"类型声明\"></a>类型声明</h3><p>类型声明给变量设置了类型，使得变量只能存储某种类型的值<br>语法：</p>\n<pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let 变量: 类型;\n\nlet 变量: 类型 &#x3D; 值;\n\nfunction fn(参数: 类型, 参数: 类型): 类型&#123;\n    ...\n&#125;</code></pre>\n\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>例子</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>number</td>\n<td>1, -33, 2.5</td>\n<td>任意数字</td>\n</tr>\n<tr>\n<td>string</td>\n<td>‘hi’, “hi”, hi</td>\n<td>任意字符串</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>true、false</td>\n<td>布尔值 true 或 false</td>\n</tr>\n<tr>\n<td>字面量</td>\n<td>其本身</td>\n<td>限制变量的值就是该字面量的值</td>\n</tr>\n<tr>\n<td>any</td>\n<td>*</td>\n<td>任意类型</td>\n</tr>\n<tr>\n<td>unknown</td>\n<td>*</td>\n<td>类型安全的 any</td>\n</tr>\n<tr>\n<td>void</td>\n<td>空值（undefined）</td>\n<td>没有值（或 undefined）</td>\n</tr>\n<tr>\n<td>never</td>\n<td>没有值</td>\n<td>不能是任何值</td>\n</tr>\n<tr>\n<td>object</td>\n<td>{name:’孙悟空’}</td>\n<td>任意的 JS 对象</td>\n</tr>\n<tr>\n<td>array</td>\n<td>[1,2,3]</td>\n<td>任意 JS 数组</td>\n</tr>\n<tr>\n<td>tuple</td>\n<td>[4,5]</td>\n<td>元素，TS 新增类型，固定长度数组</td>\n</tr>\n<tr>\n<td>enum</td>\n<td>enum{A, B}</td>\n<td>枚举，TS 中新增类型</td>\n</tr>\n</tbody></table>\n<p><em>Number</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let decimal: number &#x3D; 6;\nlet hex: number &#x3D; 0xf00d;\nlet binary: number &#x3D; 0b1010;\nlet octal: number &#x3D; 0o744;\nlet big: bigint &#x3D; 100n;</code></pre>\n\n</p>\n</details>\n<p><em>Boolean</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let isDone: boolean &#x3D; false;</code></pre>\n\n</p>\n</details>\n<p><em>String</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let color: string &#x3D; &quot;blue&quot;;\ncolor &#x3D; &#39;red&#39;;\n\nlet fullName: string &#x3D; &#96;Bob Bobbington&#96;;\nlet age: number &#x3D; 37;\nlet sentence: string &#x3D; &#96;Hello, my name is $&#123;fullName&#125;.\n\nI&#39;ll be $&#123;age + 1&#125; years old next month.&#96;;</code></pre>\n\n</p>\n</details>\n<p><em>字面量</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<ul>\n<li>言外之意取值只能从规定的几个里面取<pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;</code></pre></li>\n</ul>\n\n</details>\n<p><em>Any</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><ul>\n<li>相当于变成JavaScript<pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;</code></pre></li>\n</ul>\n</p>\n</details>\n<p><em>Unknown</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let notSure: unknown &#x3D; 4;\nnotSure &#x3D; &#39;hello&#39;;</code></pre>\n\n</p>\n</details>\n<p><em>void</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let unusable: void &#x3D; undefined;</code></pre>\n\n</p>\n</details>\n<p><em>Never</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">function error(message: string): never &#123;\n  throw new Error(message);\n&#125;</code></pre>\n\n</p>\n</details>\n<p><em>Object</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let obj: object &#x3D; &#123;&#125;;</code></pre>\n</p>\n</details>\n<p><em>Array</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let list: number[] &#x3D; [1, 2, 3];\nlet list: Array&lt;number&gt; &#x3D; [1, 2, 3];</code></pre>\n</p>\n</details>\n<p><em>Tuple</em></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let x: [string, number];\nx &#x3D; [&quot;hello&quot;, 10];</code></pre>\n</p>\n</details>\n<p><em>Enum</em></p>\n<ul>\n<li><p>枚举（Enum）类型用于取值被限定在一定范围内的场景</p>\n</li>\n<li><p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射</p>\n</li>\n<li><p>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉</p>\n</li>\n<li><p>除了普通枚举，还有常量枚举、外部枚举等</p>\n</li>\n<li><p>枚举成员只读，不可修改</p>\n</li>\n<li><p>普通枚举：做了反向映射，可双向访问，会编译到JS代码中；使用场景：状态的判断、状态码</p>\n</li>\n<li><p>字符串枚举：枚举的是字符串</p>\n</li>\n<li><p>常量枚举：不会被编译到JS中。使用场景：如果某个变量你确定只有几种值，那么就可以使用常枚举去规定，超出规定就会提示报错；</p>\n</li>\n</ul>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<ul>\n<li>相当于变成JavaScript<pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">&#x2F;&#x2F; 普通枚举 | 数字枚举\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; true\nconsole.log(Days[0] &#x3D;&#x3D;&#x3D; &quot;Sun&quot;); &#x2F;&#x2F; true\nenum Color &#123;\n  Red, &#x2F;&#x2F; 0\n  Green, &#x2F;&#x2F; 1\n  Blue, &#x2F;&#x2F; 2\n&#125;\nenum Color &#123;\n  Red &#x3D; 1, &#x2F;&#x2F; 1\n  Green &#x3D; 7, &#x2F;&#x2F; 7\n  Blue, &#x2F;&#x2F; 8\n&#125;\nenum Color &#123;\n  Red &#x3D; 1,\n  Green &#x3D; 2,\n  Blue &#x3D; 4,\n&#125;\nenum Demo &#123;\n    &#x2F;&#x2F; const\n    a,                  &#x2F;&#x2F; 没有初始值\n    b &#x3D; Demo.a,         &#x2F;&#x2F; 对已有枚举成员的引用\n    c &#x3D; 1 + 2,          &#x2F;&#x2F; 常量的表达式\n    &#x2F;&#x2F; computed\n    d &#x3D; Math.random(),  &#x2F;&#x2F; 需要被计算的枚举成员\n    e &#x3D; &#39;abc&#39;.length    &#x2F;&#x2F; 需要被计算的枚举成员\n&#125;\n&#x2F;&#x2F; 字符串枚举\nenum orderStatusDesc &#123;\n    UN_PAYED &#x3D; &#39;未支付&#39;,\n    PAYED &#x3D; &#39;已支付&#39;,\n    CANCELED &#x3D; &#39;已取消&#39;,\n    CLOSED &#x3D; &#39;已关闭&#39;\n&#125;\n&#x2F;&#x2F; 常量枚举\nconst enum Month &#123;\n    Jan,\n    Feb,\n    Mar\n&#125;\n&#x2F;&#x2F; 异构枚举：字符串与数字枚举混合，不推荐\nenum Status&#123;\n    UN_PAYED,\n    PAYED &#x3D; &#39;已支付&#39;\n&#125;</code></pre>\n:::</li>\n</ul>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型</p>\n<p><em>第一种</em></p>\n<pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let someValue: unknown &#x3D; &quot;this is a string&quot;;\nlet strLength: number &#x3D; (someValue as string).length;</code></pre>\n\n<p><em>第二种</em></p>\n<pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">let someValue: unknown &#x3D; &quot;this is a string&quot;;\nlet strLength: number &#x3D; (&lt;string&gt;someValue).length;</code></pre>\n\n\n<h2 id=\"编译选项\"><a href=\"#编译选项\" class=\"headerlink\" title=\"编译选项\"></a>编译选项</h2><ul>\n<li>自动监视文件并编译：tsc xxx.ts -w </li>\n<li>自动编译整个项目：tsc</li>\n</ul>\n<p>:::details tsconfig.json文件配置</p>\n<pre class=\"line-numbers language-Typescript\" data-language=\"Typescript\"><code class=\"language-Typescript\">&#x2F;&#x2F; tsconfig.json\n&#123;\n  &quot;files&quot;: [&quot;src&#x2F;a.ts&quot;], &#x2F;&#x2F; 需要编译的单个文件列表\n  &quot;include&quot;: [&quot;src&#x2F;*&quot;], &#x2F;&#x2F; 编译某个文件夹下的一级所有文件\n  &quot;exclude&quot;: [&quot;src&#x2F;lib&quot;], &#x2F;&#x2F; 需要排除的文件、文件夹\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base&quot;, &#x2F;&#x2F; 需继承的配置文件tsconfig.base.json\n  &quot;compileOnSave&quot;: true, &#x2F;&#x2F;保存文件的时候自动编译，但当前vscode不支持\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; 增量编译，第一次编译生成一个文件，使得第二次编译速度会提高\n    &quot;tsBuildInfoFile&quot;: &quot;.tsbuildinfo&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n    &quot;module&quot;: &quot;commonjs&quot;, &#x2F;&#x2F; 生成代码的模块标准\n    &quot;target&quot;: &quot;ES3&quot;, &#x2F;&#x2F; 生成代码目标语言的版本\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可用在AMD模块中\n    &quot;lib&quot;: [], &#x2F;&#x2F; ts需要引用的库，即声明文件，target&#x3D;es5则默认引用dom, es5,scripthost\n    &quot;allowJs&quot;: true, &#x2F;&#x2F; 允许编译JS文件\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 与allowJs配合使用，对JS文件进行语法检查\n    &quot;outDir&quot;: &quot;.&#x2F;out&quot;, &#x2F;&#x2F; 指定输出目录\n    &quot;rootDir&quot;: &quot;.&#x2F;src&quot;, &#x2F;&#x2F; 指定输入文件目录\n    &quot;declaration&quot;: false, &#x2F;&#x2F; 生成声明文件\n    &quot;declarationDir&quot;: &quot;.&#x2F;d&quot;, &#x2F;&#x2F; 声明文件的路径\n    &quot;emitDeclarationOnly&quot;: false, &#x2F;&#x2F; 只生成声明文件\n    &quot;sourceMap&quot;: false, &#x2F;&#x2F; 生成目标文件的sourceMap\n    &quot;inlineSourceMap&quot;: false, &#x2F;&#x2F; 生成目标文件的inlineSourceMap\n    &quot;declarationMap&quot;: false, &#x2F;&#x2F; 生成目标文件的declarationMap\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认node_modules&#x2F;@types\n    &quot;types&quot;: [], &#x2F;&#x2F; 声明文件包\n    &quot;removeComments&quot;: false, &#x2F;&#x2F; 删除注释\n    &quot;noEmit&quot;: false, &#x2F;&#x2F; 不输出文件\n    &quot;noEmitOnError&quot;: false, &#x2F;&#x2F; 发生错误时不输出文件\n    &quot;noEmitHelpers&quot;: false, &#x2F;&#x2F; 不生成helper函数，需额外安装ts-helpers\n    &quot;importHelpers&quot;: false, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n    &quot;downlevelIteration&quot;: false, &#x2F;&#x2F; 降级遍历器的实现(es3&#x2F;5)\n    &quot;strict&quot;: false, &#x2F;&#x2F; 开启所有严格的类型检查\n    &quot;alwaysStrict&quot;: false, &#x2F;&#x2F; 在代码中注入&quot;use strict&quot;\n    &quot;noImplicitAny&quot;: false, &#x2F;&#x2F; 不允许隐式的any类型\n    &quot;strictNullChecks&quot;: false, &#x2F;&#x2F; 不允许把null、undefined赋值给其它类型变量\n    &quot;strictFunctionTypes&quot;: false, &#x2F;&#x2F; 不允许函数参数双向协变\n    &quot;strictPropertyInitialization&quot;: false, &#x2F;&#x2F; 类的实例属性必须初始化\n    &quot;strictBindCallApply&quot;: false, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n    &quot;noImplicitThis&quot;: false, &#x2F;&#x2F; 不允许this有隐式的any类型\n    &quot;noUnusedLocals&quot;: false, &#x2F;&#x2F; 检查只声明，未使用的局部变量\n    &quot;noUnusedParameters&quot;: false, &#x2F;&#x2F; 检查未使用的函数参数\n    &quot;noFallthroughCasesInSwitch&quot;: false, &#x2F;&#x2F; 防止Switch语句贯穿\n    &quot;noImplicitReturns&quot;: false, &#x2F;&#x2F; 每个分支都要有返回值\n    &quot;esModuleInterop&quot;: false, &#x2F;&#x2F; 允许export &#x3D; 导出，由import from导入\n    &quot;allowUmdGlobalAccess&quot;: false, &#x2F;&#x2F; 允许在模块中访问UMD全局变量\n    &quot;moduleResolution&quot;: &quot;classic&quot;, &#x2F;&#x2F; 模块解析策略\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址\n    &quot;paths&quot;: &#123;&#125;, &#x2F;&#x2F; 路径映射，相对于baseUrl\n    &quot;rootDirs&quot;: [], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时\n    &quot;listEmittedFiles&quot;: false, &#x2F;&#x2F; 打印输出的文件\n    &quot;listFiles&quot;: false &#x2F;&#x2F; 打印编译的文件（包括引用的声明文件）\n  &#125;\n&#125;</code></pre>\n\n</details>\n<ul>\n<li>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。 </li>\n<li>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json </li>\n<li>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc -</li>\n</ul>\n","text":"TS 简介 TypeScript 是 JavaScript 的超集。 它对 JS 进行了扩展，向 JS 中引入了类型的概念，并添加了许多新的特性。 TS 代码需要通过编译器编译为 JS，然后再交由 JS 解析器执行。 TS 完全兼容 JS，换言之，任何的 JS 代码都可以直接当成...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"Tecnology","slug":"Tecnology","count":7,"path":"api/categories/Tecnology.json"},{"name":"Gadgets","slug":"Tecnology/Gadgets","count":2,"path":"api/categories/Tecnology/Gadgets.json"}],"tags":[{"name":"tecnology","slug":"tecnology","count":7,"path":"api/tags/tecnology.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TS-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">TS 简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">开发环境搭建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">单文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%84%9A%E6%89%8B%E6%9E%B6\"><span class=\"toc-text\">脚手架</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">基本类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">类型声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">类型断言</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">编译选项</span></a></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Pinia","uid":"6a13b89bc1d9db16e3bd75ad19728f7b","slug":"pinia","date":"2023-03-21T15:21:53.000Z","updated":"2023-03-22T14:19:26.602Z","comments":true,"path":"api/articles/pinia.json","keywords":null,"cover":"https://pinia.vuejs.org/social.png","text":"介绍但 Pinia 适用于 Vue 2 和 Vue 3 ，并且不需要您使用组合 API。 Benefit 开发工具支持 跟踪操作、突变的时间表 商店出现在使用它们的组件中 时间旅行和更容易的调试 热模块更换 无需重新加载页面即可修改您的商店 在开发时保持任何现有状态 为 JS 用...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Tecnology","slug":"Tecnology","count":7,"path":"api/categories/Tecnology.json"},{"name":"Gadgets","slug":"Tecnology/Gadgets","count":2,"path":"api/categories/Tecnology/Gadgets.json"}],"tags":[{"name":"tecnology","slug":"tecnology","count":7,"path":"api/tags/tecnology.json"}],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Vue3","uid":"3a4eda1192ec992162144e15ab7e2ec5","slug":"Vue3","date":"2023-02-25T15:36:05.000Z","updated":"2023-03-22T14:20:14.973Z","comments":true,"path":"api/articles/Vue3.json","keywords":null,"cover":"https://www.nickagas.com/wp-content/uploads/60fca23c22c4.jpg","text":"创建工程使用 vite 创建工程npm init vite-app 进入工程目录cd 安装依赖npm install运行npm run dev 常用的 Composition Apisetup()setup 函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"Tecnology","slug":"Tecnology","count":7,"path":"api/categories/Tecnology.json"},{"name":"Vue","slug":"Tecnology/Vue","count":3,"path":"api/categories/Tecnology/Vue.json"}],"tags":[{"name":"tecnology","slug":"tecnology","count":7,"path":"api/tags/tecnology.json"}],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}}}