{"title":"interview-javascript","uid":"cf0441f16ce9f9e8f078668d5a3bf9e5","slug":"interview-javascript","date":"2024-05-30T14:58:24.000Z","updated":"2024-06-04T03:18:31.504Z","comments":true,"path":"api/articles/interview-javascript.json","keywords":null,"cover":null,"content":"<h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"JavaScript有哪些数据类型，它们的区别？\"><a href=\"#JavaScript有哪些数据类型，它们的区别？\" class=\"headerlink\" title=\"JavaScript有哪些数据类型，它们的区别？\"></a>JavaScript有哪些数据类型，它们的区别？</h2><ul>\n<li>原始数据类型：<ul>\n<li>Undefined：表示变量已被声明但未被赋值，只有一个值<code>undefined</code>。</li>\n<li>Null：表示一个空对象指针，用于表示缺少值，只有一个值<code>null</code>。</li>\n<li>Boolean：逻辑类型，只有两个值<code>true</code>和<code>false</code>。</li>\n<li>Number：用于表示整数和浮点数，支持<code>NaN</code>（非数字）和<code>Infinity</code>。</li>\n<li>String：用于表示文本，由零个或多个字符组成，可以用单引号(‘ ‘)或双引号(“ “)包围。</li>\n<li>Symbol（ES6引入）：唯一且不可变的数据类型，常用于对象的唯一属性键。</li>\n<li>BigInt（ES10引入）：用于处理超过<code>Number</code>安全整数范围的大整数。</li>\n</ul>\n</li>\n<li>引用数据类型：<ul>\n<li>Object：复合数据类型，可以是一组键值对的集合（普通对象）、数组、函数、正则表达式、日期等。存储在堆内存中，并且变量实际存储的是指向这些数据的引用（地址）。</li>\n</ul>\n</li>\n<li>区别：<ul>\n<li>存储方式：原始数据类型存储在栈内存中，直接存储值；引用数据类型存储在堆内存中，栈中存储的是指向堆内存中实际数据的引用。</li>\n<li>值传递：原始数据类型的变量之间传递时，传递的是值的副本，互不影响；引用数据类型变量间传递的是引用的副本，修改其中一个变量可能会影响到原始数据。</li>\n<li>内存占用：原始数据类型占用内存较少，复制成本低；引用数据类型由于存储的是引用，占用内存较大，复制时实际上是复制引用，可能导致数据共享。</li>\n<li>操作方式：原始数据类型的比较是值的比较；引用数据类型的比较是引用（地址）的比较，即使内容相同，不同实例也不相等。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据类型检测的方式有哪些\"><a href=\"#数据类型检测的方式有哪些\" class=\"headerlink\" title=\"数据类型检测的方式有哪些\"></a>数据类型检测的方式有哪些</h2><ul>\n<li><p>typeof运算符<br>用途：用于检测基本数据类型，如字符串(<code>String</code>)、数字(<code>Number</code>)、布尔(<code>Boolean</code>)、<code>undefined</code>、<code>symbol</code>、以及函数(<code>Function</code>)。对于对象(<code>Object</code>)和数组(<code>Array</code>)，**typeof会返回”object”<strong>，</strong>对于null，它会返回”object”**，这是typeof的一个常见陷阱。</p>\n</li>\n<li><p>instanceof运算符<br>用途：用于检测一个对象是否属于某个构造函数的实例。例如，可以用来检测一个对象是否是<code>Array</code>、<code>Function</code>等的实例。但它依赖于构造函数，对于基本类型和原型被修改的对象可能不准确。</p>\n</li>\n<li><p>Array.isArray()<br>用途：专门用于检测一个值是否为数组类型，返回布尔值。这是检测数组最准确的方法。</p>\n</li>\n<li><p>Object.prototype.toString.call()<br>用途：这是最全面也是最推荐的检测数据类型的方法。通过调用<code>Object.prototype.toString.call()</code>并传递待检测的值作为上下文，可以得到一个表示该值类型的标准字符串，如”[object Array]”、”[object Object]”等。这种方法几乎能准确区分所有内置类型，包括数组、正则表达式等。</p>\n</li>\n</ul>\n<h2 id=\"null和undefined区别\"><a href=\"#null和undefined区别\" class=\"headerlink\" title=\"null和undefined区别\"></a>null和undefined区别</h2><ul>\n<li>含义与用途：<ul>\n<li><code>null</code> 表示一个刻意的空值，意味着变量被设置为“什么都没有”，或者说是一个空的对象指针。当你想要表示一个变量的值是“空”或者“无对象”时，可以使用 <code>null</code>。它是一个关键字，用来表示空对象或者空指针。</li>\n<li><code>undefined</code> 表示一个变量声明了但未被赋值时的默认值，或者访问一个对象上不存在的属性时返回的值。这意味着变量存在，但没有具体的值关联到它，是一种未定义的状态。</li>\n</ul>\n</li>\n<li>数据类型：<ul>\n<li><code>null</code> 是一个独立的数据类型，称为 <code>Null</code> 类型。</li>\n<li><code>undefined</code> 也是一个独立的数据类型，称为 <code>Undefined</code> 类型。</li>\n</ul>\n</li>\n<li>类型检查：<ul>\n<li>使用 <code>typeof</code> 操作符时，<code>null</code> 返回 <code>&quot;object&quot;</code>（这被认为是一个历史遗留的错误），而 <code>undefined</code> 返回 <code>&quot;undefined&quot;</code>。<br>使用严格相等运算符 (&#x3D;&#x3D;&#x3D;) 比较时，null &#x3D;&#x3D;&#x3D; null 和 undefined &#x3D;&#x3D;&#x3D; undefined 都为 true，但 <code>null === undefined 为 false</code>，说明它们在值上不等，尽管都代表“无值”。</li>\n</ul>\n</li>\n<li>转换为布尔值：<ul>\n<li>在条件语句中，两者都会被自动转换为 false，但原因不同：<strong>null 是因为它是对象的空值，而 undefined 是因为它是未定义的值</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何获取安全的-undefined-值？\"><a href=\"#如何获取安全的-undefined-值？\" class=\"headerlink\" title=\"如何获取安全的 undefined 值？\"></a>如何获取安全的 undefined 值？</h2><ul>\n<li><p>使用 void 0: 这是最常用的获取undefined值的方法，因为void操作符返回一个undefined值，并且void 0是恒定的，不会受到外部影响。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let safeUndefined &#x3D; void 0;</code></pre>\n</li>\n<li><p>函数式接口或自定义函数: 可以定义一个函数，它总是返回undefined，这样做的好处是可以控制返回值，并且易于理解代码意图</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function getSafeUndefined() &#123;\n    return undefined;\n&#125;\nlet safeUndefined &#x3D; getSafeUndefined();</code></pre></li>\n</ul>\n<h2 id=\"typeof-NaN-的结果是什么？\"><a href=\"#typeof-NaN-的结果是什么？\" class=\"headerlink\" title=\"typeof NaN 的结果是什么？\"></a>typeof NaN 的结果是什么？</h2><p>  <code>typeof NaN 的结果是 &quot;number&quot;。</code>在 JavaScript 中，尽管 <code>NaN</code> 代表 “Not a Number”，表示一个本应为数值但实际并非有效数值的特殊值，它的类型仍然是 “number”</p>\n<h2 id=\"x3D-x3D-操作符的强制类型转换规则？\"><a href=\"#x3D-x3D-操作符的强制类型转换规则？\" class=\"headerlink\" title=\"&#x3D;&#x3D; 操作符的强制类型转换规则？\"></a>&#x3D;&#x3D; 操作符的强制类型转换规则？</h2><ul>\n<li><p>数字与非数字比较：非数字类型（字符串、布尔值、对象等）会转换为数字进行比较。布尔值<code>true转为1</code>，<code>false转为0</code>；字符串尝试解析为数字，无法解析时转为NaN。</p>\n</li>\n<li><p>对象与非对象比较：对象会先转换为原始值（通常通过<code>toString</code>或<code>valueOf</code>方法），然后再进行比较。</p>\n</li>\n<li><p>null与undefined比较：它们之间相等（null &#x3D;&#x3D; undefined），与其他类型比较都不相等。</p>\n</li>\n<li><p>字符串与数字比较：字符串会被转换为数字进行比较。</p>\n</li>\n<li><p>符号类型比较：Symbol类型与任何非Symbol类型比较（包括另一个不同的Symbol）都返回false。</p>\n</li>\n</ul>\n<h2 id=\"Object-is-与比较操作符-x3D-x3D-x3D-，-x3D-x3D-的区别？\"><a href=\"#Object-is-与比较操作符-x3D-x3D-x3D-，-x3D-x3D-的区别？\" class=\"headerlink\" title=\"Object.is() 与比较操作符 &#x3D;&#x3D;&#x3D;，&#x3D;&#x3D;的区别？\"></a>Object.is() 与比较操作符 &#x3D;&#x3D;&#x3D;，&#x3D;&#x3D;的区别？</h2><ul>\n<li>Object.is():<br>  类似于&#x3D;&#x3D;&#x3D;，但有两个关键差异：<ul>\n<li>对于NaN，Object.is(NaN, NaN)返回true，这是与&#x3D;&#x3D;&#x3D;最大的不同，它认为两个NaN值是相等的。</li>\n<li>对于+0和-0，虽然它们在JavaScript中通常被视为相等（+0 &#x3D;&#x3D;&#x3D; -0为true），但Object.is(+0, -0)会返回false，区分了这两种零值。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JavaScript-中如何进行隐式类型转换？\"><a href=\"#JavaScript-中如何进行隐式类型转换？\" class=\"headerlink\" title=\"JavaScript 中如何进行隐式类型转换？\"></a>JavaScript 中如何进行隐式类型转换？</h2><ul>\n<li><p>字符串与数字相加:<br>当字符串与数字相加时，数字会被转换为字符串，然后进行拼接。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let num &#x3D; 5;\nlet str &#x3D; &quot;3&quot;;\nconsole.log(num + str); &#x2F;&#x2F; 输出 &quot;53&quot;</code></pre>\n</li>\n<li><p>布尔值参与算术运算:<br>布尔值在进行算术运算时，true会被转换为1，false会被转换为0。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let boolTrue &#x3D; true;\nlet result &#x3D; 4 + boolTrue; &#x2F;&#x2F; true 转换为 1\nconsole.log(result); &#x2F;&#x2F; 输出 5</code></pre>\n</li>\n<li><p>比较运算中的类型转换:<br>在使用&#x3D;&#x3D;比较操作符时，会发生类型转换以比较值。</p>\n<ul>\n<li>数字与字符串比较时，字符串会被转换为数字。</li>\n<li>布尔值参与比较时，true变为1，false变为0。</li>\n<li>对象与非对象比较时，对象会通过toString()或valueOf()方法转换为原始值。</li>\n</ul>\n</li>\n<li><p>条件语句中的转换:<br>在条件语句如if中，非布尔值会被转换为布尔值进行判断，类似于使用Boolean()函数。</p>\n</li>\n</ul>\n<h2 id=\"为什么会有BigInt的提案\"><a href=\"#为什么会有BigInt的提案\" class=\"headerlink\" title=\"为什么会有BigInt的提案\"></a>为什么会有BigInt的提案</h2><p>BigInt 类型的提案被提出，主要是为了解决 JavaScript 中传统 <code>Number</code> 类型无法安全、精确表示极大整数的问题。在 JavaScript 中，<code>Number</code> 类型使用 IEEE 754 双精度浮点数格式存储数值，这限制了它可以安全表示的最大整数范围大约在 -(2^53 - 1) 到 2^53 - 1 之间。超过这个范围，整数可能会失去精度，导致不准确的计算结果。</p>\n<p>BigInt 类型的引入，使得开发者能够安全地处理任意大小的整数，这对于诸如加密算法、科学计算、大规模数据分析等领域尤为重要，这些领域经常需要处理超大整数且对精度有严格要求。BigInt 提供了对大整数的原生支持，可以进行精确的算术运算，避免了浮点数运算可能带来的精度损失。</p>\n<h2 id=\"object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别\"><a href=\"#object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别\" class=\"headerlink\" title=\"object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别\"></a>object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h2><ul>\n<li>Object.assign和扩展运算符（…）都是执行浅拷贝，意味着它们只会复制对象的顶层属性，而不会递归复制嵌套对象。如果对象中有属性是另一个对象或数组，这些属性将会共享同一份引用，修改时会影响原对象。</li>\n<li>主要区别在于语法使用上：Object.assign是一个方法，可以合并多个源对象到目标对象；扩展运算符更适用于构造新对象或在模板字面量中展开对象。两者都不适合需要完全独立拷贝对象结构的深拷贝场景。</li>\n</ul>\n<h2 id=\"let、const、var的区别\"><a href=\"#let、const、var的区别\" class=\"headerlink\" title=\"let、const、var的区别\"></a>let、const、var的区别</h2><ul>\n<li><p>作用域</p>\n<ul>\n<li><strong><code>var</code></strong>: 具有函数作用域或全局作用域，无块级作用域。在函数内声明的<code>var</code>变量对整个函数可见，块外部也可访问。</li>\n<li><strong><code>let</code> &amp; <code>const</code></strong>: 引入了块级作用域，只在声明它们的块内有效。</li>\n</ul>\n</li>\n<li><p>变量提升</p>\n<ul>\n<li><strong><code>var</code></strong>: 存在变量提升，可在声明前使用，值为<code>undefined</code>。</li>\n<li><strong><code>let</code> &amp; <code>const</code></strong>: 无变量提升，声明前引用会导致TDZ（Temporal Dead Zone）错误。</li>\n</ul>\n</li>\n<li><p>重复声明</p>\n<ul>\n<li><strong><code>var</code></strong>: 允许在同一作用域内重复声明，可能导致意料之外的行为。</li>\n<li><strong><code>let</code></strong>: 不允许在相同作用域或块内重复声明，否则报错。</li>\n<li><strong><code>const</code></strong>: 同样不允许重复声明，且声明时必须初始化，值不可变。</li>\n</ul>\n</li>\n<li><p>可变性</p>\n<ul>\n<li><strong><code>var</code> &amp; <code>let</code></strong>: 声明的变量值可以改变。</li>\n<li><strong><code>const</code></strong>: 声明常量，值一旦设定不可更改。但对于对象或数组等复杂数据类型，内部属性或元素可修改。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"const对象的属性可以修改吗？\"><a href=\"#const对象的属性可以修改吗？\" class=\"headerlink\" title=\"const对象的属性可以修改吗？\"></a>const对象的属性可以修改吗？</h2><p>当使用<code>const</code>声明一个对象时，实际上是使该对象的引用不可改变，也就是说，你不能让这个变量指向另一个不同的对象。但是，这并不意味着对象本身的属性是不可修改的。如果对象的属性是可写的，你可以修改其属性值，增加新的属性，甚至删除已有属性。这是因为<code>const</code>限制的是变量的赋值操作，而非对象内容的变更。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123; prop: &quot;value&quot; &#125;;\nobj.prop &#x3D; &quot;new value&quot;; &#x2F;&#x2F; 这是允许的，修改属性值\nobj.newProp &#x3D; &quot;added&quot;; &#x2F;&#x2F; 也可以，添加新属性\ndelete obj.prop; &#x2F;&#x2F; 删除属性也是可以的</code></pre>\n\n<h2 id=\"如果new一个箭头函数的会怎么样\"><a href=\"#如果new一个箭头函数的会怎么样\" class=\"headerlink\" title=\"如果new一个箭头函数的会怎么样\"></a>如果new一个箭头函数的会怎么样</h2><p>箭头函数不能作为构造函数使用，所以你不能用 <code>new</code> 操作符来实例化箭头函数。尝试这么做会抛出错误。</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const ArrowFunction &#x3D; () &#x3D;&gt; &#123;&#125;;\nconst instance &#x3D; new ArrowFunction(); &#x2F;&#x2F; 这是错误的用法</code></pre>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">TypeError: ArrowFunction is not a constructor</code></pre>\n\n<h2 id=\"箭头函数与普通函数的区别\"><a href=\"#箭头函数与普通函数的区别\" class=\"headerlink\" title=\"箭头函数与普通函数的区别\"></a>箭头函数与普通函数的区别</h2><ul>\n<li><p>语法</p>\n<ul>\n<li><strong>普通函数</strong>：使用<code>function</code>关键字定义，可具名也可匿名。</li>\n<li><strong>箭头函数</strong>：使用<code>=&gt;</code>符号定义，总是匿名，语法更为简洁。</li>\n</ul>\n</li>\n<li><p>this绑定</p>\n<ul>\n<li><strong>普通函数</strong>：<code>this</code>值在运行时确定，受调用上下文影响。</li>\n<li><strong>箭头函数</strong>：不绑定自己的<code>this</code>，继承自外层作用域，提供固定的<code>this</code>引用。</li>\n</ul>\n</li>\n<li><p>arguments对象</p>\n<ul>\n<li><strong>普通函数</strong>：提供<code>arguments</code>对象访问所有传入参数。</li>\n<li><strong>箭头函数</strong>：不支持<code>arguments</code>，推荐使用剩余参数<code>...args</code>。</li>\n</ul>\n</li>\n<li><p>构造函数</p>\n<ul>\n<li><strong>普通函数</strong>：可用作构造函数，通过<code>new</code>实例化。</li>\n<li><strong>箭头函数</strong>：不可用作构造函数，<code>new</code>实例化会抛错。</li>\n</ul>\n</li>\n<li><p>原型</p>\n<ul>\n<li><strong>普通函数</strong>：具有<code>prototype</code>属性，用于定义对象原型。</li>\n<li><strong>箭头函数</strong>：无<code>prototype</code>属性。</li>\n</ul>\n</li>\n<li><p>call(), apply(), bind()方法</p>\n<ul>\n<li><strong>普通函数</strong>：可改变<code>this</code>指向。</li>\n<li><strong>箭头函数</strong>：使用这些方法不影响<code>this</code>，维持外层作用域的<code>this</code>。</li>\n</ul>\n</li>\n<li><p>Generator函数</p>\n<ul>\n<li><strong>普通函数</strong>：支持通过<code>yield</code>定义为Generator，实现迭代。</li>\n<li><strong>箭头函数</strong>：不支持<code>yield</code>，不能定义为Generator。</li>\n</ul>\n</li>\n<li><p>适用场景</p>\n<ul>\n<li><strong>箭头函数</strong>：适合简洁表达式、回调函数，适合不需独立<code>this</code>或<code>arguments</code>的场景。</li>\n<li><strong>普通函数</strong>：更广泛用途，特别是需要灵活<code>this</code>绑定、原型继承或生成器功能时。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"箭头函数的this指向哪里？\"><a href=\"#箭头函数的this指向哪里？\" class=\"headerlink\" title=\"箭头函数的this指向哪里？\"></a>箭头函数的<code>this</code>指向哪里？</h2><p>箭头函数的<code>this</code>关键字指向在其定义时所在的上下文环境，即采用<strong>词法绑定</strong>（lexical binding）方式确定。具体规则概括如下：</p>\n<ul>\n<li><p>全局作用域：箭头函数中的<code>this</code>指向全局对象，浏览器环境下通常是<code>window</code>，Node.js中是<code>global</code>或<code>globalThis</code>。</p>\n</li>\n<li><p>非箭头函数内部：若箭头函数位于另一个函数内部，它将继承最近一层非箭头函数的<code>this</code>值，不论该箭头函数如何被调用。</p>\n</li>\n<li><p>对象方法中：当箭头函数作为对象的属性方法被定义时，其<code>this</code>仍由包含它的最近一层非箭头函数确定，而非指向该对象。</p>\n</li>\n<li><p>事件处理器、定时器等：在事件监听器、<code>setTimeout</code>等异步回调中，箭头函数维持外层作用域的<code>this</code>，避免了传统函数因执行环境改变导致的<code>this</code>变化问题。</p>\n</li>\n</ul>\n<h2 id=\"扩展运算符（Spread-Operator）的作用及使用场景\"><a href=\"#扩展运算符（Spread-Operator）的作用及使用场景\" class=\"headerlink\" title=\"扩展运算符（Spread Operator）的作用及使用场景\"></a>扩展运算符（Spread Operator）的作用及使用场景</h2><ul>\n<li><p>作用<br>扩展运算符（<code>...</code>）在JavaScript中是一个非常强大的特性，主要用于以下几个方面：</p>\n<ul>\n<li><p>数组解构与合并：</p>\n<ul>\n<li><strong>解构</strong>：可以将数组的元素分解到单独的变量中。</li>\n<li><strong>合并</strong>：合并数组，将一个数组的元素插入到另一个数组中，或创建数组的新副本。</li>\n</ul>\n</li>\n<li><p>函数参数传递：</p>\n<ul>\n<li>将数组作为参数传递给接收多个参数的函数，自动展开数组元素为独立参数。</li>\n</ul>\n</li>\n<li><p>对象属性复制与合并：</p>\n<ul>\n<li>复制对象，快速创建新对象作为原对象的浅拷贝。</li>\n<li>合并对象，将一个对象的可枚举属性复制到另一个对象中。</li>\n</ul>\n</li>\n<li><p>替换<code>apply()</code>方法：</p>\n<ul>\n<li>在调用函数时，用扩展运算符替代<code>Function.prototype.apply()</code>方法传递数组作为参数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用场景</p>\n<ul>\n<li><p>数组操作：</p>\n<ul>\n<li>快速克隆数组：<code>let arrClone = [...arr];</code></li>\n<li>合并多个数组：<code>let combined = [...arr1, ...arr2, ...arr3];</code></li>\n<li>数组合并与去重：结合Set实现数组去重后合并。</li>\n</ul>\n</li>\n<li><p>函数调用：</p>\n<ul>\n<li>传递数组为函数参数：<code>func(...arrayArgs);</code></li>\n<li>在类的构造函数中使用扩展运算符继承父类的属性和方法。</li>\n</ul>\n</li>\n<li><p>对象操作：</p>\n<ul>\n<li>快速复制对象：<code>let newObj = &#123; ...originalObj &#125;;</code></li>\n<li>合并对象属性：<code>let mergedObj = &#123; ...obj1, ...obj2 &#125;;</code></li>\n<li>用于解构赋值时忽略某些属性或添加默认值。</li>\n</ul>\n</li>\n<li><p>字符串与迭代器：</p>\n<ul>\n<li>将字符串或Map&#x2F;Set等可迭代对象转换为数组：<code>[...str]</code> 或 <code>[...map]</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"new操作符的实现原理\"><a href=\"#new操作符的实现原理\" class=\"headerlink\" title=\"new操作符的实现原理\"></a>new操作符的实现原理</h2><p>在JavaScript中，<code>new</code>操作符用于实例化对象，其背后的实现原理大致可以分为以下四个步骤：</p>\n<ul>\n<li><p>创建新对象：<br> 当使用<code>new</code>关键字调用一个函数时，JavaScript引擎首先会在内存中创建一个新的空对象。此对象将作为构造函数的实例。</p>\n</li>\n<li><p>设置原型链：<br> 新创建的对象的<code>[[Prototype]]</code>（或可访问的<code>__proto__</code>属性）会被设置为构造函数的<code>prototype</code>属性所指向的对象。这样，新对象就可以继承构造函数原型上的属性和方法。</p>\n</li>\n<li><p>绑定this值：<br> 在构造函数内部，<code>this</code>关键字会被绑定到新创建的对象上。这意味着通过<code>this</code>可以访问和修改新对象的属性和方法。</p>\n</li>\n<li><p>执行构造函数体：<br> 接着，构造函数的代码体被执行，其中可以使用<code>this</code>来初始化新对象的属性和方法。任何在构造函数中返回的非原始值（即不是基本类型如数字、字符串、布尔值、<code>null</code>或<code>undefined</code>）都将被忽略，除非构造函数显式地返回了一个对象，这时<code>new</code>表达式的结果就是这个返回的对象。</p>\n</li>\n<li><p>返回新对象：<br> 如果构造函数没有显式返回一个对象，<code>new</code>操作符最终会自动返回步骤1中创建的那个新对象。</p>\n</li>\n</ul>\n<p>以伪代码形式表示，<code>new</code>操作符的工作流程大致如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function newInstance(Constructor, ...args) &#123;\n  &#x2F;&#x2F; 创建新对象\n  var instance &#x3D; Object.create(Constructor.prototype);\n  &#x2F;&#x2F; 绑定this并执行构造函数\n  var result &#x3D; Constructor.apply(instance, args);\n  &#x2F;&#x2F; 检查构造函数是否返回了一个对象\n  return typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; result !&#x3D;&#x3D; null ? result : instance;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nfunction Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\nvar person &#x3D; newInstance(Person, &#39;Alice&#39;);</code></pre>\n\n\n<h2 id=\"Map与Object的区别\"><a href=\"#Map与Object的区别\" class=\"headerlink\" title=\"Map与Object的区别\"></a><code>Map</code>与<code>Object</code>的区别</h2><ul>\n<li><p>键的类型：</p>\n<ul>\n<li><strong>Object</strong>：键值（Key）只能是字符串或Symbol类型。即使你使用非字符串作为键，它们也会被转换成字符串（例外是使用Symbol作为键）。</li>\n<li><strong>Map</strong>：键可以是任意类型，包括对象、函数、基本类型等。这意味着Map提供了更灵活的键值对存储方式。</li>\n</ul>\n</li>\n<li><p>迭代顺序：</p>\n<ul>\n<li><strong>Object</strong>：键值对的迭代顺序不确定，尽管ES2015引入了迭代器，但具体顺序可能受实现和环境影响。</li>\n<li><strong>Map</strong>：保持插入时的顺序，键值对的迭代顺序是确定的，按照插入的顺序进行。</li>\n</ul>\n</li>\n<li><p>大小属性：</p>\n<ul>\n<li><strong>Object</strong>：没有内置的属性可以直接获取对象的大小，需要手动计算或遍历键值对。</li>\n<li><strong>Map</strong>：提供了一个内置的<code>size</code>属性，可以快速获取键值对的数量。</li>\n</ul>\n</li>\n<li><p>原型链：</p>\n<ul>\n<li><strong>Object</strong>：拥有原型链，可能会导致意外的键冲突，如<code>hasOwnProperty</code>等方法可能存在于用户数据中。</li>\n<li><strong>Map</strong>：没有原型链上的默认属性，因此不会发生这种键冲突问题。</li>\n</ul>\n</li>\n<li><p>默认值：</p>\n<ul>\n<li><strong>Object</strong>：由于原型的存在，可能会有默认的属性和方法。</li>\n<li><strong>Map</strong>：默认为空，不包含任何额外的默认属性或方法。</li>\n</ul>\n</li>\n<li><p>性能：</p>\n<ul>\n<li><strong>Map</strong>：在频繁增删键值对的场景下，由于其底层实现（通常基于哈希表），性能往往优于普通的Object。</li>\n</ul>\n</li>\n<li><p>创建方式：</p>\n<ul>\n<li><strong>Object</strong>：可以通过字面量<code>&#123;&#125;</code>或<code>Object.create</code>方法创建。</li>\n<li><strong>Map</strong>：使用<code>new Map()</code>构造函数创建，并可以传入迭代器初始化。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JavaScript有哪些内置对象\"><a href=\"#JavaScript有哪些内置对象\" class=\"headerlink\" title=\"JavaScript有哪些内置对象\"></a>JavaScript有哪些内置对象</h2><ul>\n<li>基础内置对象<ul>\n<li>Object：所有对象的基类，其他对象都继承自此。</li>\n<li>Function：函数对象，JavaScript中的函数也是对象。</li>\n<li>Array：用于构建数组数据结构。</li>\n<li>String：处理字符串数据。</li>\n<li>Number：数字相关的操作与属性。</li>\n<li>Boolean：布尔值，表示真&#x2F;假状态。</li>\n<li>Symbol（ES6引入）：创建独一无二的符号，通常作为对象的键。</li>\n<li>BigInt（ES10引入）：用于处理超过Number.MAX_SAFE_INTEGER的大整数。</li>\n</ul>\n</li>\n<li>数学与日期<ul>\n<li>Math：包含数学运算相关的静态方法。</li>\n<li>Date：处理日期和时间。</li>\n</ul>\n</li>\n<li>正则表达式<ul>\n<li>RegExp：用于文本匹配和替换操作。</li>\n</ul>\n</li>\n<li>集合类型<ul>\n<li>Map：存储键值对的集合，键可以是任意类型。</li>\n<li>Set：存储唯一值的集合。</li>\n<li>WeakMap：类似于Map，但其键是弱引用，易被垃圾回收。</li>\n<li>WeakSet：类似于Set，成员为弱引用对象。</li>\n</ul>\n</li>\n<li>迭代与异步<ul>\n<li>Promise：处理异步操作的结果。</li>\n<li>Iterator 和 可迭代协议：使对象可被迭代。</li>\n<li>Generator：生成器函数，控制迭代过程。</li>\n</ul>\n</li>\n<li>二进制数据处理<ul>\n<li>ArrayBuffer：二进制数据缓冲区。</li>\n<li>TypedArray：视图对象，访问ArrayBuffer的不同数据类型。</li>\n<li>DataView：提供灵活读写ArrayBuffer数据的方式。</li>\n<li>WebAssembly相关</li>\n<li>WebAssembly：在JavaScript中使用WebAssembly模块。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数组有哪些原生方法\"><a href=\"#数组有哪些原生方法\" class=\"headerlink\" title=\"数组有哪些原生方法\"></a>数组有哪些原生方法</h2><ul>\n<li>修改原数组的方法<ul>\n<li>push(…items)：在数组末尾添加一个或多个元素，并返回新数组长度。</li>\n<li>pop()：移除数组最后一个元素，并返回该元素。</li>\n<li>shift()：移除数组第一个元素，并返回该元素。</li>\n<li>unshift(…items)：在数组开头添加一个或多个元素，并返回新数组长度。</li>\n<li>splice(start, deleteCount, …items)：从数组中添加&#x2F;删除元素，可修改原数组。start指定开始位置，deleteCount指定删除数量，后续参数为要添加的元素。</li>\n<li>reverse()：反转数组中的元素顺序。</li>\n<li>sort([compareFn])：对数组元素排序，默认按字典顺序，可通过比较函数自定义排序规则。</li>\n</ul>\n</li>\n<li>不修改原数组的方法<ul>\n<li>concat(…arrays)：合并当前数组与其他数组或值，返回新数组。</li>\n<li>slice(start, end)：返回从start到end（不包括end）的数组片段，生成新数组。</li>\n<li>indexOf(searchElement[, fromIndex])：查找元素首次出现的位置，未找到返回-1。</li>\n<li>lastIndexOf(searchElement[, fromIndex])：查找元素最后一次出现的位置，未找到返回-1。</li>\n<li>join([separator])：将数组元素连接成字符串，可选分隔符，默认为,。</li>\n<li>includes(searchElement[, fromIndex])：检查数组是否包含指定元素，返回布尔值。</li>\n<li>entries() &#x2F; keys() &#x2F; values()：返回迭代器，分别用于遍历键值对、键、值。</li>\n</ul>\n</li>\n<li>高级操作方法<ul>\n<li>map(callback[, thisArg])：对每个元素执行函数，返回新数组，原数组不变。</li>\n<li>filter(callback[, thisArg])：筛选符合条件的元素，组成新数组返回。</li>\n<li>reduce(callback[, initialValue]) &#x2F; reduceRight(callback[, - initialValue])：从左&#x2F;右遍历数组，累计执行函数，可用于求和、计数等。</li>\n<li>some(callback[, thisArg])：检测数组中是否有元素满足条件，返回布尔值。</li>\n<li>every(callback[, thisArg])：检测数组中所有元素是否都满足条件，返回布尔值。</li>\n</ul>\n</li>\n<li>迭代方法<ul>\n<li>forEach(callback[, thisArg])：对每个元素执行函数，无返回值，主要用于副作用操作。</li>\n<li>find(callback[, thisArg])：返回数组中满足提供的测试函数的第一个元素的值，否则返回undefined。</li>\n<li>findIndex(callback[, thisArg])：返回数组中满足提供的测试函数的第一个元素的索引，否则返回-1。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组\"><a href=\"#为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组\" class=\"headerlink\" title=\"为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?\"></a>为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h2><ul>\n<li>为什么是类数组？<ul>\n<li>灵活性：允许JavaScript函数接受可变数量的参数，而无需预先定义参数个数。</li>\n<li>兼容性历史：在JavaScript早期设计时，这样设计是为了简化语言并保持向后兼容性。</li>\n<li>性能与内存考虑：直接使用类数组对象减少了创建完整数组实例的需求，可能在某些场景下更轻量级。</li>\n</ul>\n</li>\n<li>如何遍历类数组？<ul>\n<li><p>for循环</p>\n  <pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123;\n  console.log(arguments[i]);\n&#125;</code></pre>\n</li>\n<li><p>forEach方法（借助Array.prototype.call）</p>\n  <pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Array.prototype.forEach.call(arguments, function(item, index) &#123;\n console.log(item);\n&#125;);</code></pre></li>\n<li><p>转换为真正的数组再遍历</p>\n  <pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const argsArray &#x3D; [...arguments];\nargsArray.forEach(item &#x3D;&gt; console.log(item));</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"JavaScript为什么要进行变量提升，它导致了什么问题\"><a href=\"#JavaScript为什么要进行变量提升，它导致了什么问题\" class=\"headerlink\" title=\"JavaScript为什么要进行变量提升，它导致了什么问题\"></a>JavaScript为什么要进行变量提升，它导致了什么问题</h2><ul>\n<li><p>为什么进行变量提升？<br>JavaScript进行变量提升主要是因为其设计之初为了简化编程模型，让开发者能够更加灵活地在函数内部声明变量，不必严格在使用前声明。这一机制允许在声明之前访问变量，给予开发者更多自由。此外，它也反映了JavaScript的解释器在执行前进行的两个阶段：预编译（解析变量和函数声明）和执行（运行代码）。</p>\n</li>\n<li><p>导致的问题</p>\n<ul>\n<li>代码可读性和维护性下降：变量可以在声明之后使用，可能导致逻辑混乱，特别是当变量声明远离使用位置时。</li>\n<li>潜在的错误和误解：未初始化的变量默认为 undefined，在声明前访问可能会导致意外行为或错误。</li>\n<li>作用域混淆：在ES6之前，由于变量提升，var 声明的变量会提升到全局或函数作用域顶部，可能导致无意中覆盖已有的变量。</li>\n<li>与let和const的差异：引入块级作用域的 let 和 const 不具备变量提升特性，这可能导致开发者在使用不同声明方式时产生混淆。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"什么是尾调用，使用尾调用有什么好处？\"><a href=\"#什么是尾调用，使用尾调用有什么好处？\" class=\"headerlink\" title=\"什么是尾调用，使用尾调用有什么好处？\"></a>什么是尾调用，使用尾调用有什么好处？</h2><p>尾调用（Tail Call）是函数式编程中的一个概念，指的是一个函数的最后操作是调用另一个函数，并且将这个调用的结果直接返回，不做任何进一步的计算。换句话说，当一个函数的最后一个动作是调用另一个函数时，这种情况就称为尾调用。</p>\n<p>使用尾调用的好处：</p>\n<ul>\n<li>内存优化：尾调用优化（Tail Call Optimization, TCO）是一种编译器优化技术。在支持此优化的环境中，当函数以尾调用方式结束时，编译器或解释器可以复用当前函数的调用帧（call frame），而不是在调用栈上为新函数分配新的栈帧。这样可以避免栈溢出（stack overflow）问题，尤其是在进行深度递归时，极大节省了内存空间。</li>\n<li>提高性能：由于减少了调用栈的深度，程序执行的效率得到提升，尤其是在递归算法中，能够显著减少执行时间。</li>\n<li>简洁代码：尾调用使得代码更加简洁清晰，易于理解，尤其是当用于实现递归逻辑时，可以帮助开发者写出更优雅的解决方案。</li>\n</ul>\n<p>需要注意的是，尽管尾调用优化在理论上很有吸引力，但在JavaScript中，尾调用优化是有条件的，通常只在使用严格模式（use strict）的情况下才有可能生效，而且并非所有JavaScript引擎都实现了这一优化。因此，在依赖尾调用优化来避免栈溢出或提升性能时，需要确认运行环境是否支持这一特性。</p>\n<h2 id=\"use-strict是什么意思-使用它区别是什么？\"><a href=\"#use-strict是什么意思-使用它区别是什么？\" class=\"headerlink\" title=\"use strict是什么意思 ? 使用它区别是什么？\"></a>use strict是什么意思 ? 使用它区别是什么？</h2><p>use strict 是一个放在JavaScript代码文件或函数开头的字符串字面量，用于指示代码应当在严格模式（strict mode）下执行。这一特性首次出现在 ECMAScript 5 标准中，目的是通过改变 JavaScript 的某些行为，使得代码编写更加安全、严谨并易于调试。</p>\n<p>使用 use strict 的区别主要包括：</p>\n<ul>\n<li><p>变量声明：在严格模式下，未声明就使用的变量会抛出错误，而不是默认创建全局变量，这有助于避免因拼写错误导致的意外全局变量。</p>\n</li>\n<li><p>禁止删除变量或函数：尝试删除不可配置的属性（如变量、函数）会抛出错误。</p>\n</li>\n<li><p>禁止八进制字面量：不允许使用八进制数字字面量，除非采用ES6引入的0o前缀。</p>\n</li>\n<li><p>禁止with语句：with 语句在严格模式下被禁用，因为它可能导致变量作用域的混乱。</p>\n</li>\n<li><p>更严格的函数调用：函数调用时，this 值不会被自动绑定到全局对象，如果上下文中没有明确的this，它将是undefined（在非箭头函数中）。</p>\n</li>\n<li><p>更严格的错误检查：某些在非严格模式下可能静默通过的操作会抛出错误，比如给非对象使用delete操作符。</p>\n</li>\n<li><p>eval的行为变化：在严格模式中，eval代码不能修改其外部作用域的变量，它要么在全局作用域中执行，要么有自己的作用域。</p>\n</li>\n</ul>\n<h2 id=\"for…in和for…of的区别\"><a href=\"#for…in和for…of的区别\" class=\"headerlink\" title=\"for…in和for…of的区别\"></a>for…in和for…of的区别</h2><ul>\n<li><p>for…in</p>\n<ul>\n<li>用途：主要用于遍历对象的可枚举属性（包括原型链上的属性）。</li>\n<li>输出：循环变量获取的是对象的键名（key）。</li>\n<li>问题：因为遍历包括原型链上的属性，可能导致意料之外的结果，特别是在遍历数组时可能遍历到数组原型上的方法。因此，在使用 for…in 遍历数组时，通常需要结合 hasOwnProperty 检查来过滤掉原型链上的属性。<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let obj &#x3D; &#123;a: 1, b: 2&#125;;\nfor(let key in obj) &#123;\n    console.log(key); &#x2F;&#x2F; 输出 &#39;a&#39;, &#39;b&#39;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>for…of</p>\n<ul>\n<li>用途：主要用于遍历可迭代对象（如数组、Set、Map、字符串、生成器等）的元素值。</li>\n<li>输出：循环变量直接获取的是元素值（value）。</li>\n<li>特点：不会遍历对象的键名，也不会遍历原型链。对于普通对象，直接使用 for…of 会报错，需要配合 Object.keys()、Object.values() 或 Object.entries() 等方法使用。</li>\n<li>优势：提供了一种更简洁、直观的遍历集合的方式，且能够正确响应 break、continue 和 return 语句。<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let arr &#x3D; [1, 2, 3];\nfor(let value of arr) &#123;\n    console.log(value); &#x2F;&#x2F; 输出 1, 2, 3\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数组循环的方法\"><a href=\"#数组循环的方法\" class=\"headerlink\" title=\"数组循环的方法\"></a>数组循环的方法</h2><ul>\n<li><p>for循环</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [1, 2, 3];\nfor (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  console.log(arr[i]);\n&#125;</code></pre>\n</li>\n<li><p>forEach():</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">arr.forEach((element, index, array) &#x3D;&gt; &#123;\n  console.log(element);\n&#125;);</code></pre></li>\n<li><p>for…of:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (const element of arr) &#123;\n  console.log(element);\n&#125;</code></pre></li>\n<li><p>map():</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const newArr &#x3D; arr.map((element, index, array) &#x3D;&gt; &#123;\n  return element * 2;\n&#125;);</code></pre></li>\n<li><p>filter():</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const filteredArr &#x3D; arr.filter((element, index, array) &#x3D;&gt; &#123;\n  return element &gt; 1;\n&#125;);</code></pre></li>\n<li><p>reduce():</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const sum &#x3D; arr.reduce((accumulator, currentValue, currentIndex, array) &#x3D;&gt; &#123;\n  return accumulator + currentValue;\n&#125;, 0);</code></pre></li>\n<li><p>some()、every()、find()、findIndex()</p>\n</li>\n</ul>\n<h2 id=\"forEach和map方法有什么区别\"><a href=\"#forEach和map方法有什么区别\" class=\"headerlink\" title=\"forEach和map方法有什么区别\"></a>forEach和map方法有什么区别</h2><ul>\n<li>forEach方法不返回任何值（返回undefined）。它主要用于执行某种操作，如打印数组元素，但不对原数组进行修改（除非函数内部显式修改了数组元素）。</li>\n<li>map方法则会返回一个新的数组，这个新数组的元素是原数组中每个元素经过回调函数处理后的结果。这意味着map可以用来转换数组，而不影响原始数组。</li>\n</ul>\n<h2 id=\"对原型、原型链的理解\"><a href=\"#对原型、原型链的理解\" class=\"headerlink\" title=\"对原型、原型链的理解\"></a>对原型、原型链的理解</h2><ul>\n<li>原型（Prototype）</li>\n</ul>\n<p>在JavaScript中，<strong>函数</strong> 的一个核心特性是它们拥有一个名为 <code>prototype</code> 的属性，该属性是一个<strong>对象</strong>，我们称之为<strong>原型对象</strong>。原型对象的主要目的是<strong>实现属性和方法的共享</strong>。当你使用一个<strong>构造函数</strong>（用于初始化新创建对象的函数）来生成新对象时，这个新对象会自动地与该构造函数的原型对象相连接。如此一来，新对象就能够访问并继承原型对象上的所有属性和方法，形成了简单的继承关系。</p>\n<ul>\n<li>原型链（Prototype Chain）</li>\n</ul>\n<p><strong>原型链</strong> 是JavaScript实现<strong>继承</strong>的一个核心概念。实际上，不仅仅是新创建的对象，<strong>每一个对象</strong>（包括原型对象自身）都有一个内部链接指向其对应的原型对象，这个链接通常称为<code>[[Prototype]]</code>。在一些环境中，可以通过非标准但广泛支持的<code>__proto__</code>属性来访问这个链接。当试图访问一个对象的属性或方法时，如果该对象本身没有定义，JavaScript引擎会继续在其<code>[[Prototype]]</code>链接指向的原型对象中查找，如果还没有找到，则继续向上追溯原型链，直到找到该属性或方法，或者到达原型链的末端（通常是<code>Object.prototype</code>）。这一连串的查找过程就构成了所谓的<strong>原型链</strong>。</p>\n<p>简而言之，<strong>原型</strong>机制让对象能够继承功能，而<strong>原型链</strong>则是这一继承过程中查找属性和方法的路径。</p>\n<h2 id=\"原型修改、重写\"><a href=\"#原型修改、重写\" class=\"headerlink\" title=\"原型修改、重写\"></a>原型修改、重写</h2><p>在JavaScript中，原型对象并非静态不变的。开发者可以根据需要对原型对象进行修改或重写，以便为基于特定构造函数创建的所有实例添加、修改或删除方法及属性。这进一步体现了原型继承的灵活性。以下是原型修改和重写的一些关键点：</p>\n<ul>\n<li>添加属性或方法</li>\n</ul>\n<p>可以直接在构造函数的原型对象上添加新的属性或方法，这些改动会影响到所有现有及未来通过该构造函数创建的对象。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person(name) &#123;\n    this.name &#x3D; name;\n&#125;\n\nPerson.prototype.sayHello &#x3D; function() &#123;\n    console.log(&quot;Hello, my name is &quot; + this.name);\n&#125;;</code></pre>\n\n<ul>\n<li>修改已有属性或方法</li>\n</ul>\n<p>对于原型对象上已存在的属性或方法，可以直接赋值以修改其内容或行为。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Person.prototype.sayHello &#x3D; function() &#123;\n    console.log(&quot;Greetings, I am &quot; + this.name);\n&#125;;</code></pre>\n\n<ul>\n<li>重写原型对象</li>\n</ul>\n<p>有时可能需要完全替换原有的原型对象。这通常涉及两步操作：首先创建一个新的原型对象，然后将其设置为原构造函数的原型。重要提示：这样做会断开与原原型链的联系，因此在新原型上应手动设置或链回Object.prototype，以保持基本的对象行为。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Person.prototype &#x3D; &#123;\n    constructor: Person, &#x2F;&#x2F; 重要！确保constructor属性正确指向\n    sayHello: function() &#123;\n        console.log(&quot;Salutations, the name&#39;s &quot; + this.name);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 确保新原型链不断开，可选操作：\nObject.setPrototypeOf(Person.prototype, Object.prototype);</code></pre>\n\n<h2 id=\"原型链指向\"><a href=\"#原型链指向\" class=\"headerlink\" title=\"原型链指向\"></a>原型链指向</h2><ul>\n<li><p>JavaScript中的原型链指向<br>在JavaScript中，每个对象都有一个内部属性<code>[[Prototype]]</code>（可通辻<code>__proto__</code>访问，尽管不建议直接使用），它形成了对象之间的原型链。原型链是实现继承机制的基础，允许一个对象可以从另一个对象继承属性和方法。以下是原型链指向的相关概念和示例：</p>\n</li>\n<li><p>原型链基础</p>\n<ul>\n<li>**原型对象(<code>prototype</code>)**：每个函数自动具有一个名为<code>prototype</code>的属性，该属性是一个对象，用于存储所有由该构造函数创建的对象所共享的属性和方法。</li>\n<li><strong>原型链</strong>：当试图访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript引擎会继续在其<code>[[Prototype]]</code>（即<code>__proto__</code>）所指向的对象中查找，这个过程会一直向上追溯，直到找到该属性或方法，或者到达原型链的末端（通常是<code>Object.prototype</code>）。</li>\n</ul>\n</li>\n<li><p>示例说明</p>\n</li>\n</ul>\n<p>假设我们有如下的构造函数和对象关系：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Animal(name) &#123;\n    this.name &#x3D; name;\n&#125;\n\nAnimal.prototype.speak &#x3D; function() &#123;\n    console.log(&quot;Some sound&quot;);\n&#125;;\n\nfunction Dog(name) &#123;\n    Animal.call(this, name); &#x2F;&#x2F; 继承Animal属性\n&#125;\n\nDog.prototype &#x3D; Object.create(Animal.prototype); &#x2F;&#x2F; 设置Dog的原型为Animal的实例\nDog.prototype.constructor &#x3D; Dog; &#x2F;&#x2F; 修复constructor属性\n\nDog.prototype.speak &#x3D; function() &#123;\n    console.log(&quot;Woof, my name is &quot; + this.name);\n&#125;;\n\nvar myDog &#x3D; new Dog(&quot;Buddy&quot;);</code></pre>\n\n<p>上述代码中，myDog对象的原型链可以表示为：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">myDog -&gt; Dog.prototype -&gt; Animal.prototype -&gt; Object.prototype -&gt; null</code></pre>\n\n<h2 id=\"原型链的终点是什么？如何打印出原型链的终点？\"><a href=\"#原型链的终点是什么？如何打印出原型链的终点？\" class=\"headerlink\" title=\"原型链的终点是什么？如何打印出原型链的终点？\"></a>原型链的终点是什么？如何打印出原型链的终点？</h2><p>原型链的终点是<code>null</code>。在JavaScript中，每个对象的原型链最终都会指向null，标志着不再有更上一层的原型对象。</p>\n<p>要打印出一个对象的原型链终点，你可以检查一个对象的原型链直到遇到null。以下是如何在JavaScript中打印出原型链终点的一个简单示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function printPrototypeChainEnd(obj) &#123;\n    while (obj) &#123;\n        obj &#x3D; Object.getPrototypeOf(obj); &#x2F;&#x2F; 获取对象的原型\n        if (obj &#x3D;&#x3D;&#x3D; null) &#123;\n            console.log(&quot;原型链的终点是: null&quot;);\n            return;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nlet anyObject &#x3D; new Object(); &#x2F;&#x2F; 或者使用其他对象\nprintPrototypeChainEnd(anyObject);</code></pre>\n\n\n<h2 id=\"如何获得对象非原型链上的属性？\"><a href=\"#如何获得对象非原型链上的属性？\" class=\"headerlink\" title=\"如何获得对象非原型链上的属性？\"></a>如何获得对象非原型链上的属性？</h2><p>要获得JavaScript对象非原型链上的属性，可以使用hasOwnProperty()方法配合循环遍历对象的属性。以下是一个典型示例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function getOwnProperties(obj) &#123;\n    let ownProps &#x3D; [];\n    for (let key in obj) &#123;\n        if (obj.hasOwnProperty(key)) &#123;\n            ownProps.push(key);\n        &#125;\n    &#125;\n    return ownProps;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nlet obj &#x3D; &#123;\n    name: &quot;Alice&quot;,\n    age: 30,\n&#125;;\n\n&#x2F;&#x2F; 假设有一个原型扩展\nObject.prototype.country &#x3D; &quot;Wonderland&quot;;\n\nconsole.log(getOwnProperties(obj)); &#x2F;&#x2F; 输出: [&#39;name&#39;, &#39;age&#39;]</code></pre>\n<p>在这个例子中，getOwnProperties函数遍历对象obj的所有属性。对于每个属性，它使用hasOwnProperty()方法检查该属性是否直接定义在对象实例上，而不是从原型链继承来的。如果是对象自身的属性，则将其添加到ownProps数组中。最后，函数返回包含所有非原型链上属性名称的数组。</p>\n<h2 id=\"对闭包的理解\"><a href=\"#对闭包的理解\" class=\"headerlink\" title=\"对闭包的理解\"></a>对闭包的理解</h2><p>在JavaScript中，<strong>闭包</strong>是一个核心且强大的特性，它使得函数能够访问并记住其自身作用域以外的变量。具体来说，闭包指的是有权访问另一个函数作用域中的变量的函数，通常这种情况发生在内层函数访问外层函数的变量时。闭包由两部分组成：内部函数以及该函数被创建时的词法环境（作用域链）。</p>\n<ul>\n<li>关键特点</li>\n</ul>\n<ol>\n<li><p><strong>变量访问</strong>: 内部函数可以访问其外部函数的局部变量，即使外部函数已经执行完毕。</p>\n</li>\n<li><p><strong>持久化存储</strong>: 闭包可以使得局部变量不随外部函数的执行结束而销毁，达到数据隐藏和封装的目的。</p>\n</li>\n<li><p><strong>内存管理</strong>: 由于闭包会维持对外部变量的引用，因此可能会导致这些变量不会被垃圾回收机制回收，进而占用更多内存。</p>\n</li>\n</ol>\n<ul>\n<li><p>应用场景</p>\n</li>\n<li><p><strong>封装变量</strong>: 通过闭包，可以创建私有变量，防止外部直接修改内部状态。</p>\n</li>\n<li><p><strong>异步处理</strong>: 如<code>setTimeout</code>中使用闭包确保回调函数能正确访问外部函数的变量。</p>\n</li>\n<li><p><strong>函数工厂</strong>: 利用闭包创建一系列具有特定状态的函数。</p>\n</li>\n<li><p><strong>实现模块化</strong>: 封装相关功能和数据，避免全局变量污染。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function outerFunction(outerVariable) &#123;\n    return function innerFunction(innerVariable) &#123;\n        console.log(&#39;outerVariable:&#39;, outerVariable);\n        console.log(&#39;innerVariable:&#39;, innerVariable);\n    &#125;;\n&#125;\n\nconst closureExample &#x3D; outerFunction(&#39;outside&#39;);\nclosureExample(&#39;inside&#39;); &#x2F;&#x2F; 输出: outerVariable: outside, innerVariable: inside</code></pre>\n\n<h2 id=\"对作用域、作用域链的理解\"><a href=\"#对作用域、作用域链的理解\" class=\"headerlink\" title=\"对作用域、作用域链的理解\"></a>对作用域、作用域链的理解</h2><ul>\n<li>作用域(Scope)</li>\n</ul>\n<p>在JavaScript中，<strong>作用域</strong>定义了变量、函数以及对象的可访问性范围。作用域主要有两种类型：</p>\n<ol>\n<li><p><strong>全局作用域</strong>: 在代码的任何地方都能访问到的变量拥有全局作用域。全局作用域中的变量在浏览器环境中通常作为<code>window</code>对象的属性存在。</p>\n</li>\n<li><p><strong>局部作用域&#x2F;函数作用域</strong>: 当一个变量在一个函数内部声明时，它就拥有了局部作用域，这意味着这个变量只能在该函数内部被访问。</p>\n</li>\n</ol>\n<ul>\n<li>作用域链(Scope Chain)</li>\n</ul>\n<p><strong>作用域链</strong>是JavaScript引擎用来解决变量访问权限的一种机制。每个函数在创建时，都会生成一个作用域链，这个作用域链用于决定函数执行时如何查找变量。作用域链的构成遵循以下原则：</p>\n<ol>\n<li><p><strong>静态作用域</strong>: JavaScript采用静态作用域（也称词法作用域），意味着函数的作用域链在函数定义时确定，而非运行时。</p>\n</li>\n<li><p><strong>链条构造</strong>: 作用域链的首端是当前函数的局部作用域，之后是包含当前函数的外部函数的作用域（如果有的话），以此类推，直到全局作用域为止。这条链定义了变量查找的顺序。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var globalVar &#x3D; &#39;global&#39;;\n\nfunction outer() &#123;\n    var outerVar &#x3D; &#39;outer&#39;;\n    \n    function inner() &#123;\n        var innerVar &#x3D; &#39;inner&#39;;\n        console.log(globalVar); &#x2F;&#x2F; 访问全局作用域变量\n        console.log(outerVar); &#x2F;&#x2F; 访问外部函数作用域变量\n        console.log(innerVar); &#x2F;&#x2F; 访问当前函数作用域变量\n    &#125;\n    \n    inner();\n&#125;\n\nouter();</code></pre>\n\n<h2 id=\"对this对象的理解\"><a href=\"#对this对象的理解\" class=\"headerlink\" title=\"对this对象的理解\"></a>对this对象的理解</h2><p>在JavaScript中，this关键字是一个非常重要且有时可能引起混淆的概念。this的值取决于函数调用的上下文，即函数是如何被调用的，而不是函数在哪里被定义。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>动态绑定: this的值是在运行时基于函数的调用方式动态确定的，并非在编写代码时静态决定。</li>\n<li>上下文依赖: 它通常指向函数执行时的环境对象——调用该函数的对象。</li>\n</ul>\n<h3 id=\"不同场景下的this值\"><a href=\"#不同场景下的this值\" class=\"headerlink\" title=\"不同场景下的this值\"></a>不同场景下的this值</h3><ul>\n<li>全局上下文<ul>\n<li>在全局执行环境中（非严格模式下），this指向全局对象。在浏览器中是window对象，在Node.js中是global对象。</li>\n<li>使用严格模式（’use strict’;声明），全局上下文中的this会是undefined。</li>\n</ul>\n</li>\n<li>函数调用<ul>\n<li>普通函数调用: 如果函数不是作为某个对象的方法被调用，非严格模式下this默认指向全局对象；严格模式下this为undefined。</li>\n<li>方法调用: 当函数作为某个对象的属性（方法）被调用时，this指向该对象。<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  method: function() &#123;\n    console.log(this); &#x2F;&#x2F; this指向obj\n  &#125;\n&#125;;\nobj.method();</code></pre></li>\n</ul>\n</li>\n<li>构造函数调用: 使用new关键字调用函数时，this指向新创建的实例对象。<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\nconst person &#x3D; new Person(&#39;Alice&#39;);\nconsole.log(person.name); &#x2F;&#x2F; &#39;Alice&#39;</code></pre></li>\n<li>箭头函数: 箭头函数不绑定自己的this，它会从外层（词法作用域）继承this值。<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  normalFunc: function() &#123;\n    console.log(this); &#x2F;&#x2F; obj\n  &#125;,\n  arrowFunc: () &#x3D;&gt; &#123;\n    console.log(this); &#x2F;&#x2F; 全局对象或undefined（严格模式）\n  &#125;\n&#125;;\nobj.normalFunc(); \nobj.arrowFunc();</code></pre></li>\n<li>Function.prototype.call(), apply(), bind(): 这些方法可以显式地设置函数调用时的this值。<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function greet(greeting) &#123;\n  console.log(&#96;$&#123;greeting&#125;, $&#123;this.name&#125;!&#96;);\n&#125;\n\nconst user &#x3D; &#123; name: &#39;Bob&#39; &#125;;\ngreet.call(user, &#39;Hello&#39;); &#x2F;&#x2F; Hello, Bob!</code></pre></li>\n</ul>\n<h2 id=\"call-和-apply-、bind-的区别？\"><a href=\"#call-和-apply-、bind-的区别？\" class=\"headerlink\" title=\"call() 和 apply() 、bind()的区别？\"></a>call() 和 apply() 、bind()的区别？</h2><h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call()\"></a>call()</h3><ul>\n<li>用途: call()方法用于调用一个函数，并指定函数内部this的值，同时可以传递给函数独立的参数。</li>\n<li>参数: 第一个参数是你希望函数内部this所指向的对象，之后可以依次传入函数执行时需要的参数，这些参数必须一一列出。</li>\n<li>立即执行: call()会立即调用函数。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function greet(name, greeting) &#123;\n    console.log(&#96;$&#123;greeting&#125;, $&#123;this.title&#125; $&#123;name&#125;!&#96;);\n&#125;\n\nconst person &#x3D; &#123; title: &#39;Mr.&#39; &#125;;\n\ngreet.call(person, &#39;John&#39;, &#39;Hello&#39;); &#x2F;&#x2F; 输出: Hello, Mr. John!</code></pre>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h3><ul>\n<li>用途: 类似于call(), apply()也是为了改变函数的调用上下文并立即执行函数，但它接收参数的方式不同。</li>\n<li>参数: 第一个参数同样用于指定this的值，第二个参数则是一个数组或类数组对象，包含了传递给函数的参数列表。</li>\n<li>参数形式: 由于使用数组，apply()适用于参数不确定或需要从数组中传递的情况。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">greet.apply(person, [&#39;John&#39;, &#39;Hello&#39;]); &#x2F;&#x2F; 输出: Hello, Mr. John!</code></pre>\n\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind()\"></a>bind()</h3><ul>\n<li>用途: bind()方法创建一个新的函数，其this值被永久地绑定到传给bind()的第一个参数，但并不立即执行这个函数。</li>\n<li>返回值: 返回一个新函数，当这个新函数被调用时，里面的this值会被永久绑定到bind()的第一个参数。</li>\n<li>参数: 同样可以传入额外的参数，这些参数将被预置，作为新函数的一部分，当调用这个新函数时，传入的额外参数会排在bind()指定的参数之前。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const boundGreet &#x3D; greet.bind(person, &#39;John&#39;);\nboundGreet(&#39;Hello&#39;); &#x2F;&#x2F; 输出: Hello, Mr. John!\n\n&#x2F;&#x2F; 绑定并预置部分参数\nconst greetJohn &#x3D; greet.bind(person, &#39;John&#39;);\ngreetJohn(&#39;Good morning&#39;); &#x2F;&#x2F; 输出: Good morning, Mr. John!</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>立即执行 vs. 延迟执行: call()和apply()会立即调用函数，而bind()返回一个新函数供后续调用。</li>\n<li>参数传递: call()和apply()都可以改变函数的调用上下文，区别在于参数的传递方式——call()接受单独的参数列表，而apply()接受一个参数数组。</li>\n<li>绑定用途: bind()常用于创建一个具有特定this上下文和预置参数的函数副本，适用于需要多次调用或作为事件处理器的情况。</li>\n</ul>\n<h2 id=\"异步编程的实现方式？\"><a href=\"#异步编程的实现方式？\" class=\"headerlink\" title=\"异步编程的实现方式？\"></a>异步编程的实现方式？</h2><p>异步编程是JavaScript中处理并发和非阻塞操作的关键技术，旨在提高程序响应性和性能。</p>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><ul>\n<li>概念: 最传统的异步处理方式，将一个函数（回调函数）作为参数传递给另一个函数，待异步操作完成后调用该回调函数。</li>\n<li>优点: 实现简单，无需额外库。</li>\n<li>缺点: 回调地狱（Callback Hell），当多个异步操作需要嵌套时，代码可读性和可维护性大大降低。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fs.readFile(&#39;file.txt&#39;, &#39;utf8&#39;, (err, data) &#x3D;&gt; &#123;\n    if (err) throw err;\n    console.log(data);\n&#125;);</code></pre>\n\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><ul>\n<li>概念: 一种解决回调地狱的异步编程模式，代表一个异步操作的最终完成（成功或失败）及其结果。</li>\n<li>状态: Pending（等待中）、Fulfilled（已完成，成功）、Rejected（已拒绝，失败）。</li>\n<li>方法: .then()处理成功结果，.catch()处理错误，.finally()无论结果如何都会执行。</li>\n<li>优点: 链式调用，易于理解和维护，支持并发执行（Promise.all()）和竞态执行（Promise.race()）。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fetch(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;)\n    .then(response &#x3D;&gt; response.json())\n    .then(data &#x3D;&gt; console.log(data))\n    .catch(error &#x3D;&gt; console.error(&#39;Error:&#39;, error));</code></pre>\n\n<h3 id=\"async-x2F-await\"><a href=\"#async-x2F-await\" class=\"headerlink\" title=\"async&#x2F;await\"></a>async&#x2F;await</h3><ul>\n<li>概念: 基于Promise的语法糖，使异步代码看起来更像同步代码。</li>\n<li>关键字: async定义异步函数，await等待Promise结果，暂停函数执行直到Promise解决。</li>\n<li>优点: 代码更简洁、直观，易于理解和维护。</li>\n<li>注意: 必须在async函数内部使用await，且await后的表达式通常是一个Promise。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function fetchData() &#123;\n    try &#123;\n        const response &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;);\n        const data &#x3D; await response.json();\n        console.log(data);\n    &#125; catch (error) &#123;\n        console.error(&#39;Error:&#39;, error);\n    &#125;\n&#125;\nfetchData();</code></pre>\n\n<h2 id=\"Promise的理解与应用\"><a href=\"#Promise的理解与应用\" class=\"headerlink\" title=\"Promise的理解与应用\"></a>Promise的理解与应用</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Promise 是 JavaScript 中用于处理异步操作的一种编程模型，它提供了一种标准化的方式来处理异步操作的成功或失败，并且支持链式调用，从而使得异步代码更加结构化和易于阅读。Promise 对象代表一个现在、将来或永远可能可用，或者永远不会可用的异步操作的结果。</p>\n<h3 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h3><p>Promise 有三种状态：</p>\n<ul>\n<li>Pending（等待中）：初始状态，既没有被兑现，也没有被拒绝。</li>\n<li>Fulfilled（已成功）：表示操作成功完成，此时 Promise 的值就是 resolve 方法传递的参数。</li>\n<li>Rejected（已失败）：表示操作失败，此时 Promise 的值是 reject 方法传递的参数。</li>\n<li>一旦 Promise 转变为 Fulfilled 或 Rejected 状态，它就会一直保持这个状态，不会再改变。</li>\n</ul>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>创建一个 Promise 实例：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 异步操作\n&#125;);</code></pre>\n\n<h3 id=\"resolve-与-reject\"><a href=\"#resolve-与-reject\" class=\"headerlink\" title=\"resolve 与 reject\"></a>resolve 与 reject</h3><ul>\n<li>resolve(value)：用于改变 Promise 的状态为 Fulfilled，传递一个可选的 value 参数作为异步操作的结果。</li>\n<li>reject(reason)：用于改变 Promise 的状态为 Rejected，并传递一个 reason 参数表示失败的原因。</li>\n</ul>\n<h3 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h3><p>通过 .then() 和 .catch() 方法实现链式调用，处理 Promise 的不同状态：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">myPromise\n  .then(result &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 成功处理逻辑\n    console.log(&#39;Success:&#39;, result);\n  &#125;)\n  .catch(error &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 失败处理逻辑\n    console.error(&#39;Error:&#39;, error);\n  &#125;);</code></pre>\n\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally\"></a>finally</h3><p>finally() 方法无论 Promise 的结果是 fulfilled 还是 rejected，都会执行指定的回调函数，常用于清理操作。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">myPromise\n  .then(...)\n  .catch(...)\n  .finally(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 清理或通知操作\n  &#125;);</code></pre>\n\n<h3 id=\"并行与串行\"><a href=\"#并行与串行\" class=\"headerlink\" title=\"并行与串行\"></a>并行与串行</h3><ul>\n<li>并行执行：使用 Promise.all() 可以同时执行多个 Promise，并在所有 Promise 完成（不论成功或失败）后返回一个新的 Promise。</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const promise1 &#x3D; Promise.resolve(3);\nconst promise2 &#x3D; 42;\nconst promise3 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  setTimeout(resolve, 100, &#39;foo&#39;);\n&#125;);\n\nPromise.all([promise1, promise2, promise3]).then((values) &#x3D;&gt; &#123;\n  console.log(values); &#x2F;&#x2F; [3, 42, &quot;foo&quot;]\n&#125;);</code></pre>\n\n<ul>\n<li>串行执行：通过在每个 Promise 的 .then() 中返回一个新的 Promise，可以实现按顺序执行异步操作</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">doSomething()\n  .then(result1 &#x3D;&gt; doSomethingElse(result1))\n  .then(result2 &#x3D;&gt; doThirdThing(result2))\n  .catch(error &#x3D;&gt; console.error(error));</code></pre>\n\n<h2 id=\"对象创建的方式有哪些？\"><a href=\"#对象创建的方式有哪些？\" class=\"headerlink\" title=\"对象创建的方式有哪些？\"></a>对象创建的方式有哪些？</h2><h3 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h3><p>特点：最直接、简洁的创建单个对象的方式。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let obj &#x3D; &#123;\n    key1: &#39;value1&#39;,\n    key2: &#39;value2&#39;,\n    method: function() &#123;\n        console.log(&#39;这是一个方法&#39;);\n    &#125;\n&#125;;</code></pre>\n\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>特点：通过函数来创建特定类型的对象，可以重复使用，支持new操作符。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.sayHello &#x3D; function() &#123;\n        console.log(&#39;Hello, I am &#39; + this.name);\n    &#125;;\n&#125;\n\nlet person1 &#x3D; new Person(&#39;Alice&#39;, 30);</code></pre>\n\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>特点：通过函数来创建特定类型的对象，可以重复使用，支持new操作符。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Person(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.sayHello &#x3D; function() &#123;\n        console.log(&#39;Hello, I am &#39; + this.name);\n    &#125;;\n&#125;\n\nlet person1 &#x3D; new Person(&#39;Alice&#39;, 30);</code></pre>\n\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>特点：通过构造函数的prototype属性共享方法，减少内存消耗。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function PersonProto(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n&#125;\n\nPersonProto.prototype.sayHello &#x3D; function() &#123;\n    console.log(&#39;Hello, I am &#39; + this.name);\n&#125;;\n\nlet person3 &#x3D; new PersonProto(&#39;Carol&#39;, 28);</code></pre>\n\n<h3 id=\"Class（ES6-）\"><a href=\"#Class（ES6-）\" class=\"headerlink\" title=\"Class（ES6+）\"></a>Class（ES6+）</h3><p>特点：基于原型但语法更接近面向对象语言的类实现，支持继承、静态方法等。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class PersonClass &#123;\n    constructor(name, age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    sayHello() &#123;\n        console.log(&#39;Hello, I am &#39; + this.name);\n    &#125;\n&#125;\n\nlet person4 &#x3D; new PersonClass(&#39;David&#39;, 32);</code></pre>\n\n<h3 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create\"></a>Object.create</h3><p>特点：直接从一个对象原型创建新对象，不通过构造函数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let personPrototype &#x3D; &#123;\n    sayHello: function() &#123;\n        console.log(&#39;Hello from prototype&#39;);\n    &#125;\n&#125;;\n\nlet person5 &#x3D; Object.create(personPrototype);\nperson5.name &#x3D; &#39;Eva&#39;;</code></pre>\n\n\n<h2 id=\"浏览器的垃圾回收机制\"><a href=\"#浏览器的垃圾回收机制\" class=\"headerlink\" title=\"浏览器的垃圾回收机制\"></a>浏览器的垃圾回收机制</h2><p>浏览器的垃圾回收机制（GC）是自动管理内存资源的重要组成部分，它负责回收不再被使用的内存空间，确保内存的有效利用。以下是关于浏览器垃圾回收机制的详细说明，采用Markdown格式呈现：</p>\n<h3 id=\"浏览器垃圾回收机制概览\"><a href=\"#浏览器垃圾回收机制概览\" class=\"headerlink\" title=\"浏览器垃圾回收机制概览\"></a>浏览器垃圾回收机制概览</h3><p>浏览器垃圾回收机制旨在自动回收JavaScript代码运行过程中分配的、不再被任何变量引用的内存空间。这一过程主要依赖于两种基本算法：<strong>标记-清除（Mark-and-Sweep）</strong> 和 <strong>引用计数（Reference Counting）</strong>，现代浏览器通常采用更复杂的策略来优化这一过程，比如 <strong>分代收集（Generational Collection）</strong> 和 <strong>增量回收（Incremental Collection）</strong>。</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><ol>\n<li><strong>标记阶段</strong>：从根对象（通常是全局对象）出发，遍历所有可达的对象，将它们标记为“活着”。</li>\n<li><strong>清除阶段</strong>：遍历堆内存，未被标记的对象被视为垃圾，其占用的内存空间被回收。</li>\n</ol>\n<h3 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h3><ul>\n<li>每个对象有一个引用计数，每当一个地方引用它时计数加一，引用被移除时减一。</li>\n<li>当对象的引用计数降为零时，该对象被认为是垃圾，可以被回收。</li>\n</ul>\n<h3 id=\"分代收集\"><a href=\"#分代收集\" class=\"headerlink\" title=\"分代收集\"></a>分代收集</h3><ul>\n<li><strong>新生代（Young Generation）</strong>：存放短期存活的对象，通常使用<strong>Scavenge算法</strong>快速回收。</li>\n<li><strong>老生代（Old Generation）</strong>：存放长期存活的对象，回收成本较高，采用标记-清除或更复杂的算法。</li>\n<li>对象在经历一定次数的回收后若仍存活，会被晋升至老生代。</li>\n</ul>\n<h3 id=\"增量回收\"><a href=\"#增量回收\" class=\"headerlink\" title=\"增量回收\"></a>增量回收</h3><ul>\n<li>为了避免长时间的垃圾回收导致页面冻结，现代浏览器采用增量回收策略，将回收过程拆分成多个小步骤穿插在JavaScript执行之间执行。</li>\n</ul>\n<h3 id=\"内存管理注意事项\"><a href=\"#内存管理注意事项\" class=\"headerlink\" title=\"内存管理注意事项\"></a>内存管理注意事项</h3><ul>\n<li><strong>避免内存泄漏</strong>：确保不再使用的对象能够被适时地解除引用，防止无意识的循环引用导致内存无法释放。</li>\n<li><strong>优化代码</strong>：减少大对象的创建和销毁，合理使用闭包，注意定时器和事件监听器的清理。</li>\n</ul>\n<h3 id=\"触发时机\"><a href=\"#触发时机\" class=\"headerlink\" title=\"触发时机\"></a>触发时机</h3><ul>\n<li>浏览器自动管理GC触发，无需开发者直接干预，但过度分配内存或复杂的对象关系可能频繁触发GC，影响性能。</li>\n</ul>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>浏览器的垃圾回收机制是一个复杂而智能的过程，旨在平衡内存的有效利用与程序的执行效率。开发者应关注内存管理最佳实践，以辅助垃圾回收机制高效运作，避免因不当编码导致的性能瓶颈。</p>\n<h2 id=\"哪些情况会导致内存泄漏\"><a href=\"#哪些情况会导致内存泄漏\" class=\"headerlink\" title=\"哪些情况会导致内存泄漏\"></a>哪些情况会导致内存泄漏</h2><p>在JavaScript中，尽管有自动垃圾回收机制来管理内存，但不当的编码实践仍可能导致内存泄漏。以下是可能导致JavaScript内存泄漏的常见情况，以Markdown格式展示：</p>\n<h3 id=\"JavaScript内存泄漏常见场景\"><a href=\"#JavaScript内存泄漏常见场景\" class=\"headerlink\" title=\"JavaScript内存泄漏常见场景\"></a>JavaScript内存泄漏常见场景</h3><ol>\n<li><p><strong>意外的全局变量</strong></p>\n<ul>\n<li>未使用<code>var</code>、<code>let</code>或<code>const</code>声明的变量会自动成为全局对象的属性，导致无法被垃圾回收。</li>\n</ul>\n</li>\n<li><p><strong>闭包中的引用</strong></p>\n<ul>\n<li>闭包可能长期持有对外部变量的引用，如果这些变量包含大量数据或对象，会阻止它们被回收。</li>\n</ul>\n</li>\n<li><p><strong>未清理的定时器和回调函数</strong></p>\n<ul>\n<li>使用<code>setTimeout</code>或<code>setInterval</code>后未调用<code>clearTimeout</code>或<code>clearInterval</code>来清理，导致回调函数持续占用内存。</li>\n</ul>\n</li>\n<li><p><strong>DOM元素引用</strong></p>\n<ul>\n<li>即使DOM元素已从页面中移除，若JavaScript中仍有对该元素的引用，该元素及其相关资源将不会被回收。</li>\n</ul>\n</li>\n<li><p><strong>事件监听器</strong></p>\n<ul>\n<li>未正确解除的事件监听器会持续持有DOM元素的引用，阻止元素和相关上下文被回收。</li>\n</ul>\n</li>\n<li><p><strong>循环引用</strong></p>\n<ul>\n<li>两个或更多对象互相引用，形成循环链，若没有外部引用指向这个循环，垃圾回收器可能无法释放它们。</li>\n</ul>\n</li>\n<li><p><strong>未释放的资源</strong></p>\n<ul>\n<li>如网络请求、Web Workers、Image对象等未正确关闭或释放，可能导致资源泄露。</li>\n</ul>\n</li>\n<li><p><strong>大型数据结构</strong></p>\n<ul>\n<li>大型数组或对象若长期保存在内存中且不再使用，若没有适时清空或重新分配，会占用大量内存。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"setTimeout、setInterval、requestAnimationFrame-各有什么特点？\"><a href=\"#setTimeout、setInterval、requestAnimationFrame-各有什么特点？\" class=\"headerlink\" title=\"setTimeout、setInterval、requestAnimationFrame 各有什么特点？\"></a>setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h2><p><code>setTimeout</code>、<code>setInterval</code>、和<code>requestAnimationFrame</code>都是JavaScript中用于处理延时或周期性执行任务的功能，但它们各有特点，适用于不同的场景：</p>\n<h3 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h3><ul>\n<li><strong>特点</strong>：<ul>\n<li><strong>一次性执行</strong>：<code>setTimeout</code>用于在指定的时间（延迟时间）之后执行一次指定的函数或代码块。</li>\n<li><strong>非阻塞</strong>：它不会阻塞代码的执行，而是将回调函数加入到任务队列，待到时间到了再执行。</li>\n<li><strong>不精确</strong>：实际执行时间可能晚于指定时间，因为JavaScript是单线程且执行环境是事件驱动的。</li>\n<li><strong>应用场景</strong>：适合执行一次性、延迟执行的任务，例如用户操作后的反馈延迟显示、定时任务的启动等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h3><ul>\n<li><strong>特点</strong>：<ul>\n<li><strong>周期性执行</strong>：按指定的时间间隔重复执行函数或代码块，直到被明确停止（通过<code>clearInterval</code>）。</li>\n<li><strong>可能存在累积延迟</strong>：如果某个执行周期的代码执行时间超过了间隔时间，后续执行可能会被推迟，导致累积延迟。</li>\n<li><strong>资源占用</strong>：如果间隔设置不合理或忘记清除，可能导致CPU占用过高、页面卡顿等问题。</li>\n<li><strong>应用场景</strong>：适用于需要重复执行的定时任务，如实时更新时钟、轮播图自动切换等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h3><ul>\n<li><strong>特点</strong>：<ul>\n<li><strong>与重绘同步</strong>：它会在浏览器下一次重绘之前执行回调函数，确保动画与页面渲染同步，提供平滑的视觉效果。</li>\n<li><strong>自动调整频率</strong>：根据设备的屏幕刷新率自动调整执行频率，一般接近60fps，有助于节省系统资源。</li>\n<li><strong>暂停后台标签页</strong>：在非当前活动的标签页中，<code>requestAnimationFrame</code>会暂停执行，避免消耗不必要的计算资源。</li>\n<li><strong>应用场景</strong>：特别适合于创建高性能的动画效果，如页面滚动、元素移动、CSS动画增强等，以达到流畅的用户体验。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"async-x2F-await的优势\"><a href=\"#async-x2F-await的优势\" class=\"headerlink\" title=\"async&#x2F;await的优势\"></a>async&#x2F;await的优势</h2><p><code>async/await</code> 是现代JavaScript中处理异步操作的强有力工具，相比传统的回调函数和Promise，它带来了多方面的优势，使得异步编程变得更加简洁、直观和易于维护。以下是<code>async/await</code>的主要优点：</p>\n<h3 id=\"1-代码可读性和简洁性\"><a href=\"#1-代码可读性和简洁性\" class=\"headerlink\" title=\"1. 代码可读性和简洁性\"></a>1. <strong>代码可读性和简洁性</strong></h3><ul>\n<li><strong>清晰的流程控制</strong>：通过使用类似于同步代码的编写方式，<code>async/await</code>极大地提高了代码的可读性和可维护性。开发者可以使用熟悉的顺序、条件和循环结构来组织异步逻辑，而不需要嵌套回调或复杂的Promise链。</li>\n</ul>\n<h3 id=\"2-错误处理的简化\"><a href=\"#2-错误处理的简化\" class=\"headerlink\" title=\"2. 错误处理的简化\"></a>2. <strong>错误处理的简化</strong></h3><ul>\n<li><strong>集中错误处理</strong>：使用try&#x2F;catch块可以直接在异步函数内部捕获错误，这种方式与同步代码中的错误处理一致，使得错误处理逻辑更加集中和易于理解。</li>\n</ul>\n<h3 id=\"3-更自然的异常传播\"><a href=\"#3-更自然的异常传播\" class=\"headerlink\" title=\"3. 更自然的异常传播\"></a>3. <strong>更自然的异常传播</strong></h3><ul>\n<li><strong>自动Promise封装</strong>：<code>async</code>函数会自动将非Promise的返回值转换为resolved的Promise，并且任何未被捕获的异常都会被自动封装成一个rejected的Promise，这使得异常处理和Promise链的组合更加自然。</li>\n</ul>\n<h3 id=\"4-更少的回调地狱\"><a href=\"#4-更少的回调地狱\" class=\"headerlink\" title=\"4. 更少的回调地狱\"></a>4. <strong>更少的回调地狱</strong></h3><ul>\n<li><strong>减少嵌套</strong>：避免了传统异步编程中常见的“回调地狱”现象，使得代码结构更加扁平，易于阅读和调试。</li>\n</ul>\n<h3 id=\"5-更好的代码调试体验\"><a href=\"#5-更好的代码调试体验\" class=\"headerlink\" title=\"5. 更好的代码调试体验\"></a>5. <strong>更好的代码调试体验</strong></h3><ul>\n<li><strong>步进执行</strong>：在支持的开发工具中，可以逐步执行<code>async</code>函数内的代码，包括跨<code>await</code>点，这使得调试异步代码就像调试同步代码一样直观。</li>\n</ul>\n<h3 id=\"6-易于理解和协作\"><a href=\"#6-易于理解和协作\" class=\"headerlink\" title=\"6. 易于理解和协作\"></a>6. <strong>易于理解和协作</strong></h3><ul>\n<li><strong>普遍易接受</strong>：对于新手和经验丰富的开发者而言，<code>async/await</code>模式都更加直观，减少了学习和团队协作的成本。</li>\n</ul>\n<h3 id=\"7-灵活性与兼容性\"><a href=\"#7-灵活性与兼容性\" class=\"headerlink\" title=\"7. 灵活性与兼容性\"></a>7. <strong>灵活性与兼容性</strong></h3><ul>\n<li><strong>与Promise兼容</strong>：虽然<code>async/await</code>是基于Promise实现的，但它本身并不排斥Promise的使用。在需要更复杂的异步控制流时，可以灵活地混合使用两者。</li>\n</ul>\n<h2 id=\"对async-x2F-await-的理解\"><a href=\"#对async-x2F-await-的理解\" class=\"headerlink\" title=\"对async&#x2F;await 的理解\"></a>对async&#x2F;await 的理解</h2><p><code>async</code> 和 <code>await</code> 是 ES2017 引入的JavaScript关键字，用于简化基于Promise的异步编程，使得异步代码更加易于理解和维护。</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><ul>\n<li><strong>定义</strong>: <code>async</code> 是一个在函数声明前使用的修饰符，它标志着该函数是一个异步函数。</li>\n<li><strong>返回值</strong>: 异步函数总是返回一个Promise。即使函数内部没有显式地返回Promise，函数也会隐式地将其非Promise返回值包装成一个 resolved 状态的Promise。</li>\n<li><strong>错误处理</strong>: 如果异步函数内部抛出了一个错误，这个错误会被异步函数捕获并返回一个rejected状态的Promise。</li>\n</ul>\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><ul>\n<li><strong>使用场景</strong>: <code>await</code> 关键字只能在 <code>async</code> 函数内部使用。</li>\n<li><strong>作用</strong>: 让JavaScript引擎等待一个Promise的结果，即等待Promise resolve或reject，然后继续执行后面的代码。<ul>\n<li>当 <code>await</code> 后面的Promise resolve时，<code>await</code> 表达式的值就是Promise的resolve值。</li>\n<li>如果Promise被reject，那么<code>await</code>表达式会抛出错误，可以使用try&#x2F;catch语句来捕获这个错误。</li>\n</ul>\n</li>\n<li><strong>非阻塞</strong>: 虽然<code>await</code>会让代码“等待”，但实际上它并不会阻塞其他任务的执行。JavaScript引擎会在这期间处理其他任务，只有当await的Promise完成时才会回到当前async函数继续执行。</li>\n</ul>\n<h2 id=\"宏任务和微任务的区别\"><a href=\"#宏任务和微任务的区别\" class=\"headerlink\" title=\"宏任务和微任务的区别\"></a>宏任务和微任务的区别</h2><p>宏任务（Macro Task）和微任务（Micro Task）是JavaScript中任务调度的一部分，用于处理异步操作。它们在事件循环（Event Loop）中起到不同的作用，影响了代码执行的顺序和性能。</p>\n<h3 id=\"宏任务（Macro-Task）\"><a href=\"#宏任务（Macro-Task）\" class=\"headerlink\" title=\"宏任务（Macro Task）\"></a>宏任务（Macro Task）</h3><p>宏任务是相对较大的任务，包括主代码块（全局脚本）、setTimeout、setInterval、I&#x2F;O操作、UI rendering等。每个宏任务在执行时会处理所有同步代码，以及在宏任务队列中排队等待的任务。</p>\n<h3 id=\"微任务（Micro-Task）\"><a href=\"#微任务（Micro-Task）\" class=\"headerlink\" title=\"微任务（Micro Task）\"></a>微任务（Micro Task）</h3><p>微任务是相对较小的任务，通常用于处理比宏任务优先级更高的任务。微任务主要包括 Promise 的回调函数、MutationObserver 和 process.nextTick（Node.js 中）。微任务会在当前宏任务执行完后立即执行。</p>\n<h3 id=\"事件循环（Event-Loop）\"><a href=\"#事件循环（Event-Loop）\" class=\"headerlink\" title=\"事件循环（Event Loop）\"></a>事件循环（Event Loop）</h3><p>JavaScript 是单线程执行的，事件循环机制帮助管理异步操作的执行顺序。事件循环的基本步骤如下：</p>\n<ol>\n<li>执行一个宏任务（如果有的话）。</li>\n<li>执行所有的微任务（依次执行，直到微任务队列为空）。</li>\n<li>更新渲染（如果需要的话）。</li>\n<li>重复上述步骤。</li>\n</ol>\n<h3 id=\"示例解释\"><a href=\"#示例解释\" class=\"headerlink\" title=\"示例解释\"></a>示例解释</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(&#39;Start&#39;);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;Timeout&#39;);\n&#125;, 0);\n\nPromise.resolve().then(() &#x3D;&gt; &#123;\n  console.log(&#39;Promise&#39;);\n&#125;);\n\nconsole.log(&#39;End&#39;);</code></pre>\n\n<p>执行顺序如下：</p>\n<ol>\n<li><p>首先执行同步代码：<code>console.log(&#39;Start&#39;)</code> 和 <code>console.log(&#39;End&#39;)</code>，输出为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Start\nEnd</code></pre>\n</li>\n<li><p>同步代码执行完后，事件循环开始处理微任务队列中的任务，即 <code>Promise.resolve().then(...)</code>，输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise</code></pre>\n</li>\n<li><p>最后，事件循环处理宏任务队列中的任务，即 <code>setTimeout</code> 回调，输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Timeout</code></pre></li>\n</ol>\n<p>完整输出顺序为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Start\nEnd\nPromise\nTimeout</code></pre>\n\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>宏任务</strong> 包括主代码块、setTimeout、setInterval、I&#x2F;O操作等，影响了异步操作的执行顺序。</li>\n<li><strong>微任务</strong> 包括 Promise 的回调、MutationObserver、process.nextTick 等，具有比宏任务更高的优先级。</li>\n<li><strong>事件循环</strong> 按顺序执行宏任务和微任务，保证异步代码按预期执行。</li>\n</ul>\n<p>理解宏任务和微任务有助于优化JavaScript代码的性能和预期行为。</p>\n<h2 id=\"MVVM和MVC的区别\"><a href=\"#MVVM和MVC的区别\" class=\"headerlink\" title=\"MVVM和MVC的区别\"></a>MVVM和MVC的区别</h2><p>MVC（Model-View-Controller）和 MVVM（Model-View-ViewModel）是两种常见的架构模式，用于分离应用程序的关注点，使代码更加模块化和可维护。尽管它们有相似之处，但它们在结构和数据绑定方面有显著的区别。</p>\n<h3 id=\"MVC（Model-View-Controller）\"><a href=\"#MVC（Model-View-Controller）\" class=\"headerlink\" title=\"MVC（Model-View-Controller）\"></a>MVC（Model-View-Controller）</h3><p><strong>1. Model（模型）</strong></p>\n<ul>\n<li>负责应用程序的业务逻辑和数据处理。</li>\n<li>与数据库交互，执行CRUD操作。</li>\n<li>通知视图更新数据。</li>\n</ul>\n<p><strong>2. View（视图）</strong></p>\n<ul>\n<li>负责展示数据给用户。</li>\n<li>从模型中获取数据，并将其呈现给用户。</li>\n<li>通常是被动的，只负责显示数据。</li>\n</ul>\n<p><strong>3. Controller（控制器）</strong></p>\n<ul>\n<li>负责处理用户输入和操作。</li>\n<li>将用户的输入转发给模型进行处理。</li>\n<li>更新视图以反映模型的变化。</li>\n</ul>\n<h3 id=\"工作流程：\"><a href=\"#工作流程：\" class=\"headerlink\" title=\"工作流程：\"></a>工作流程：</h3><ol>\n<li>用户在视图中触发一个事件（如点击按钮）。</li>\n<li>控制器捕获事件并处理它，可能会调用模型进行数据更新。</li>\n<li>模型更新数据后通知视图进行更新。</li>\n<li>视图从模型获取最新数据并重新渲染。</li>\n</ol>\n<h3 id=\"MVVM（Model-View-ViewModel）\"><a href=\"#MVVM（Model-View-ViewModel）\" class=\"headerlink\" title=\"MVVM（Model-View-ViewModel）\"></a>MVVM（Model-View-ViewModel）</h3><p><strong>1. Model（模型）</strong></p>\n<ul>\n<li>与MVC中的模型类似，负责应用程序的业务逻辑和数据处理。</li>\n</ul>\n<p><strong>2. View（视图）</strong></p>\n<ul>\n<li>与MVC中的视图类似，负责展示数据给用户。</li>\n<li>通常绑定到ViewModel。</li>\n</ul>\n<p><strong>3. ViewModel（视图模型）</strong></p>\n<ul>\n<li>负责在视图和模型之间进行通信。</li>\n<li>包含表示视图数据的逻辑。</li>\n<li>通过双向数据绑定与视图进行交互，即视图的变化自动更新ViewModel，ViewModel的变化自动更新视图。</li>\n</ul>\n<h3 id=\"工作流程：-1\"><a href=\"#工作流程：-1\" class=\"headerlink\" title=\"工作流程：\"></a>工作流程：</h3><ol>\n<li>用户在视图中触发一个事件。</li>\n<li>事件通过数据绑定机制自动传递给ViewModel。</li>\n<li>ViewModel处理事件，可能会调用模型进行数据更新。</li>\n<li>模型更新数据后，ViewModel接收并更新自身状态。</li>\n<li>ViewModel的变化通过数据绑定自动更新视图。</li>\n</ol>\n<h3 id=\"主要区别\"><a href=\"#主要区别\" class=\"headerlink\" title=\"主要区别\"></a>主要区别</h3><ol>\n<li><p><strong>数据绑定</strong></p>\n<ul>\n<li><strong>MVC</strong>：通常是单向数据绑定，视图依赖于模型的通知来更新数据。</li>\n<li><strong>MVVM</strong>：通常是双向数据绑定，视图和ViewModel之间自动同步数据变化。</li>\n</ul>\n</li>\n<li><p><strong>中介者角色</strong></p>\n<ul>\n<li><strong>MVC</strong>：控制器充当视图和模型之间的中介者。</li>\n<li><strong>MVVM</strong>：ViewModel充当视图和模型之间的中介者，并处理视图的逻辑。</li>\n</ul>\n</li>\n<li><p><strong>关注点分离</strong></p>\n<ul>\n<li><strong>MVC</strong>：控制器包含视图的逻辑，有时导致视图逻辑分散在多个控制器中。</li>\n<li><strong>MVVM</strong>：ViewModel包含视图的逻辑，使视图逻辑更集中，更容易测试。</li>\n</ul>\n</li>\n<li><p><strong>适用场景</strong></p>\n<ul>\n<li><strong>MVC</strong>：适用于传统的服务器端渲染应用程序，例如许多Web应用。</li>\n<li><strong>MVVM</strong>：适用于现代前端框架，如Angular、React和Vue，它们有强大的数据绑定和组件系统。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>MVC</strong> 强调的是控制器的作用，通过控制器处理视图和模型之间的交互。</li>\n<li><strong>MVVM</strong> 强调的是双向数据绑定，通过ViewModel来处理视图逻辑和模型数据的同步。</li>\n</ul>\n<p>这两种模式各有优缺点，选择使用哪种模式通常取决于应用的具体需求和开发团队的偏好。</p>\n<h2 id=\"实现图片懒加载的方式有哪些\"><a href=\"#实现图片懒加载的方式有哪些\" class=\"headerlink\" title=\"实现图片懒加载的方式有哪些\"></a>实现图片懒加载的方式有哪些</h2><p>图片懒加载是一种优化页面性能的技术，通过延迟加载页面中非可视区域的图片，减少初始加载时间和网络带宽消耗。实现图片懒加载的方式有多种，以下是一些常见的实现方法：</p>\n<h3 id=\"1-原生-loading-属性\"><a href=\"#1-原生-loading-属性\" class=\"headerlink\" title=\"1. 原生 loading 属性\"></a>1. 原生 <code>loading</code> 属性</h3><p>现代浏览器支持通过 <code>loading</code> 属性直接实现图片懒加载。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;img src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;example&quot; loading&#x3D;&quot;lazy&quot;&gt;</code></pre>\n\n<h3 id=\"2-使用-Intersection-Observer-API\"><a href=\"#2-使用-Intersection-Observer-API\" class=\"headerlink\" title=\"2. 使用 Intersection Observer API\"></a>2. 使用 Intersection Observer API</h3><p>Intersection Observer API 是一种高效的观察元素是否在视口内的方式，适用于实现懒加载。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;img class&#x3D;&quot;lazy&quot; data-src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;example&quot;&gt;\n\n&lt;script&gt;\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;\n  const lazyImages &#x3D; document.querySelectorAll(&#39;img.lazy&#39;);\n\n  if (&#39;IntersectionObserver&#39; in window) &#123;\n    const lazyImageObserver &#x3D; new IntersectionObserver(function(entries, observer) &#123;\n      entries.forEach(function(entry) &#123;\n        if (entry.isIntersecting) &#123;\n          const lazyImage &#x3D; entry.target;\n          lazyImage.src &#x3D; lazyImage.dataset.src;\n          lazyImage.classList.remove(&#39;lazy&#39;);\n          lazyImageObserver.unobserve(lazyImage);\n        &#125;\n      &#125;);\n    &#125;);\n\n    lazyImages.forEach(function(lazyImage) &#123;\n      lazyImageObserver.observe(lazyImage);\n    &#125;);\n  &#125; else &#123;\n    &#x2F;&#x2F; Fallback for browsers that don&#39;t support IntersectionObserver\n    let lazyLoadThrottleTimeout;\n    function lazyLoad() &#123;\n      if (lazyLoadThrottleTimeout) &#123;\n        clearTimeout(lazyLoadThrottleTimeout);\n      &#125;    \n\n      lazyLoadThrottleTimeout &#x3D; setTimeout(function() &#123;\n        const scrollTop &#x3D; window.pageYOffset;\n        lazyImages.forEach(function(img) &#123;\n          if (img.offsetTop &lt; (window.innerHeight + scrollTop)) &#123;\n            img.src &#x3D; img.dataset.src;\n            img.classList.remove(&#39;lazy&#39;);\n          &#125;\n        &#125;);\n        if (lazyImages.length &#x3D;&#x3D;&#x3D; 0) &#123; \n          document.removeEventListener(&quot;scroll&quot;, lazyLoad);\n          window.removeEventListener(&quot;resize&quot;, lazyLoad);\n          window.removeEventListener(&quot;orientationChange&quot;, lazyLoad);\n        &#125;\n      &#125;, 20);\n    &#125;\n\n    document.addEventListener(&quot;scroll&quot;, lazyLoad);\n    window.addEventListener(&quot;resize&quot;, lazyLoad);\n    window.addEventListener(&quot;orientationChange&quot;, lazyLoad);\n  &#125;\n&#125;);\n&lt;&#x2F;script&gt;</code></pre>\n\n<h3 id=\"3-使用第三方库\"><a href=\"#3-使用第三方库\" class=\"headerlink\" title=\"3. 使用第三方库\"></a>3. 使用第三方库</h3><p>一些第三方库提供了简便的懒加载实现，例如 <code>lazysizes</code>。</p>\n<h4 id=\"使用-lazysizes\"><a href=\"#使用-lazysizes\" class=\"headerlink\" title=\"使用 lazysizes\"></a>使用 <code>lazysizes</code></h4><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;lazysizes&#x2F;5.2.2&#x2F;lazysizes.min.js&quot; async&gt;&lt;&#x2F;script&gt;\n&lt;img data-src&#x3D;&quot;image.jpg&quot; class&#x3D;&quot;lazyload&quot; alt&#x3D;&quot;example&quot;&gt;</code></pre>\n\n<h3 id=\"4-监听滚动事件-不推荐\"><a href=\"#4-监听滚动事件-不推荐\" class=\"headerlink\" title=\"4. 监听滚动事件 (不推荐)\"></a>4. 监听滚动事件 (不推荐)</h3><p>直接监听滚动事件虽然也能实现懒加载，但性能较差，不推荐使用。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;img class&#x3D;&quot;lazy&quot; data-src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;example&quot;&gt;\n\n&lt;script&gt;\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;\n  const lazyImages &#x3D; document.querySelectorAll(&#39;img.lazy&#39;);\n  \n  function lazyLoad() &#123;\n    lazyImages.forEach(function(img) &#123;\n      if (img.getBoundingClientRect().top &lt; window.innerHeight) &#123;\n        img.src &#x3D; img.dataset.src;\n        img.classList.remove(&#39;lazy&#39;);\n      &#125;\n    &#125;);\n  &#125;\n\n  document.addEventListener(&#39;scroll&#39;, lazyLoad);\n&#125;);\n&lt;&#x2F;script&gt;</code></pre>\n\n<h3 id=\"5-结合-React-和-React-Lazy-Load-库\"><a href=\"#5-结合-React-和-React-Lazy-Load-库\" class=\"headerlink\" title=\"5. 结合 React 和 React-Lazy-Load 库\"></a>5. 结合 React 和 React-Lazy-Load 库</h3><p>在 React 项目中，可以使用 <code>react-lazy-load</code> 库。</p>\n<h4 id=\"使用-react-lazy-load\"><a href=\"#使用-react-lazy-load\" class=\"headerlink\" title=\"使用 react-lazy-load\"></a>使用 <code>react-lazy-load</code></h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install react-lazy-load</code></pre>\n\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React from &#39;react&#39;;\nimport LazyLoad from &#39;react-lazy-load&#39;;\n\nconst LazyImage &#x3D; () &#x3D;&gt; (\n  &lt;LazyLoad height&#x3D;&#123;200&#125; offsetVertical&#x3D;&#123;300&#125;&gt;\n    &lt;img src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;example&quot; &#x2F;&gt;\n  &lt;&#x2F;LazyLoad&gt;\n);\n\nexport default LazyImage;</code></pre>\n\n<h3 id=\"6-使用-react-intersection-observer-库\"><a href=\"#6-使用-react-intersection-observer-库\" class=\"headerlink\" title=\"6. 使用 react-intersection-observer 库\"></a>6. 使用 <code>react-intersection-observer</code> 库</h3><p>在 React 中也可以使用 <code>react-intersection-observer</code> 库来实现懒加载。</p>\n<h4 id=\"使用-react-intersection-observer\"><a href=\"#使用-react-intersection-observer\" class=\"headerlink\" title=\"使用 react-intersection-observer\"></a>使用 <code>react-intersection-observer</code></h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install react-intersection-observer</code></pre>\n\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React from &#39;react&#39;;\nimport &#123; useInView &#125; from &#39;react-intersection-observer&#39;;\n\nconst LazyImage &#x3D; () &#x3D;&gt; &#123;\n  const &#123; ref, inView &#125; &#x3D; useInView(&#123;\n    triggerOnce: true, &#x2F;&#x2F; 只触发一次\n    rootMargin: &#39;100px&#39;, &#x2F;&#x2F; 提前加载\n  &#125;);\n\n  return (\n    &lt;img\n      ref&#x3D;&#123;ref&#125;\n      src&#x3D;&#123;inView ? &#39;image.jpg&#39; : &#39;&#39;&#125;\n      alt&#x3D;&quot;example&quot;\n    &#x2F;&gt;\n  );\n&#125;;\n\nexport default LazyImage;</code></pre>\n\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>实现图片懒加载有多种方法，选择合适的方法可以根据项目需求和浏览器支持情况。原生 <code>loading</code> 属性简单易用，Intersection Observer API 性能优越，第三方库提供了便捷的解决方案。在 React 项目中，可以使用相应的库来实现懒加载功能。</p>\n<h2 id=\"用户访问页面白屏了，原因是啥，如何排查\"><a href=\"#用户访问页面白屏了，原因是啥，如何排查\" class=\"headerlink\" title=\"用户访问页面白屏了，原因是啥，如何排查\"></a>用户访问页面白屏了，原因是啥，如何排查</h2><p>用户访问页面出现白屏的情况，可能是由多种原因导致的。排查这个问题需要逐步分析和调试，以下是一些常见原因及排查方法：</p>\n<h3 id=\"常见原因\"><a href=\"#常见原因\" class=\"headerlink\" title=\"常见原因\"></a>常见原因</h3><ol>\n<li><p><strong>JavaScript 错误</strong></p>\n<ul>\n<li>JavaScript 执行时出错，阻止了页面的正常渲染。</li>\n</ul>\n</li>\n<li><p><strong>资源加载失败</strong></p>\n<ul>\n<li>关键资源（如 CSS、JavaScript 文件、图片等）未能成功加载。</li>\n</ul>\n</li>\n<li><p><strong>HTML 结构问题</strong></p>\n<ul>\n<li>HTML 结构错误或未正确加载，导致页面内容无法渲染。</li>\n</ul>\n</li>\n<li><p><strong>网络问题</strong></p>\n<ul>\n<li>网络连接问题导致资源加载失败。</li>\n</ul>\n</li>\n<li><p><strong>权限问题</strong></p>\n<ul>\n<li>资源受权限限制，导致无法加载。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"排查步骤\"><a href=\"#排查步骤\" class=\"headerlink\" title=\"排查步骤\"></a>排查步骤</h3><ol>\n<li><p><strong>检查浏览器控制台</strong></p>\n<ul>\n<li>打开浏览器开发者工具（通常按 <code>F12</code> 或 <code>Ctrl + Shift + I</code>）。</li>\n<li>查看控制台（Console）中是否有报错信息。通常，JavaScript 错误会在控制台中显示，帮助定位问题。</li>\n</ul>\n</li>\n<li><p><strong>检查网络请求</strong></p>\n<ul>\n<li>在开发者工具中，切换到“网络”标签页（Network）。</li>\n<li>刷新页面，查看是否有资源加载失败。注意 404（未找到）或 500（服务器错误）状态码的请求。</li>\n<li>检查资源加载时间，是否有请求超时或加载时间过长。</li>\n</ul>\n</li>\n<li><p><strong>查看 HTML 结构</strong></p>\n<ul>\n<li>在开发者工具的“元素”标签页（Elements）中查看页面的 HTML 结构。</li>\n<li>确认 HTML 结构是否正确，是否有内容被渲染。</li>\n</ul>\n</li>\n<li><p><strong>查看 CSS 样式</strong></p>\n<ul>\n<li>确认 CSS 文件是否加载成功。</li>\n<li>在“样式”标签页（Styles）中查看应用的 CSS 样式，确保样式正确应用且不会导致元素不可见（如 <code>display: none</code> 或 <code>visibility: hidden</code>）。</li>\n</ul>\n</li>\n<li><p><strong>禁用浏览器扩展</strong></p>\n<ul>\n<li>某些浏览器扩展可能会干扰页面的正常加载。尝试禁用所有扩展后重新加载页面。</li>\n</ul>\n</li>\n<li><p><strong>查看服务器日志</strong></p>\n<ul>\n<li>检查服务器日志，确认没有服务器端的错误。</li>\n</ul>\n</li>\n<li><p><strong>检查代码部署</strong></p>\n<ul>\n<li>确认代码是否正确部署到服务器，版本是否正确。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例排查\"><a href=\"#示例排查\" class=\"headerlink\" title=\"示例排查\"></a>示例排查</h3><p>假设你在控制台中看到以下错误信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Uncaught SyntaxError: Unexpected token &#39;&lt;&#39;</code></pre>\n\n<p>这种错误通常表明 JavaScript 文件未正确加载，可能是返回了 HTML 文件。接下来可以：</p>\n<ol>\n<li>在“网络”标签页中查看对应的 JavaScript 文件请求，确认其内容是否正确。</li>\n<li>确认服务器配置是否正确，确保 JavaScript 文件请求未被错误地重定向或返回 HTML 内容。</li>\n</ol>\n<h3 id=\"进一步调试\"><a href=\"#进一步调试\" class=\"headerlink\" title=\"进一步调试\"></a>进一步调试</h3><p>如果上述方法未能解决问题，可以尝试：</p>\n<ol>\n<li><p><strong>在本地环境复现问题</strong></p>\n<ul>\n<li>尝试在本地环境复现问题，便于调试和查看详细错误信息。</li>\n</ul>\n</li>\n<li><p><strong>使用断点调试</strong></p>\n<ul>\n<li>在开发者工具中设置断点，逐步调试 JavaScript 代码，定位导致白屏的具体代码。</li>\n</ul>\n</li>\n<li><p><strong>回滚到上一个版本</strong></p>\n<ul>\n<li>如果问题出现在最新版本，可以回滚到上一个版本，检查是否为最新更改引入的问题。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"预防措施\"><a href=\"#预防措施\" class=\"headerlink\" title=\"预防措施\"></a>预防措施</h3><ol>\n<li><p><strong>错误捕获</strong></p>\n<ul>\n<li><p>使用全局错误处理器捕获并记录未处理的错误，例如：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">window.addEventListener(&#39;error&#39;, function(event) &#123;\n  console.error(&#39;Error occurred:&#39;, event.message, event.filename, event.lineno, event.colno);\n&#125;);\n\nwindow.addEventListener(&#39;unhandledrejection&#39;, function(event) &#123;\n  console.error(&#39;Unhandled rejection:&#39;, event.reason);\n&#125;);</code></pre></li>\n</ul>\n</li>\n<li><p><strong>测试覆盖</strong></p>\n<ul>\n<li>编写单元测试和集成测试，确保代码变更不会引入新的问题。</li>\n</ul>\n</li>\n<li><p><strong>日志记录</strong></p>\n<ul>\n<li>在关键代码位置添加日志，帮助定位和分析问题。</li>\n</ul>\n</li>\n</ol>\n<p>通过以上方法，可以逐步排查和解决用户访问页面出现白屏的问题。</p>\n<h2 id=\"组件封装的基本原则是什么\"><a href=\"#组件封装的基本原则是什么\" class=\"headerlink\" title=\"组件封装的基本原则是什么\"></a>组件封装的基本原则是什么</h2><p>组件封装的基本原则是为了提高代码的复用性、可维护性和可测试性。以下是组件封装的基本原则：</p>\n<ol>\n<li><p><strong>单一职责原则 (Single Responsibility Principle)</strong></p>\n<ul>\n<li>组件应该专注于单一功能或责任，而不是包含过多的功能。这样可以使组件更加清晰、易于理解和维护。</li>\n</ul>\n</li>\n<li><p><strong>高内聚低耦合 (High Cohesion, Low Coupling)</strong></p>\n<ul>\n<li>高内聚指组件内部各部分的功能相关性强，低耦合指组件与其他组件之间的依赖关系尽量降低。这样可以提高组件的独立性和灵活性，使其易于替换、修改和测试。</li>\n</ul>\n</li>\n<li><p><strong>可配置性 (Configurability)</strong></p>\n<ul>\n<li>组件应该具有一定的可配置性，允许用户通过配置参数来定制组件的行为和外观。这样可以增强组件的灵活性和适用性。</li>\n</ul>\n</li>\n<li><p><strong>接口清晰明确 (Clear and Explicit Interfaces)</strong></p>\n<ul>\n<li>组件的接口应该清晰明确，包括输入参数、输出结果和事件回调等。这样可以使组件的使用方式清晰可见，降低误用的可能性。</li>\n</ul>\n</li>\n<li><p><strong>可扩展性 (Extensibility)</strong></p>\n<ul>\n<li>组件应该具有一定的可扩展性，允许在不修改核心代码的情况下进行功能扩展。这可以通过插件机制、钩子函数等方式实现。</li>\n</ul>\n</li>\n<li><p><strong>适应性 (Adaptability)</strong></p>\n<ul>\n<li>组件应该具有一定的适应性，能够适应不同的使用场景和环境。这可以通过响应式设计、自适应布局等方式实现。</li>\n</ul>\n</li>\n<li><p><strong>易用性 (Usability)</strong></p>\n<ul>\n<li>组件应该易于使用，提供良好的文档和示例，并且具有良好的用户体验。这可以通过良好的设计、交互效果和反馈等方式实现。</li>\n</ul>\n</li>\n<li><p><strong>可测试性 (Testability)</strong></p>\n<ul>\n<li>组件应该易于测试，具有良好的测试覆盖率和测试可用性。这可以通过模块化设计、依赖注入、单元测试等方式实现。</li>\n</ul>\n</li>\n</ol>\n<p>总体而言，组件封装的基本原则是为了提高代码的质量、可维护性和可重用性，使得组件能够在各种场景下被广泛应用，并且能够快速、安全地进行修改和扩展。</p>\n","text":"JavaScriptJavaScript有哪些数据类型，它们的区别？ 原始数据类型： Undefined：表示变量已被声明但未被赋值，只有一个值undefined。 Null：表示一个空对象指针，用于表示缺少值，只有一个值null。 Boolean：逻辑类型，只有两个值true和...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"37 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaScript\"><span class=\"toc-text\">JavaScript</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaScript%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">JavaScript有哪些数据类型，它们的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">数据类型检测的方式有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">null和undefined区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%89%E5%85%A8%E7%9A%84-undefined-%E5%80%BC%EF%BC%9F\"><span class=\"toc-text\">如何获取安全的 undefined 值？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#typeof-NaN-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">typeof NaN 的结果是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#x3D-x3D-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F\"><span class=\"toc-text\">&#x3D;&#x3D; 操作符的强制类型转换规则？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object-is-%E4%B8%8E%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-x3D-x3D-x3D-%EF%BC%8C-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">Object.is() 与比较操作符 &#x3D;&#x3D;&#x3D;，&#x3D;&#x3D;的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaScript-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9F\"><span class=\"toc-text\">JavaScript 中如何进行隐式类型转换？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89BigInt%E7%9A%84%E6%8F%90%E6%A1%88\"><span class=\"toc-text\">为什么会有BigInt的提案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#object-assign%E5%92%8C%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E6%B3%95%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#let%E3%80%81const%E3%80%81var%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">let、const、var的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#const%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">const对象的属性可以修改吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9Cnew%E4%B8%80%E4%B8%AA%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7\"><span class=\"toc-text\">如果new一个箭头函数的会怎么样</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">示例代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">箭头函数与普通函数的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C%EF%BC%9F\"><span class=\"toc-text\">箭头函数的this指向哪里？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Spread-Operator%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">扩展运算符（Spread Operator）的作用及使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">new操作符的实现原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map%E4%B8%8EObject%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Map与Object的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaScript%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">JavaScript有哪些内置对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">数组有哪些原生方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E7%9A%84-arguments-%E5%8F%82%E6%95%B0%E6%98%AF%E7%B1%BB%E6%95%B0%E7%BB%84%E8%80%8C%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E7%B1%BB%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaScript%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%8C%E5%AE%83%E5%AF%BC%E8%87%B4%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">JavaScript为什么要进行变量提升，它导致了什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F\"><span class=\"toc-text\">什么是尾调用，使用尾调用有什么好处？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#use-strict%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">use strict是什么意思 ? 使用它区别是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#for%E2%80%A6in%E5%92%8Cfor%E2%80%A6of%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">for…in和for…of的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">数组循环的方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">forEach和map方法有什么区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对原型、原型链的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E4%BF%AE%E6%94%B9%E3%80%81%E9%87%8D%E5%86%99\"><span class=\"toc-text\">原型修改、重写</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%8C%87%E5%90%91\"><span class=\"toc-text\">原型链指向</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%88%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E5%87%BA%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%88%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">原型链的终点是什么？如何打印出原型链的终点？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E5%AF%B9%E8%B1%A1%E9%9D%9E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">如何获得对象非原型链上的属性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对闭包的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对作用域、作用域链的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对this对象的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84this%E5%80%BC\"><span class=\"toc-text\">不同场景下的this值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#call-%E5%92%8C-apply-%E3%80%81bind-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">call() 和 apply() 、bind()的区别？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call\"><span class=\"toc-text\">call()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#apply\"><span class=\"toc-text\">apply()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bind\"><span class=\"toc-text\">bind()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">异步编程的实现方式？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">回调函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise\"><span class=\"toc-text\">Promise</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async-x2F-await\"><span class=\"toc-text\">async&#x2F;await</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Promise%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">Promise的理解与应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">基本用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#resolve-%E4%B8%8E-reject\"><span class=\"toc-text\">resolve 与 reject</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">链式调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#finally\"><span class=\"toc-text\">finally</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E4%B8%B2%E8%A1%8C\"><span class=\"toc-text\">并行与串行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">对象创建的方式有哪些？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">对象字面量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">工厂模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">原型模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Class%EF%BC%88ES6-%EF%BC%89\"><span class=\"toc-text\">Class（ES6+）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-create\"><span class=\"toc-text\">Object.create</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">浏览器的垃圾回收机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%A6%82%E8%A7%88\"><span class=\"toc-text\">浏览器垃圾回收机制概览</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">标记-清除算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0\"><span class=\"toc-text\">引用计数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86\"><span class=\"toc-text\">分代收集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E9%87%8F%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">增量回收</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">内存管理注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">触发时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">哪些情况会导致内存泄漏</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaScript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">JavaScript内存泄漏常见场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#setTimeout%E3%80%81setInterval%E3%80%81requestAnimationFrame-%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">setTimeout、setInterval、requestAnimationFrame 各有什么特点？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#setTimeout\"><span class=\"toc-text\">setTimeout</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#setInterval\"><span class=\"toc-text\">setInterval</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#requestAnimationFrame\"><span class=\"toc-text\">requestAnimationFrame</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#async-x2F-await%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">async&#x2F;await的优势</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7%E5%92%8C%E7%AE%80%E6%B4%81%E6%80%A7\"><span class=\"toc-text\">1. 代码可读性和简洁性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E7%AE%80%E5%8C%96\"><span class=\"toc-text\">2. 错误处理的简化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%9B%B4%E8%87%AA%E7%84%B6%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD\"><span class=\"toc-text\">3. 更自然的异常传播</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%9B%B4%E5%B0%91%E7%9A%84%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1\"><span class=\"toc-text\">4. 更少的回调地狱</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E4%BD%93%E9%AA%8C\"><span class=\"toc-text\">5. 更好的代码调试体验</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%98%93%E4%BA%8E%E7%90%86%E8%A7%A3%E5%92%8C%E5%8D%8F%E4%BD%9C\"><span class=\"toc-text\">6. 易于理解和协作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E7%81%B5%E6%B4%BB%E6%80%A7%E4%B8%8E%E5%85%BC%E5%AE%B9%E6%80%A7\"><span class=\"toc-text\">7. 灵活性与兼容性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9async-x2F-await-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">对async&#x2F;await 的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async\"><span class=\"toc-text\">async</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#await\"><span class=\"toc-text\">await</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">宏任务和微任务的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E4%BB%BB%E5%8A%A1%EF%BC%88Macro-Task%EF%BC%89\"><span class=\"toc-text\">宏任务（Macro Task）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%88Micro-Task%EF%BC%89\"><span class=\"toc-text\">微任务（Micro Task）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89\"><span class=\"toc-text\">事件循环（Event Loop）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">示例解释</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MVVM%E5%92%8CMVC%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">MVVM和MVC的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MVC%EF%BC%88Model-View-Controller%EF%BC%89\"><span class=\"toc-text\">MVC（Model-View-Controller）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">工作流程：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MVVM%EF%BC%88Model-View-ViewModel%EF%BC%89\"><span class=\"toc-text\">MVVM（Model-View-ViewModel）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A-1\"><span class=\"toc-text\">工作流程：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">主要区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-2\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">实现图片懒加载的方式有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%8E%9F%E7%94%9F-loading-%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">1. 原生 loading 属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8-Intersection-Observer-API\"><span class=\"toc-text\">2. 使用 Intersection Observer API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\"><span class=\"toc-text\">3. 使用第三方库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-lazysizes\"><span class=\"toc-text\">使用 lazysizes</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%9B%91%E5%90%AC%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6-%E4%B8%8D%E6%8E%A8%E8%8D%90\"><span class=\"toc-text\">4. 监听滚动事件 (不推荐)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%BB%93%E5%90%88-React-%E5%92%8C-React-Lazy-Load-%E5%BA%93\"><span class=\"toc-text\">5. 结合 React 和 React-Lazy-Load 库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-react-lazy-load\"><span class=\"toc-text\">使用 react-lazy-load</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E4%BD%BF%E7%94%A8-react-intersection-observer-%E5%BA%93\"><span class=\"toc-text\">6. 使用 react-intersection-observer 库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-react-intersection-observer\"><span class=\"toc-text\">使用 react-intersection-observer</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-3\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E7%99%BD%E5%B1%8F%E4%BA%86%EF%BC%8C%E5%8E%9F%E5%9B%A0%E6%98%AF%E5%95%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5\"><span class=\"toc-text\">用户访问页面白屏了，原因是啥，如何排查</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">常见原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">排查步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B%E6%8E%92%E6%9F%A5\"><span class=\"toc-text\">示例排查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">进一步调试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%84%E9%98%B2%E6%8E%AA%E6%96%BD\"><span class=\"toc-text\">预防措施</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">组件封装的基本原则是什么</span></a></li></ol></li></ol>","author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"interview-next","uid":"4a7b4bd5c9b6fe1d1c2302e2f1ecfc49","slug":"interview-next","date":"2024-05-30T14:58:58.000Z","updated":"2024-05-30T14:59:09.470Z","comments":true,"path":"api/articles/interview-next.json","keywords":null,"cover":null,"text":"Next当然，以下是关于Next.js的十个面试题目及其答案，采用Markdown格式： 什么是Next.js？它解决了什么问题？Next.js是一个基于React的框架，用于构建服务器渲染（SSR）和静态站点生成（SSG）的应用程序。它简化了设置、路由、代码拆分、服务器端渲染等...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"interview-css","uid":"22d898182469a084004dd0b5135b46c1","slug":"interview-css","date":"2024-05-30T14:57:57.000Z","updated":"2024-05-30T14:58:10.080Z","comments":true,"path":"api/articles/interview-css.json","keywords":null,"cover":null,"text":"CSSCSS选择器及其优先级 内联样式：直接在HTML元素上使用style属性定义的样式具有最高优先级，权值为1000。 ID选择器：形如#idName的选择器，权值为100。 类选择器、属性选择器、伪类选择器：包括.className、[attribute&#x3D;value...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"X-29","slug":"blog-author","avatar":"https://i.postimg.cc/3Rd6NTPm/X.png","link":"/","description":"Welcome to this blog! Here will tell you everything about X-29.","socials":{"github":"https://github.com/X29w","twitter":"","stackoverflow":"https://stackoverflow.com/users/20511900/x29","wechat":"","qq":"","weibo":"https://weibo.com/u/7801588846","zhihu":"","csdn":"","juejin":"","customs":{}}}}}