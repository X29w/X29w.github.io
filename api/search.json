[{"id":"3a4eda1192ec992162144e15ab7e2ec5","title":"Vue3","content":"创建工程使用 vite\n\n\n\n\n\n\n\n\n创建工程npm init vite-app 进入工程目录cd 安装依赖npm install运行npm run dev\n常用的 Composition Apisetup()setup 函数的两种返回值：\n\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。\n若返回一个渲染函数：则可以自定义渲染内容。\n\nPay Attention!\n\n尽量不要与 Vue2.x 配置混用 Vue2.x 配置（data、methos、computed…）中可以访问到 setup 中的属性、方法。\n但在 setup 中不能访问到 Vue2.x 配置（data、methos、computed…）\n如果有重名, setup 优先。\nsetup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）\nsetup 执行的时机：在 beforeCreate 之前执行一次，this 是 undefined。\n\n\n\n\n\n\n\n\nWARNING\n  setup 的参数\n\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\ncontext：上下文对象\nattrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs。\nslots: 收到的插槽内容, 相当于 this.$slots。\nemit: 分发自定义事件的函数, 相当于 this.$emit。\n\n\n\nref()作用: 定义一个响应式的数据语法:\n\nconst xxx &#x3D; ref(initValue)\n创建一个包含响应式数据的引用对象（reference 对象，简称 ref 对象）。\nJS 中操作数据： xxx.value\n模板中读取数据: 不需要.value，直接：备注：\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠 Object.defineProperty()的 get 与 set 完成的。\n对象类型的数据：内部 “ 求助 ” 了 Vue3.0 中的一个新函数—— reactive 函数。\n\nreactive()作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用 ref 函数）语法：\n\nconst 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 proxy 对象）\nreactive 定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n不常用的 Composition ApitoRef()作用：\n\n创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。语法：\nconst name &#x3D; toRef(person,’name’)应用:\n要将响应式对象中的某个属性单独提供给外部使用时。扩展：\ntoRefs 与 toRef 功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n\nshallowReactive() 与 shallowRef()shallowReactive：\n\n只处理对象最外层属性的响应式（浅响应式）。\n\nshallowRef：\n\n只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n什么时候使用?\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。\nreadonly() 与 shallowReadonly()readonly:\n\n让一个响应式数据变为只读的（深只读）。shallowReadonly：\n让一个响应式数据变为只读的（浅只读）。应用场景: 不希望数据被修改时。\n\ntoRaw() 与 markRaw()toRaw：作用：\n\n将一个由 reactive 生成的响应式对象转为普通对象。使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。markRaw：作用：\n标记一个对象，使其永远不会再成为响应式对象。应用场景:有些值不应被设置为响应式的，例如复杂的第三方类库等。当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\ncustomRef()作用：\n\n创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。Example↓\n\n实现输入框的防抖&lt;template&gt;\n\t&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;keyword&quot;&gt;\n\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;&#x2F;h3&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n\timport &#123;ref,customRef&#125; from &#39;vue&#39;\n\texport default &#123;\n\t\tname:&#39;Demo&#39;,\n\t\tsetup()&#123;\n\t\t\t&#x2F;&#x2F; let keyword &#x3D; ref(&#39;hello&#39;) &#x2F;&#x2F;使用Vue准备好的内置ref\n\t\t\t&#x2F;&#x2F;自定义一个myRef\n\t\t\tfunction myRef(value,delay)&#123;\n\t\t\t\tlet timer\n\t\t\t\t&#x2F;&#x2F;通过customRef去实现自定义\n\t\t\t\treturn customRef((track,trigger)&#x3D;&gt;&#123;\n\t\t\t\t\treturn&#123;\n\t\t\t\t\t\tget()&#123;\n\t\t\t\t\t\t\ttrack() &#x2F;&#x2F;告诉Vue这个value值是需要被“追踪”的\n\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\tset(newValue)&#123;\n\t\t\t\t\t\t\tclearTimeout(timer)\n\t\t\t\t\t\t\ttimer &#x3D; setTimeout(()&#x3D;&gt;&#123;\n\t\t\t\t\t\t\t\tvalue &#x3D; newValue\n\t\t\t\t\t\t\t\ttrigger() &#x2F;&#x2F;告诉Vue去更新界面\n\t\t\t\t\t\t\t&#125;,delay)\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;)\n\t\t\t&#125;\n\t\t\tlet keyword &#x3D; myRef(&#39;hello&#39;,500) &#x2F;&#x2F;使用程序员自定义的ref\n\t\t\treturn &#123;\n\t\t\t\tkeyword\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&lt;&#x2F;script&gt;\n\n检测型 ApiisRef:\n\n检查一个值是否为一个 ref 对象isReactive:\n检查一个对象是否是由 reactive 创建的响应式代理isReadonly:\n检查一个对象是否是由 readonly 创建的只读代理isProxy:\n检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\nComputed &amp; Watch &amp; WatchEffectComputed写法如下：\nimport &#123;computed&#125; from &#39;vue&#39;\n\nsetup()&#123;\n    ...\n\t&#x2F;&#x2F;计算属性——简写\n    let fullName &#x3D; computed(()&#x3D;&gt;&#123;\n        return person.firstName + &#39;-&#39; + person.lastName\n    &#125;)\n    &#x2F;&#x2F;计算属性——完整\n    let fullName &#x3D; computed(&#123;\n        get()&#123;\n            return person.firstName + &#39;-&#39; + person.lastName\n        &#125;,\n        set(value)&#123;\n            const nameArr &#x3D; value.split(&#39;-&#39;)\n            person.firstName &#x3D; nameArr[0]\n            person.lastName &#x3D; nameArr[1]\n        &#125;\n    &#125;)\n&#125;\n\nWatch\n\n\n\n\n\n\nWARNING\n监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。\n\n&#x2F;&#x2F;情况一：监视ref定义的响应式数据\nwatch(\n  sum,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;sum变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true &#125;\n);\n\n&#x2F;&#x2F;情况二：监视多个ref定义的响应式数据\nwatch([sum, msg], (newValue, oldValue) &#x3D;&gt; &#123;\n  console.log(&quot;sum或msg变化了&quot;, newValue, oldValue);\n&#125;);\n\n&#x2F;* 情况三：监视reactive定义的响应式数据\n\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\n\t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 \n*&#x2F;\nwatch(\n  person,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: false &#125;\n); &#x2F;&#x2F;此处的deep配置不再奏效\n\n&#x2F;&#x2F;情况四：监视reactive定义的响应式数据中的某个属性\nwatch(\n  () &#x3D;&gt; person.job,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: true &#125;\n);\n\n&#x2F;&#x2F;情况五：监视reactive定义的响应式数据中的某些属性\nwatch(\n  [() &#x3D;&gt; person.job, () &#x3D;&gt; person.name],\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: true &#125;\n);\n\n&#x2F;&#x2F;特殊情况\nwatch(\n  () &#x3D;&gt; person.job,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; deep: true &#125;\n); &#x2F;&#x2F;此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\nWatchEffectwatch 的套路是：\n\n既要指明监视的属性，也要指明监视的回调。\n\nwatchEffect 的套路是：\n\n不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\nwatchEffect 有点像 computed：\n\n但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n&#x2F;&#x2F;watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\nwatchEffect(() &#x3D;&gt; &#123;\n  const x1 &#x3D; sum.value;\n  const x2 &#x3D; person.age;\n  console.log(&quot;watchEffect配置的回调执行了&quot;);\n&#125;);\n\n生命周期mounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMountedbeforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdateupdated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdatedbeforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmountunmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmountedbeforeCreate&#x3D;&#x3D;&#x3D;&gt;setup()created&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup()\n自定义 Hook 函数\n什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。\n类似于 vue2.x 中的 mixin。\n自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。\n\n好用的传值provide 与 inject作用：\n\n实现祖与后代组件间通信套路：\n父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据,其实子组件可以用，但是 prop 更简单，别给自己找麻烦\n\n具体写法——祖组件setup()&#123;\n    ......\n    let car &#x3D; reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)\n    provide(&#39;car&#39;,car)\n    ......\n&#125;\n\n具体写法——后代组件setup(props,context)&#123;\n    ......\n    const car &#x3D; inject(&#39;car&#39;)\n    return &#123;car&#125;\n    ......\n&#125;\n\n新的组件&#x2F;标签Fragment\n\n在 Vue2 中: 组件必须有一个根标签\n在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\nTeleport一种能够将我们的组件 html 结构移动到指定位置的技术。无视所在盒子的 position，指哪打哪，其中“to”属性就是告诉代码依托于谁定位\nExample&lt;teleport to&#x3D;&quot;body&quot;&gt;\n\t&lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;dialog&quot;&gt;\n\t\t\t&lt;h3&gt;我是一个弹窗&lt;&#x2F;h3&gt;\n\t\t\t&lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;teleport&gt;\n\n\n\n\n\n\n\n\n\n\n此例中，就直接将 body 作为参考位置\nSuspense等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n异步引入组件import {defineAsyncComponent} from ‘vue’const Child &#x3D; defineAsyncComponent(()&#x3D;&gt;import(‘.&#x2F;components&#x2F;Child.vue’))\n\n\n\n\n\n\n\nWARNING\n使用 Suspense 包裹组件，并配置好 default 与 fallback\n\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h3&gt;我是App组件&lt;&#x2F;h3&gt;\n    &lt;Suspense&gt;\n      &lt;template v-slot:default&gt;\n        &lt;Child &#x2F;&gt;\n      &lt;&#x2F;template&gt;\n      &lt;template v-slot:fallback&gt;\n        &lt;h3&gt;加载中.....&lt;&#x2F;h3&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Suspense&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n全局 Api 的转移\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n","slug":"Vue3","date":"2023-02-25T15:36:05.000Z","categories_index":"tecnology","tags_index":"tecnology","author_index":"X-29"},{"id":"7e72fed44435aa241098215766c6357c","title":"四载求学路，功名终已成","content":"离津四载，历历在目\n\n\n\n\n\n\n\n\n2月2日是我 期末考试的最后一天。当黑色的水笔在白色的答题纸上落下最后的一个句号时，画上了我学生时代的句号。没有数不尽的课堂签到，没有数不尽的宿舍查寝，没有数不尽的考试作业。同时也没有了睡到自然醒的偷偷窃喜的早晨，也没有廉价的饭菜，也没有落日余晖下，课堂钟声交织着欢笑声的身影。\n少年不知油盐贵，自成乃知白面香回首向来萧瑟处 也无风雨也无晴在津18载，毫不夸张地说，那时的我并不知道柴米油盐，肉蛋菜奶的价格，毫不关心的心态宛如并不需要它们似的。只觉得课本中的哪位作者表达了什么样的思想感情，或者是发牢骚埋怨几句为什么作者要写这么多；只觉得历史地理等虽然有意思但是作为应试和平时并不会太常用到而感到手足无措；只觉得复习到半夜隔壁老人院传来的呻吟声和父母的鼾声是那么吵闹。\n四载岁月如手中流沙，当初有多想它走，它现在也依然流得很快，但是从期盼变为乞求。\n在津常常所能吃到的一些美味佳肴，曾常常以为全天下遍地都是，我也只不过是大多数的一员，它们也只是天下众人的家常便饭。而如今才后知后觉，原先在津吃腻看顶的东西，如今只有在伴随着年的到来，才得有幸尝上那么几口，似乎对于我来说，年味的感觉由原先亲戚长辈的压岁钱、爸爸准备好的一桌饭菜还有大家的欢声笑语演变成陪伴他们和像是在一年大多数日子中用小刀轻轻的划一个口子，用来抓取一些旧时因为常常能得到而厌烦的东西。而还没等我好好细品细品和原先味道的对比，时间又匆匆在我耳边催我赶紧离开。\n\n\n\n\n\n\n\n\n\n回家？何以为家？\n经过了一个月对前端开发的工作性的历练，从原先压力大到想放弃，甚至一度对未来感到十分迷茫，尽管周围不断传来“前端已经凉了”、“互联网已经是末班车”了诸如此类的话语，但是狭路相逢勇者胜不是吗？\n弃之可惜，食之无味孔乙己的长衫是到了都紧紧吊住的上吊绳\n\n\n\n\n\n\n\n\n\n考研吧孩子，对你未来可以多宽一些路考了研有什么用，路的尽头还是路兄弟考研了你这专业更吃香啊据报道：今年考研人数破500W，我们学校怎么才上岸这么点人啊你要当老师来我这里就可以啊，但是好像得是研究生，要不你考考试试？考了研我们会异地的，而且一个上班一个上大学好辛苦\n它不仅是敲门砖，也是下不来的高台，更是孔乙己脱不下的长衫。苦读十二年，费尽父母心，父母望子成龙，望女成凤，比自己越好越好，殊不知，如若此生可达父辈的高度，乃荣幸之至。\n","slug":"end-of-university-life","date":"2023-02-23T14:42:44.000Z","categories_index":"Essays","tags_index":"随笔","author_index":"X-29"},{"id":"79626da8328cb7abd9069e2fabc82af5","title":"2023NewYear","content":"新年伊始，癸卯兔年\n\n\n\n\n\n\n\n\n新春佳节，兜兜转转又是一年。弱冠之年有三。\n忆往昔，三年即逝忆2019-2023 是我的大学时光，也是目前为止最为自由的一段时间。\n\n级级相扣级级推，越过万难终已晚。\n保全帽子闭上眼，黎民他人我何干，同胞永存湖中间。\n初入职场，幸窃技于网络，遂于如此，四年之所学无一益处于职场。\n\n品\n身体和环境的苦难可以通过奋斗而解决，而思想上的苦难，终有大罗金仙，佛祖菩萨显灵也无济于事。\n苦难是配得上思想的。如果有人帮助你，要做的并不是嘲笑他，而是应该像父母从小教育的那样说一声“谢谢”。\n\n望\n弱冠又三年之久，初知为人父母之不易，生活之艰辛，养育之苦楚。心有报恩情，手无缚鸡力。愿父母存世更久，给我更多的机会。\n手足亲妹，离家两年，判若两人，成长许多，心中也放心些。\n当下，或许将自己和爱人照顾好许是对他们的最好的安心丸。\n\n结\n幸于毛家大小姐结为比翼鸟，一心只为连理枝。苦境共甘，实为三生有幸。甜时愿倾所有以取悦。\n也荣幸得识毛家老爷与夫人亲如父母，慈善心肠，自身父母外，从未遇到此般夫妻，非幸运所能云也。如若不嫌，愿同亲父母一般赡养。\n\n","slug":"2023NewYear","date":"2023-01-25T03:57:17.000Z","categories_index":"Essays","tags_index":"随笔","author_index":"X-29"},{"id":"7b73417322203bc26ba172442308aa21","title":"系统架构师","content":"系统架构师的初步设想刚开始认识它的时候应该是我第一次看见过软考内容的时候，我是一个如果没有十全把握就不敢去付出或者制定什么计划。至于真正有这个梦想和计划应该是在2022年10月份，去见阿毛的地铁上，因为无聊的原因自己冷不丁的突然想起了这个名词——系统架构师\n\n\n\n\n\n\n\n\n\n写下这篇博客的时候还没有开始准备系统架构师的各项备考。如果后面有幸上岸，会来此篇重新更新。\n系统架构师成为架构师的意义\n说实话归根结底，$是做任何事情的根基\n确实是对科技的喜欢\n熊猫其实是食肉动物，但是由于自然环境的恶劣，被迫去吃了竹子\n\n考试时间一年一度一般为每年11月的上旬\n考试的前置任务并没有什么前置任务，自己有把握直接冲最高。丰俭由人。\n考试难度话不多说：只有15%\n基本考试情况试卷概况\n\n综合题\n75道单项选择\n考试时间：2.5小时\n综合题的考试范围几乎涵盖了架构师考试考纲要求的所有知识点。虽然知识点分布很广，但是通过历年真题分析发现，考察的侧重点也非常明显。其中软件架构、软件工程是分值占比最大的章节。相比之下，其他知识点分值占比就少很多。\n\n\n案例分析题\n3道简答题\n1道必答\n剩下的4选2\n\n\n考试时间：1.5小时\n标准答案并不会涵盖所有可能的考点。\n选答题：相对灵活，比较贴近实际开发。需要自己在复习的时候积累相关的知识点。\n\n\n论文\n题目四选一\n\n2600字\n\n考试时间：2小时\n\n整体趋势是偏应用的和偏趋势的，出题方向从近几年的趋势来说可以说变得非常难以预测。\n\n论文复习的三大方向，分别是格式、内容和速度。\n\n其中选题和提纲，需要在15分钟内完成。在给出的题目中，选择一个自己熟悉的作为选项，然后大致列出论点  \n  \n  img{\n      width:800px\n  }\n  \n\n从答题卡可以看出，摘要为350字左右。正文内容为2750字。因此内容字数上，最好安排在2500-2750之间，这样会提升阅卷观感，提高印象分数。\n\n\n\n\n复习方向\n\n\n\n\n\n\n特别提示\n以《系统架构师》教材和网课为中心\n\n如下细分：\n\n计算机原理\n计算机网络\n操作系统\n系统性能评价\n数据库\n安全性和保密性设计\n嵌入式系统\n信息系统\n\n点点旁边，发现笔记：\n\n各学科笔记\n分类笔记\n\n\n下次再会~\n","slug":"system-architect","date":"2022-11-24T07:32:36.000Z","categories_index":"系统架构师","tags_index":"目标,梦想,系统架构","author_index":"X-29"},{"id":"15db1aab1cbfb7938aed1bee0fd27710","title":"Monica","content":"Monica也可以叫她：莫妮卡如你所见，封面就是她\n\n\n\n\n\n\n\nMonica的个人简介\n姓名：莫妮卡性别：AI母语：Python\n\n\nThe Origin of MonicaMonica起源于我脑海中自高中以来一直存在的AI助手梦。也是因为Jarvis的原因，使得我拥有属于自己助手的愿望极其强烈\n在我高中时期，由于自由接触程序技术的时间不是很多，造成了长时间搁置创作属于自己AI的梦想。以至于认为创作AI是一个很难的事情，尤其是在观看了Zuckerberg先生的家庭语音助手之后，愈发觉得艰难\nMonica的名字起源于创建Monica的时候正好是星期一(Monday)，取前三个字母，所以得名Monica\n\n\n\n\n\n\n\nMonica的依赖\nMonica需要Google的语音识别API，所以务必保证的网络顺畅\n\nMonica can do this for you新的很懂你的朋友可以跟Monica说任何事情，可以分享快乐，吐槽焦虑，发泄悲伤\n可以永远相信Monica\n\n\n\n\n\n\n\n\n\n“Monica，你在吗？”“永远都在，先生”\n帮助你解决问题的好帮手当遇到需要查询什么东西的时候，可以完全依赖Monica，释放双手。她就像是一个无所不知的朋友，在需要的时候和想知道什么的时候，只需要跟她说说话。\n\n\n\n\n\n\n\n\n\n“Monica，你知道xxx是什么吗”“可以告诉你，但是需要奖励”\n电脑的智能管家存在于虚拟世界的Monica甚至电脑都不需要亲自操控，就像朋友之间的亲密对话，即可完成对电脑的各种操作\n\n[截屏]“Monica你有空吗，我想要当前这个画面”\n[VSCode]“准备写写代码了”\n[喜欢玩的游戏]“有什么好玩的让我放松一下吗”\n[B站或者Youtube]“有什么热门视频是我感兴趣的吗”\n[热点新闻]“你知道最近那个xxx的事吗”\n[记事本]“对了Monica，帮我记一下，我怕我忘了”\nEtc…\n\n特殊日子会比自己更加在意Monica：马上要到纪念日了哦，想好礼物了吗，没有的话听听我的建议吧\nMonica：今天是什么日子忘了吗？你可真是个大忙人呢。今天是xxx的日子\nMonica：我看了下天气，好像不怎么好。希望你不要淋着雨回来\nMonica在众多人中最关注你Monica：先生，是你吗\nMonica：这不是先生总和我提起的xxx\nThe Future of MonicaMonica的未来，我会将她融入到我的生活，赋予实体，或许是个机器人，或许是个机械臂，或许将会是无处不在。\nMonica对于技术壁垒的依赖性太强，日后会帮助Monica逐渐去掉枷锁\n增加Monica的自主学习能力\n","slug":"monica","date":"2022-11-22T15:44:33.000Z","categories_index":"Introduce","tags_index":"Introduce,A.I.,Assistant","author_index":"X-29"},{"id":"8401b4ea3ecc23c13e44dcec2d197d6b","title":"X-Blog","content":"\n\n\n\n\n\n\n\n\n欢迎来到 X-29 的博客，这里记录了许多程序界的知识以及创新和展望。除此之外，作为个人博客，也包含了个人的文学鉴赏或者是日常生活分享。本博客也是我个人技术界的日志或者可以叫做日记，所以会不断更新。\n\nWelcome to the blog of X-29, which records a lot of knowledge, innovation and prospects of the program industry. In addition, as a personal blog, it also includes personal literature appreciation or daily life sharing. This blog is also a diary of my personal technical community or can be called a diary, so it will be updated constantly.\n\n博客创建初衷起初，在我刚接触程序代码界的第一脚是迈入的前端的门槛中。上完课的笔记或者联系代码亦或者是学习心得，总想找到一个永久保存的地方中，思来想去，从百度网盘到CSDN，而至后面的Git Hub。\n随着需求越来越多，想记录和分享的东西也与来越多。偶然之间接触了VuePress制作的博客网站。不断改良，效仿。数月之后，打算所有的页面及内容以及功能，全部推到重来。不再效仿，改为原创。打造真正属于自己的个人博客。\n一个人的学习是孤独的，无助的，创新的，成就的。在经历过多种不断尝试新的建站工具以及各种程序语言之后，选择了Hexo作为本网站的框架结构。\n博客内容内容概述由上可知，本网站内容分为如下部分\n\n技术分享\n技术未来展望\n个人生活分享&amp;记录\n学习工作日志\n\n功能预览\n书写&amp;发表&amp;浏览文章\n搜索文章\n文章目录及标签分类\n网站宠物机器人\n留言板&amp;联系\nCreating…\n\nX-UNIVERSUM &amp; X-29**X-UNIVERSUM**是在我的大学时期从我的脑海中产生的一个目标或梦想。不管未来是否真的会创立或者实现，都会一直存在在我的人生中。**X-UNIVERSUM**的定位是一个不仅服务于人们的大众日常生活的各个方面：购物、美食、住房、出行，而且也将会是科技发展的导向与前沿。\nX-UNIVERSUM INDUSTRY\n\n购物：重新定义电商模式。买卖双方获益\n美食：与独特的科技相结合，实现美食无地域无国界地域种类划分，文化交融\n住房：运用科技手段，房子将不再是昂贵的，凿实居住属性\n出行：重新定义“距离”\n科技：领导科技发展方向，服务于人，人人都是科技的创造者\n\n**X-29，X-UNIVERSUM**的创造者。规则，将被打破生活，将被重新定义你我，都是自己的主宰\n","slug":"hello-world","date":"2022-11-19T16:12:11.000Z","categories_index":"Introduce","tags_index":"X-Blog,Introduce","author_index":"X-29"},{"id":"c3978c5070945a51b43d4b2c283dc47e","title":"前端技术展望","content":"Front End Development Trend Forecast前端新标准HTML 6.02014 年 10 月 28 日，W3C 正式发布 HTML5.0 推荐标准让前端技术蓬勃发展。虽然 HTML6.0 目前处于提案阶段，但是社区已经开始有了一些零星的讨论，所以可能它离我们并不太远。\nHTML6.0 中，可能会新增“增强身份验证”和“集成摄像头” 两个能力，大家可以持续关注相关进展。\n一直以来，浏览器由于身份验证问题导致 Web 应用在很多场景乏力，特别是目前大部分 APP 是十分“重”的，功能繁多，如果这两个能力得以普及，那么可能会有更多的 WEB 应用代替以前 APP 的极速版本。\n由于新冠疫情影响，越来越多人的工作方式变成了 WFH。可以预见，疫情彻底清除以后，远程办公也许会成为不少人的选择。所以“集成摄像头”能力，很有可能在人与人线上交流场景中，发挥更大的作用。\n2022 年，可能 HTML6 并不会推出，但是可能会有更多利于用户体验的提案出现。\nWeb3.0Facebook 改名 Meta 后，元宇宙话题很火热，但突然一夜之间，讨论似乎又从元宇宙过渡到了 Web3.0。\n前端工程化展望前端框架在 StackOverflow 的“最受欢迎的 Web 框架”调查中，除去 SSR 渲染框架和 jQuery，上榜的前端框架共有 5 个：\n\n前端框架排行图\n\n\n而从 NPM 下载量来分析，观察到的现象是：\n\nReact 一家独大，独自吃掉 70% 的市场份额；\nVue 和 Angular 平分秋色打的难舍难分；\nPreact 作为“轻量版 React”在小众中最受欢迎；\nSvelte 作为无 vdom 的 MVVM 框架，艰难爬升中，甚至还没超过已经停止更新的 AngularJS。\n\n\n\n\n\n\n\n\n\n\n总的来说，React，Vue，Angular 依然是强势铁三角向前发展。在 2022 年 Vue3 会成为 Vue 的默认版本，React 18 也会发布正式版本，从目前社区关注度来看， Vue3 源码 Github star 27k+， React 18 WG Github star 3.9k+，且在 npm 的下载量上，新版本下载数目都比较可观，所以很有可能今年尝试和使用的人会变得更多。\n打包器打包器大概可以分为两类：\n\n传统编译：Webpack, Rollup, Parcel, Esbuild\nESM 混合编译：Snowpack, Vite\n\n目前是 Webpack、Rollup、Esbuild 三分天下：\n\nWebpack：我们的老熟人，生态最丰富、功能最多，独自吃掉 70% 的市场份额；\nRollup：ESM 版的 Webpack，甩掉了很多历史包袱；\nEsbuild：Go 写的 Webpack，性能有数十倍提升。\n\nUI框架由于模块化 CSS、摇树、MVVM 的流行，UI 框架的选择其实没有那么举足轻重了，针对自己选用的框架选择一个符合项目风格的 UI 即可。\n桌面端值得关注的只有两个：\n\nElectron: 我们的老熟人，Chromium + Nodejs，深受大家喜爱；\nTauri: 异军突起的新星，Webview + Rust。对比 Electron 因为不用打包 Chromium 和 Nodejs 运行时，产物体积小，运行性能好；\n\n智能前端低代码的崛起低代码开发平台（英语：Low-Code Development Platform，简称 LCDP），是一种方便产生应用程序的平台软件，软件会开发环境让用户以图形化接口以及配置编写程序，而不是用传统的程序设计做法。此平台是针对某些种类的应用而设计开发的，例如数据库、业务过程、以及用户界面（例如网页应用程序）。这类平台一般可以产生完整且可运作的应用程序，在一些特殊的情形下仍需要编写程序。\nAI与图形化的探索人工智能作为跨时代技术在各个领域大放异彩，近些年 AI 能力在前端领域的尝试与应用带来新一轮的技术革命。前端可以依赖 D3.js，ECharts，WebGL 等进行数据可视化的显示：\n跨平台技术随着从 PC 时代向移动互联网时代演进，原生客户端因为自身天花板的原因也在逐渐向跨平台方案倾斜，当然这得益于跨平台方案的明显优势。对于开发者而言，可以做到一次开发多端复用，这在很大程度上能够降低研发成本，提高产品效能\n2020-2021 年间，有 42% 的开发者用过 React Native 进行开发，这一年内没有增长；而 Flutter 这一数据从 2020 年的 39% 上升到了 42%。\n成为泛前端前端研发需要掌握的技术也在迭代更新，基本可以理解为 FaaS BaaS，在 Baas 层进行存储与计算，在 Faas 层提供云函数。\n尽可能成为全栈从工程师能力模型来看，第一级需要集“天时地利人和”大成，是工程师的最高荣誉。普通人或许可以将目标聚焦在第二、三级。优秀的工程师并不是以“栈”数取胜，更重要的是拥有产品观、全局思维、沟通能力、学习能力、解决问题能力等\n","slug":"front-end-expectation","date":"2022-11-18T14:42:46.000Z","categories_index":"Front-End","tags_index":"前端技术栈,前端发展前景","author_index":"X-29"},{"id":"6b9a8f6982f1769c256f388c30975912","title":"前端技术栈","content":"Front-End技术栈概论\n\n\n\n\n\nWhat’s the meaning of Fronot-End\n前端的意义在于创造。\n\n技术的诞生，从来不是为了获得更多的利益。树上的苹果并不会给牛顿带来新的一笔巨大财富。如今市场的需求化已经金钱的吮吸灵魂的力量，将技术本来的面目，弄得灰头土脸。禁锢、限制、局限。不止前端。\nFront-End Learning Path后知后觉，如梦初醒。师从四方，自力更生。\n学习路径前端核心：HTML5+CSS3→移动端web→JavaScript→DOM&amp;BOM→Jquery→Ajax技术进阶：ES6-ES11→Node.js→Promise→Axios前沿框架：Typescript→Vue2→Vue3→React\n工程化构建：Git&amp;NPM&amp;YARN&amp;WebPack数据可视化：Echarts&amp;D3.js&amp;HighCharts&amp;AntV&amp;Three.js&amp;Ceisum&amp;WebGLUI 库：Element UI&amp;Vuetify&amp;Ant Design&amp;Bottstrap&amp;Vant UI&amp;Framework7&amp;WEUI\nSoftware Development Basics设计模式降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性常用七大设计模式：\n\n创建型模式：单例模式、工厂方法模式、抽象工厂模式\n\n结构型模式：代理模式、装饰器模式\n\n行为型模式：观察者模式、责任链模式\n\n\nGit常用命令\n\n\n\n\n\n\nWARNING\n如果git命令报错，一定先检查一下是否开启VPN、节点、steam++等影响国内网络的软件\n\n\n\n\n\n\n\n\n\n\n初始化本地仓库，提交代码，提交到远程git仓库\n\nClick to see more\n\n初始化代码仓库\ngit init\n将当前目录下的所有文件放到暂存区\ngit add .\n查看文件状态\ngit status\n添加提交的描述信息\ngit commit -m &#39;[提交的描述信息]&#39;\n远程仓库地址\ngit remote add origin [远程仓库地址]\n推送到远程仓库\ngit push -u origin master\n\n\n\n\n\n\n\n\n\n\n\n\n创建分支，提交代码到分支\n\nClick to see more\n\n创建切换分支\ngit checkout -b [分支名称]\n将当前目录下的所有文件放到暂存区\ngit add .\n添加提交的描述信息\ngit commit -m &#39;[描述]&#39;\n将分支推送到远程仓库\ngit push --set-upstream origin dev1 \n切换到主分支\ngit checkout master\n将dev合并到主分支\ngit merge dev \n推送到远程仓库\ngit push origin master \n\n\n\nFront-End Optimization通过分析和优化手段，提高网站的性能和用户体验。\n性能优化FP（First Paint）从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。\nFCP（First Contentful Paint）浏览器首次绘制来自 DOM 的内容的时间。\nFMP（First Meaningful Paint）页面的主要内容绘制到屏幕上的时间。\nFSP（First Screen Paint）页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。\nTTI（Time to Interactive）表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。\n优化手段\n性能监控(Performance API)\n样式优化\n防抖 &amp; 节流\n代码分割\n资源压缩\n打包优化\n服务器优化\n缓存优化(Service Worker)\n动画性能\ndns-prefetch\nLazy loading\n\n安全问题\nXSS\nCSRF\n反爬虫\nSQL 注入\nDDoS\n\nFront-End Ecology博客编写\n✅ Gatsby.js\n✅ Docusaurus\nHugo\nHexo\n\n文档编写\n⭐️ Docsify\nJekyII\nVuePress\nDumi\n\n移动应用\nHybrid\nWebView\nReact Native\nFlutter\n\n桌面应用\nElectron\nNW.js\nProton Native\n\n小程序\n原生\nWebView\n\n","slug":"front-end","date":"2022-11-16T16:12:10.000Z","categories_index":"Front-End","tags_index":"前端技术栈","author_index":"X-29"}]