[{"id":"6d1a44d72f500b2ae165cfd01771a531","title":"rollup","content":"rollup前端工程化历程\n除屑优化(tree shaking)除了可以使用 ES 模块之外，Rollup 还可以静态分析你导入的代码，并将排除任何实际上没有使用的内容，从上面的引入和最后的打包结果就可以看到，没有使用到的内容直接被删除了。\n\n\n\n\n\n\n\n\n\n注意，除屑优化的核心思想是在编译阶段通过静态分析确定代码的使用情况，而不是在运行时。\n所以除屑优化一般是建立在ES6 模块化语法基础之上的，ESM 的导入导出是静态的。\nCommonJS 模块的导入和导出是动态的，无法在编译阶段静态确定代码的使用情况。一般情况下，除屑优化工具无法在 CommonJS 模块中进行精确的除屑，因为无法静态分析模块间的导入和导出关系。\n然而，一些构建工具（如 Webpack）会尝试通过静态分析和启发式方法对 CommonJS 模块进行近似的除屑优化。它们会尽可能地识别出那些可以在编译阶段确定未被使用的代码，并进行剔除。但这种处理方式可能不如对 ES6 模块的优化效果好，且有一定的限制。\n除屑优化的原理：\n\n静态分析：对 JavaScript 代码进行静态分析，识别出模块的导入和导出关系。\n标记未使用代码：标记出在导入和导出关系上没有被使用的代码。这些代码可能是模块的导出函数、变量、类等。\n剔除未使用代码：根据标记结果，构建工具会将未被使用的代码从最终的打包结果中剔除，只保留被使用的部分。\n\n由于是静态分析，所以我们在写代码的时候，需要注意自己的写法，简单来说，尽量的使用最小导入，比如你可以比较一下我们这里导入代码之后，打包的区别：\n&#x2F;&#x2F; 直接默认导入整个对象\nimport util from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; util.getRandomNum(1, 10)\nconsole.log(r)\n​\n&#x2F;&#x2F; 具名导入具体的函数\nimport &#123; getRandomNum &#125; from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; getRandomNum(1, 10)\nconsole.log(r)\n\n与 webpack 打包的区别这个打包结果其实就已经和我们熟知的webpack有了很鲜明的区别，我们把 webpack 安装一下试试\ncsharp 代码解读复制代码pnpm add webpack webpack-cli -D\n\n运行 webpack-cli：\ncss 代码解读复制代码# --entry 入口文件 -o 打包文件夹位置 --mode 打包模式\nnpx webpack --entry .&#x2F;src&#x2F;index.js -o dist --mode development\n\n当然我们可以选择生成模式进行打包\ncss 代码解读复制代码npx webpack --entry .&#x2F;src&#x2F;index.js -o dist --mode production\n\n(() &#x3D;&gt; &#123;\n  &quot;use strict&quot;;\n  const o &#x3D;\n    ((t &#x3D; 1),\n    (a &#x3D; 10),\n    (t &#x3D; Math.ceil(t)),\n    (a &#x3D; Math.floor(a)),\n    Math.floor(Math.random() * (a - t + 1)) + t);\n  var t, a;\n  console.log(o);\n&#125;)();\n\n现在打包出来的内容就直接是压缩之后的代码了\n配置文件Rollup配置文件是一个 ES 模块。通常，它被称为 rollup.config.js 或 rollup.config.mjs，并位于项目的根目录中。它导出一个默认对象，其中包含所需的选项：\ncss 代码解读复制代码export default &#123;\n\tinput: &#39;src&#x2F;index.js&#39;,\n\toutput: &#123;\n\t\tfile: &#39;dist&#x2F;bundle.js&#39;,\n\t\tformat: &#39;esm&#39;\n\t&#125;\n&#125;;\n\n\n\n\n\n\n\n\n\n\n注意：nodejs 环境下要运行 esm 模块化的内容，要么文件名后缀处理为 .mjs，要么 package.json 文件中配置 “type”:”module” ，因为 Rollup 将遵循 Node ESM 语义。\n常用配置多产物配置我们可以将 output 改造成一个数组，对外暴露出不同格式的产物供他人使用，不仅包括 ESM，也需要包括诸如CommonJS、UMD等格式，保证良好的兼容性\nphp 代码解读复制代码import &#123; defineConfig &#125; from &#39;rollup&#39;\n\nexport default defineConfig(&#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: [\n    &#123;\n      file: &#39;dist&#x2F;bundle-iife.js&#39;,\n      format: &#39;iife&#39;\n    &#125;,\n    &#123;\n      file: &#39;dist&#x2F;bundle-esm.js&#39;,\n      format: &#39;esm&#39;\n    &#125;,\n    &#123;\n      file: &#39;dist&#x2F;bundle-cjs.js&#39;,\n      format: &#39;cjs&#39;\n    &#125;,\n    &#123;\n      file: &#39;dist&#x2F;bundle-umd.js&#39;,\n      format: &#39;umd&#39;,\n      name: &#39;bundle&#39;\n    &#125;\n  ],\n&#125;)\n\n多入口配置除了多产物配置，Rollup 中也支持多入口配置\nmain.js\n&#x2F;&#x2F; src&#x2F;main.js\nimport util from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; util.getRandomNum(1, 10);\nconsole.log(&quot;🚀 ~ r:&quot;, r);\n\nconst obj &#x3D; &#123;\n  a: 1,\n  b: &#123;\n    c: 3,\n  &#125;,\n&#125;;\nconst cloneObj &#x3D; util.deepClone(obj);\ncloneObj.b.c &#x3D; 4;\nconsole.log(&quot;🚀 ~ obj:&quot;, obj);\nconsole.log(&quot;🚀 ~ cloneObj:&quot;, cloneObj);\n\nrollup.config.js\nphp 代码解读复制代码import &#123; defineConfig &#125; from &#39;rollup&#39;\n\nexport default defineConfig(&#123;\n  input: [&#39;src&#x2F;index.js&#39;,&#39;src&#x2F;main.js&#39;],\n  output: [\n    &#123;\n      dir: &#39;dist&#39;,\n      format: &#39;cjs&#39;\n    &#125;\n  ],\n&#125;)\n\n通常情况下多产物和多入口两者会被结合起来使用\nphp 代码解读复制代码import &#123; defineConfig &#125; from &#39;rollup&#39;\nexport default defineConfig(&#123;\n  input: [&#39;src&#x2F;index.js&#39;,&#39;src&#x2F;main.js&#39;],\n  output: [\n    &#123;\n      dir: &#39;cjs&#39;,\n      format: &#39;cjs&#39;\n    &#125;,\n    &#123;\n      dir: &#39;esm&#39;,\n      format: &#39;esm&#39;\n    &#125;\n  ],\n&#125;)\n\n当然，上面这样的写的话，生成的产物会把两个入口一起进行构建，我们可能的想法是一个入口一种构建方式：\npython 代码解读复制代码import &#123; defineConfig &#125; from &#39;rollup&#39;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;umd&#x2F;&#39;,\n    format: &#39;umd&#39;,\n    name: &#39;bundle&#39;\n  &#125;\n&#125;\n\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: &#39;src&#x2F;main.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\nexport default [buildIndexOptions, buildMainOptions];\n\n动态导入与默认代码分割使用路由来说明懒加载是大家喜闻乐见的方式，估计大多数同学对于懒加载都只是停留在路由的懒加载，其实，任何时候，我们都可以使用 import 动态懒加载的方式。重新编辑一下 main.js 入口：\n&#x2F;&#x2F; src&#x2F;main.js\nfunction run() &#123;\n  &#x2F;&#x2F; 如果不清楚import动态导入返回的是什么，可以先打印一下下面结果\n  &#x2F;&#x2F; import(&quot;.&#x2F;util.js&quot;).then(chunk &#x3D;&gt; console.log(&quot;🚀 ~ chunk:&quot;, chunk));\n\n  import(&quot;.&#x2F;util.js&quot;).then((&#123; default: foo &#125;) &#x3D;&gt; &#123;\n    const r &#x3D; foo.getRandomNum(1, 10);\n    console.log(&quot;🚀 ~ r:&quot;, r);\n  &#125;);\n&#125;\nrun();\n\n重新运行可以看到 dist 目录形成了下面的结构:\nerlang 代码解读复制代码.\n├── dist\n│ ├── esm\n│ │ ├── main.js\n│ │ └── util-371e3ef9.js\n│ └── umd\n│     └── index.js\n└── ...\n\nRollup 将使用动态导入创建一个仅在需要时加载的单独块。所以你可以看到这里多了一个util-371e3ef9.js的文件\n\n\n\n\n\n\n\n\n\n注意： 为了让 Rollup 知道在哪里放置第二个块，我们不使用 --file 选项，而是使用 --dir 选项设置一个输出文件夹\n其中，util-371e3ef9.js是自动生成的chunk-[hash].js的名字，[hash] 是基于内容的哈希字符串。你可以通过指定 output.chunkFileNames (chunk 文件)和 output.entryFileNames (打包入口文件)选项来提供自己的命名模式。\npython 代码解读复制代码&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: &#39;src&#x2F;main.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\n\n而且，很智能的是，如果这个时候，我定义了又多个入口点都调用了util.js文件，会自动的引入分割出来的文件\npython 代码解读复制代码&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: [&#39;src&#x2F;main.js&#39;, &#39;src&#x2F;main2.js&#39;],\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\n\n在打包后的 main2.js 中，可以看到这样的引用：\nimport util from &quot;.&#x2F;chunk-util-371e3ef9.js&quot;;\n\n使用插件到目前为止，我们已经用入口文件和通过相对路径导入的模块打了一个简单的包。随着你需要打包更复杂的代码，通常需要更灵活的配置，例如导入使用 NPM 安装的模块、使用 Babel 编译代码、处理 JSON 文件等等。\n插件列表 ： the Rollup Awesome List。\n@rollup&#x2F;plugin-node-resolve比如我们现在引入 lodash-es 库\ncsharp 代码解读复制代码pnpm add lodash-es -D\n\n在 index.js 中使用\nimport &#123; chunk &#125; from &quot;lodash-es&quot;;\nconst r &#x3D; chunk([1, 2, 3, 4], 2);\nconsole.log(&quot;🚀 ~ r:&quot;, r);\n\n现在直接打包\npython 代码解读复制代码&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\nexport default buildIndexOptions\n\n会出现下面的警告：\nbash 代码解读复制代码src&#x2F;index.js → dist&#x2F;esm&#x2F;...\n(!) Unresolved dependencies\nhttps:&#x2F;&#x2F;rollupjs.org&#x2F;troubleshooting&#x2F;#warning-treating-module-as-external-dependency\nlodash-es (imported by &quot;src&#x2F;index.js&quot;)\ncreated dist&#x2F;esm&#x2F; in 13ms\n\n意思是，不能解析lodash-es这个依赖，报出了警告，问你是不是需要external，并提示你点击链接有这个警告的解释。当我们点击这个链接，按照提示解决这个 external 警告问题，很简单，就加上 external，也就是把lodash-es这个库给排除出去\ncss 代码解读复制代码const buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n+  external: [&#39;lodash-es&#39;]\n&#125;\nexport default buildIndexOptions\n\n再此打包，果然没警告了，而且我们在 nodejs 环境中确实也能正常运行了\n\n\n\n\n\n\n\n\n\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n重要的事情说三遍，这里虽然看似一个很小的问题，但是却有很多基本理论点\n1、rollup 默认只能解析导入的相对路径，也就是/ ， ./或者../开头的路径，对于bare import，也就是import &#123; chunk &#125; from &#39;lodash-es&#39;;这种直接导入的第三方包的格式，并不支持\n2、rollup相比webpack最大的优势并不是构建一个足够大的应用打包，大多是情况下，我们使用rollup用来构建工具库，因此，这里导入的lodash-es并没有报错，而仅仅报出警告，因为rollup认为lodash-es这个库并没有加入构建，那么你的意思是将来用作第三方库来使用，因此将lodash-es使用配置external排除掉就好。\n3、lodash-es这个包本身就是支持 ESM 的\n4、最后打包好的index.js文件只所以在nodejs环境下运行，是因为nodejs可以帮我们解析bare import，我们可以试着将index.js放入到html文件中运行，你就可以看到其中的问题所在，在 html 环境中就会报错了：index.html:1 Uncaught TypeError: Failed to resolve module specifier &quot;lodash-es&quot;. Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;.\n如果希望在最后的打包中，将lodash-es内容解析打包进去，就可以使用@rollup/plugin-node-resolve\n安装:\nsql 代码解读复制代码pnpm add @rollup&#x2F;plugin-node-resolve --save-dev\n\n使用：\npython 代码解读复制代码import &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [nodeResolve()]\n  &#x2F;&#x2F; external: [&#39;lodash-es&#39;]\n&#125;\nexport default buildIndexOptions\n\n现在，再此进行打包，无论是打包时间，还是打包内容和之前都很不一样了，把lodash-es中，关于chunk()函数的内容，都打包进了index.js文件中\noutput.manualChunks上面讲了对于动态加载模块，rollup 帮我们自动做了代码分割，其实我们也可以手动的操作，直接在 rollup 配置中声明\nless 代码解读复制代码const buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    manualChunks: &#123;\n      &#39;lodash-es&#39;: [&#39;lodash-es&#39;],\n    &#125;\n    &#x2F;&#x2F;也可以是函数形式\n    &#x2F;&#x2F; manualChunks(id)&#123;\n    &#x2F;&#x2F;   if(id.includes(&#39;lodash-es&#39;))&#123;\n    &#x2F;&#x2F;     return &#39;lodash-es&#39;\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F; &#125;\n\t&#125;,\n  plugins: [nodeResolve()]\n&#125;\n\n@rollup&#x2F;plugin-commonjs上面最开始导入lodash-es，没有加入external和plugins，之所以还能直接运行，还因为lodash-es本身就是支持 ESM 的，因为 rollup 默认并不支持 Commonjs 模块化，比如将 lodash-es 换位 lodash，马上就能看到不一样的效果,直接打包失败\nvbnet 代码解读复制代码[!] RollupError: &quot;chunk&quot; is not exported by &quot;node_modules&#x2F;.pnpm&#x2F;lodash@4.17.21&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js&quot;, imported by &quot;src&#x2F;index.js&quot;.\nhttps:&#x2F;&#x2F;rollupjs.org&#x2F;troubleshooting&#x2F;#error-name-is-not-exported-by-module\n\n这个错误在官网上解释的很清楚了，无非就是 commonjs 没有这种导出，因此我们需要@rollup/plugin-commonjs帮我们处理 commonjs 模块化的问题\n安装:\nsql 代码解读复制代码pnpm add @rollup&#x2F;plugin-commonjs --save-dev\n\n使用:\npython 代码解读复制代码import &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\n+import commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n+  plugins: [nodeResolve(), commonjs()]\n&#125;\nexport default buildIndexOptions\n\n@rollup&#x2F;plugin-babel使用 Babel 来使用尚未被浏览器和 Node.js 支持的最新 JavaScript 特性。\n使用 Babel 和 Rollup 最简单的方法是使用 @rollup&#x2F;plugin-babel\n安装:\nsql 代码解读复制代码pnpm add @rollup&#x2F;plugin-babel -D\n\n使用：\ncss 代码解读复制代码import &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\n+import babel from &#39;@rollup&#x2F;plugin-babel&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n+    babel(&#123; babelHelpers: &#39;bundled&#39; &#125;)\n  ]\n&#125;\nexport default buildIndexOptions\n\n不过这么做之后，打包代码并不会有什么变化，因为我们都知道 babel 是需要预设的.\n安装 babel-core 和 env 预设\nsql 代码解读复制代码pnpm add -D @babel&#x2F;core @babel&#x2F;preset-env\n\n在 Babel 实际编译代码之前，需要进行配置。在项目根目录创建一个名为 .babelrc.json 的新文件\nperl 代码解读复制代码&#123;\n  &quot;presets&quot;: [&quot;@babel&#x2F;preset-env&quot;]\n&#125;\n\n具体的 babel 设置，可以参考babel 文档\n题外话：@babel&#x2F;runtime我们在index.js代码中加入如下的 api\nimport &#123; getRandomNum &#125; from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; getRandomNum(1, 10);\nconsole.log(r);\n\nconst arr &#x3D; [1, 2, 3, 4].map((item) &#x3D;&gt; item * item);\nconsole.log(&quot;🚀 ~ arr:&quot;, arr);\n\nPromise.resolve(1).then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);\n\n我们通过 babel 处理之后会发现一些问题：\n@babel&#x2F;preset-env 只转换了语法，也就是我们看到的箭头函数、const 一类，但是对于进一步需要转换内置对象、实例方法等等 API，就显得无能为力了，这些代码需要polyfill(兼容性垫片) 。所以这个我需要@babel/runtime来帮我们处理。\n@babel/runtime是一个核心， 一种实现方式，但是在实现 polyfill 垫片的过程中，可能会产生很多重复的代码，所以需要@babel/plugin-transform-runtime防止污染全局， 抽离公共的 helper function , 防止冗余，当然在处理 polyfill 的时候，我们还需要 core-js 的辅助，基于 babel，我们可以使用@babel/runtime-corejs3\n安装：\nsql 代码解读复制代码pnpm add @babel&#x2F;plugin-transform-runtime -D\npnpm add @babel&#x2F;runtime @babel&#x2F;runtime-corejs3\n\n要使用@babel/plugin-transform-runtime，@rollup/plugin-babel的babelHelper处理必须改为 runtime\npython 代码解读复制代码import &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\nimport babel from &#39;@rollup&#x2F;plugin-babel&#39;;\nimport typescript from &#39;@rollup&#x2F;plugin-typescript&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n    babel(&#123;\n      babelHelpers: &#39;runtime&#39;,\n      include: &#39;src&#x2F;**&#39;,\n      exclude: &#39;node_modules&#x2F;**&#39;,\n      extensions:[&#39;.js&#39;, &#39;.ts&#39;]\n    &#125;),\n    typescript(),\n  ]\n&#125;\nexport default buildIndexOptions\n\n.babelrc.json：\nperl 代码解读复制代码&#123;\n  &quot;presets&quot;: [\n    [\n      &quot;@babel&#x2F;preset-env&quot;,\n      &#123;\n        &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;,\n        &quot;useBuiltIns&quot;: &quot;usage&quot;,\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ],\n  &quot;plugins&quot;: [\n    [\n      &quot;@babel&#x2F;plugin-transform-runtime&quot;,\n      &#123;\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ]\n&#125;\n\n这个时候你再进行构建，会发现打包后的文件多出了一大堆，这其实就是 polyfill 中的代码。\n@rollup&#x2F;plugin-typescript要使用 typescript 就需要依赖这个插件，当然这个插件本身还依赖了typescript和tslib，因此我们需要导入 3 个包\nsql 代码解读复制代码pnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\nutil.ts\ntypescript 代码解读复制代码&#x2F;**\n * 深拷贝\n * @param obj 需要深拷贝的对象\n * @returns 深拷贝对象\n *&#x2F;\nexport const deepClone &#x3D; &lt;T&gt;(obj: T): T &#x3D;&gt; &#123;\n  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\n    return obj\n  &#125;\n  const result:any &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\n  for(let key in obj) &#123;\n    if(obj.hasOwnProperty(key)) &#123;\n      result[key] &#x3D; deepClone(obj[key])\n    &#125;\n  &#125;\n  return result\n&#125;\n\nexport const getRandomNum &#x3D; (min: number, max: number): number &#x3D;&gt; &#123;\n  let num &#x3D; Math.floor(Math.random() * (min - max) + max);\n  return num;\n&#125;\n\nIndex.ts\nini 代码解读复制代码import &#123; getRandomNum,deepClone &#125; from &#39;.&#x2F;util.ts&#39;;\nconst r &#x3D; getRandomNum(1, 10);\nconsole.log(r);\n\nconst obj &#x3D; &#123; a: 1, b: &#123; c: 3 &#125; &#125;;\nconst obj2 &#x3D; deepClone(obj);\nobj2.b.c &#x3D; 4;\n\nconsole.log(obj);\nconsole.log(obj2);\n\n当然，配置文件我们也完全可以是 ts 的\nrollup.config.ts\ncss 代码解读复制代码import &#123; RollupOptions &#125; from &quot;rollup&quot;\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\nimport babel from &#39;@rollup&#x2F;plugin-babel&#39;;\nimport typescript from &#39;@rollup&#x2F;plugin-typescript&#39;;\n\nconst config: RollupOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.ts&#39;,\n  output: &#123;\n    file: &#39;dist&#x2F;umd&#x2F;index.js&#39;,\n    format: &#39;umd&#39;,\n    name: &#39;rollupDemo&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n    babel(&#123;\n      babelHelpers: &#39;runtime&#39;,\n      include: &#39;src&#x2F;**&#39;,\n      exclude: &#39;node_modules&#x2F;**&#39;,\n      extensions:[&#39;.js&#39;, &#39;.ts&#39;]\n    &#125;),\n    typescript(),\n  ],\n&#125;\nexport default config;\n\ntsconfig.json\njson 代码解读复制代码&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;esnext&quot;,\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;],\n    &quot;skipLibCheck&quot;: true,\n\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;noEmit&quot;: true,\n    &quot;allowImportingTsExtensions&quot;:true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;rollup.config.ts&quot;],\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意： 别忘记 tsconfig.json 文件中需要加入 rollup.config.ts 配置文件,不然要报错\njson 代码解读复制代码&#123;\n  &quot;compilerOptions&quot;: &#123;\n    ......\n  &#125;,\n+  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;rollup.config.ts&quot;],\n&#125;\n\n运行：\nlua 代码解读复制代码npx rollup -c rollup.config.ts --configPlugin typescript\n\n构建 react 应用node_modulesruby 代码解读复制代码# react\npnpm add react react-dom\n\n# @types&#x2F;react\npnpm add @types&#x2F;react @types&#x2F;react-dom -D\n\n# react预设\npnpm add @babel&#x2F;preset-react -D\n\n# rollup\npnpm add rollup -D\n\n# rollup常规插件\npnpm add @rollup&#x2F;plugin-node-resolve @rollup&#x2F;plugin-commonjs -D\n\n# typescript相关\npnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\n# @rollup&#x2F;plugin-babel相关\npnpm add @rollup&#x2F;plugin-babel @babel&#x2F;core @babel&#x2F;preset-env -D\n\n# @babel&#x2F;runtime相关\npnpm add @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime @babel&#x2F;runtime-corejs3 -D\n\n# html文件模板\npnpm add rollup-plugin-generate-html-template -D\n\n# 替换字符串\npnpm add @rollup&#x2F;plugin-replace -D\n\n# 开发服务器与live server\npnpm add rollup-plugin-serve rollup-plugin-livereload -D\n\n# clear插件\npnpm add rollup-plugin-clear -D\n\n# scss\npnpm add rollup-plugin-scss sass -D\n\n# postcss\npnpm add postcss rollup-plugin-postcss -D\n\n# 图片处理\npnpm add @rollup&#x2F;plugin-image -D\n\n# nodejs typescript类型\npnpm add @types&#x2F;node -D\n\n# 别名插件\npnpm add @rollup&#x2F;plugin-alias -D\n\n# terser\npnpm add @rollup&#x2F;plugin-terser -D\n\n# visualizer\npnpm add rollup-plugin-visualizer -D\n\ntsconfig.jsonjson 代码解读复制代码&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;esnext&quot;,\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;],\n    &quot;skipLibCheck&quot;: true,\n\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;noEmit&quot;: true,\n    &quot;allowImportingTsExtensions&quot;:true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;jsx&quot;: &quot;preserve&quot;,\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;,\n    &quot;paths&quot;: &#123;\n      &quot;@&#x2F;*&quot;: [&quot;src&#x2F;*&quot;]\n    &#125;,\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;rollup.config.ts&quot;, &quot;global.d.ts&quot;],\n&#125;\n\n.babelrc.jsonperl 代码解读复制代码&#123;\n  &quot;presets&quot;: [\n    [\n      &quot;@babel&#x2F;preset-env&quot;,\n      &#123;\n        &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;,\n        &quot;useBuiltIns&quot;: &quot;usage&quot;,\n        &quot;corejs&quot;: 3\n      &#125;\n    ],\n    [&quot;@babel&#x2F;preset-react&quot;]\n  ],\n  &quot;plugins&quot;: [\n    [\n      &quot;@babel&#x2F;plugin-transform-runtime&quot;,\n      &#123;\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ]\n&#125;\n\nrollup.config.tsphp 代码解读复制代码import &#123; RollupOptions &#125; from &quot;rollup&quot;;\nimport &#123; nodeResolve &#125; from &quot;@rollup&#x2F;plugin-node-resolve&quot;;\nimport commonjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\nimport babel from &quot;@rollup&#x2F;plugin-babel&quot;;\nimport typescript from &quot;@rollup&#x2F;plugin-typescript&quot;;\nimport htmlTemplate from &quot;rollup-plugin-generate-html-template&quot;;\nimport serve from &quot;rollup-plugin-serve&quot;;\nimport livereload from &quot;rollup-plugin-livereload&quot;;\nimport replace from &quot;@rollup&#x2F;plugin-replace&quot;;\nimport postcss from &quot;rollup-plugin-postcss&quot;;\nimport alias from &quot;@rollup&#x2F;plugin-alias&quot;;\nimport clear from &quot;rollup-plugin-clear&quot;;\nimport image from &quot;@rollup&#x2F;plugin-image&quot;\nimport terser from &#39;@rollup&#x2F;plugin-terser&#39;;\nimport &#123; fileURLToPath &#125; from &quot;node:url&quot;;\nimport &#123; visualizer &#125; from &quot;rollup-plugin-visualizer&quot;;\n\nconst config: RollupOptions &#x3D; &#123;\n  input: &quot;src&#x2F;main.tsx&quot;,\n  output: &#123;\n    dir: &quot;dist&#x2F;&quot;,\n    format: &quot;esm&quot;,\n    name: &quot;rollupDemo&quot;,\n    sourcemap: true,\n    plugins: [terser()],\n    entryFileNames: &quot;[name].[hash:6].js&quot;,\n    chunkFileNames: &quot;chunks&#x2F;chunk-[name]-[hash].js&quot;,\n    &#x2F;&#x2F; 代码分割\n    &#x2F;&#x2F; manualChunks: &#123;\n    &#x2F;&#x2F;   react: [&quot;react&quot;, &quot;react-dom&quot;]\n    &#x2F;&#x2F; &#125;,\n    globals: &#123;\n      react: &quot;React&quot;,\n      &quot;react-dom&quot;: &quot;ReactDOM&quot;,\n    &#125;,\n    paths: &#123;\n      react: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;react@18.2.0&#x2F;+esm&quot;,\n      &quot;react-dom&quot;: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;react-dom@18.2.0&#x2F;+esm&quot;,\n    &#125;\n  &#125;,\n  external: [&quot;react&quot;, &quot;react-dom&quot;],\n  plugins: [\n    visualizer(),\n    nodeResolve(&#123;\n      extensions: [&quot;.js&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;],\n    &#125;),\n    commonjs(),\n    typescript(),\n    babel(&#123;\n      babelHelpers: &quot;runtime&quot;,\n      include: &quot;src&#x2F;**&quot;,\n      exclude: &quot;node_modules&#x2F;**&quot;,\n      extensions: [&quot;.js&quot;, &quot;.ts&quot;, &quot;jsx&quot;, &quot;tsx&quot;],\n    &#125;),\n    alias(&#123;\n      entries: [\n        &#123;\n          find: &quot;@&quot;,\n          replacement: fileURLToPath(new URL(&quot;src&quot;, import.meta.url)),\n        &#125;,\n      ],\n    &#125;),\n    postcss(&#123;\n      extensions: [&quot;.css&quot;], &#x2F;&#x2F; 将scss解析成css\n      extract: true,\n      modules: true,\n    &#125;),\n    replace(&#123;\n      preventAssignment: true,\n      &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;), &#x2F;&#x2F; 否则会报：process is not defined的错\n    &#125;),\n    clear(&#123;\n      targets: [&quot;dist&quot;],\n    &#125;),\n    htmlTemplate(&#123;\n      template: &quot;public&#x2F;index.html&quot;,\n      target: &quot;dist&#x2F;index.html&quot;,\n      attrs: [&#39;type&#x3D;&quot;module&quot;&#39;],\n    &#125;),\n    image(),\n    serve(&quot;dist&quot;),\n    livereload(&quot;src&quot;),\n  ],\n&#125;;\nexport default config;\n\nnpm 发包npm 发布node_modulessql 代码解读复制代码# rollup\npnpm add rollup -D\n\n# rollup常规插件\npnpm add @rollup&#x2F;plugin-node-resolve @rollup&#x2F;plugin-commonjs -D\n\n# typescript相关\npnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\n# @rollup&#x2F;plugin-babel相关\npnpm add @rollup&#x2F;plugin-babel @babel&#x2F;core @babel&#x2F;preset-env -D\n\n# lodash-es\npnpm add lodash-es\n\n# @types&#x2F;lodash-es\npnpm add @types&#x2F;lodash-es -D\n\ntsconfig.json 文件json 代码解读复制代码&#x2F;&#x2F; tsconfig.json\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;declaration&quot;: true,&#x2F;&#x2F; 根据ts文件自动生成.d.ts声明文件和js文件\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只输出.d.ts声明文件，不生成js文件\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 输出目录\n\t\t......\n  &#125;\n&#125;\n\n本地调试 link 安装最终打包的文件夹是 dist 文件夹，我们可以把 package.json 文件和 README.md 文件都拷贝到 dist 目录中。\nnpm link 地址其实就是全局安装地址：\nmac: /usr/local/lib/node_modules/\nWindows: c:\\用户(Users)\\你的用户名\\AppData(隐藏文件夹)\\Roaming\\npm\\node_modules\npnpm link\n在库文件的 dist 目录下执行：\nbash 代码解读复制代码pnpm link --global\n\n这个命令会读取 package.json 文件中的 name，作为包文件的名字，你可以理解为，相当于 pnpm 将我们打包的项目，全局安装在了本地\n在目标项目中，使用命令\nbash 代码解读复制代码pnpm link --global 包名\n\n进行安装。\n卸载 link pnpm unlink\n发布到 npm常用命令：\n\nnpm whoami 检测当前登录状态\nnpm config ls 显示当前 npm 配置信息\nnpm addUser 、npm login 登录\nnpm config set registry 链接地址 切换源地址\nnpm publish 发布\n\n\n\n\n\n\n\n\n\n\n注意必须使用 npm 源镜像才能发布，如果使用的是阿里源等镜像，需要切换成源镜像才能发布 https://registry.npmjs.org/\nJavaScript APIRollup 提供了一个可从 Node.js 使用的 JavaScript API。你很少需要使用它，不过通过这个 API 我们可以比较明显的知道 rollup 的构建大致流程。\n内容其实并不多，主要核心两个函数，rollup()与 watch()\n\nrollup.rollup\n\ninputOptions 对象\noutputOptions 对象\n\n\nrollup.watch\n\nwatchOptions\n\n\n\n其实用起来的基本思路和配置文件差不多。直接来看一下效果：\nini 代码解读复制代码const rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nconst outputOptions &#x3D; &#123;\n  dir: &#39;dist&#39;,\n  format: &#39;esm&#39;,\n  sourcemap: true,\n  entryFileNames: &#39;[name].[hash].js&#39;\n&#125;\n\nasync function build() &#123;\n  let bundle;\n  let buildFailed &#x3D; false;\n  try &#123;\n    bundle &#x3D; await rollup.rollup(inputOptions);\n    await bundle.write(outputOptions);\n  &#125; catch (error) &#123;\n    buildFailed &#x3D; true;\n    console.error(error);\n  &#125;\n\n  if (bundle) &#123;\n    &#x2F;&#x2F; 关闭打包过程\n    await bundle.close();\n  &#125;\n  process.exit(buildFailed ? 1 : 0);\n&#125;\n\nbuild();\n\nconst watchOptions &#x3D; &#123;\n  ...inputOptions,\n  output: [outputOptions],\n  watch: &#123;\n    include: &#39;src&#x2F;**&#39;,\n    exclude: &#39;node_modules&#x2F;**&#39;\n  &#125;\n&#125;;\nconst watcher &#x3D; rollup.watch(watchOptions);\n\nwatcher.on(&#39;event&#39;, event &#x3D;&gt; &#123;\n  console.log(event);\n  &#x2F;&#x2F;确保每次打包完成后正确的关闭打包\n  if (event.result) &#123;\n    event.result.close();\n  &#125;\n&#125;)\n\n其实整个过程无非就是把我们之前配置的流程转换位了 js 代码的形式。watch api很明显就是命令行中使用 --watch 标志运行 Rollup 时的效果。\n两大构建工作流我们主要来看一下rollup()函数，从rollup()函数就可以看出，rollup 打包构建流程主要是两大步骤：\n1、build主要负责创建模块依赖，初始化哥哥模块的 AST(抽象语法树)，以及模块之间的依赖关系\nini 代码解读复制代码const rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nasync function build() &#123;\n  const bundle &#x3D; await rollup.rollup(inputOptions);\n  console.log(bundle); &#x2F;&#x2F; 打印bundle对象\n  console.log(bundle.cache.modules); &#x2F;&#x2F;打印模块内容\n&#125;\n\nbuild();\n\nyaml 代码解读复制代码&#x2F;&#x2F; 打印bundle对象\n&#123;\n  cache: &#123;\n    modules: [ [Object], [Object], [Object] ],\n    plugins: [Object: null prototype] &#123;&#125;\n  &#125;,\n  close: [AsyncFunction: close],\n  closed: false,\n  generate: [AsyncFunction: generate],\n  watchFiles: [\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;\n  ],\n  write: [AsyncFunction: write]\n&#125;\n\n&#x2F;&#x2F; 打印模块内容\n[\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 262,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;&#x2F;**\\n&#39; +\n      &#39; * 随机数\\n&#39; +\n      &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n      &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n      &#39; * @returns min-max之间的随机整数\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n      &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n      &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n      &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default randomNumber&#39;,\n    customTransformCache: false,\n    dependencies: [],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;&#x2F;**\\n&#39; +\n      &#39; * 随机数\\n&#39; +\n      &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n      &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n      &#39; * @returns min-max之间的随机整数\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n      &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n      &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n      &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default randomNumber&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;&#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;,\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 349,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;&#x2F;**\\n&#39; +\n      &#39; * 深拷贝\\n&#39; +\n      &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n      &#39; * @returns 深拷贝对象\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n      &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n      &#39;    return obj\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n      &#39;  for(let key in obj) &#123;\\n&#39; +\n      &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n      &#39;      result[key] &#x3D; deepClone(obj[key])\\n&#39; +\n      &#39;    &#125;\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  return result\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;export default deepClone&#39;,\n    customTransformCache: false,\n    dependencies: [],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;&#x2F;**\\n&#39; +\n      &#39; * 深拷贝\\n&#39; +\n      &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n      &#39; * @returns 深拷贝对象\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n      &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n      &#39;    return obj\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n      &#39;  for(let key in obj) &#123;\\n&#39; +\n      &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n      &#39;      result[key] &#x3D; deepClone(obj[key])\\n&#39; +\n      &#39;    &#125;\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  return result\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;export default deepClone&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;&#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;,\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 131,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;import randomNumber from &quot;.&#x2F;randomNumber.js&quot;;\\n&#39; +\n      &#39;import deepClone from &quot;.&#x2F;deepClone.js&quot;;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default &#123; randomNumber, deepClone &#125;\\n&#39; +\n      &#39;\\n&#39;,\n    customTransformCache: false,\n    dependencies: [\n      &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n      &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;\n    ],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;import randomNumber from &quot;.&#x2F;randomNumber.js&quot;;\\n&#39; +\n      &#39;import deepClone from &quot;.&#x2F;deepClone.js&quot;;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default &#123; randomNumber, deepClone &#125;\\n&#39; +\n      &#39;\\n&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;\n      &#39;.&#x2F;randomNumber.js&#39;: [Object],\n      &#39;.&#x2F;deepClone.js&#39;: [Object]\n    &#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;\n]\n\n通过上面两个打印语句的结果，其实就可以分析出，在build阶段产生的bunlde对象，并没有模块打包，这个对象的作用在于存储各个模块的内容及依赖关系，并且提供了generate(不写入)，write(写入磁盘)方法，方便后续 output 阶段输出产物\n2、output通过 rollup()函数返回的对象 bundle 有两个重要的函数\n\ngenerate 生成打包产物，不写入磁盘\nwrite 生成打包产物，写入磁盘\n\nini 代码解读复制代码const rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nconst outputOptions &#x3D; &#123;\n  dir: &#39;dist&#39;,\n  format: &#39;esm&#39;,\n  sourcemap: true,\n  entryFileNames: &#39;[name].[hash].js&#39;\n&#125;\n\nasync function build() &#123;\n  const bundle &#x3D; await rollup.rollup(inputOptions);\n  const resp &#x3D; await bundle.generate(outputOptions);\n  console.log(resp)\n&#125;\n\nbuild();\n\n执行结果：\nswift 代码解读复制代码&#123;\n  output: [\n    &#123;\n      exports: [Array],\n      facadeModuleId: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n      isDynamicEntry: false,\n      isEntry: true,\n      isImplicitEntry: false,\n      moduleIds: [Array],\n      name: &#39;index&#39;,\n      type: &#39;chunk&#39;,\n      dynamicImports: [],\n      fileName: &#39;index.1730c9fc.js&#39;,\n      implicitlyLoadedBefore: [],\n      importedBindings: &#123;&#125;,\n      imports: [],\n      modules: [Object: null prototype],\n      referencedFiles: [],\n      code: &#39;&#x2F;**\\n&#39; +\n        &#39; * 随机数\\n&#39; +\n        &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n        &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n        &#39; * @returns min-max之间的随机整数\\n&#39; +\n        &#39; *&#x2F;\\n&#39; +\n        &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n        &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n        &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n        &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n        &#39;&#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;&#x2F;**\\n&#39; +\n        &#39; * 深拷贝\\n&#39; +\n        &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n        &#39; * @returns 深拷贝对象\\n&#39; +\n        &#39; *&#x2F;\\n&#39; +\n        &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n        &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n        &#39;    return obj\\n&#39; +\n        &#39;  &#125;\\n&#39; +\n        &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n        &#39;  for(let key in obj) &#123;\\n&#39; +\n        &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n        &#39;      result[key] &#x3D; deepClone(obj[key]);\\n&#39; +\n        &#39;    &#125;\\n&#39; +\n        &#39;  &#125;\\n&#39; +\n        &#39;  return result\\n&#39; +\n        &#39;&#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;var index &#x3D; &#123; randomNumber, deepClone &#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;export &#123; index as default &#125;;\\n&#39; +\n        &#39;&#x2F;&#x2F;# sourceMappingURL&#x3D;index.1730c9fc.js.map\\n&#39;,\n      map: [SourceMap],\n      preliminaryFileName: &#39;index.!~&#123;001&#125;~.js&#39;,\n      sourcemapFileName: &#39;index.1730c9fc.js.map&#39;\n    &#125;,\n    &#123;\n      fileName: &#39;index.1730c9fc.js.map&#39;,\n      name: undefined,\n      needsCodeReference: false,\n      source: &#96;&#123;&quot;version&quot;:3,&quot;file&quot;:&quot;index.1730c9fc.js&quot;,&quot;sources&quot;:[&quot;..&#x2F;src&#x2F;randomNumber.js&quot;,&quot;..&#x2F;src&#x2F;deepClone.js&quot;,&quot;..&#x2F;src&#x2F;index.js&quot;],&quot;sourcesContent&quot;:[&quot;&#x2F;**\\n * 随机数\\n * @param &#123;*&#125; min 最小值\\n * @param &#123;*&#125; max 最大值\\n * @returns min-max之间的随机整数\\n *&#x2F;\\nconst randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n  min &#x3D; Math.ceil(min);\\n  max &#x3D; Math.floor(max);\\n  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#125;\\n\\nexport default randomNumber&quot;,&quot;&#x2F;**\\n * 深拷贝\\n * @param obj 需要深拷贝的对象\\n * @returns 深拷贝对象\\n *&#x2F;\\nconst deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n    return obj\\n  &#125;\\n  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n  for(let key in obj) &#123;\\n    if(obj.hasOwnProperty(key)) &#123;\\n      result[key] &#x3D; deepClone(obj[key])\\n    &#125;\\n  &#125;\\n  return result\\n&#125;\\nexport default deepClone&quot;,&quot;import randomNumber from \\&quot;.&#x2F;randomNumber.js\\&quot;;\\nimport deepClone from \\&quot;.&#x2F;deepClone.js\\&quot;;\\n\\nexport default &#123; randomNumber, deepClone &#125;\\n\\n&quot;],&quot;names&quot;:[],&quot;mappings&quot;:&quot;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,KAAK;AACnC,EAAE,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACvB,EAAE,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACxB,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;AAC3D;;ACVA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,GAAG,CAAC,GAAG,KAAK;AAC3B,EAAE,GAAG,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,EAAE;AAC9C,IAAI,OAAO,GAAG;AACd,GAAG;AACH,EAAE,MAAM,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;AAC9C,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,EAAE;AACtB,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;AAChC,MAAM,MAAM,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAC;AACvC,KAAK;AACL,GAAG;AACH,EAAE,OAAO,MAAM;AACf;;ACbA,YAAe,EAAE,YAAY,EAAE,SAAS;;;;&quot;&#125;&#96;,\n      type: &#39;asset&#39;\n    &#125;\n  ]\n&#125;\n\n插件机制\n\n\n\n\n\n\n\n\n代码：github.com&#x2F;Sunny-117&#x2F;r…\nRollup 插件概述\n\n\n\n\n\n\n\n\nRollup 插件是一个对象，具有 属性、构建钩子 和 输出生成钩子 中的一个或多个，并遵循我们的 约定。插件应作为一个导出一个函数的包进行发布，该函数可以使用插件特定的选项进行调用并返回此类对象。\n简单来说，rollup 插件一般会做成一个函数，函数返回一个对象，返回的对象中包含一些属性和不同阶段的钩子函数。\n约定插件应该有一个明确的名称，并以rollup-plugin-作为前缀。\n属性name：插件的名称，用于在警告和错误消息中标识插件。\nversion：插件的版本\n钩子函数的特点\n钩子函数区分不同的调用时机\n钩子函数是有执行顺序的\n钩子函数有不同的执行方式\n钩子函数也可以是对象的形式\n对象形式的钩子函数可以改变钩子的执行，让不同插件的同名钩子函数获取不通的执行先后\n\n钩子函数的调用时机这里的调用时机，其实就是以我们上面的 API，build 和 output 两大工作流的不同阶段进行分类。根据这两个不同阶段，rollup 提供的不同的函数让我们调用\n\nconst bundle &#x3D; await rollup.rollup(inputOptions) 执行期间的构建钩子函数 - build-hooks\nawait bundle.generate(outputOptions)&#x2F;write(outputOptions) 执行期间的输出钩子函数-output-generation-hooks\n\n钩子函数的执行方式除了上面简单的划分为两个阶段的调用时机之外，我们还可以以钩子函数的执行方式来分类。\n\nasync/sync：异步&#x2F;同步钩子，async 标记的钩子可以返回一个解析为相同类型的值的 Promise；否则，该钩子被标记为 sync。\nfirst：如果有多个插件实现此钩子，则钩子按顺序运行，直到钩子返回一个不是 null 或 undefined 的值。\nsequential：如果有多个插件实现此钩子，则所有这些钩子将按指定的插件顺序运行。如果钩子是 async，则此类后续钩子将等待当前钩子解决后再运行。\nparallel：如果有多个插件实现此钩子，则所有这些钩子将按指定的插件顺序运行。如果钩子是 async，则此类后续钩子将并行运行，而不是等待当前钩子。\n\n钩子函数也可以是对象除了函数之外，钩子也可以是对象。在这种情况下，实际的钩子函数（或 banner/footer/intro/outro 的值）必须指定为 handler。这允许你提供更多的可选属性，以改变钩子的执行：\n\norder: “pre” | “post” | null\n\n如果有多个插件实现此钩子，则可以先运行此插件（&quot;pre&quot;），最后运行此插件（&quot;post&quot;），或在用户指定的位置运行（没有值或 null）。\nexport default function resolveFirst() &#123;\n  return &#123;\n    name: &quot;resolve-first&quot;,\n    resolveId: &#123;\n      order: &quot;pre&quot;,\n      handler(source) &#123;\n        console.log(source);\n        return null;\n      &#125;,\n    &#125;,\n  &#125;;\n&#125;\n\n构建钩子执行顺序\n\n通过 options 钩子读取配置，并进行配置的转换，得到处理后的配置对象\n调用 buildStart 钩子，考虑了所有 options钩子配置的转换，包含未设置选项的正确默认值，正式开始构建流程\n调用 resolveId 钩子解析模块文件路径。rollup 中模块文件的 id 就是文件地址，所以，类似 resolveId 这种就是解析文件地址的意思。从inputOption的input配置指定的入口文件开始，每当匹配到引入外部模块的语句(如：import moudleA from &#39;./moduleA&#39;)便依次执行注册插件中的每一个 resolveId 钩子，直到某一个插件中的 resolveId 执行完后返回非 null 或非 undefined 的值，将停止执行后续插件的 resolveId 逻辑并进入下一个钩子\n调用load钩子加载模块内容，resolveId中的路径一般为相对路径，load 中的路径为处理之后的绝对路径\n接着判断当前解析的模块是否存在缓存，若不存在则执行所有的 transform 钩子来对模块内容进行进行自定义的转换；若存在则判断shouldTransformCachedModule属性，true 则执行所有的 transform 钩子，false 则进入moduleParsed钩子逻辑\n拿到最后的模块内容，进行 AST 分析，调用 moduleParsed 钩子。如果内部没有imports内容，进入buildEnd环节。如果还有imports内容则继续，如果是普通的 import，则执行resolveId 钩子，继续回到步骤 3-调用 resolveId；如果是动态 import，则执行resolveDynamicImport 钩子解析路径，如果解析成功，则回到步骤 4-load加载模块，否则回到步骤 3 通过 resolveId 解析路径\n直到所有的 import 都解析完毕，Rollup 执行buildEnd钩子，Build 阶段结束\n\n&#x2F;&#x2F; rollup-plugin-example.js\n\nexport default function myExample() &#123;\n  return &#123;\n    name: &quot;my-example&quot;,\n    options(options) &#123;\n      console.log(&quot;🎉 -- options:&quot;, options);\n    &#125;,\n    buildStart(options) &#123;\n      console.log(&quot;✨ -- buildStart:&quot;, options);\n    &#125;,\n    resolveId(source, importer) &#123;\n      console.log(&quot;🚀 -- resolveId(source):&quot;, source);\n      console.log(&quot;🚀 -- resolveId(importer):&quot;, importer);\n      return null;\n    &#125;,\n    load(id) &#123;\n      console.log(&quot;🌈 ~ id:&quot;, id);\n      return null;\n    &#125;,\n    transform(code, id) &#123;\n      console.log(&quot;🌟 -- transform&quot;);\n      console.log(&quot;---&quot;, code);\n      console.log(&quot;---&quot;, id);\n    &#125;,\n    moduleParsed(info) &#123;\n      console.log(&quot;⭐️ -- moduleParsed:&quot;, info);\n    &#125;,\n    buildEnd() &#123;\n      console.log(&quot;😁 -- buildEnd&quot;);\n    &#125;,\n  &#125;;\n&#125;\n\n调用虚拟模块插件示例const virtualModuleId &#x3D; &quot;virtual-module&quot;;\n&#x2F;&#x2F; rollup约定插件使用“虚拟模块”，使用\\0前缀模块 ID。这可以防止其他插件尝试处理它。\nconst resolvedVirtualModuleId &#x3D; &quot;\\0&quot; + virtualModuleId;\nexport default function virtualModule() &#123;\n  return &#123;\n    name: &quot;virtual-module&quot;,\n    resolveId(source) &#123;\n      if (source &#x3D;&#x3D;&#x3D; &quot;virtual-module&quot;) &#123;\n        return resolvedVirtualModuleId; &#x2F;&#x2F; 告诉Rollup，这个ID是外部模块，不要在此处查找它\n      &#125;\n      return null; &#x2F;&#x2F; 其他ID应按通常方式处理\n    &#125;,\n    load(id) &#123;\n      console.log(&quot;🌈 - id:&quot;, id);\n      if (id &#x3D;&#x3D;&#x3D; resolvedVirtualModuleId) &#123;\n        &#x2F;&#x2F; return &#39;export default &quot;This is virtual!&quot;&#39;; &#x2F;&#x2F; 告诉Rollup，如何加载此模块\n        return &quot;export default function fib(n) &#123; return n &lt;&#x3D; 1 ? n : fib(n - 1) + fib(n - 2); &#125;&quot;;\n      &#125;\n      return null; &#x2F;&#x2F; 其他ID应按通常方式处理\n    &#125;,\n  &#125;;\n&#125;\n\n界面调用\nimport fib from &quot;virtual-module&quot;;\nconsole.log(fib(10));\n\nJSON 插件示例rollup 默认是不能直接读取 json 文件的内容的，我们自己写一个插件处理一下，不过写这个插件之前，有一些小知识点需要补充一下\n@rollup&#x2F;pluginutils rollup 官方提供的工具插件,里面有一些制作插件常用的方法\n安装\nsql 代码解读复制代码pnpm add @rollup&#x2F;plugin-commonjs @rollup&#x2F;plugin-node-resolve @rollup&#x2F;pluginutils -D\n\n插件上下文\n这个其实也是插件中很常用的一些 api，可以通过 this 从大多数钩子中访问一些实用函数和信息位\nrollup-plugin-json\nimport &#123; createFilter, dataToEsm &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\nimport path from &quot;path&quot;;\n\nexport default function myJson(options &#x3D; &#123;&#125;) &#123;\n  &#x2F;&#x2F; createFilter 返回一个函数，这个函数接收一个id路径参数，返回一个布尔值\n  &#x2F;&#x2F; 这个布尔值表示是否要处理这个id路径\n  &#x2F;&#x2F; rollup 推荐每一个 transform 类型的插件都需要提供 include 和 exclude 选项，生成过滤规则\n  const filter &#x3D; createFilter(options.include, options.exclude);\n  return &#123;\n    name: &quot;rollup-plugin-json&quot;,\n    transform: &#123;\n      order: &quot;pre&quot;,\n      handler(code, id) &#123;\n        if (!filter(id) || path.extname(id) !&#x3D;&#x3D; &quot;.json&quot;) return null;\n        try &#123;\n          const parse &#x3D; JSON.stringify(JSON.parse(code));\n          return &#123;\n            &#x2F;&#x2F; dataToEsm 将数据转换成esm模块\n            &#x2F;&#x2F; 其实就是 export default &quot;xxx&quot;\n            code: dataToEsm(parse),\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125; catch (err) &#123;\n          const message &#x3D; &quot;Could not parse JSON file&quot;;\n          this.error(&#123; message, id, cause: err &#125;);\n          return null;\n        &#125;\n      &#125;,\n    &#125;,\n  &#125;;\n&#125;\n\n界面调用\nimport pkg from &quot;..&#x2F;package.json&quot;;\nimport test from &quot;..&#x2F;test.json&quot;; &#x2F;&#x2F; 错误json格式演示\nconsole.log(pkg.name);\n\n插件上下文import &#123; createFilter &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\n\nexport default function customPlugin(options) &#123;\n  const filter &#x3D; createFilter(options.include, options.exclude);\n\n  return &#123;\n    name: &quot;custom-plugin&quot;,\n\n    transform(code, id) &#123;\n      if (!filter(id)) &#123;\n        return null;\n      &#125;\n\n      const parsedCode &#x3D; this.parse(code); &#x2F;&#x2F; 解析代码,获取AST\n\n      const source &#x3D; &#96;$&#123;code&#125;\\n\\n$&#123;JSON.stringify(parsedCode, null, 2)&#125;&#96;;\n\n      const fileName &#x3D; id.split(&quot;&#x2F;&quot;).pop();\n\n      if (options.emitFile) &#123;\n        this.emitFile(&#123;\n          type: &quot;asset&quot;,\n          fileName: fileName + &quot;.txt&quot;,\n          source,\n        &#125;);\n      &#125;\n    &#125;,\n  &#125;;\n&#125;\n\n图片读取import &#123; createFilter, dataToEsm &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\nimport &#123; extname, resolve, basename, relative, normalize, sep &#125; from &quot;path&quot;;\nimport fs from &quot;fs&quot;;\nimport svgToMiniDataURI from &quot;mini-svg-data-uri&quot;;\n\nconst defaults &#x3D; &#123;\n  fileSize: 1024 * 4,\n  target: &quot;.&#x2F;dist&quot;,\n  include: null,\n  exclude: null,\n&#125;;\n\nconst mimeTypes &#x3D; &#123;\n  &quot;.png&quot;: &quot;image&#x2F;png&quot;,\n  &quot;.jpg&quot;: &quot;image&#x2F;jpeg&quot;,\n  &quot;.jpeg&quot;: &quot;image&#x2F;jpeg&quot;,\n  &quot;.gif&quot;: &quot;image&#x2F;gif&quot;,\n  &quot;.svg&quot;: &quot;image&#x2F;svg+xml&quot;,\n  &quot;.ico&quot;: &quot;image&#x2F;x-icon&quot;,\n  &quot;.webp&quot;: &quot;image&#x2F;webp&quot;,\n  &quot;.avif&quot;: &quot;image&#x2F;avif&quot;,\n&#125;;\n\nconst getDataUri &#x3D; (&#123; format, isSvg, mime, source &#125;) &#x3D;&gt;\n  isSvg ? svgToMiniDataURI(source) : &#96;data:$&#123;mime&#125;;$&#123;format&#125;,$&#123;source&#125;&#96;;\n\nconst ensureDirExists &#x3D; async (dirPath) &#x3D;&gt; &#123;\n  try &#123;\n    await fs.promises.access(dirPath);\n    return true;\n  &#125; catch (err) &#123;\n    &#x2F;&#x2F; 文件夹不存在就创建文件夹\n    try &#123;\n      await fs.promises.mkdir(dirPath, &#123; recursive: true &#125;);\n      return true;\n    &#125; catch (err) &#123;\n      console.error(err);\n      return false;\n    &#125;\n  &#125;\n&#125;;\n\nexport default function myImage(opts &#x3D; &#123;&#125;) &#123;\n  const options &#x3D; Object.assign(&#123;&#125;, defaults, opts);\n  const filter &#x3D; createFilter(options.include, options.exclude);\n  return &#123;\n    name: &quot;my-image&quot;,\n    async transform(code, id) &#123;\n      if (!filter(id)) return null;\n\n      &#x2F;&#x2F; 获取后缀\n      const ext &#x3D; extname(id);\n      &#x2F;&#x2F; 判断是否是图片\n      if (!mimeTypes.hasOwnProperty(ext)) &#123;\n        return null;\n      &#125;\n\n      &#x2F;&#x2F; 获取图片的mime类型\n      const mime &#x3D; mimeTypes[ext];\n      &#x2F;&#x2F; 判断是否svg\n      const isSvg &#x3D; mime &#x3D;&#x3D;&#x3D; mimeTypes[&quot;.svg&quot;];\n      &#x2F;&#x2F; 图片format格式\n      const format &#x3D; isSvg ? &quot;utf-8&quot; : &quot;base64&quot;;\n\n      &#x2F;&#x2F; 目标路径\n      const assetsPath &#x3D; resolve(process.cwd(), options.target);\n      console.log(&quot;---&quot;, process.cwd());\n      console.log(&quot;---&quot;, options.target);\n      console.log(&quot;---&quot;, assetsPath);\n\n      &#x2F;&#x2F;获取文件名\n      const fileName &#x3D; basename(id);\n      &#x2F;&#x2F; 最终文件路径\n      const filePath &#x3D; resolve(assetsPath, fileName);\n      console.log(&quot;&#x3D;&#x3D;&#x3D;&quot;, filePath);\n\n      let relativePath &#x3D; normalize(relative(process.cwd(), filePath));\n      relativePath &#x3D; relativePath.substring(relativePath.indexOf(sep) + 1);\n\n      console.log(relativePath);\n\n      try &#123;\n        &#x2F;&#x2F; 如果图片文件过大，就应该直接拷贝文件，返回文件路径\n        &#x2F;&#x2F; 读取图片文件大小与设置的大小进行比较\n        const stat &#x3D; await fs.promises.stat(id);\n        if (stat.size &gt; options.fileSize) &#123;\n          &#x2F;&#x2F; 文件的拷贝，以及对象的返回\n          &#x2F;&#x2F; 文件拷贝，无非就是文件源路径，目标路径\n          &#x2F;&#x2F;copyFile 拷贝文件地址的文件夹必须存在\n          &#x2F;&#x2F; 如果文件夹不存在，那么就创建文件夹\n          const dirExists &#x3D; await ensureDirExists(assetsPath);\n          dirExists &amp;&amp; (await fs.promises.copyFile(id, filePath));\n          return &#123;\n            code: dataToEsm(relativePath), &#x2F;&#x2F;返回拷贝之后处理的路径\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125; else &#123;\n          &#x2F;&#x2F; 否则转换为base64格式\n          &#x2F;&#x2F; 读取文件\n          const source &#x3D; await fs.promises.readFile(id, format);\n\n          return &#123;\n            code: dataToEsm(getDataUri(&#123; format, isSvg, mime, source &#125;)),\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125;\n      &#125; catch (err) &#123;\n        const message &#x3D; &quot;图片转换失败:&quot; + id;\n        this.error(&#123; message, id, cause: err &#125;);\n        return null;\n      &#125;\n    &#125;,\n  &#125;;\n&#125;\n\n输出钩子执行顺序\n\n执行所有插件的 outputOptions 钩子函数，对 output 配置进行转换\n执行 renderStart，该钩子读取所有 outputOptions 钩子的转换之后的输出选项\n扫描 动态import 语句执行 renderDynamicImport 钩子，让开发者能自定义动态import的内容与行为\n并发执行所有插件的 banner、footer、intro、outro 钩子，这四个钩子功能简单，就是往打包产物的固定位置(比如头部和尾部)插入一些自定义的内容，比如版本号、作者、内容、项目介绍等等\n是否存在 import.meta 语句，没有就直接进入下一步，否则：对于import.meta.url调用 resolveFileUrl 来自定义 url 解析逻辑。对于import.meta调用 resolveImportMeta 来进行自定义元信息解析\n生成 chunk 调用renderChunk钩子，便于在该钩子中进行自定义操作。如果生成的 chunk 文件有 hash 值，执行 augmentChunkHash 钩子，来决定是否更改 chunk 的哈希值。\n调用 generateBundle 钩子，这个钩子的入参里面会包含所有的打包产物信息，包括 chunk (打包后的代码)、asset(最终的静态资源文件)。在这个钩子中你做自定义自己的操作，比如：可以在这里删除一些 chunk 或者 asset，最终被删除的内容将不会作为产物输出\n上节课讲解的 javascript api—rollup.rollup方法会返回一个bundle对象，bundle对象的 write 方法，会触发writeBundle钩子，传入所有的打包产物信息，包括 chunk 和 asset，与generateBundle钩子非常相似。唯一的区别是writeBundle钩子执行的时候，产物已经输出了。而 generateBundle 执行的时候产物还并没有输出。简单来说，顺序是：generateBundle---&gt;输出并保存产物到磁盘---&gt;writeBundle\n当bundle的close方法被调用时，会触发closeBundle钩子，这个 output 阶段结束\n\nexport default function myExample2() &#123;\n  return &#123;\n    name: &quot;my-example2&quot;,\n    outputOptions(options) &#123;\n      console.log(&quot;🎉 ~ options:&quot;, options);\n    &#125;,\n    renderStart(options) &#123;\n      console.log(&quot;✨ ~ renderStart:&quot;, options);\n    &#125;,\n    renderDynamicImport(options) &#123;\n      console.log(&quot;✨~ renderDynamicImport:&quot;, options);\n    &#125;,\n    banner(chunk) &#123;\n      console.log(&quot;🔥 ~ banner(chunk):&quot;, chunk);\n      return &quot;&quot;;\n    &#125;,\n    renderChunk(source) &#123;\n      console.log(&quot;🚀 ~ source:&quot;, source);\n      return null;\n    &#125;,\n    augmentChunkHash(chunk) &#123;\n      console.log(&quot;🎉 ~ augmentChunkHash:&quot;, chunk);\n    &#125;,\n    generateBundle(options, bundle) &#123;\n      console.log(&quot;🌈 ~ options:&quot;, options);\n      console.log(&quot;🌈 ~ bundle:&quot;, bundle);\n      Object.keys(bundle).forEach((key) &#x3D;&gt; &#123;\n        if (key.includes(&quot;sum&quot;)) &#123;\n          &#x2F;&#x2F;删除对象中的这个键值对\n          delete bundle[key];\n        &#125;\n      &#125;);\n    &#125;,\n    closeBundle() &#123;\n      console.log(&quot;😁 ~ closeBundle&quot;);\n    &#125;,\n  &#125;;\n&#125;\n\n打包大小和时间示例：export default function bundleStats() &#123;\n let startTime;\n return &#123;\n  name: &#39;bundle-stats&#39;,\n  options() &#123;\n   startTime &#x3D; Date.now();\n   &#125;,\n  generateBundle(_, bundle) &#123;\n   const fileSizes &#x3D; &#123;&#125;;\n​\n   for (const [fileName, output] of Object.entries(bundle)) &#123;\n    if (output.type &#x3D;&#x3D;&#x3D; &#39;chunk&#39;) &#123;\n     const content &#x3D; output.code;\n     const size &#x3D; Buffer.byteLength(content, &#39;utf8&#39;);\n     const sizeInKB &#x3D; (size &#x2F; 1024).toFixed(2);\n​\n     fileSizes[fileName] &#x3D; &#96;$&#123;sizeInKB&#125; KB&#96;;\n     &#125;\n    &#125;\n   console.log(&#39;Bundle Stats:&#39;);\n   console.log(&#39;-------------&#39;);\n   console.log(&#39;File Sizes:&#39;);\n   console.log(fileSizes);\n   console.log(&#39;-------------&#39;);\n   &#125;,\n  closeBundle() &#123;\n   const totalTime &#x3D; Date.now() - startTime;\n   console.log(&#96;Total Bundle Time: $&#123;totalTime&#125; ms&#96;);\n   console.log(&#39;-------------&#39;);\n   &#125;\n  &#125;;\n&#125;\n\n代码压缩import &#123; minify &#125; from &#39;uglify-js&#39;;\n​\nexport default function uglifyPlugin() &#123;\n return &#123;\n  name: &#39;uglify&#39;,\n​\n  renderChunk(code) &#123;\n   const result &#x3D; minify(code);\n   if (result.error) &#123;\n    throw new Error(&#96;minify error: $&#123;result.error&#125;&#96;);\n    &#125;\n   return &#123;\n    code: result.code,\n    map: &#123; mappings: &#39;&#39; &#125;\n    &#125;;\n   &#125;,\n  &#125;;\n&#125;\n","slug":"rollup","date":"2024-12-22T08:39:14.000Z","categories_index":"Academic","tags_index":"rollup","author_index":"X-29"},{"id":"6f35d21607cc4ac40e0305fd85e2df31","title":"React-Principle","content":"React-Principle此文章旨在于剖析 React 的一些基本原理，帮助读者更好地理解 React 的工作原理。并写出属于自己的 React 代码。\n前置任务搭建目录以及配置一些工具First of all！\n├── packages| ├── react| | ├── src| | ├── index.ts| | └── package.json| ├── react-reconciler| | └── package.json| └── shared| ├── package.json| ├── ReactSymbols.ts| └── ReactTypes.ts├── scripts| └── rollup| ├── react.config.js| └── utils.js├── .gitignore├── .prettier.json├── eslint.config.js├── package-lock.json├── package.json├── README.md└── tsconfig.json\n安装依赖根目录的package.json文件在根目录的package.json文件中，我们需要安装一些依赖并配置好 scripts 命令：\n&#123;\n  &quot;name&quot;: &quot;react&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;lint&quot;: &quot;eslint .&#x2F;packages&quot;,\n    &quot;build:dev&quot;: &quot;rimraf dist &amp;&amp; rollup --bundleConfigAsCjs --config scripts&#x2F;rollup&#x2F;react.config.js&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@eslint&#x2F;js&quot;: &quot;^9.15.0&quot;,\n    &quot;@rollup&#x2F;plugin-commonjs&quot;: &quot;^28.0.1&quot;,\n    &quot;@types&#x2F;node&quot;: &quot;^22.9.3&quot;,\n    &quot;@types&#x2F;rollup-plugin-generate-package-json&quot;: &quot;^3.2.9&quot;,\n    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^8.15.0&quot;,\n    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^8.15.0&quot;,\n    &quot;eslint&quot;: &quot;^9.15.0&quot;,\n    &quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,\n    &quot;eslint-plugin-prettier&quot;: &quot;^5.2.1&quot;,\n    &quot;prettier&quot;: &quot;^3.3.3&quot;,\n    &quot;rimraf&quot;: &quot;^6.0.1&quot;,\n    &quot;rollup&quot;: &quot;^4.27.3&quot;,\n    &quot;rollup-plugin-generate-package-json&quot;: &quot;^3.2.0&quot;,\n    &quot;rollup-plugin-typescript2&quot;: &quot;^0.36.0&quot;,\n    &quot;typescript&quot;: &quot;^5.6.3&quot;\n  &#125;\n&#125;\n\ntsconfig.json在根目录下创建tsconfig.json文件，并配置好编译选项：\n&#123;\n  &quot;compileOnSave&quot;: true,\n  &quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ESNext&quot;,\n    &quot;useDefineForClassFields&quot;: true,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;],\n    &quot;moduleResolution&quot;: &quot;Node&quot;,\n    &quot;strict&quot;: true,\n    &quot;sourceMap&quot;: true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;noEmit&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noImplicitReturns&quot;: false,\n    &quot;skipLibCheck&quot;: true,\n    &quot;baseUrl&quot;: &quot;.&#x2F;packages&quot;\n  &#125;\n&#125;\n\neslint.config.jsimport eslint from &quot;@eslint&#x2F;js&quot;;\nimport tseslint from &quot;@typescript-eslint&#x2F;eslint-plugin&quot;;\nimport tsparser from &quot;@typescript-eslint&#x2F;parser&quot;;\nimport prettier from &quot;eslint-plugin-prettier&quot;;\nimport eslintConfigPrettier from &quot;eslint-config-prettier&quot;;\n\nexport default [\n  &#x2F;&#x2F; 基础 ESLint 配置\n  eslint.configs.recommended,\n\n  &#x2F;&#x2F; Prettier 配置\n  eslintConfigPrettier,\n\n  &#123;\n    files: [&quot;**&#x2F;*.ts&quot;, &quot;**&#x2F;*.tsx&quot;],\n    languageOptions: &#123;\n      parser: tsparser,\n      parserOptions: &#123;\n        ecmaVersion: &quot;latest&quot;,\n        sourceType: &quot;module&quot;,\n      &#125;,\n    &#125;,\n    plugins: &#123;\n      &quot;@typescript-eslint&quot;: tseslint,\n      prettier: prettier,\n    &#125;,\n    rules: &#123;\n      &quot;prettier&#x2F;prettier&quot;: &quot;error&quot;,\n      &quot;no-case-declarations&quot;: &quot;off&quot;,\n      &quot;no-constant-condition&quot;: &quot;off&quot;,\n      &quot;@typescript-eslint&#x2F;ban-ts-comment&quot;: &quot;off&quot;,\n      &quot;@typescript-eslint&#x2F;no-var-requires&quot;: &quot;off&quot;,\n      &quot;react&#x2F;react-in-jsx-scope&quot;: &quot;off&quot;,\n      &quot;prettier&#x2F;prettier&quot;: [\n        &quot;error&quot;,\n        &#123;\n          endOfLine: &quot;auto&quot;,\n        &#125;,\n      ],\n    &#125;,\n  &#125;,\n];\n\n.prettier.json&#123;\n  &quot;printWidth&quot;: 80,\n  &quot;tabWidth&quot;: 2,\n  &quot;useTabs&quot;: true,\n  &quot;singleQuote&quot;: true,\n  &quot;semi&quot;: true,\n  &quot;trailingComma&quot;: &quot;none&quot;,\n  &quot;bracketSpacing&quot;: true\n&#125;\n\n打包脚本rollup.config.js在scripts目录下创建rollup.config.js文件，并配置打包选项：::: warning注意：rollup.config.js文件需要使用commonjs模块规范，因为rollup默认使用esm模块规范，而node环境不支持esm模块规范。并且一定要是js文件，不能是ts文件。:::\nimport &#123; getBaseRollupPlugins, getPackageJSON, resolvePkgPath &#125; from &quot;.&#x2F;utils&quot;;\n\nimport generatePackageJson from &quot;rollup-plugin-generate-package-json&quot;;\n\n&#x2F;&#x2F; 获取package.json下面的name字段\nconst &#123; name, module &#125; &#x3D; getPackageJSON(&quot;react&quot;, false); &#x2F;&#x2F; react\n&#x2F;&#x2F; react包的路径\nconst pkgPath &#x3D; resolvePkgPath(name, false);\n&#x2F;&#x2F;react 产物路劲\nconst pkgDistPath &#x3D; resolvePkgPath(name, true);\nexport default [\n  &#x2F;&#x2F; 对应react包\n  &#123;\n    input: &#96;$&#123;pkgPath&#125;&#x2F;$&#123;module&#125;&#96;,\n    output: &#123;\n      file: &#96;$&#123;pkgDistPath&#125;&#x2F;index.js&#96;,\n      name: &quot;react&quot;,\n      format: &quot;umd&quot;,\n    &#125;,\n    plugins: [\n      ...getBaseRollupPlugins(),\n      generatePackageJson(&#123;\n        inputFolder: pkgPath,\n        outputFolder: pkgDistPath,\n        baseContents: (&#123; name, description, version &#125;) &#x3D;&gt; (&#123;\n          name,\n          description,\n          version,\n          main: &quot;index.js&quot;,\n        &#125;),\n      &#125;),\n    ],\n  &#125;,\n  &#x2F;&#x2F; jsx-runtime包\n  &#123;\n    input: &#96;$&#123;pkgPath&#125;&#x2F;src&#x2F;jsx.ts&#96;,\n    output: [\n      &#x2F;&#x2F; jsx-runtime\n      &#123;\n        file: &#96;$&#123;pkgDistPath&#125;&#x2F;jsx-runtime.js&#96;,\n        name: &quot;jsx-runtime.js&quot;,\n        format: &quot;umd&quot;,\n      &#125;,\n      &#123;\n        file: &#96;$&#123;pkgDistPath&#125;&#x2F;jsx-dev-runtime.js&#96;,\n        name: &quot;jsx-dev-runtime.js&quot;,\n        format: &quot;umd&quot;,\n      &#125;,\n    ],\n    plugins: getBaseRollupPlugins(),\n  &#125;,\n];\n\nutils.js在scripts目录下创建utils.js文件，并配置一些工具函数：\nimport path from &quot;path&quot;;\nimport fs from &quot;fs&quot;;\nimport ts from &quot;rollup-plugin-typescript2&quot;;\nimport cjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\n\n&#x2F;&#x2F; 包路径\nconst pkgPath &#x3D; path.resolve(__dirname, &quot;..&#x2F;..&#x2F;packages&quot;);\n&#x2F;&#x2F; 打包产物路径\nconst distPath &#x3D; path.resolve(__dirname, &quot;..&#x2F;..&#x2F;dist&#x2F;node_modules&quot;);\n\n&#x2F;**\n * @name 获取包路径或者是打包产物路径\n * @param pkgName\n * @param isDist 是否是打包\n *&#x2F;\nexport const resolvePkgPath &#x3D; (pkgName, isDist) &#x3D;&gt; &#123;\n  return isDist ? &#96;$&#123;distPath&#125;&#x2F;$&#123;pkgName&#125;&#96; : &#96;$&#123;pkgPath&#125;&#x2F;$&#123;pkgName&#125;&#96;;\n&#125;;\n\n&#x2F;**\n * @name 解析包对应的package.json文件\n * @param pkgName\n *&#x2F;\nexport const getPackageJSON &#x3D; (pkgName, isDist) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;1. 包路径 + Package.json\n  const path &#x3D; &#96;$&#123;resolvePkgPath(pkgName, isDist)&#125;&#x2F;package.json&#96;;\n  const str &#x3D; fs.readFileSync(path, &#123; encoding: &quot;utf-8&quot; &#125;);\n  return JSON.parse(str);\n&#125;;\n\nexport const getBaseRollupPlugins &#x3D; (&#123; typeScriptConfig &#x3D; &#123;&#125; &#125; &#x3D; &#123;&#125;) &#x3D;&gt; [\n  cjs(),\n  ts(typeScriptConfig),\n];\n\npackage&#x2F;react该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;react&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;module&quot;: &quot;index.ts&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;shared&quot;: &quot;workspace:*&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;react公共方法&quot;\n&#125;\n\n其中 package&#x2F;index.ts 和 package&#x2F;src&#x2F;jsx.ts 文件先随便写点什么 ts 代码，为了npm run build:dev命令可以正常运行。package&#x2F;src&#x2F;jsx.ts 的目录和文件名在 rollup.config.js 中配置一一对应的\npackage&#x2F;shared该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;shared&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;所有公共方法以及类型定义&quot;\n&#125;\n\npackage&#x2F;react-reconciler该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;react-reconciler&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;&quot;\n&#125;\n\n至此，我们已经完成了项目的目录结构以及一些依赖的安装。在根目录下，我们可以运行npm run build:dev命令进行项目的打包。npm run lint命令可以对项目的代码进行 eslint 检查。\njsx基本介绍React 主要是将页面的结构通过 jsx 进行描述，在调和后，每一个 React element 对象的子节点都会形成一个对应的 fiberNode\n本节内容主要是实现 jsx 的生成。在 React 的源码中，jsx 的代码逻辑存在 packages 下面的 react 包中。为了兼容 React 的旧版本，我们主要是实现最后导出三个文件。\nindex.js: import React from &#39;react&#39; 这样使用jsx-runtime.js: 新版通过 babel 导入jsx-dev-runtime.js: 开发环境的包\n为了开发者方便，React 提供一种类似于 html 的方式去书写代码，然后 React 通过 babel 去进行转义。在 React 的新版本中，我们不再需要手动去引入 React, plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。\n&lt;div className&#x3D;&quot;x&quot;&gt;\n  123\n  &lt;span&gt;yx&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n\n新版Automaticimport &#123; jsx as _jsx &#125; from &quot;react&#x2F;jsx-runtime&quot;;\nimport &#123; jsxs as _jsxs &#125; from &quot;react&#x2F;jsx-runtime&quot;;\n&#x2F;*#__PURE__*&#x2F; _jsxs(&quot;div&quot;, &#123;\n  className: &quot;x&quot;,\n  children: [\n    &quot;123&quot;,\n    &#x2F;*#__PURE__*&#x2F; _jsx(&quot;span&quot;, &#123;\n      children: &quot;yx&quot;,\n    &#125;),\n  ],\n&#125;);\n\n旧版Classic&#x2F;*#__PURE__*&#x2F; React.createElement(\n  &quot;div&quot;,\n  &#123;\n    className: &quot;x&quot;,\n  &#125;,\n  &quot;123&quot;,\n  &#x2F;*#__PURE__*&#x2F; React.createElement(&quot;span&quot;, null, &quot;yx&quot;)\n);\n\n\n\n\n\n\n\n\n\n\n主要是分为三部分：1. 对应的 tag 字段， 2. 属性和 children， 3. key 等一些特殊字段。\n实现 JSX声明类型在 packages/shared/ReactTypes.ts 文件中，我们声明了 JSX 相关的类型。\n&#x2F;** 在这里集中定义React的类型 *&#x2F;\n\n&#x2F;** 定义 React 的 Type 类型 *&#x2F;\nexport type Type &#x3D; any;\n\n&#x2F;** 定义 React 的 Key 类型 *&#x2F;\nexport type Key &#x3D; string | null;\n\n&#x2F;** 定义 React 的 Ref 类型 *&#x2F;\nexport type Ref&lt;T &#x3D; any&gt; &#x3D;\n  | &#123; current: T | null &#125;\n  | ((instance: T | null) &#x3D;&gt; void)\n  | null;\n\n&#x2F;** 定义 React 的 Props 类型 *&#x2F;\nexport type Props &#x3D; &#123;\n  [key: string]: any;\n  children?: any;\n&#125;;\n\n&#x2F;** 定义 React 的 ElementType 类型 *&#x2F;\nexport type ElementType &#x3D; string | ((props: any) &#x3D;&gt; ReactElementType | null);\n\n&#x2F;** 定义 React 的 ReactElement 类型 *&#x2F;\nexport interface ReactElementType &#123;\n  $$typeof: symbol | number;\n  type: ElementType;\n  key: Key;\n  ref: Ref;\n  props: Props;\n  __mark: string;\n&#125;\n\n在 packages/shared/ReactSymbols.ts 文件中，我们声明了 JSX 相关的 symbol。\n&#x2F;**\n * 判断当前环境是否支持 Symbol 及其 for 方法\n * 1. typeof Symbol &#x3D;&#x3D;&#x3D; &#39;function&#39; 检查 Symbol 是否可用且是函数类型\n * 2. Symbol.for 检查是否支持全局 Symbol 注册表功能\n * 3. 在较老的浏览器中可能不支持 Symbol，此时返回 false\n *&#x2F;\nconst supportSymbol &#x3D; typeof Symbol &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; Symbol.for;\n\n&#x2F;**\n * 1. Symbol.for() 是什么：\n *   - 这是 JavaScript 的全局 Symbol 注册表功能\n *   - Symbol.for(&#39;react.element&#39;) 会创建一个全局唯一的 Symbol\n *   - 如果已经存在同名的 Symbol，则返回已存在的那个\n *   - 这确保了在不同的模块中使用相同的字符串创建的 Symbol 是完全相同的\n * 2.为什么需要降级方案 0xeac7：\n *   - 不是所有 JavaScript 环境都支持 Symbol（比如老版本浏览器）\n *   - 0xeac7 是一个十六进制数字，作为降级后的标识符\n *   - 这个数字是 React 团队选择的一个特定值，用来标识 React 元素\n * 3. 这个值的用途：\n *   - 用来标识一个对象是否是合法的 React 元素\n *   - 在 ReactElement 接口中，我们看到有 $$typeof 属性\n *   - $$typeof 就会被赋值为 REACT_ELEMENT_TYPE\n *   - React 内部会检查这个值来确保元素的合法性 *&#x2F;\nexport const REACT_ELEMENT_TYPE &#x3D; supportSymbol\n  ? Symbol.for(&quot;react.element&quot;)\n  : 0xeac7;\n\n实现 JSX在 packages/react/src/jsx.ts 文件中，我们实现 JSX 的逻辑。\nimport &#123; REACT_ELEMENT_TYPE &#125; from &quot;shared&#x2F;ReactSymbols&quot;;\nimport &#123;\n  ElementType,\n  Key,\n  Props,\n  ReactElementType,\n  Ref,\n  Type,\n&#125; from &quot;shared&#x2F;ReactTypes&quot;;\n\n&#x2F;**\n * 创建 React 元素的核心函数\n * @param type 元素类型 - 可以是字符串(原生 DOM 元素)或函数(组件)\n * @param key 用于标识元素的唯一键值，帮助 React 进行高效的 DOM diff\n * @param ref 引用对象，用于访问 DOM 节点或组件实例\n * @param props 元素的属性对象，包含所有传入的属性和子元素\n * @returns 返回一个 React 元素对象\n *&#x2F;\nconst ReactElement &#x3D; (\n  type: Type,\n  key: Key,\n  ref: Ref,\n  props: Props\n): ReactElementType &#x3D;&gt; (&#123;\n  &#x2F;&#x2F; 标识这是一个 React 元素的内部类型标记\n  $$typeof: REACT_ELEMENT_TYPE,\n  &#x2F;&#x2F; 元素类型（div, p, 或自定义组件等）\n  type,\n  &#x2F;&#x2F; 用于优化更新的 key 值\n  key,\n  &#x2F;&#x2F; DOM 或组件实例的引用\n  ref,\n  &#x2F;&#x2F; 元素的所有属性\n  props,\n  &#x2F;&#x2F; 自定义标记，用于标识这是我们的 React 实现\n  __mark: &quot;x-react&quot;,\n&#125;);\n\n&#x2F;**\n * 从配置对象中提取并处理 key、ref 和其他 props\n * @param &#123;Config&#125; Jsx.JsxConfig - React 元素的配置对象\n * @returns &#123;[Key, Ref, Props]&#125; 返回一个元组，包含处理后的 key、ref 和 props\n *\n * @description\n * 1. 通过解构获取 key 和 ref，设置默认值为 null\n * 2. 将 key 转换为字符串（如果存在）\n * 3. 使用 reduce 处理剩余的 props，确保只包含对象自身的属性\n * 4. 返回处理后的 [key, ref, props] 元组\n *&#x2F;\nconst extractPropsFromConfig &#x3D; (config: Jsx.JsxConfig): [Key, Ref, Props] &#x3D;&gt; &#123;\n  const &#123; key &#x3D; null, ref &#x3D; null, ...props &#125; &#x3D; config;\n  return [\n    key !&#x3D; null ? String(key) : null,\n    ref,\n    Object.keys(props).reduce((acc, prop) &#x3D;&gt; &#123;\n      if (&#123;&#125;.hasOwnProperty.call(config, prop)) &#123;\n        acc[prop] &#x3D; props[prop];\n      &#125;\n      return acc;\n    &#125;, &#123;&#125; as Props),\n  ];\n&#125;;\n\n&#x2F;**\n * 处理并合并 children 到 props 中\n * @param &#123;Props&#125; props - 原始的 props 对象\n * @param &#123;any[]&#125; children - 子元素数组\n * @returns &#123;Props&#125; 返回合并了 children 的新 props 对象\n *\n * @description\n * 1. 如果没有 children，直接返回原始 props\n * 2. 如果只有一个 child，直接使用该 child\n * 3. 如果有多个 children，保持数组形式\n * 4. 使用展开运算符创建新的 props 对象，确保不修改原始对象\n *&#x2F;\nconst processChildren &#x3D; (props: Props, children: any[]): Props &#x3D;&gt; &#123;\n  if (children.length &#x3D;&#x3D;&#x3D; 0) return props;\n\n  return &#123;\n    ...props,\n    children: children.length &#x3D;&#x3D;&#x3D; 1 ? children[0] : children,\n  &#125;;\n&#125;;\n\n&#x2F;**\n * JSX 转换函数 - 将 JSX 语法转换为 React 元素\n * @param &#123;ElementType&#125; type - 元素类型（可以是字符串或组件函数）\n * @param &#123;Config&#125; Jsx.JsxConfig - 元素的配置对象，包含 props、key、ref 等\n * @param &#123;...any&#125; children - 子元素列表\n * @returns &#123;ReactElementType&#125; 返回创建的 React 元素\n *\n * @description\n * 1. 首先从配置中提取必要的属性\n * 2. 处理并添加 children\n * 3. 使用这些处理后的值创建 React 元素\n *\n * @description\n * * 完整的处理流程：\n * 1. jsx(&#39;div&#39;, &#123; className: &#39;container&#39; &#125;, child1, child2) 被调用\n * 2. extractPropsFromConfig 处理配置对象：\n *    - 提取 key 和 ref（如果有）\n *    - 处理其余属性（如 className, onClick 等）\n * 3. processChildren 处理子元素：\n *    - 将所有子元素规范化处理\n *    - 添加到 props.children 中\n * 4. ReactElement 创建最终的 React 元素对象\n * 5. 返回的元素对象将被 React 用于后续的渲染流程\n *&#x2F;\nexport const jsx &#x3D; (\n  type: ElementType,\n  config: Jsx.JsxConfig,\n  ...children: any\n) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 第一步：提取和处理配置\n  const [key, ref, props] &#x3D; extractPropsFromConfig(config);\n  &#x2F;&#x2F; 第二步：处理子元素\n  const propsWithChildren &#x3D; processChildren(props, children);\n\n  &#x2F;&#x2F; 第三步：创建 React 元素\n  return ReactElement(type, key, ref, propsWithChildren);\n\n  &#x2F;* 返回的对象形如：\n   &#123;\n     $$typeof: Symbol(react.element),\n     type: &#39;div&#39;,\n     props: &#123;\n       className: &#39;container&#39;,\n       children: &#123;\n         $$typeof: Symbol(react.element),\n         type: &#39;span&#39;,\n         props: &#123; children: &#39;Hello&#39; &#125;\n       &#125;\n     &#125;\n   &#125; *&#x2F;\n&#125;;\n\n&#x2F;**\n * 开发环境使用的 JSX 转换函数\n * @param &#123;ElementType&#125; type - 元素类型\n * @param &#123;Config&#125; Jsx.JsxConfig - 元素配置对象\n * @returns &#123;ReactElementType&#125; 返回创建的 React 元素\n *\n * @description\n * 1. 开发环境版本，不处理 children\n * 2. 用于开发工具和调试\n * 3. 保持与生产版本相同的基本结构，但可能包含额外的开发时检查\n *\n * @description 开发环境的 JSX 转换函数\n * 与生产版本的主要区别：\n * 1. 可以进行额外的类型检查\n * 2. 可以提供更好的错误信息\n * 3. 可以进行开发时的警告提示\n * 4. 可以添加开发工具所需的调试信息\n *&#x2F;\nexport const jsxDev &#x3D; (type: ElementType, config: Jsx.JsxConfig) &#x3D;&gt; &#123;\n  const [key, ref, props] &#x3D; extractPropsFromConfig(config);\n  return ReactElement(type, key, ref, props);\n&#125;;\n\n整体 jsx 函数的调用流程\n\nJSX 代码：\n\nfunction App() &#123;\n  return (\n    &lt;div className&#x3D;&quot;container&quot;&gt;\n      &lt;span&gt;Hello&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n\nBabel 转义后的代码：\n\nfunction App() &#123;\n  return jsx(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;, jsx(&quot;span&quot;, null, &quot;Hello&quot;));\n&#125;\n\njsx 函数的作用就是接收 Babel 转换后的参数，并创建出 React 元素（虚拟 DOM 节点）\n\n最终生成的 React 元素结构：\n\n&#123;\n$$typeof: Symbol(react.element),\ntype: &#39;div&#39;,\nkey: null,\nref: null,\nprops: &#123;\n    className: &#39;container&#39;,\n    children: [\n      &#123;\n        $$typeof: Symbol(react.element),\n        type: &#39;span&#39;,\n        props: &#123; children: &#39;Hello&#39; &#125;,\n        &#x2F;&#x2F; ...\n      &#125;\n    ]\n&#125;\n&#125;\n\n\n所以整个流程是：\n\n\n开发者写 JSX 代码\nBabel 在编译时将 JSX 语法转换为 jsx() 函数调用\n运行时，jsx() 函数被调用，创建 React 元素\nReact 使用这些元素来渲染实际的 DOM 5.简单来说：Babel 的工作是：转换语法（ → jsx(‘div’)）,jsx 函数的工作是：创建虚拟 DOM 节点（jsx(‘div’) → { type: ‘div’, props: {…} }）,这就是为什么在 React 17 之后的版本中，我们不需要手动引入 React（import React from ‘react’），因为 Babel 会自动帮我们引入 jsx 函数。\n\n\n那么为什么还存在 jsxDev 函数呢？\n\njsxDev 函数的作用是为了开发环境的 JSX 转换，它的作用和 jsx 函数一样，只是它不处理 children 子元素，所以它的返回值和生产环境的 jsx 函数返回值是一样的。\n区别的具体体现：\n\nBabel 的转换会根据环境不同选择不同的函数：\n\n&#x2F;&#x2F; 开发环境下，Babel 会转换成：\njsxDev(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;);\n\n&#x2F;&#x2F; 生产环境下，Babel 会转换成：\njsx(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;);\n\n\n实际应用场景：\n\nfunction App() &#123;\n  &#x2F;&#x2F; 开发环境下，如果你这样写：\n  return &lt;div&gt;&#123;undefined.toString()&#125;&lt;&#x2F;div&gt;;\n\n  &#x2F;&#x2F; jsxDev 可以提供更友好的错误信息：\n  &#x2F;&#x2F; &quot;Cannot read property &#39;toString&#39; of undefined at App&quot;\n  &#x2F;&#x2F; 并显示具体的组件栈信息\n\n  &#x2F;&#x2F; 而在生产环境下，jsx 函数会简单地抛出错误，\n  &#x2F;&#x2F; 没有这些额外的调试信息\n&#125;\n\n\n性能考虑：\n\n&#x2F;&#x2F; 开发环境：更多的检查，更多的警告\njsxDev(&quot;div&quot;, &#123;\n  &#x2F;&#x2F; 可以检查 props 类型\n  &#x2F;&#x2F; 可以检查废弃的 API 使用\n  &#x2F;&#x2F; 可以添加更多的调试信息\n&#125;);\n\n&#x2F;&#x2F; 生产环境：更简洁的代码，更好的性能\njsx(&quot;div&quot;, &#123;\n  &#x2F;&#x2F; 只进行必要的转换\n  &#x2F;&#x2F; 没有额外的检查和警告\n  &#x2F;&#x2F; 代码体积更小，运行更快\n&#125;);\n\nSummary：\n\n开发体验：提供更好的错误信息和警告\n调试能力：支持 React DevTools 等开发工具\n性能优化：生产环境可以移除开发时的检查代码\n包体积：生产环境的代码更精简\n\n这就是为什么 React 需要维护两个版本的 JSX 转换函数，它们服务于不同的目的：jsx: 注重性能和包体积jsxDev: 注重开发体验和调试能力\nReact reconcilerReact reconciler 主要是实现了 React 的核心算法，包括调和、渲染、更新等。\n更改 packages&#x2F;react-reconciler&#x2F;package.json 文件&#123;\n  &quot;name&quot;: &quot;react-reconciler&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;react-reconciler&quot;,\n  &quot;module&quot;: &quot;index.ts&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;shared&quot;: &quot;workspace: *&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n在 packages&#x2F;react&#x2F;src&#x2F;currentBatchConfig.ts 文件中，我们声明了 currentBatchConfig 类型。\n\n\n\n\n\n\n\n\ncurrentBatchConfig.ts - React 批处理配置文件\n作用：\n\n存储当前 React 批量更新的配置信息\n主要用于 Transition 相关的功能\n在并发渲染中控制更新的优先级\n\n&#x2F;**\n * React 当前批处理配置对象\n *\n * 用途：\n * 1. 在组件更新时标记更新的类型\n * 2. 帮助 React 区分普通更新和 Transition 更新\n * 3. 影响更新的优先级和调度方式\n *\n * @type &#123;React.BatchConfig&#125;\n *\n * @example\n * &#x2F;&#x2F; React 内部使用示例\n * function scheduleUpdate(fiber, update) &#123;\n *   const transition &#x3D; ReactCurrentBatchConfig.transition;\n *   if (transition !&#x3D;&#x3D; null) &#123;\n *     &#x2F;&#x2F; 这是一个 Transition 更新，使用较低的优先级\n *     scheduleTransitionUpdate(fiber, update);\n *   &#125; else &#123;\n *     &#x2F;&#x2F; 这是一个普通更新，使用正常优先级\n *     scheduleRegularUpdate(fiber, update);\n *   &#125;\n * &#125;\n *&#x2F;\nconst ReactCurrentBatchConfig: React.BatchConfig &#x3D; &#123;\n  transition: null,\n&#125;;\n\nexport default ReactCurrentBatchConfig;\n\n\n\n\n\n\n\n\n\n\n实际应用场景：\n\nuseTransition Hook:\n\nfunction App() &#123;\n  const [isPending, startTransition] &#x3D; useTransition();\n  return (\n    &lt;button\n      onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n        startTransition(() &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 这里的更新会被标记为 Transition\n          setLargeList(generateLargeList());\n        &#125;);\n      &#125;&#125;\n    &gt;\n      Update List\n    &lt;&#x2F;button&gt;\n  );\n&#125;\n\n\n并发特性：\n\n\n允许 React 中断渲染以处理更高优先级的更新\n帮助实现更流畅的用户体验\n支持可中断的渲染过程\n\n在 packages&#x2F;react-reconciler&#x2F;src&#x2F;fiberFlags.ts 文件中\n\n\n\n\n\n\n\n\nfiberFlags.ts - React Fiber 节点的副作用（side-effects）标记定义\n作用：\n\n定义所有可能的 Fiber 节点副作用类型\n使用二进制位标记实现高效的副作用追踪\n通过位运算组合多个副作用\n\n&#x2F;**\n\n\n&#x2F;**\n * Flags 类型定义\n * 用于在 TypeScript 中标识副作用标记的类型\n *&#x2F;\nexport type Flags &#x3D; number;\n\n&#x2F;**\n * 无副作用标记\n * 表示节点不需要进行任何操作\n * 二进制：0000000\n *&#x2F;\nexport const NoFlags &#x3D; 0b0000000;\n\n&#x2F;**\n * 插入&#x2F;移动标记\n * 表示节点需要插入到 DOM 中或在 DOM 中移动位置\n * 二进制：0000001\n *&#x2F;\nexport const Placement &#x3D; 0b0000001;\n\n&#x2F;**\n * 更新标记\n * 表示节点的属性或内容需要更新\n * 二进制：0000010\n *&#x2F;\nexport const Update &#x3D; 0b0000010;\n\n&#x2F;**\n * 子节点删除标记\n * 表示需要删除子节点\n * 二进制：0000100\n *&#x2F;\nexport const ChildDeletion &#x3D; 0b0000100;\n\n&#x2F;**\n * 被动效果标记（如 useEffect）\n * 表示节点包含需要在提交阶段后异步执行的副作用\n * 二进制：0001000\n *&#x2F;\nexport const PassiveEffect &#x3D; 0b0001000;\n\n&#x2F;**\n * Ref 更新标记\n * 表示节点的 ref 需要更新\n * 二进制：0010000\n *&#x2F;\nexport const Ref &#x3D; 0b0010000;\n\n&#x2F;**\n * 可见性变更标记\n * 表示节点的显示&#x2F;隐藏状态需要更新\n * 二进制：0100000\n *&#x2F;\nexport const Visibility &#x3D; 0b0100000;\n\n&#x2F;**\n * 已捕获标记\n * 表示错误已经被捕获\n * 二进制：1000000\n *&#x2F;\nexport const DidCapture &#x3D; 0b1000000;\n\n&#x2F;**\n * 应该捕获标记\n * 表示这个节点应该尝试捕获错误\n * 二进制：01000000000\n *&#x2F;\nexport const ShouldCapture &#x3D; 0b01000000000;\n\n&#x2F;**\n * 突变阶段的标记集合\n * 包含了在 DOM 突变阶段需要处理的所有副作用\n * 通过位运算组合多个标记\n *\n * @example\n * if (fiber.flags &amp; MutationMask) &#123;\n *   &#x2F;&#x2F; 需要在突变阶段处理这个节点\n * &#125;\n *&#x2F;\nexport const MutationMask &#x3D;\n  Placement | Update | ChildDeletion | Ref | Visibility;\n\n&#x2F;**\n * 布局阶段的标记集合\n * 包含了在 DOM 布局阶段需要处理的所有副作用\n * 目前只包含 Ref 的更新\n *&#x2F;\nexport const LayoutMask &#x3D; Ref;\n\n&#x2F;**\n * 被动效果的标记集合\n * 包含了需要异步处理的副作用\n * 主要用于 useEffect 的处理\n *&#x2F;\nexport const PassiveMask &#x3D; PassiveEffect | ChildDeletion;\n\n使用示例：\n&#x2F;&#x2F; 添加副作用标记\nfiber.flags |&#x3D; Update;\n\n&#x2F;&#x2F; 检查是否包含某个副作用\nif (fiber.flags &amp; Placement) &#123;\n  &#x2F;&#x2F; 需要插入或移动节点\n&#125;\n\n&#x2F;&#x2F; 在不同阶段检查相关副作用\nif (fiber.flags &amp; MutationMask) &#123;\n  &#x2F;&#x2F; 处理 DOM 突变相关的副作用\n&#125;\n\nif (fiber.flags &amp; PassiveMask) &#123;\n  &#x2F;&#x2F; 处理 useEffect 相关的副作用\n&#125;\n\n在 packages&#x2F;react-reconciler&#x2F;src&#x2F;workTags.ts 文件中\n\n\n\n\n\n\n\n\nworkTags.ts - React Fiber 节点类型定义文件\n作用：\n\n定义所有可能的 Fiber 节点类型\n用于在 Fiber 树中标识不同类型的节点\n帮助 React 在协调过程中正确处理不同类型的组件\n\n&#x2F;**\n * 函数组件标识\n * 用于标识函数式组件创建的 Fiber 节点\n * @example\n * function App() &#123; return &lt;div&gt;Hello&lt;&#x2F;div&gt; &#125;\n * &#x2F;&#x2F; App 组件对应的 Fiber 节点的 tag 值为 FunctionComponent (0)\n *&#x2F;\nexport const FunctionComponent: React.FunctionComponent &#x3D; 0;\n\n&#x2F;**\n * 根节点标识\n * 用于标识应用的根节点（Root）\n * @example\n * ReactDOM.render(&lt;App &#x2F;&gt;, container)\n * &#x2F;&#x2F; container 对应的 Fiber 节点的 tag 值为 HostRoot (3)\n *&#x2F;\nexport const HostRoot: React.HostRoot &#x3D; 3;\n\n&#x2F;**\n * 原生 DOM 元素标识\n * 用于标识普通 HTML 元素的 Fiber 节点\n * @example\n * &lt;div&gt;Hello&lt;&#x2F;div&gt;\n * &#x2F;&#x2F; div 对应的 Fiber 节点的 tag 值为 HostComponent (5)\n *&#x2F;\nexport const HostComponent: React.HostComponent &#x3D; 5;\n\n&#x2F;**\n * 文本节点标识\n * 用于标识文本内容的 Fiber 节点\n * @example\n * &lt;div&gt;Hello World&lt;&#x2F;div&gt;\n * &#x2F;&#x2F; &quot;Hello World&quot; 对应的 Fiber 节点的 tag 值为 HostText (6)\n *&#x2F;\nexport const HostText: React.HostText &#x3D; 6;\n\n&#x2F;**\n * Fragment 标识\n * 用于标识 React.Fragment 的 Fiber 节点\n * @example\n * &lt;React.Fragment&gt;\n *   &lt;div&gt;Item 1&lt;&#x2F;div&gt;\n *   &lt;div&gt;Item 2&lt;&#x2F;div&gt;\n * &lt;&#x2F;React.Fragment&gt;\n * &#x2F;&#x2F; Fragment 对应的 Fiber 节点的 tag 值为 Fragment (7)\n *&#x2F;\nexport const Fragment: React.Fragment &#x3D; 7;\n\n&#x2F;**\n * Context Provider 标识\n * 用于标识 Context.Provider 的 Fiber 节点\n * @example\n * &lt;MyContext.Provider value&#x3D;&#123;value&#125;&gt;\n *   &#123;children&#125;\n * &lt;&#x2F;MyContext.Provider&gt;\n * &#x2F;&#x2F; Provider 对应的 Fiber 节点的 tag 值为 ContextProvider (11)\n *&#x2F;\nexport const ContextProvider: React.ContextProvider &#x3D; 11;\n\n&#x2F;**\n * Suspense 组件标识\n * 用于标识 Suspense 组件的 Fiber 节点\n * @example\n * &lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n *   &lt;SomeComponent &#x2F;&gt;\n * &lt;&#x2F;Suspense&gt;\n * &#x2F;&#x2F; Suspense 对应的 Fiber 节点的 tag 值为 SuspenseComponent (13)\n *&#x2F;\nexport const SuspenseComponent: React.SuspenseComponent &#x3D; 13;\n\n&#x2F;**\n * Offscreen 组件标识\n * 用于标识 Offscreen 组件的 Fiber 节点\n * 通常用于实现一些性能优化相关的功能\n * @example\n * &#x2F;&#x2F; React 内部使用，用于优化渲染性能\n * &#x2F;&#x2F; 对应的 Fiber 节点的 tag 值为 OffscreenComponent (14)\n *&#x2F;\nexport const OffscreenComponent: React.OffscreenComponent &#x3D; 14;\n\n\n\n\n\n\n\n\n\n\n使用示例：\nfunction processFiber(fiber: FiberNode) &#123;\n  switch (fiber.tag) &#123;\n    case FunctionComponent:\n      &#x2F;&#x2F; 处理函数组件\n      updateFunctionComponent(fiber);\n      break;\n    case HostComponent:\n      &#x2F;&#x2F; 处理 DOM 元素\n      updateHostComponent(fiber);\n      break;\n    case HostText:\n      &#x2F;&#x2F; 处理文本节点\n      updateTextContent(fiber);\n      break;\n    &#x2F;&#x2F; ... 处理其他类型\n  &#125;\n&#125;\n\n","slug":"React-Principle","date":"2024-11-23T16:50:47.000Z","categories_index":"React","tags_index":"React","author_index":"X-29"},{"id":"78c733f14091289904e8c5ab0e4b1c53","title":"前端自动化部署","content":"所谓自动化部署就是当代码触发提交的时候自动部署到服务器上\n前置准备工作\n\n服务器：需要有一台可以部署代码的服务器，比如阿里云、腾讯云、GitHub Pages 等\n代码仓库：需要有一个代码仓库，比如 GitHub、GitLab 等\n会 linux\n懂点 Ngnix\n懂点 Git\n\n买一台服务器\n不要贪便宜到不知名小平台买，之前我也有过投机取巧不想买大平台的服务器，因为觉得贵，但是贵有贵的道理，小平台的安装都会报错，可能对于当时的我技术还不够，不太能分析出错误的原因是什么，总之避雷就对了。\n\n到阿里云我买的 99&#x2F;年的，我买的是 Alibaba Cloud Linux3，和 CentOS 没差，用就行\n\n一路先确定直到支付完成就会看到有服务器的 IP 地址，记住这个 IP 地址，后面会用到。然后重置密码，记住密码，不管是脑子还是别的什么地方\n\n\n连接服务器固定模板 ssh root@服务器 IP 地址\n安装 Docker以下命令以此执行，无脑做就能成功\n**一些命令的解释: **\n\ndnf: 这是一个包管理工具，用于安装、更新和删除软件包。它是 yum 的下一代版本，提供更好的性能和依赖管理功能。\n\ninstall: 这是 dnf 的一个子命令，用于安装指定的软件包。\n\n-y: 这个选项表示自动回答“yes”给所有的提示。这意味着在安装过程中，如果有任何确认提示，使用此标志可以自动接受，避免手动干预。\n\ndocker-ce: 这是要安装的软件包的名称。在这里，docker-ce 指的是 Docker 的社区版（Community Edition）。Docker 是一个开源的容器化平台，用于自动化应用程序的部署、扩展和管理。\n\n–nobest: 这个选项告诉 dnf 在安装时不一定选择最好的（最新的）版本来进行安装，而是可以选择可用版本中的较好版本。这在某些情况下可以避免因为依赖问题而无法安装最新版本\n\n\n运行以下命令，安装Docker存储驱动的依赖包dnf install -y device-mapper-persistent-data lvm2\n\n运行以下命令，添加稳定的Docker软件源。dnf config-manager --add-repo&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n\n运行以下命令，查看已添加的Docker软件源。dnf list docker-ce\n\n正确的返回示例如下。docker-ce.x86_64        3:19.03.13-3.el7        docker-ce-stable\n\n运行以下命令安装Dockerdnf install -y docker-ce --nobest\n\n设置开机自启sudo systemctl enable docker\n\n启动dockersudo systemctl start docker\n\n检测是否安装成功 docker -v 查看版本号docker -v\n\n\n安装 docker-compose安sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -olink\n\n对二进制文件应用可执行权限sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n\n检测是否安装成功 docker-compose -v 查看版本号docker-compose -v\n\n安装 Nginx 镜像和 Jenkins 镜像安装 Nginx镜像docker pull nginx\n\n\n\n\n\n\n\n\n\n\n\nwarning: 如果报错内容是 Error response from daemon: Get “https://registry-1.docker.io/v2/“: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 就按下方命令执行\n\n修改下这个json文件，没有就创建vim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n\n写入以下内容&#123;\n  &quot;registry-mirrors&quot;: [\n    &quot;https:&#x2F;&#x2F;2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;,\n    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,\n    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;,\n    &quot;https:&#x2F;&#x2F;your_preferred_mirror&quot;,\n    &quot;https:&#x2F;&#x2F;dockerhub.icu&quot;,\n    &quot;https:&#x2F;&#x2F;docker.registry.cyou&quot;,\n    &quot;https:&#x2F;&#x2F;docker-cf.registry.cyou&quot;,\n    &quot;https:&#x2F;&#x2F;dockercf.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;docker.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;dockertest.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.aliyuncs.com&quot;,\n    &quot;https:&#x2F;&#x2F;dockerproxy.com&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;,\n    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,\n    &quot;https:&#x2F;&#x2F;docker.nju.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.mirrors.sjtug.sjtu.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.iscas.ac.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.rainbond.cc&quot;\n  ]\n&#125;\n\n重新加载配置文件systemctl daemon-reload\n\n重启docker服务systemctl restart docker\n\n检查下docker是否启动正常systemctl status docker\n\n这样再重新 pull Nginx 就正常了\n安装 Jenkins查看镜像listdocker search jenkins\n\n\n\n\n\n\n\n\n\n\nwarning:可能会报错，需要配置下镜像源无所谓，反正是查看列表的命令，往下走接着拉镜像\n拉取Jenkins镜像 本次镜像jenkins/jenkins:ltsdocker pull jenkins&#x2F;jenkins:lts\n\n\n\n\n\n\n\n\nWARNING\n就拉最新版的镜像，lts 版本是最稳定的版本，一般情况下都用这个版本，别整没有用的\n\n安装完成后执行docker images 查看已安装镜像docker images\n\n\n配置目录编写\n\n\n\n\n\n\nWARNING\n!! 注意：这里的 docker 是放在根目录的和&#x2F;root 平级的\n\n\ndocker\ncompose\ndocker-compose.yml &#x2F;&#x2F;docker-compose 配置\n\n\nhtml &#x2F;&#x2F;各环境代码目录(实际项目可能不在同一目录)\ndev &#x2F;&#x2F;dev 环境代码目录\nprod &#x2F;&#x2F;sit 环境代码目录\n\n\njenkins_home &#x2F;&#x2F;Jenkins 工程目录\nnginx &#x2F;&#x2F;nginx 工程目录\nconf\nnginx.conf &#x2F;&#x2F;nginx 配置\n\n\n\n\n\n\n\ndocker-compose.yml 配置文件version: &quot;3&quot;\n\nservices: # 容器\n  docker_jenkins:\n    privileged: true\n    user: root # root权限\n    restart: always # 重启方式\n    image: jenkins&#x2F;jenkins:lts # 使用的镜像\n    container_name: jenkins # 容器名称\n    ports: # 对外暴露的端口定义\n      - 8080:8080\n      - 50000:50000\n    volumes: # 卷挂载路径\n      - &#x2F;docker&#x2F;jenkins_home&#x2F;:&#x2F;var&#x2F;jenkins_home # 挂载到容器内的jenkins_home目录\n      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock\n      - &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n      - &#x2F;usr&#x2F;bin&#x2F;docker:&#x2F;usr&#x2F;bin&#x2F;docker\n\n  docker_nginx_dev: # nginx-dev环境\n    restart: always\n    image: nginx\n    container_name: nginx_dev\n    ports:\n      - 8001:8001\n    volumes:\n      - &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n      - &#x2F;docker&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html\n      - &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx\n\n  docker_nginx_prod: # nginx-prod环境\n    restart: always\n    image: nginx\n    container_name: nginx_prod\n    ports:\n      - 8002:8002\n    volumes:\n      - &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n      - &#x2F;docker&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html\n      - &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx\n\nnginx.conf 配置文件# nginx.conf 例：\nuser  nginx;\nworker_processes  1;\n\nerror_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;\npid        &#x2F;var&#x2F;run&#x2F;nginx.pid;\n\n\nevents &#123;\n    worker_connections  1024;\n&#125;\n\n\nhttp &#123;\n    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;\n    default_type  application&#x2F;octet-stream;\n\n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    gzip  on;\n\n    #dev环境\n    server &#123;\n            #监听的端口\n        listen  8001;\n        server_name  localhost;\n        #设置日志\n#        access_log  logs&#x2F;dev.access.log  main;\n\n        #定位到index.html\n           location &#x2F; &#123;\n               #linux下HTML文件夹,就是你的前端项目文件夹\n               root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;dev&#x2F;dist;\n#               root  &#x2F;home&#x2F;html&#x2F;dev&#x2F;dist;\n               #输入网址（server_name：port）后，默认的访问页面\n               index  index.html;\n               try_files $uri $uri&#x2F; &#x2F;index.html;\n           &#125;\n    &#125;\n\n    #prod环境\n    server &#123;\n            #监听的端口\n        listen  8002;\n        server_name  localhost;\n        #设置日志\n#        access_log  logs&#x2F;prod.access.log  main;\n\n        #定位到index.html\n           location &#x2F; &#123;\n               #linux下HTML文件夹,就是你的前端项目文件夹\n               root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;prod&#x2F;dist;\n#               root  &#x2F;home&#x2F;html&#x2F;dev&#x2F;dist;\n               #输入网址（server_name：port）后，默认的访问页面\n               index  index.html;\n               try_files $uri $uri&#x2F; &#x2F;index.html;\n           &#125;\n    &#125;\n\n\n#    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;\n\n\n&#125;\n\n\n\n\n\n\n\n\nTIP\n在 docker-compose.yml 文件所在目录下执行命令创建容器\n\n启动容器docker-compose up -d\n\n执行docker ps查看容器情况docker ps\n\nJenkins 配置爆坑来了！！！\n阿里云安全组配置\n\n\n\n\n\n\nWARNING\n此时通过 ip:8080 打不开 jenkins 的，因为阿里云那边需要手动加上要访问那个端口，就放行哪个端口\n\n防火墙配置\n\n\n\n\n\n\n\n\n输入命令开启防火墙和 8080 端口\n检查防火墙装填sudo systemctl status firewalld\n\n开启防火墙sudo systemctl start firewalld\n\nsudo systemctl enable firewalld\n\n开启8080端口sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent\n\n重启防火墙sudo firewall-cmd --reload\n\n\n\n\n\n\n\n\nWARNING\n后面每开放一个端口就要到安全组手动配置一下，然后防火墙开启端口，防火墙 reload 一下，三步，每一步都不能少\n\nJenkins 初次密码在容器启动后，可以在浏览器输入服务器 ip:8080 进入 jenkins 管理界面。至此，jenkins 配置完成。\n密码在 docker/jenkins_home/secrets/initialAdminPassword可以通过命令：\ncat &#x2F;docker&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword\n\nNginx 配置在对应目录/docker/html/dev/dist、/docker/html/prod/dist各新建一个 index.html\n经过上述步骤之后，可以通过 ip+对应的 nignx 端口访问到对应的环境的页面。\n\n\nJenkins 进入后的配置下载插件\nlocal（可选。将界面设置为中文）\nGitHub\npublish over SSH (用来连接远程服务器的)\nNodeJs\n\n下载插件后，Jenkins 需要重启地址栏输入ip:端口/restart\n\nPublish Over SSH 配置第一步\n第二步 进去找到 Publish Over SSH\n第三步 点击 Publish Over SSH 下方的 SSH Server,点击新增\n第四步 点击高级\n\n\nNodeJs 配置\n\n添加凭据添加凭据（账号密码）是为了方便后续使用\n\n\n添加 github 账号密码\n创建 job源码管理\n应用保存后，点击立即构建\n\n无论是否成功，都可以在构建记录控制台查看\n\nGithub WebHooks 配置webhooks 配置\n\n创建一个 Personal access tokens\n配置 jenkins进入一个 job\n\n\n\n\n\n\n(图片说明：描述就是取一个名称)\n\nBuild Steps在&#x2F;docker&#x2F;jenkins_home&#x2F;workspace&#x2F;gitlab_web,每次构建对应代码都会同步更新，由于代码没有在 git 上传 node_moudle 文件夹，所以后续需要在服务器重新安装 node_moudle\nExecute NodeJS script这里选的 node 是上面配置的\n点击应用后保存，然后点击立即构建，此次时间会长一点，此时构建会去自动安装对应的 nodejs 安装包到 jenkins 目录并配置好环境变量，注意尽量与本地开发环境的node版本一致，为了保持环境同步，等待构建好后再执行下一步\n\n应用保存并构建成功后，可以进入下一步\nShell 命令\n在 shell 命令这块有的执行 node -v 都报错，此时请检查环境变量是否与服务器的环境变量有差异，执行echo $PATH第一行代码一般要添加#!/bin/bash如果环境变量有问题可能要在第二行执行刷新环境变量命令\nsource ~&#x2F;.bash_profile\nsource &#x2F;etc&#x2F;profile\n\n上面哪个有效果用哪个然后执行对应命令，验证环境可用\n\n#!&#x2F;bin&#x2F;bash\n\nnode -v\nnpm -v\necho $PATH\n\n保存之后回到桌面在此构建一次上述命令如成功执行，进行下一步\n安装node_moule并build打包\n\n\n\n\n\n\nWARNING\n先自己本地build一下，看看哪里有问题\n\n修改job的shell配置\nnode -v\nnpm -v\n\nnpm i \nnpm run build:dev\n\n\n此时服务器代码出现dist文件夹目录在&#x2F;docker&#x2F;jenkins_home&#x2F;workspace&#x2F;github_test_web\n代码自动部署到对应环境项目目录同一服务器可以用cp命令，可以参考linux cp命令\n此处为另一种方式：压缩包ssh传输，因为使用cp命令到&#x2F;docker&#x2F;html&#x2F;dev目录报错了，遂采用第二种方式\n#!&#x2F;bin&#x2F;bash\n\nnode -v \nnpm -v \nnpm i\nnpm run build:dev\nrm -rf dist.tar\ntar -zcvf dist.tar .&#x2F;dist\n\n构建成功后多了个dist.tar文件\n连接SSH服务器系统配置已经设置过ssh相关配置再操作下面，如未设置，请往上翻 Publish Over SSH\n\n字段说明：Source files：准备发送的文件，该文件是相对于这个项目的workspace目录。例如要发送/docker/jenkins_home/workspace/gitlab_web/dist.tar到目标目录，则设置Source files为dist.tarRemove prefix：目标文件前缀添加，例如要操作src下面的某个文件，就设置成src,本案例是跟目录，无需设置Remote directory：目标目录，本案例要复制到dev环境下的dist文件，/docker/html/devExec command：最后执行的命令，可在这里进行解压，删除，复制等操作\n执行构建后，对应目录已经有了一个dist.tar文件\n\n这样肯定是不行的，还需要删除原有dist文件夹，解压dist.tar,再删除dist.tar,最终命令如下修改刚才配置的ssh最下方有个Exec command\ncd &#x2F;docker&#x2F;html&#x2F;dev\nrm  -rf   dist&#x2F;\ntar zxvf dist.tar\nrm dist.tar\n至此，shell命令执行结束，目前的效果是:gitlab 项目dev分支git提交后，触发jenkins自动构建，自动构建会先在服务器从gitlab的dev分支拉取最新代码，执行build打包后生成dist.tar文件，然后通过ssh将对应dist.tar发送到对应dev环境的项目目录解压dist.tar并更新对应文件，实现自动更新dev环境\n","slug":"automated-deployment","date":"2024-10-20T04:18:31.000Z","categories_index":"Academic","tags_index":"docker,nginx,jenkins,linux","author_index":"X-29"},{"id":"9668cd611991e16937a9fdd60d6dd807","title":"web多环境配置","content":"web 端多环境配置多环境无非就是请求的接口不一样所以本文将介绍如何在 web 端配置不同的请求接口的环境\n1. 准备工作npm init vite@latest\n\n完成之后长这样\n2.配置一些变量2.1 在根目录下新增 config 文件夹config\n├── plugins.ts\n├── constant.ts\n\nconstant 用于配置一些常量&#x2F;&#x2F; 基本路径\nexport const VITE_BASE_PATH &#x3D; &quot;&#x2F;&quot;;\n&#x2F;&#x2F; 应用名称\nexport const VITE_APP_TITLE &#x3D; &quot;xxx&quot;;\n&#x2F;&#x2F; 开启包依赖分析 可视化\nexport const VITE_APP_ANALYZE &#x3D; false;\n&#x2F;&#x2F; 开启Gzip压缩\nexport const VITE_APP_COMPRESS_GZIP &#x3D; false;\n&#x2F;&#x2F; 开启Gzip压缩，删除原文件\nexport const VITE_APP_COMPRESS_GZIP_DELETE_FILE &#x3D; false;\n&#x2F;&#x2F; 去除 console\nexport const VITE_DROP_CONSOLE &#x3D; true;\n&#x2F;&#x2F; 开启兼容\nexport const VITE_APP_LEGACY &#x3D; true;\n\nplugins 用于后续 vite 插件的配置npm install vite-plugin-compression vite-plugin-remove-console --save-dev\n\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\nimport viteCompression from &quot;vite-plugin-compression&quot;;\n\nimport removeConsole from &quot;vite-plugin-remove-console&quot;;\nimport &#123;\n  VITE_APP_COMPRESS_GZIP,\n  VITE_APP_COMPRESS_GZIP_DELETE_FILE,\n&#125; from &quot;.&#x2F;constant&quot;;\n\nexport const createVitePlugins &#x3D; (isBuild: boolean) &#x3D;&gt; &#123;\n  const vitePlugins &#x3D; [react(), removeConsole()];\n\n  if (isBuild) &#123;\n    if (VITE_APP_COMPRESS_GZIP) &#123;\n      vitePlugins.push(\n        viteCompression(&#123;\n          disable: true,\n          deleteOriginFile: VITE_APP_COMPRESS_GZIP_DELETE_FILE,\n        &#125;)\n      );\n    &#125;\n  &#125;\n\n  return vitePlugins;\n&#125;;\n\n3.查看 vite.config.ts 文件import &#123; defineConfig &#125; from &quot;vite&quot;;\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\n\nexport default defineConfig(&#123;\n  plugins: [react()],\n&#125;);\n\n修改 vite.config.ts 文件\n\n\n\n\n\n\n\n\n如果提示：找不到模块“path”或其相应的类型声明，智能导入一下导入类型就行，这样就报错了\nimport &#123; ConfigEnv, loadEnv, UserConfig &#125; from &quot;vite&quot;;\nimport &#123; createVitePlugins &#125; from &quot;.&#x2F;config&#x2F;plugins&quot;;\nimport &#123; resolve &#125; from &quot;path&quot;;\nimport &#123; VITE_DROP_CONSOLE &#125; from &quot;.&#x2F;config&#x2F;constant&quot;;\n\nexport default (&#123; command, mode &#125;: ConfigEnv): UserConfig &#x3D;&gt; &#123;\n  const isBuild &#x3D; command.includes(&quot;build&quot;);\n  const root &#x3D; process.cwd();\n  const env &#x3D; loadEnv(mode, root);\n  const &#123; VITE_PORT &#125; &#x3D; env;\n\n  return &#123;\n    root: process.cwd(),\n    publicDir: &quot;public&quot;,\n    base: &quot;.&#x2F;&quot;,\n    plugins: createVitePlugins(isBuild),\n    css: &#123;\n      modules: &#123;\n        generateScopedName: &quot;[name]__[local]___[hash:base64:5]&quot;,\n        hashPrefix: &quot;prefix&quot;,\n      &#125;,\n      postcss: &#123;\n        plugins: [],\n      &#125;,\n      preprocessorOptions: &#123;\n        less: &#123;\n          javascriptEnabled: true,\n        &#125;,\n      &#125;,\n    &#125;,\n    resolve: &#123;\n      alias: &#123;\n        &quot;@&quot;: &#96;$&#123;resolve(__dirname, &quot;src&quot;)&#125;&#96;,\n      &#125;,\n      mainFields: [&quot;module&quot;, &quot;jsnext:main&quot;, &quot;jsnext&quot;],\n    &#125;,\n    clearScreen: true,\n    logLevel: &quot;info&quot;,\n    server: &#123;\n      open: true,\n      host: &quot;0.0.0.0&quot;,\n      port: parseInt(VITE_PORT),\n    &#125;,\n    build: &#123;\n      target: &quot;modules&quot;,\n      outDir: &quot;build&quot;,\n      assetsDir: &quot;assets&quot;,\n      cssCodeSplit: true,\n      assetsInlineLimit: 4096,\n      sourcemap: !isBuild,\n      chunkSizeWarningLimit: 500,\n      emptyOutDir: true,\n      manifest: false,\n      terserOptions: &#123;\n        compress: &#123;\n          keep_infinity: true,\n          drop_console: VITE_DROP_CONSOLE,\n        &#125;,\n      &#125;,\n    &#125;,\n    define: &#123;\n      _GLOBAL_VARS_: JSON.stringify(&#123;\n        ...env,\n        MODE: mode,\n        BUILD_TIME: new Date().toLocaleString(),\n      &#125;),\n    &#125;,\n  &#125;;\n&#125;;\n\n4.修改 package.json 文件原先的 scripts 部分\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;vite&quot;,\n  &quot;build&quot;: &quot;tsc -b &amp;&amp; vite build&quot;,\n  &quot;lint&quot;: &quot;eslint .&quot;,\n  &quot;preview&quot;: &quot;vite preview&quot;\n&#125;,\n\n修改后的 scripts 部分\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;vite --mode dev&quot;,\n  &quot;prod&quot;: &quot;vite --mode prod&quot;,\n  &quot;build:dev&quot;: &quot;tsc -b &amp;&amp; vite build --mode dev&quot;,\n  &quot;build:prod&quot;: &quot;tsc -b &amp;&amp; vite build --mode prod&quot;,\n  &quot;lint&quot;: &quot;eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0&quot;,\n  &quot;preview&quot;: &quot;vite preview&quot;\n&#125;,\n\n5.根目录下新增 .env 文件VITE_PORT &#x3D; 7200\nVITE_HOST &#x3D; http:&#x2F;&#x2F;dev.example.com &#x2F;&#x2F; 修改为你的域名,这里就是测试环境的接口前缀\n\n6.根目录下新增 .env.prod 文件VITE_PORT &#x3D; 7200\nVITE_HOST &#x3D; http:&#x2F;&#x2F;prod.example.com &#x2F;&#x2F; 修改为你的域名,这里就是生产环境的接口前缀\n\n7.新增 types 目录，里面新增 global.d.ts 文件declare const _GLOBAL_VARS_: &#123;\n  VITE_HOST: string;\n  MODE: string;\n  &#x2F;&#x2F; 如果还有其他变量，可以在这里继续声明\n&#125;;\n\n8.修改 tsconfig.node.json 文件在 include 中加入\n&quot;compilerOptions&quot;: &#123;\n  &quot;jsx&quot;: &quot;react-jsx&quot;,\n&#125;,\n&quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;config&#x2F;*&quot;,&quot;vite.config.ts&quot;,&quot;.&#x2F;types&#x2F;global.d.ts&quot;],\n\n完整的 tsconfig.node.json 文件如下：\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;jsx&quot;: &quot;react-jsx&quot;, &#x2F;&#x2F; 为了避免识别不出jsx和避免提示需要导入react的提示\n    &quot;target&quot;: &quot;ES2022&quot;,\n    &quot;lib&quot;: [&quot;ES2023&quot;],\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;skipLibCheck&quot;: true,\n\n    &#x2F;* Bundler mode *&#x2F;\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;allowImportingTsExtensions&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;moduleDetection&quot;: &quot;force&quot;,\n    &quot;noEmit&quot;: true,\n\n    &#x2F;* Linting *&#x2F;\n    &quot;strict&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noFallthroughCasesInSwitch&quot;: true\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;, &quot;config&#x2F;*&quot;, &quot;vite.config.ts&quot;, &quot;.&#x2F;types&#x2F;global.d.ts&quot;]\n&#125;\n\n9.在 src 目录下创建 constant.ts 文件export const HOST &#x3D; _GLOBAL_VARS_.VITE_HOST;\nexport const MODE &#x3D; _GLOBAL_VARS_.MODE;\n\n查看效果npm run dev\n\n\nnpm run prod\n\n\n","slug":"multiple-environments","date":"2024-10-20T02:15:18.000Z","categories_index":"Skill","tags_index":"React,web,Vite","author_index":"X-29"}]