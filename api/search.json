[{"id":"3aa405af8114bdbedccc4d79b50ad9ac","title":"interview-html","content":"src 和 href 的区别在 HTML 中，src 和 href 是两个常用的属性，它们的主要区别在于它们的用途和适用的标签。以下是详细的解释：\n1. src 属性\n全称：source（源）\n用途：用于指定外部资源的路径，通常用于嵌入媒体文件，如图像、音频、视频等。\n适用标签：\n&lt;img&gt;：用于图像\n&lt;script&gt;：用于 JavaScript 文件\n&lt;iframe&gt;：用于嵌入其他网页\n&lt;audio&gt; 和 &lt;video&gt;：用于音频和视频文件\n\n\n\n示例：&lt;img src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;示例图像&quot; &#x2F;&gt;\n&lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;iframe src&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot;&gt;&lt;&#x2F;iframe&gt;\n\n2. href 属性\n全称：hyperlink reference（超链接引用）\n用途：用于指定链接的目标地址，通常用于创建超链接。\n适用标签：\n&lt;a&gt;：用于超链接\n&lt;link&gt;：用于链接外部样式表\n\n\n\n示例：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot;&gt;访问示例网站&lt;&#x2F;a&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;styles.css&quot; &#x2F;&gt;\n\n总结HTML 语义化是指使用 HTML 标签来准确地描述网页内容的意义和结构，而不仅仅是为了视觉效果。语义化的 HTML 使得网页更易于理解、维护和优化，尤其是在搜索引擎优化（SEO）和无障碍访问方面。\n1. 语义化的好处\n提高可读性：语义化的标签使得代码更易于阅读和理解，开发者可以快速识别网页的结构和内容。\n增强 SEO：搜索引擎能够更好地理解网页内容，从而提高网页在搜索结果中的排名。\n改善无障碍访问：使用语义化标签可以帮助屏幕阅读器等辅助技术更好地解析网页内容，提升残障人士的访问体验。\n便于维护：清晰的结构使得后续的维护和更新变得更加简单。\n\n2. 常用的语义化标签\n&lt;header&gt;：定义文档的头部，通常包含网站的标题、导航等。\n&lt;nav&gt;：定义导航链接的部分。\n&lt;main&gt;：定义文档的主要内容。\n&lt;article&gt;：定义独立的内容块，通常是博客文章或新闻报道。\n&lt;section&gt;：定义文档中的一个区域，通常包含相关的内容。\n&lt;aside&gt;：定义与主内容相关但不直接相关的内容，如侧边栏。\n&lt;footer&gt;：定义文档的底部，通常包含版权信息、联系信息等。\n\n3. 示例以下是一个简单的 HTML 结构示例，展示了如何使用语义化标签：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;语义化 HTML 示例&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;header&gt;\n      &lt;h1&gt;我的网站&lt;&#x2F;h1&gt;\n      &lt;nav&gt;\n        &lt;ul&gt;\n          &lt;li&gt;&lt;a href&#x3D;&quot;#home&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n          &lt;li&gt;&lt;a href&#x3D;&quot;#about&quot;&gt;关于我们&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n          &lt;li&gt;&lt;a href&#x3D;&quot;#contact&quot;&gt;联系我们&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;nav&gt;\n    &lt;&#x2F;header&gt;\n    &lt;main&gt;\n      &lt;article&gt;\n        &lt;h2&gt;第一篇文章&lt;&#x2F;h2&gt;\n        &lt;p&gt;这是文章的内容。&lt;&#x2F;p&gt;\n      &lt;&#x2F;article&gt;\n      &lt;section&gt;\n        &lt;h2&gt;相关信息&lt;&#x2F;h2&gt;\n        &lt;p&gt;这是与文章相关的信息。&lt;&#x2F;p&gt;\n      &lt;&#x2F;section&gt;\n    &lt;&#x2F;main&gt;\n    &lt;aside&gt;\n      &lt;h2&gt;侧边栏&lt;&#x2F;h2&gt;\n      &lt;p&gt;这是侧边栏的内容。&lt;&#x2F;p&gt;\n    &lt;&#x2F;aside&gt;\n    &lt;footer&gt;\n      &lt;p&gt;© 2023 我的公司&lt;&#x2F;p&gt;\n    &lt;&#x2F;footer&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结HTML 语义化不仅有助于提升网页的可读性和可维护性，还能增强搜索引擎的理解能力和无障碍访问体验。使用合适的语义化标签是现代网页开发的重要实践。\nDOCTYPE(⽂档类型) 的作⽤DOCTYPE（文档类型声明）是 HTML 文档的第一行代码，用于告诉浏览器该文档使用的 HTML 或 XHTML 版本。它的主要作用包括以下几个方面：\n1. 指定文档类型DOCTYPE 声明帮助浏览器识别文档的类型和版本，从而正确解析和渲染网页。不同的 HTML 版本有不同的语法和特性，DOCTYPE 确保浏览器使用正确的规则来处理文档。\n2. 启用标准模式使用 DOCTYPE 声明可以使浏览器进入标准模式（Standards Mode），在这种模式下，浏览器会遵循 W3C 的标准来渲染页面。没有 DOCTYPE 声明时，浏览器可能会进入怪异模式（Quirks Mode），这可能导致页面在不同浏览器中的表现不一致。\n3. 提高兼容性通过明确指定文档类型，开发者可以确保网页在不同浏览器和设备上的兼容性。这样可以减少因浏览器解析差异而导致的显示问题。\n4. 示例以下是几种常见的 DOCTYPE 声明示例：\n\nHTML5：\n&lt;!DOCTYPE html&gt;\n\nHTML 4.01：\n&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;\n\nXHTML 1.0：\n&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Strict&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-strict.dtd&quot;&gt;\n\n5. 总结DOCTYPE 声明在 HTML 文档中起着至关重要的作用，它不仅指定了文档的类型和版本，还影响浏览器的渲染模式和兼容性。为了确保网页的正确显示和良好的用户体验，建议在每个 HTML 文档的开头都包含适当的 DOCTYPE 声明。\nscript 标签中 defer 和 async 的区别在 HTML 中，&lt;script&gt; 标签用于引入和执行 JavaScript 代码。为了优化网页的加载性能，&lt;script&gt; 标签可以使用 defer 和 async 属性。这两个属性的主要区别在于它们的加载和执行方式。以下是详细的解释：\n1. defer 属性\n加载方式：当使用 defer 属性时，脚本会在文档解析完成后异步加载，但会在 DOMContentLoaded 事件之前执行。\n执行顺序：多个带有 defer 的脚本会按照它们在文档中出现的顺序依次执行。\n适用场景：适合需要在 DOM 完全加载后执行的脚本，尤其是当脚本之间有依赖关系时。\n\n示例：&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;使用 defer&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;script1.js&quot; defer&gt;&lt;&#x2F;script&gt;\n    &lt;script src&#x3D;&quot;script2.js&quot; defer&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2. async 属性\n加载方式：当使用 async 属性时，脚本会异步加载，并且在加载完成后立即执行，而不等待文档解析完成。\n执行顺序：多个带有 async 的脚本的执行顺序是不确定的，取决于它们的加载时间。\n适用场景：适合独立的脚本，不依赖于其他脚本或 DOM 的内容。\n\n示例：&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;使用 async&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;script1.js&quot; async&gt;&lt;&#x2F;script&gt;\n    &lt;script src&#x3D;&quot;script2.js&quot; async&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3. 总结\n**defer**：脚本异步加载，执行顺序按照文档中的顺序，适合需要在 DOM 加载完成后执行的脚本。\n**async**：脚本异步加载，执行顺序不确定，适合独立的脚本。\n\n选择使用 defer 还是 async 取决于脚本的依赖关系和执行时机。如果脚本需要在 DOM 完全加载后执行，使用 defer；如果脚本是独立的，可以使用 async。\n常⽤的 meta 标签有哪些在 HTML 中，&lt;meta&gt; 标签用于提供关于文档的元数据，这些元数据不会直接显示在网页上，但对浏览器、搜索引擎和其他服务非常重要。以下是一些常用的 &lt;meta&gt; 标签及其作用：\n1. 字符集声明&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\n\n作用：指定文档的字符编码，UTF-8 是一种常用的字符编码，支持多种语言字符。\n\n2. 页面描述&lt;meta\n  name&#x3D;&quot;description&quot;\n  content&#x3D;&quot;这是一个示例网页，用于展示常用的 meta 标签。&quot;\n&#x2F;&gt;\n\n\n作用：提供网页的简短描述，搜索引擎通常会在搜索结果中显示这个描述。\n\n3. 关键词&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;HTML, meta 标签, 示例, 编程&quot; &#x2F;&gt;\n\n\n作用：列出与网页内容相关的关键词，虽然现代搜索引擎对这个标签的重视程度降低，但仍然可以提供一些帮助。\n\n4. 作者信息&lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;张三&quot; &#x2F;&gt;\n\n\n作用：指定网页的作者信息。\n\n5. 视口设置&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n\n\n作用：控制网页在移动设备上的布局和缩放，确保网页在不同设备上良好显示。\n\n6. 兼容性设置&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n\n\n作用：指定 Internet Explorer 的渲染模式，IE=edge 表示使用最新的渲染引擎。\n\n7. 版权信息&lt;meta name&#x3D;&quot;copyright&quot; content&#x3D;&quot;© 2023 我的公司&quot; &#x2F;&gt;\n\n\n作用：提供网页的版权信息。\n\n8. 社交媒体分享&lt;meta property&#x3D;&quot;og:title&quot; content&#x3D;&quot;示例网页&quot; &#x2F;&gt;\n&lt;meta\n  property&#x3D;&quot;og:description&quot;\n  content&#x3D;&quot;这是一个示例网页，用于展示常用的 meta 标签。&quot;\n&#x2F;&gt;\n&lt;meta property&#x3D;&quot;og:image&quot; content&#x3D;&quot;image.jpg&quot; &#x2F;&gt;\n&lt;meta property&#x3D;&quot;og:url&quot; content&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot; &#x2F;&gt;\n\n\n作用：用于社交媒体分享时的元数据，og 表示 Open Graph 协议，帮助在社交平台上更好地展示链接。\n\n9. 其他常用标签\n刷新页面：&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;30&quot; &#x2F;&gt;\n\n作用：每 30 秒刷新一次页面。\n\n\n\n总结&lt;meta&gt; 标签在网页中扮演着重要的角色，提供了关于文档的各种信息，帮助浏览器和搜索引擎更好地理解和处理网页内容。根据需要，可以选择合适的 &lt;meta&gt; 标签来优化网页的表现和可访问性。\nHTML5 有哪些更新HTML5 是 HTML 的最新版本，相较于之前的版本，HTML5 引入了许多新特性和改进。以下是一些主要的更新和新特性：\n1. 新的语义元素HTML5 引入了一些新的语义标签，使得网页结构更加清晰和易于理解：\n\n&lt;header&gt;：定义文档的头部。\n&lt;nav&gt;：定义导航链接的部分。\n&lt;main&gt;：定义文档的主要内容。\n&lt;section&gt;：定义文档中的一个区域。\n&lt;article&gt;：定义独立的内容块。\n&lt;aside&gt;：定义与主内容相关但不直接相关的内容。\n&lt;footer&gt;：定义文档的底部。\n\n2. 新的表单控件HTML5 增强了表单功能，新增了一些输入类型和属性：\n\n新的输入类型：email、url、date、time、number、range、color 等。\n新的表单属性：placeholder、required、pattern、autocomplete 等。\n\n3. 多媒体支持HTML5 提供了原生的音频和视频支持，使用 &lt;audio&gt; 和 &lt;video&gt; 标签，无需依赖外部插件：\n&lt;audio controls&gt;\n  &lt;source src&#x3D;&quot;audio.mp3&quot; type&#x3D;&quot;audio&#x2F;mpeg&quot; &#x2F;&gt;\n  您的浏览器不支持音频元素。\n&lt;&#x2F;audio&gt;\n\n&lt;video width&#x3D;&quot;320&quot; height&#x3D;&quot;240&quot; controls&gt;\n  &lt;source src&#x3D;&quot;video.mp4&quot; type&#x3D;&quot;video&#x2F;mp4&quot; &#x2F;&gt;\n  您的浏览器不支持视频元素。\n&lt;&#x2F;video&gt;\n\n4. Canvas 和 SVGHTML5 引入了 &lt;canvas&gt; 元素，允许在网页上动态绘制图形和动画：\n&lt;canvas\n  id&#x3D;&quot;myCanvas&quot;\n  width&#x3D;&quot;200&quot;\n  height&#x3D;&quot;100&quot;\n  style&#x3D;&quot;border:1px solid #000000;&quot;\n&gt;&lt;&#x2F;canvas&gt;\n\n5. 本地存储HTML5 提供了本地存储 API，允许在用户的浏览器中存储数据，分为两种：\n\nlocalStorage：持久存储，数据不会过期。\nsessionStorage：会话存储，数据在浏览器会话结束时清除。\n\n6. 地理位置 APIHTML5 引入了地理位置 API，允许网页获取用户的地理位置信息：\nnavigator.geolocation.getCurrentPosition(function (position) &#123;\n  console.log(position.coords.latitude, position.coords.longitude);\n&#125;);\n\n7. WebSocketsHTML5 引入了 WebSockets，允许在客户端和服务器之间建立持久的双向通信通道，适用于实时应用。\n8. 离线应用HTML5 提供了应用缓存（Application Cache）和 Service Workers，允许网页在离线状态下运行。\n9. 新的 APIHTML5 还引入了许多新的 API，如：\n\n拖放 API：支持拖放操作。\nWeb Workers：允许在后台线程中运行 JavaScript，提升性能。\nWeb Storage：提供更简单的本地存储解决方案。\n\n总结HTML5 带来了许多新的特性和改进，使得网页开发更加灵活和强大。通过引入新的语义元素、多媒体支持、存储解决方案和各种 API，HTML5 使得开发者能够创建更丰富和互动的用户体验。\nimg 的 srcset 属性的作⽤？&lt;img&gt; 标签中的 srcset 属性用于提供多个图像资源，以便浏览器根据不同的条件（如屏幕分辨率、视口大小等）选择最合适的图像进行加载。这种技术被称为响应式图像，可以提高网页的加载性能和用户体验。\n1. 主要作用\n适应不同设备：srcset 允许开发者为不同的设备和屏幕分辨率提供不同的图像版本，从而确保在各种设备上都能获得最佳的视觉效果。\n优化加载性能：通过根据设备的特性选择合适的图像，减少不必要的带宽消耗，提高页面加载速度。\n提高图像质量：在高分辨率设备（如 Retina 显示屏）上，可以提供更高质量的图像，确保图像清晰可见。\n\n2. 使用方式srcset 属性通常与 sizes 属性一起使用，sizes 属性定义了图像在不同条件下的显示大小。以下是一个示例：\n&lt;img\n  src&#x3D;&quot;image-small.jpg&quot;\n  srcset&#x3D;&quot;image-small.jpg 600w, image-medium.jpg 1200w, image-large.jpg 1800w&quot;\n  sizes&#x3D;&quot;(max-width: 600px) 100vw, \n           (max-width: 1200px) 50vw, \n           33vw&quot;\n  alt&#x3D;&quot;示例图像&quot;\n&#x2F;&gt;\n\n3. 示例解析\n**src**：提供了默认图像（在不支持 srcset 的浏览器中使用）。\n**srcset**：列出了不同图像及其对应的宽度（600w、1200w、1800w），浏览器会根据设备的屏幕宽度选择合适的图像。\n**sizes**：定义了在不同条件下图像的显示大小：\n当视口宽度小于或等于 600px 时，图像宽度为 100%（100vw）。\n当视口宽度小于或等于 1200px 时，图像宽度为 50%（50vw）。\n在其他情况下，图像宽度为 33%（33vw）。\n\n\n\n4. 总结srcset 属性使得开发者能够为不同的设备和条件提供多种图像选择，从而优化网页的加载性能和用户体验。通过合理使用 srcset 和 sizes，可以确保在各种设备上都能展示出最佳的图像效果。\n行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？在 HTML 中，元素可以根据其显示特性分为三种类型：行内元素、块级元素和空（void）元素。以下是对这三种元素的详细分类和说明：\n1. 行内元素行内元素（Inline Elements）是指不会在前后产生换行的元素，它们通常用于文本内容的格式化。常见的行内元素包括：\n\n&lt;a&gt;：超链接\n&lt;span&gt;：通用的行内容器\n&lt;strong&gt;：加粗文本\n&lt;em&gt;：斜体文本\n&lt;b&gt;：加粗文本（不带语义）\n&lt;i&gt;：斜体文本（不带语义）\n&lt;img&gt;：图像\n&lt;br&gt;：换行\n&lt;code&gt;：代码片段\n&lt;small&gt;：小号文本\n&lt;sub&gt;：下标\n&lt;sup&gt;：上标\n&lt;time&gt;：时间\n&lt;label&gt;：表单标签\n\n2. 块级元素块级元素（Block Elements）是指在前后会产生换行的元素，它们通常用于构建页面的结构。常见的块级元素包括：\n\n&lt;div&gt;：通用的块级容器\n&lt;p&gt;：段落\n&lt;h1&gt; 到 &lt;h6&gt;：标题（从大到小）\n&lt;ul&gt;：无序列表\n&lt;ol&gt;：有序列表\n&lt;li&gt;：列表项\n&lt;header&gt;：文档头部\n&lt;footer&gt;：文档底部\n&lt;section&gt;：文档中的一个区域\n&lt;article&gt;：独立的内容块\n&lt;aside&gt;：与主内容相关但不直接相关的内容\n&lt;table&gt;：表格\n&lt;form&gt;：表单\n\n3. 空（void）元素空元素（Void Elements）是指没有结束标签的元素，它们通常用于插入内容或提供功能。常见的空元素包括：\n\n&lt;br&gt;：换行\n&lt;hr&gt;：水平线\n&lt;img&gt;：图像\n&lt;input&gt;：输入框\n&lt;link&gt;：链接外部资源（如样式表）\n&lt;meta&gt;：提供文档的元数据\n&lt;base&gt;：指定相对 URL 的基准 URL\n&lt;source&gt;：为 &lt;audio&gt; 和 &lt;video&gt; 提供多个资源\n&lt;track&gt;：为 &lt;video&gt; 提供文本轨道\n&lt;area&gt;：定义图像地图中的区域\n\n总结\n行内元素：不会产生换行，通常用于文本格式化。\n块级元素：会产生换行，通常用于构建页面结构。\n空元素：没有结束标签，通常用于插入内容或提供功能。\n\n说一下 web workerWeb Worker 是一种在浏览器中运行 JavaScript 的机制，允许开发者在后台线程中执行脚本，从而实现多线程编程。Web Worker 的主要目的是提高网页的性能，尤其是在处理大量计算或长时间运行的任务时，避免阻塞主线程（UI 线程），从而保持用户界面的响应性。\n1. Web Worker 的特点\n并行执行：Web Worker 在独立的线程中运行，可以与主线程并行执行，避免了长时间的计算导致用户界面卡顿。\n不访问 DOM：Web Worker 不能直接访问 DOM 和窗口对象，但可以通过消息传递与主线程进行通信。\n异步处理：Web Worker 的任务是异步的，主线程可以继续执行其他操作，而不必等待 Worker 完成任务。\n\n2. 创建 Web Worker要创建一个 Web Worker，通常需要以下步骤：\n\n创建 Worker 脚本：编写一个 JavaScript 文件，包含 Worker 要执行的代码。\n&#x2F;&#x2F; worker.js\nself.onmessage &#x3D; function (event) &#123;\n  const result &#x3D; event.data * 2; &#x2F;&#x2F; 处理数据\n  self.postMessage(result); &#x2F;&#x2F; 将结果发送回主线程\n&#125;;\n\n在主线程中创建 Worker 实例：\n&#x2F;&#x2F; main.js\nconst worker &#x3D; new Worker(&quot;worker.js&quot;);\n\nworker.onmessage &#x3D; function (event) &#123;\n  console.log(&quot;Worker 返回的结果:&quot;, event.data);\n&#125;;\n\nworker.postMessage(10); &#x2F;&#x2F; 向 Worker 发送数据\n\n3. 消息传递主线程和 Worker 之间通过 postMessage 方法进行消息传递。主线程可以使用 worker.postMessage(data) 向 Worker 发送数据，而 Worker 可以使用 self.postMessage(data) 向主线程发送数据。\n4. 终止 Worker可以使用 worker.terminate() 方法终止 Worker 的执行。Worker 一旦被终止，将无法再恢复。\n5. 使用场景Web Worker 适用于以下场景：\n\n复杂计算：处理大量数据或复杂算法时，可以将计算任务放在 Worker 中执行。\n数据处理：在后台处理数据（如图像处理、文件解析等），避免阻塞主线程。\n实时应用：在实时应用中（如在线游戏、聊天应用等），可以使用 Worker 处理网络请求和数据更新。\n\n6. 注意事项\nWeb Worker 不能访问 DOM，因此需要通过消息传递与主线程进行交互。\nWorker 脚本必须在同源策略下加载，不能跨域。\nWorker 的创建和通信会有一定的性能开销，因此适合用于长时间运行的任务。\n\n总结Web Worker 是一种强大的工具，可以帮助开发者在浏览器中实现多线程编程，提升网页的性能和用户体验。通过将计算密集型任务放在后台线程中执行，Web Worker 可以有效避免主线程的阻塞，保持用户界面的流畅性。\nHTML5 的离线储存怎么使用，它的工作原理是什么HTML5 的离线存储主要通过两种技术实现：应用缓存（Application Cache）和Web Storage（包括 localStorage 和 sessionStorage）。以下是这两种技术的详细介绍及其工作原理。\n1. 应用缓存（Application Cache）工作原理应用缓存允许开发者指定哪些资源（如 HTML、CSS、JavaScript、图像等）可以在用户的设备上缓存，以便在离线状态下访问。应用缓存的工作原理如下：\n\nManifest 文件：开发者需要创建一个清单文件（manifest file），该文件列出了需要缓存的资源和其他相关信息。\n浏览器缓存：当用户首次访问网页时，浏览器会下载并缓存清单文件中列出的所有资源。\n离线访问：当用户处于离线状态时，浏览器会从缓存中加载资源，而不是从网络请求。\n\n示例&lt;!DOCTYPE html&gt;\n&lt;html manifest&#x3D;&quot;example.appcache&quot;&gt;\n  &lt;head&gt;\n    &lt;title&gt;离线应用示例&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎使用离线应用&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nmanifest 文件（example.appcache）：\nCACHE MANIFEST\n# 版本 1.0\n\nCACHE:\nindex.html\nstyles.css\nscript.js\n\nNETWORK:\n*\n\n\nCACHE：列出需要缓存的资源。\nNETWORK：列出需要从网络请求的资源，* 表示所有其他资源。\n\n注意事项\n应用缓存已被标记为过时，建议使用 Service Workers 作为替代方案。\n\n2. Web StorageWeb Storage 提供了两种存储机制：localStorage 和 sessionStorage。\n2.1 localStorage\n持久性：数据存储在用户的浏览器中，直到被显式删除，数据不会过期。\n存储大小：通常可以存储约 5MB 的数据。\n\n使用示例：\n&#x2F;&#x2F; 存储数据\nlocalStorage.setItem(&quot;key&quot;, &quot;value&quot;);\n\n&#x2F;&#x2F; 读取数据\nconst value &#x3D; localStorage.getItem(&quot;key&quot;);\n\n&#x2F;&#x2F; 删除数据\nlocalStorage.removeItem(&quot;key&quot;);\n\n&#x2F;&#x2F; 清空所有数据\nlocalStorage.clear();\n\n2.2 sessionStorage\n会话性：数据仅在当前会话中有效，浏览器窗口关闭后数据会被清除。\n存储大小：通常可以存储约 5MB 的数据。\n\n使用示例：\n&#x2F;&#x2F; 存储数据\nsessionStorage.setItem(&quot;sessionKey&quot;, &quot;sessionValue&quot;);\n\n&#x2F;&#x2F; 读取数据\nconst sessionValue &#x3D; sessionStorage.getItem(&quot;sessionKey&quot;);\n\n&#x2F;&#x2F; 删除数据\nsessionStorage.removeItem(&quot;sessionKey&quot;);\n\n&#x2F;&#x2F; 清空所有数据\nsessionStorage.clear();\n\n3. 总结\n应用缓存：允许开发者缓存网页资源以便离线访问，但已被标记为过时，建议使用 Service Workers。\nWeb Storage：提供 localStorage 和 sessionStorage，用于在浏览器中存储数据，适合需要持久化或会话性的数据存储。\n\n通过合理使用这些技术，开发者可以创建更好的用户体验，允许用户在离线状态下访问网页和应用。\n浏览器是如何对 HTML5 的离线储存资源进行管理和加载？浏览器对 HTML5 的离线存储资源进行管理和加载的方式主要依赖于应用缓存（Application Cache）和 Web Storage（localStorage 和 sessionStorage）。以下是这两种技术的详细管理和加载机制：\n1. 应用缓存（Application Cache）管理和加载过程\n清单文件（Manifest File）：\n\n开发者创建一个清单文件，列出需要缓存的资源。\n清单文件的 MIME 类型应为 text/cache-manifest。\n\n\n首次加载：\n\n当用户首次访问网页时，浏览器会请求清单文件。\n浏览器解析清单文件，下载并缓存文件中列出的所有资源。\n\n\n资源更新：\n\n如果清单文件的内容发生变化（例如，版本号更新），浏览器会重新下载清单文件并更新缓存。\n开发者可以通过在清单文件中添加注释（如 # version 1.0）来强制浏览器更新缓存。\n\n\n离线访问：\n\n当用户处于离线状态时，浏览器会从缓存中加载资源，而不是从网络请求。\n如果请求的资源不在缓存中，浏览器会显示错误页面。\n\n\n事件管理：\n\n浏览器会触发一些事件，如 updateready，开发者可以通过 JavaScript 监听这些事件，以便在资源更新时进行相应处理。\n\n\n\n注意事项\n应用缓存已被标记为过时，建议使用 Service Workers 作为替代方案。\n\n2. Web Storage管理和加载过程\n数据存储：\n\n开发者可以使用 localStorage 和 sessionStorage API 存储数据。\n数据以键值对的形式存储，localStorage 的数据在浏览器关闭后仍然存在，而 sessionStorage 的数据在浏览器会话结束后被清除。\n\n\n数据访问：\n\n开发者可以通过 getItem 方法读取存储的数据，通过 setItem 方法存储数据。\n数据的存储和读取是同步的，操作简单且快速。\n\n\n数据管理：\n\n开发者可以使用 removeItem 方法删除特定的键值对，使用 clear 方法清空所有存储的数据。\n\n\n存储限制：\n\n大多数浏览器对 localStorage 和 sessionStorage 的存储大小限制在 5MB 左右，具体取决于浏览器的实现。\n\n\n\n3. 总结\n应用缓存：通过清单文件管理和加载离线资源，允许用户在离线状态下访问网页。虽然功能强大，但已被标记为过时，建议使用 Service Workers。\nWeb Storage：提供简单的 API 来管理和加载数据，适合需要持久化或会话性的数据存储。\n\n通过这些机制，浏览器能够有效地管理和加载 HTML5 的离线存储资源，提升用户体验，允许用户在没有网络连接的情况下访问网页和应用。\ntitle 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？在 HTML 中，&lt;title&gt;、&lt;h1&gt;、&lt;b&gt;、&lt;strong&gt;、&lt;i&gt; 和 &lt;em&gt; 等标签各自有不同的语义和用途。以下是它们之间的区别：\n1. &lt;title&gt; 与 &lt;h1&gt;\n**&lt;title&gt;**：\n\n用途：定义文档的标题，显示在浏览器的标题栏或标签页上。\n位置：位于 &lt;head&gt; 部分。\n语义：用于描述网页的主题或内容，通常对搜索引擎优化（SEO）非常重要。\n\n&lt;head&gt;\n  &lt;title&gt;我的网页标题&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n**&lt;h1&gt;**：\n\n用途：定义文档的主标题，通常是页面内容的主要主题。\n位置：位于 &lt;body&gt; 部分，可以出现在任何地方。\n语义：表示页面的主要内容，通常是 SEO 中最重要的标题标签。\n\n&lt;h1&gt;欢迎来到我的网页&lt;&#x2F;h1&gt;\n\n2. &lt;b&gt; 与 &lt;strong&gt;\n**&lt;b&gt;**：\n\n用途：用于加粗文本，但没有语义意义。\n语义：仅用于视觉效果，不传达任何重要性。\n\n&lt;p&gt;这是一个&lt;b&gt;加粗&lt;&#x2F;b&gt;的文本。&lt;&#x2F;p&gt;\n\n**&lt;strong&gt;**：\n\n用途：用于强调文本，通常以加粗显示。\n语义：表示文本的重要性，通常用于传达更强的语气或重要性。\n\n&lt;p&gt;这是一个&lt;strong&gt;重要&lt;&#x2F;strong&gt;的文本。&lt;&#x2F;p&gt;\n\n3. &lt;i&gt; 与 &lt;em&gt;\n**&lt;i&gt;**：\n\n用途：用于斜体文本，但没有语义意义。\n语义：仅用于视觉效果，不传达任何强调。\n\n&lt;p&gt;这是一个&lt;i&gt;斜体&lt;&#x2F;i&gt;的文本。&lt;&#x2F;p&gt;\n\n**&lt;em&gt;**：\n\n用途：用于强调文本，通常以斜体显示。\n语义：表示文本的强调，通常用于传达更强的语气。\n\n&lt;p&gt;这是一个&lt;em&gt;强调&lt;&#x2F;em&gt;的文本。&lt;&#x2F;p&gt;\n\n总结\n**&lt;title&gt;**：文档的标题，位于 &lt;head&gt; 中，影响浏览器标签和 SEO。\n**&lt;h1&gt;**：页面的主标题，位于 &lt;body&gt; 中，表示主要内容。\n**&lt;b&gt;**：加粗文本，无语义意义。\n**&lt;strong&gt;**：强调文本，表示重要性。\n**&lt;i&gt;**：斜体文本，无语义意义。\n**&lt;em&gt;**：强调文本，表示语气的强调。\n\n使用语义化的标签（如 &lt;strong&gt; 和 &lt;em&gt;）有助于提高网页的可访问性和 SEO 效果，而仅用于视觉效果的标签（如 &lt;b&gt; 和 &lt;i&gt;）则应谨慎使用。\niframe 有那些优点和缺点？&lt;iframe&gt;（内联框架）是 HTML 中用于嵌入另一个 HTML 页面或文档的元素。使用 &lt;iframe&gt; 有其优点和缺点，以下是详细的分析：\n优点\n内容嵌入：\n\n可以轻松嵌入其他网页、视频、地图等内容，而无需重定向用户到新页面。\n\n\n隔离性：\n\n嵌入的内容在自己的上下文中运行，与主页面的 JavaScript 和 CSS 相互独立，减少了样式和脚本冲突的可能性。\n\n\n跨域内容：\n\n可以嵌入来自不同域的内容，允许在同一页面上显示外部资源（如社交媒体小部件、广告等）。\n\n\n便于实现复杂布局：\n\n可以在页面中创建复杂的布局，允许在同一页面中显示多个不同的内容区域。\n\n\n动态加载：\n\n可以根据需要动态加载内容，减少初始页面加载的负担。\n\n\n\n缺点\n性能问题：\n\n嵌入的页面会增加额外的 HTTP 请求，可能导致页面加载速度变慢，尤其是当嵌入的内容较大时。\n\n\nSEO 问题：\n\n搜索引擎可能不会索引 &lt;iframe&gt; 中的内容，这可能影响嵌入内容的可见性和 SEO 效果。\n\n\n安全性问题：\n\n嵌入的内容可能包含恶意代码，导致安全风险。需要确保嵌入的内容来自可信来源。\n可能受到点击劫持（Clickjacking）攻击的风险。\n\n\n用户体验：\n\n嵌入的内容可能导致用户体验不佳，尤其是在移动设备上，可能会影响响应式设计。\n\n\n跨域限制：\n\n对于跨域的 &lt;iframe&gt;，JavaScript 访问嵌入内容的限制（同源策略）可能会导致功能受限。\n\n\n\n总结&lt;iframe&gt; 是一个强大的工具，可以方便地嵌入外部内容，但在使用时需要权衡其优缺点。开发者应考虑性能、安全性和用户体验等因素，合理使用 &lt;iframe&gt;，确保嵌入的内容来自可信来源，并在必要时采取安全措施。\nlabel 的作用是什么？如何使用？&lt;label&gt; 标签在 HTML 中用于为表单控件提供可点击的标签。它的主要作用是增强表单的可用性和可访问性，使用户能够更容易地与表单元素进行交互。以下是关于 &lt;label&gt; 的详细说明及其使用方法：\n1. 作用\n提高可用性：当用户点击 &lt;label&gt; 标签时，浏览器会自动将焦点转移到与之关联的表单控件（如输入框、复选框等），这使得用户在填写表单时更加方便。\n增强可访问性：为表单控件提供描述性标签，有助于使用屏幕阅读器的用户理解表单的功能，提高无障碍访问性。\n\n2. 使用方法&lt;label&gt; 标签可以通过两种方式与表单控件关联：\n2.1 使用 for 属性使用 for 属性将 &lt;label&gt; 标签与特定的表单控件关联。for 属性的值应与表单控件的 id 属性相同。\n&lt;label for&#x3D;&quot;username&quot;&gt;用户名：&lt;&#x2F;label&gt;\n&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;\n\n在这个示例中，当用户点击“用户名”标签时，焦点会转移到输入框中。\n2.2 包裹表单控件另一种方式是将表单控件直接放在 &lt;label&gt; 标签内，这样也可以实现关联。\n&lt;label\n  &gt;用户名：\n  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;\n&lt;&#x2F;label&gt;\n\n在这个示例中，点击“用户名”文本或输入框都会将焦点转移到输入框中。\n3. 示例以下是一个完整的表单示例，展示了如何使用 &lt;label&gt; 标签：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;表单示例&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;form&gt;\n      &lt;label for&#x3D;&quot;username&quot;&gt;用户名：&lt;&#x2F;label&gt;\n      &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; required &#x2F;&gt;\n      &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;\n\n      &lt;label for&#x3D;&quot;password&quot;&gt;密码：&lt;&#x2F;label&gt;\n      &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; required &#x2F;&gt;\n      &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;\n\n      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结\n&lt;label&gt; 标签用于为表单控件提供可点击的标签，增强用户体验和可访问性。\n可以通过 for 属性与表单控件关联，或将表单控件包裹在 &lt;label&gt; 标签内。\n使用 &lt;label&gt; 标签可以提高表单的可用性，特别是对于使用辅助技术的用户。\n\nCanvas 和 SVG 的区别Canvas 和 SVG 是两种在网页上绘制图形的技术，各自有不同的特点和适用场景。以下是它们之间的主要区别：\n1. 定义和基本概念\nCanvas：\n\nCanvas 是一个 HTML 元素（&lt;canvas&gt;），用于在网页上以像素为基础绘制图形。\n使用 JavaScript API 进行绘制，适合动态生成图形和动画。\n\n\nSVG：\n\nSVG（可缩放矢量图形）是一种基于 XML 的矢量图形格式，用于描述二维图形。\n图形是由路径、形状和文本等元素组成，适合静态图形和可缩放的图像。\n\n\n\n2. 渲染方式\nCanvas：\n\n以位图（像素）方式渲染，绘制后无法直接修改单个图形元素。\n每次重绘时需要重新绘制所有内容，适合需要频繁更新的场景（如游戏、动画）。\n\n\nSVG：\n\n以矢量方式渲染，图形元素可以独立操作和修改。\n可以通过 CSS 和 JavaScript 直接操作和动画化单个元素，适合静态图形和交互式图形。\n\n\n\n3. 性能\nCanvas：\n\n在处理大量图形时性能较好，适合高频率的重绘（如游戏）。\n由于是位图，图形质量在缩放时可能会降低。\n\n\nSVG：\n\n在处理复杂图形时性能可能较差，尤其是当图形元素数量较多时。\n矢量图形在缩放时不会失去质量，适合需要高质量图形的场景。\n\n\n\n4. 文件大小\nCanvas：\n\n通常生成的图形是位图，文件大小取决于图像的分辨率和复杂度。\n\n\nSVG：\n\n由于是基于 XML 的文本格式，文件大小通常较小，尤其是对于简单图形。\n复杂图形可能导致文件大小增加，但仍然比位图小。\n\n\n\n5. 适用场景\nCanvas：\n\n适合游戏、动画、实时数据可视化等需要频繁更新的场景。\n适合处理大量像素数据的应用。\n\n\nSVG：\n\n适合图标、图表、静态图形和需要高质量缩放的场景。\n适合需要交互和动画的矢量图形。\n\n\n\n6. 示例\nCanvas 示例：\n\n&lt;canvas\n  id&#x3D;&quot;myCanvas&quot;\n  width&#x3D;&quot;400&quot;\n  height&#x3D;&quot;200&quot;\n  style&#x3D;&quot;border:1px solid #000000;&quot;\n&gt;&lt;&#x2F;canvas&gt;\n&lt;script&gt;\n  var canvas &#x3D; document.getElementById(&quot;myCanvas&quot;);\n  var ctx &#x3D; canvas.getContext(&quot;2d&quot;);\n  ctx.fillStyle &#x3D; &quot;#FF0000&quot;;\n  ctx.fillRect(20, 20, 150, 100);\n&lt;&#x2F;script&gt;\n\n\nSVG 示例：\n\n&lt;svg width&#x3D;&quot;400&quot; height&#x3D;&quot;200&quot;&gt;\n  &lt;rect x&#x3D;&quot;20&quot; y&#x3D;&quot;20&quot; width&#x3D;&quot;150&quot; height&#x3D;&quot;100&quot; fill&#x3D;&quot;red&quot; &#x2F;&gt;\n&lt;&#x2F;svg&gt;\n\n总结\nCanvas：适合动态、频繁更新的图形，使用位图渲染，性能较好，但不支持直接操作单个元素。\nSVG：适合静态和可缩放的图形，使用矢量渲染，支持直接操作和动画化单个元素，但在处理复杂图形时性能可能较差。\n\n根据具体需求选择合适的技术，可以更好地实现图形效果和用户体验。如果您有更多问题或需要进一步的解释，请随时问我！\nhead 标签有什么作用，其中什么标签必不可少？&lt;head&gt; 标签是 HTML 文档的一个重要部分，位于文档的开头，主要用于包含文档的元数据和其他信息。以下是 &lt;head&gt; 标签的主要作用及其中必不可少的标签：\n1. &lt;head&gt; 标签的作用\n元数据：包含关于文档的信息，如标题、字符集、描述、关键词等，这些信息不会直接显示在网页上，但对浏览器和搜索引擎非常重要。\n链接外部资源：可以链接外部样式表、脚本文件和其他资源，帮助网页实现样式和功能。\n设置文档的行为：可以通过 &lt;meta&gt; 标签设置文档的视口、兼容性等属性，影响网页在不同设备和浏览器中的表现。\n\n2. 必不可少的标签在 &lt;head&gt; 标签中，有几个标签是必不可少的，尤其是对于现代网页的基本结构：\n\n**&lt;title&gt;**：\n\n作用：定义文档的标题，显示在浏览器的标题栏或标签页上。\n示例：&lt;title&gt;我的网页标题&lt;&#x2F;title&gt;\n\n\n**&lt;meta charset=&quot;UTF-8&quot;&gt;**：\n\n作用：指定文档的字符编码，UTF-8 是一种常用的字符编码，支持多种语言字符。\n示例：&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\n\n\n这两个标签是构建 HTML 文档的基本要素，确保网页能够正确显示和被搜索引擎索引。\n3. 其他常用标签除了上述必不可少的标签，&lt;head&gt; 中还可以包含其他常用标签：\n\n**&lt;meta name=&quot;description&quot; content=&quot;网页描述&quot;&gt;**：提供网页的简短描述，搜索引擎通常会在搜索结果中显示这个描述。\n**&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;**：控制网页在移动设备上的布局和缩放。\n**&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;**：链接外部样式表。\n**&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;**：链接外部 JavaScript 文件。\n\n4. 示例以下是一个完整的 HTML 文档示例，展示了 &lt;head&gt; 标签的基本结构：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;这是一个示例网页。&quot; &#x2F;&gt;\n    &lt;title&gt;我的网页标题&lt;&#x2F;title&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;styles.css&quot; &#x2F;&gt;\n    &lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎来到我的网页&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n总结&lt;head&gt; 标签在 HTML 文档中起着至关重要的作用，包含了文档的元数据和外部资源链接。其中，&lt;title&gt; 和 &lt;meta charset=&quot;UTF-8&quot;&gt; 是必不可少的标签，确保网页的基本功能和正确显示。\n文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?1. 文档声明（Doctype）和 &lt;!DOCTYPE html&gt; 的作用文档声明（Doctype） 是 HTML 文档的第一行代码，用于告诉浏览器该文档使用的 HTML 或 XHTML 版本。&lt;!DOCTYPE html&gt; 是 HTML5 的文档声明，具有以下作用：\n\n指定文档类型：&lt;!DOCTYPE html&gt; 告诉浏览器该文档是 HTML5 格式，确保浏览器以正确的方式解析和渲染页面。\n启用标准模式：使用 &lt;!DOCTYPE html&gt; 可以使浏览器进入标准模式（Standards Mode），在这种模式下，浏览器会遵循 W3C 的标准来渲染页面，确保不同浏览器之间的表现一致。\n提高兼容性：通过明确指定文档类型，开发者可以确保网页在不同浏览器和设备上的兼容性，减少因浏览器解析差异而导致的显示问题。\n\n2. 严格模式与混杂模式的区分\n严格模式（Standards Mode）：\n\n在严格模式下，浏览器会遵循 W3C 的标准来渲染页面，确保页面的表现符合现代网页开发的最佳实践。\n严格模式下，某些过时的 HTML 和 CSS 特性将被忽略，开发者需要使用符合标准的代码。\n\n\n混杂模式（Quirks Mode）：\n\n在混杂模式下，浏览器会模拟旧版浏览器的行为，以兼容早期的网页设计。这种模式主要是为了支持旧版网页的显示。\n混杂模式下，浏览器可能会使用一些非标准的渲染规则，导致不同浏览器之间的表现不一致。\n\n\n\n3. 严格模式与混杂模式的意义\n严格模式的意义：\n\n提供一致的渲染行为，确保网页在不同浏览器中的表现一致。\n鼓励开发者使用符合标准的 HTML 和 CSS，提升网页的可维护性和可访问性。\n有助于提高网页的性能和安全性。\n\n\n混杂模式的意义：\n\n允许旧版网页在现代浏览器中继续正常显示，避免因标准的变化而导致的显示问题。\n为开发者提供了一个过渡期，使他们能够逐步更新和改进旧版网页。\n\n\n\n4. 示例以下是一个简单的 HTML5 文档示例，展示了如何使用 &lt;!DOCTYPE html&gt;：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;示例网页&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎来到我的网页&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n总结\n文档声明（Doctype） 是 HTML 文档的第一行代码，用于指定文档类型和启用标准模式。\n严格模式 和 混杂模式 的区别在于渲染行为和对标准的遵循程度，严格模式遵循 W3C 标准，而混杂模式则兼容旧版网页。\n使用 &lt;!DOCTYPE html&gt; 可以确保网页在现代浏览器中以标准模式渲染，从而提高网页的兼容性和一致性。\n\n浏览器乱码的原因是什么？如何解决？浏览器乱码通常是指网页内容无法正确显示，出现了不正常的字符或符号。这种情况通常是由于字符编码不匹配引起的。以下是浏览器乱码的常见原因及其解决方法：\n1. 乱码的原因\n字符编码不一致：\n\n网页的字符编码与浏览器解析时使用的字符编码不一致。例如，网页使用 UTF-8 编码，但浏览器却以 ISO-8859-1 编码解析。\n\n\n缺少字符集声明：\n\n网页没有在 &lt;head&gt; 部分声明字符集，导致浏览器无法正确识别字符编码。\n\n\n文件保存编码不一致：\n\nHTML 文件在保存时使用的编码与网页中声明的编码不一致。例如，文件以 UTF-8 编码保存，但在 HTML 中声明为 ISO-8859-1。\n\n\n服务器配置问题：\n\n服务器未正确设置响应头中的字符编码，导致浏览器无法正确解析内容。\n\n\n\n2. 解决方法2.1 声明字符集确保在 HTML 文档的 &lt;head&gt; 部分正确声明字符集，通常使用 UTF-8 编码：\n&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\n2.2 确保文件保存编码一致在保存 HTML 文件时，确保使用与声明的字符集一致的编码格式。大多数现代文本编辑器（如 VSCode、Sublime Text 等）都支持选择文件编码。\n2.3 服务器配置确保服务器正确设置响应头中的字符编码。例如，在 Apache 服务器中，可以在 .htaccess 文件中添加以下行：\nAddDefaultCharset UTF-8\n\n在 Nginx 服务器中，可以在配置文件中添加：\ncharset utf-8;\n\n2.4 检查浏览器设置在某些情况下，用户的浏览器设置可能会影响字符编码的解析。可以尝试手动设置浏览器的字符编码为 UTF-8，通常在浏览器的“查看”或“编码”菜单中可以找到相关选项。\n3. 总结浏览器乱码通常是由于字符编码不一致引起的。通过在 HTML 文档中正确声明字符集、确保文件保存编码一致、配置服务器响应头以及检查浏览器设置，可以有效解决乱码问题。使用 UTF-8 编码是现代网页开发的最佳实践，能够支持多种语言字符，减少乱码的可能性。\n渐进增强和优雅降级之间的区别渐进增强（Progressive Enhancement）和优雅降级（Graceful Degradation）是两种不同的网页设计和开发策略，它们的目标都是为了提高用户体验，但实现方式有所不同。以下是这两者之间的主要区别：\n1. 渐进增强（Progressive Enhancement）\n定义：渐进增强是一种从基础功能开始构建网页的策略，首先确保所有用户都能访问到核心内容和功能，然后在此基础上逐步添加更高级的功能和样式，以提升用户体验。\n实现方式：\n基础内容：首先提供基本的 HTML 内容，确保在所有浏览器和设备上都能正常显示。\n增强功能：在此基础上，使用 CSS 和 JavaScript 添加样式和交互功能，针对支持这些技术的浏览器进行优化。\n\n\n优点：\n确保所有用户都能访问到核心内容，无论他们使用的设备或浏览器的能力如何。\n提高了无障碍性，确保即使在不支持高级功能的环境中，用户也能获得良好的体验。\n\n\n\n2. 优雅降级（Graceful Degradation）\n定义：优雅降级是一种从完整功能开始构建网页的策略，首先为现代浏览器和设备提供丰富的功能和样式，然后确保在较旧或不支持的浏览器中仍能保持基本的可用性。\n\n实现方式：\n\n完整功能：首先开发一个功能丰富的网页，使用最新的 HTML、CSS 和 JavaScript 特性。\n降级处理：在较旧或不支持的浏览器中，提供替代方案或简化版本，以确保基本功能仍然可用。\n\n\n优点：\n\n可以充分利用现代浏览器的功能，提供丰富的用户体验。\n在设计时考虑到向后兼容性，确保在较旧的环境中仍能正常工作。\n\n\n\n3. 主要区别\n\n\n特点\n渐进增强（Progressive Enhancement）\n优雅降级（Graceful Degradation）\n\n\n\n开发策略\n从基础功能开始，逐步增强\n从完整功能开始，逐步降级\n\n\n核心内容\n确保所有用户都能访问核心内容\n以现代浏览器为目标，确保基本可用性\n\n\n用户体验\n所有用户都能获得良好体验\n现代用户获得最佳体验，旧用户获得基本体验\n\n\n无障碍性\n更加注重无障碍性\n可能忽视较旧设备的用户体验\n\n\n4. 总结\n渐进增强 强调从基础开始，确保所有用户都能访问核心内容，然后逐步添加增强功能，适合关注无障碍性和兼容性的项目。\n优雅降级 强调从完整功能开始，确保现代用户获得最佳体验，同时考虑到较旧环境的兼容性，适合需要充分利用现代技术的项目。\n\n选择哪种策略取决于项目的需求、目标用户群体和技术栈。理解这两者的区别有助于开发者在设计和开发网页时做出更合适的决策。\n说一下 HTML5 drag APIHTML5 Drag API 是一组用于实现拖放功能的接口，允许用户通过拖动元素来进行交互。这个 API 提供了一种简单的方法来处理拖放操作，使得网页应用程序能够更直观地与用户进行交互。以下是对 HTML5 Drag API 的详细介绍，包括其工作原理、主要事件和使用示例。\n1. 工作原理HTML5 Drag API 主要依赖于以下几个步骤：\n\n可拖动元素：通过设置 draggable 属性为 true，使元素可被拖动。\n拖动事件：在拖动过程中，浏览器会触发一系列事件，开发者可以通过这些事件来处理拖放操作。\n放置目标：在目标元素上处理放置操作，允许用户将拖动的元素放置到指定位置。\n\n2. 主要事件HTML5 Drag API 定义了一些重要的事件，开发者可以通过这些事件来处理拖放操作：\n\ndragstart：当用户开始拖动元素时触发。可以在此事件中设置拖动的数据。\ndrag：在拖动过程中持续触发，通常用于更新拖动效果。\ndragend：当拖动操作结束时触发，无论是成功放置还是取消。\ndragover：当拖动的元素在放置目标上方时触发。需要调用 event.preventDefault() 来允许放置。\ndragenter：当拖动的元素进入放置目标区域时触发。\ndragleave：当拖动的元素离开放置目标区域时触发。\ndrop：当拖动的元素被放置到目标区域时触发。\n\n3. 使用示例以下是一个简单的示例，展示了如何使用 HTML5 Drag API 实现拖放功能：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;HTML5 Drag API 示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      #dragItem &#123;\n        width: 100px;\n        height: 100px;\n        background-color: lightblue;\n        margin: 10px;\n        cursor: move;\n      &#125;\n      #dropZone &#123;\n        width: 300px;\n        height: 300px;\n        border: 2px dashed #ccc;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;dragItem&quot; draggable&#x3D;&quot;true&quot;&gt;拖动我&lt;&#x2F;div&gt;\n    &lt;div id&#x3D;&quot;dropZone&quot;&gt;放置区域&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const dragItem &#x3D; document.getElementById(&quot;dragItem&quot;);\n      const dropZone &#x3D; document.getElementById(&quot;dropZone&quot;);\n\n      &#x2F;&#x2F; 处理 dragstart 事件\n      dragItem.addEventListener(&quot;dragstart&quot;, (event) &#x3D;&gt; &#123;\n        event.dataTransfer.setData(&quot;text&#x2F;plain&quot;, &quot;这是拖动的数据&quot;);\n        event.target.style.opacity &#x3D; 0.5; &#x2F;&#x2F; 拖动时改变透明度\n      &#125;);\n\n      &#x2F;&#x2F; 处理 dragend 事件\n      dragItem.addEventListener(&quot;dragend&quot;, (event) &#x3D;&gt; &#123;\n        event.target.style.opacity &#x3D; 1; &#x2F;&#x2F; 恢复透明度\n      &#125;);\n\n      &#x2F;&#x2F; 处理 dragover 事件\n      dropZone.addEventListener(&quot;dragover&quot;, (event) &#x3D;&gt; &#123;\n        event.preventDefault(); &#x2F;&#x2F; 允许放置\n      &#125;);\n\n      &#x2F;&#x2F; 处理 drop 事件\n      dropZone.addEventListener(&quot;drop&quot;, (event) &#x3D;&gt; &#123;\n        event.preventDefault(); &#x2F;&#x2F; 防止默认行为\n        const data &#x3D; event.dataTransfer.getData(&quot;text&#x2F;plain&quot;);\n        alert(&#96;放置了: $&#123;data&#125;&#96;);\n      &#125;);\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结HTML5 Drag API 提供了一种简单而强大的方式来实现拖放功能。通过设置 draggable 属性和处理相关事件，开发者可以创建直观的用户交互体验。这个 API 在现代网页应用中非常有用，尤其是在需要用户自定义布局或交互的场景中。\n","slug":"interview-html","date":"2024-12-22T10:43:24.000Z","categories_index":"interview","tags_index":"html","author_index":"X-29"},{"id":"6d1a44d72f500b2ae165cfd01771a531","title":"rollup","content":"rollup前端工程化历程\n除屑优化(tree shaking)除了可以使用 ES 模块之外，Rollup 还可以静态分析你导入的代码，并将排除任何实际上没有使用的内容，从上面的引入和最后的打包结果就可以看到，没有使用到的内容直接被删除了。\n\n\n\n\n\n\n\n\n\n注意，除屑优化的核心思想是在编译阶段通过静态分析确定代码的使用情况，而不是在运行时。\n所以除屑优化一般是建立在ES6 模块化语法基础之上的，ESM 的导入导出是静态的。\nCommonJS 模块的导入和导出是动态的，无法在编译阶段静态确定代码的使用情况。一般情况下，除屑优化工具无法在 CommonJS 模块中进行精确的除屑，因为无法静态分析模块间的导入和导出关系。\n然而，一些构建工具（如 Webpack）会尝试通过静态分析和启发式方法对 CommonJS 模块进行近似的除屑优化。它们会尽可能地识别出那些可以在编译阶段确定未被使用的代码，并进行剔除。但这种处理方式可能不如对 ES6 模块的优化效果好，且有一定的限制。\n除屑优化的原理：\n\n静态分析：对 JavaScript 代码进行静态分析，识别出模块的导入和导出关系。\n标记未使用代码：标记出在导入和导出关系上没有被使用的代码。这些代码可能是模块的导出函数、变量、类等。\n剔除未使用代码：根据标记结果，构建工具会将未被使用的代码从最终的打包结果中剔除，只保留被使用的部分。\n\n由于是静态分析，所以我们在写代码的时候，需要注意自己的写法，简单来说，尽量的使用最小导入，比如你可以比较一下我们这里导入代码之后，打包的区别：\n&#x2F;&#x2F; 直接默认导入整个对象\nimport util from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; util.getRandomNum(1, 10)\nconsole.log(r)\n​\n&#x2F;&#x2F; 具名导入具体的函数\nimport &#123; getRandomNum &#125; from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; getRandomNum(1, 10)\nconsole.log(r)\n\n与 webpack 打包的区别这个打包结果其实就已经和我们熟知的webpack有了很鲜明的区别，我们把 webpack 安装一下试试\npnpm add webpack webpack-cli -D\n\n运行 webpack-cli：\n# --entry 入口文件 -o 打包文件夹位置 --mode 打包模式\nnpx webpack --entry .&#x2F;src&#x2F;index.js -o dist --mode development\n\n当然我们可以选择生成模式进行打包\nnpx webpack --entry .&#x2F;src&#x2F;index.js -o dist --mode production\n\n(() &#x3D;&gt; &#123;\n  &quot;use strict&quot;;\n  const o &#x3D;\n    ((t &#x3D; 1),\n    (a &#x3D; 10),\n    (t &#x3D; Math.ceil(t)),\n    (a &#x3D; Math.floor(a)),\n    Math.floor(Math.random() * (a - t + 1)) + t);\n  var t, a;\n  console.log(o);\n&#125;)();\n\n现在打包出来的内容就直接是压缩之后的代码了\n配置文件Rollup配置文件是一个 ES 模块。通常，它被称为 rollup.config.js 或 rollup.config.mjs，并位于项目的根目录中。它导出一个默认对象，其中包含所需的选项：\n\n\n\n\n\n\n\n\n\n注意 : 如果想要类型提示，请在 rollup.config.js 文件顶部添加以下代码：\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\n\nexport default &#123;\n  input: &quot;src&#x2F;index.js&quot;,\n  output: &#123;\n    file: &quot;dist&#x2F;bundle.js&quot;,\n    format: &quot;esm&quot;,\n  &#125;,\n&#125;;\n\n\n\n\n\n\n\n\n\n\n注意：nodejs 环境下要运行 esm 模块化的内容，要么文件名后缀处理为 .mjs，要么 package.json 文件中配置 “type”:”module” ，因为 Rollup 将遵循 Node ESM 语义。\n常用配置多产物配置我们可以将 output 改造成一个数组，对外暴露出不同格式的产物供他人使用，不仅包括 ESM，也需要包括诸如CommonJS、UMD等格式，保证良好的兼容性\nimport &#123; defineConfig &#125; from &quot;rollup&quot;;\n\nexport default defineConfig(&#123;\n  input: &quot;src&#x2F;index.js&quot;,\n  output: [\n    &#123;\n      file: &quot;dist&#x2F;bundle-iife.js&quot;,\n      format: &quot;iife&quot;,\n    &#125;,\n    &#123;\n      file: &quot;dist&#x2F;bundle-esm.js&quot;,\n      format: &quot;esm&quot;,\n    &#125;,\n    &#123;\n      file: &quot;dist&#x2F;bundle-cjs.js&quot;,\n      format: &quot;cjs&quot;,\n    &#125;,\n    &#123;\n      file: &quot;dist&#x2F;bundle-umd.js&quot;,\n      format: &quot;umd&quot;,\n      name: &quot;bundle&quot;,\n    &#125;,\n  ],\n&#125;);\n\n多入口配置除了多产物配置，Rollup 中也支持多入口配置\nmain.js\n&#x2F;&#x2F; src&#x2F;main.js\nimport util from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; util.getRandomNum(1, 10);\nconsole.log(&quot;🚀 ~ r:&quot;, r);\n\nconst obj &#x3D; &#123;\n  a: 1,\n  b: &#123;\n    c: 3,\n  &#125;,\n&#125;;\nconst cloneObj &#x3D; util.deepClone(obj);\ncloneObj.b.c &#x3D; 4;\nconsole.log(&quot;🚀 ~ obj:&quot;, obj);\nconsole.log(&quot;🚀 ~ cloneObj:&quot;, cloneObj);\n\nrollup.config.js\nimport &#123; defineConfig &#125; from &#39;rollup&#39;\n\nexport default defineConfig(&#123;\n  input: [&#39;src&#x2F;index.js&#39;,&#39;src&#x2F;main.js&#39;],\n  output: [\n    &#123;\n      dir: &#39;dist&#39;,\n      format: &#39;cjs&#39;\n    &#125;\n  ],\n&#125;)\n\n通常情况下多产物和多入口两者会被结合起来使用\nimport &#123; defineConfig &#125; from &#39;rollup&#39;\nexport default defineConfig(&#123;\n  input: [&#39;src&#x2F;index.js&#39;,&#39;src&#x2F;main.js&#39;],\n  output: [\n    &#123;\n      dir: &#39;cjs&#39;,\n      format: &#39;cjs&#39;\n    &#125;,\n    &#123;\n      dir: &#39;esm&#39;,\n      format: &#39;esm&#39;\n    &#125;\n  ],\n&#125;)\n\n当然，上面这样的写的话，生成的产物会把两个入口一起进行构建，我们可能的想法是一个入口一种构建方式：\nimport &#123; defineConfig &#125; from &#39;rollup&#39;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;umd&#x2F;&#39;,\n    format: &#39;umd&#39;,\n    name: &#39;bundle&#39;\n  &#125;\n&#125;\n\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: &#39;src&#x2F;main.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\nexport default [buildIndexOptions, buildMainOptions];\n\n动态导入与默认代码分割使用路由来说明懒加载是大家喜闻乐见的方式，估计大多数同学对于懒加载都只是停留在路由的懒加载，其实，任何时候，我们都可以使用 import 动态懒加载的方式。重新编辑一下 main.js 入口：\n&#x2F;&#x2F; src&#x2F;main.js\nfunction run() &#123;\n  &#x2F;&#x2F; 如果不清楚import动态导入返回的是什么，可以先打印一下下面结果\n  &#x2F;&#x2F; import(&quot;.&#x2F;util.js&quot;).then(chunk &#x3D;&gt; console.log(&quot;🚀 ~ chunk:&quot;, chunk));\n\n  import(&quot;.&#x2F;util.js&quot;).then((&#123; default: foo &#125;) &#x3D;&gt; &#123;\n    const r &#x3D; foo.getRandomNum(1, 10);\n    console.log(&quot;🚀 ~ r:&quot;, r);\n  &#125;);\n&#125;\nrun();\n\n重新运行可以看到 dist 目录形成了下面的结构:\n.\n├── dist\n│ ├── esm\n│ │ ├── main.js\n│ │ └── util-371e3ef9.js\n│ └── umd\n│     └── index.js\n└── ...\n\nRollup 将使用动态导入创建一个仅在需要时加载的单独块。所以你可以看到这里多了一个util-371e3ef9.js的文件\n\n\n\n\n\n\n\n\n\n注意： 为了让 Rollup 知道在哪里放置第二个块，我们不使用 --file 选项，而是使用 --dir 选项设置一个输出文件夹\n其中，util-371e3ef9.js是自动生成的chunk-[hash].js的名字，[hash] 是基于内容的哈希字符串。你可以通过指定 output.chunkFileNames (chunk 文件)和 output.entryFileNames (打包入口文件)选项来提供自己的命名模式。\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: &#39;src&#x2F;main.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\n\n而且，很智能的是，如果这个时候，我定义了又多个入口点都调用了util.js文件，会自动的引入分割出来的文件\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: [&#39;src&#x2F;main.js&#39;, &#39;src&#x2F;main2.js&#39;],\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\n\n在打包后的 main2.js 中，可以看到这样的引用：\nimport util from &quot;.&#x2F;chunk-util-371e3ef9.js&quot;;\n\n使用插件到目前为止，我们已经用入口文件和通过相对路径导入的模块打了一个简单的包。随着你需要打包更复杂的代码，通常需要更灵活的配置，例如导入使用 NPM 安装的模块、使用 Babel 编译代码、处理 JSON 文件等等。\n插件列表 ： the Rollup Awesome List。\n@rollup&#x2F;plugin-node-resolve比如我们现在引入 lodash-es 库\npnpm add lodash-es -D\n\n在 index.js 中使用\nimport &#123; chunk &#125; from &quot;lodash-es&quot;;\nconst r &#x3D; chunk([1, 2, 3, 4], 2);\nconsole.log(&quot;🚀 ~ r:&quot;, r);\n\n现在直接打包\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\nexport default buildIndexOptions\n\n会出现下面的警告：\nsrc&#x2F;index.js → dist&#x2F;esm&#x2F;...\n(!) Unresolved dependencies\nhttps:&#x2F;&#x2F;rollupjs.org&#x2F;troubleshooting&#x2F;#warning-treating-module-as-external-dependency\nlodash-es (imported by &quot;src&#x2F;index.js&quot;)\ncreated dist&#x2F;esm&#x2F; in 13ms\n\n意思是，不能解析lodash-es这个依赖，报出了警告，问你是不是需要external，并提示你点击链接有这个警告的解释。当我们点击这个链接，按照提示解决这个 external 警告问题，很简单，就加上 external，也就是把lodash-es这个库给排除出去\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n+  external: [&#39;lodash-es&#39;]\n&#125;\nexport default buildIndexOptions\n\n再此打包，果然没警告了，而且我们在 nodejs 环境中确实也能正常运行了\n\n\n\n\n\n\n\n\n\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n重要的事情说三遍，这里虽然看似一个很小的问题，但是却有很多基本理论点\n1、rollup 默认只能解析导入的相对路径，也就是/ ， ./或者../开头的路径，对于bare import，也就是import &#123; chunk &#125; from &#39;lodash-es&#39;;这种直接导入的第三方包的格式，并不支持\n2、rollup相比webpack最大的优势并不是构建一个足够大的应用打包，大多是情况下，我们使用rollup用来构建工具库，因此，这里导入的lodash-es并没有报错，而仅仅报出警告，因为rollup认为lodash-es这个库并没有加入构建，那么你的意思是将来用作第三方库来使用，因此将lodash-es使用配置external排除掉就好。\n3、lodash-es这个包本身就是支持 ESM 的\n4、最后打包好的index.js文件只所以在nodejs环境下运行，是因为nodejs可以帮我们解析bare import，我们可以试着将index.js放入到html文件中运行，你就可以看到其中的问题所在，在 html 环境中就会报错了：index.html:1 Uncaught TypeError: Failed to resolve module specifier &quot;lodash-es&quot;. Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;.\n如果希望在最后的打包中，将lodash-es内容解析打包进去，就可以使用@rollup/plugin-node-resolve\n安装:\npnpm add @rollup&#x2F;plugin-node-resolve --save-dev\n\n使用：\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [nodeResolve()]\n  &#x2F;&#x2F; external: [&#39;lodash-es&#39;]\n&#125;\nexport default buildIndexOptions\n\n现在，再此进行打包，无论是打包时间，还是打包内容和之前都很不一样了，把lodash-es中，关于chunk()函数的内容，都打包进了index.js文件中\noutput.manualChunks上面讲了对于动态加载模块，rollup 帮我们自动做了代码分割，其实我们也可以手动的操作，直接在 rollup 配置中声明\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    manualChunks: &#123;\n      &#39;lodash-es&#39;: [&#39;lodash-es&#39;],\n    &#125;\n    &#x2F;&#x2F;也可以是函数形式\n    &#x2F;&#x2F; manualChunks(id)&#123;\n    &#x2F;&#x2F;   if(id.includes(&#39;lodash-es&#39;))&#123;\n    &#x2F;&#x2F;     return &#39;lodash-es&#39;\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F; &#125;\n\t&#125;,\n  plugins: [nodeResolve()]\n&#125;\n\n@rollup&#x2F;plugin-commonjs上面最开始导入lodash-es，没有加入external和plugins，之所以还能直接运行，还因为lodash-es本身就是支持 ESM 的，因为 rollup 默认并不支持 Commonjs 模块化，比如将 lodash-es 换位 lodash，马上就能看到不一样的效果,直接打包失败\n[!] RollupError: &quot;chunk&quot; is not exported by &quot;node_modules&#x2F;.pnpm&#x2F;lodash@4.17.21&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js&quot;, imported by &quot;src&#x2F;index.js&quot;.\nhttps:&#x2F;&#x2F;rollupjs.org&#x2F;troubleshooting&#x2F;#error-name-is-not-exported-by-module\n\n这个错误在官网上解释的很清楚了，无非就是 commonjs 没有这种导出，因此我们需要@rollup/plugin-commonjs帮我们处理 commonjs 模块化的问题\n安装:\npnpm add @rollup&#x2F;plugin-commonjs --save-dev\n\n使用:\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\n+import commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n+  plugins: [nodeResolve(), commonjs()]\n&#125;\nexport default buildIndexOptions\n\n@rollup&#x2F;plugin-babel使用 Babel 来使用尚未被浏览器和 Node.js 支持的最新 JavaScript 特性。\n使用 Babel 和 Rollup 最简单的方法是使用 @rollup&#x2F;plugin-babel\n安装:\npnpm add @rollup&#x2F;plugin-babel -D\n\n使用：\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\n+import babel from &#39;@rollup&#x2F;plugin-babel&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n+    babel(&#123; babelHelpers: &#39;bundled&#39; &#125;)\n  ]\n&#125;\nexport default buildIndexOptions\n\n不过这么做之后，打包代码并不会有什么变化，因为我们都知道 babel 是需要预设的.\n安装 babel-core 和 env 预设\npnpm add -D @babel&#x2F;core @babel&#x2F;preset-env\n\n在 Babel 实际编译代码之前，需要进行配置。在项目根目录创建一个名为 .babelrc.json 的新文件\n&#123;\n  &quot;presets&quot;: [&quot;@babel&#x2F;preset-env&quot;]\n&#125;\n\n具体的 babel 设置，可以参考babel 文档\n题外话：@babel&#x2F;runtime我们在index.js代码中加入如下的 api\nimport &#123; getRandomNum &#125; from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; getRandomNum(1, 10);\nconsole.log(r);\n\nconst arr &#x3D; [1, 2, 3, 4].map((item) &#x3D;&gt; item * item);\nconsole.log(&quot;🚀 ~ arr:&quot;, arr);\n\nPromise.resolve(1).then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);\n\n我们通过 babel 处理之后会发现一些问题：\n@babel&#x2F;preset-env 只转换了语法，也就是我们看到的箭头函数、const 一类，但是对于进一步需要转换内置对象、实例方法等等 API，就显得无能为力了，这些代码需要polyfill(兼容性垫片) 。所以这个我需要@babel/runtime来帮我们处理。\n@babel/runtime是一个核心， 一种实现方式，但是在实现 polyfill 垫片的过程中，可能会产生很多重复的代码，所以需要@babel/plugin-transform-runtime防止污染全局， 抽离公共的 helper function , 防止冗余，当然在处理 polyfill 的时候，我们还需要 core-js 的辅助，基于 babel，我们可以使用@babel/runtime-corejs3\n安装：\npnpm add @babel&#x2F;plugin-transform-runtime -D\npnpm add @babel&#x2F;runtime @babel&#x2F;runtime-corejs3\n\n要使用@babel/plugin-transform-runtime，@rollup/plugin-babel的babelHelper处理必须改为 runtime\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\nimport babel from &#39;@rollup&#x2F;plugin-babel&#39;;\nimport typescript from &#39;@rollup&#x2F;plugin-typescript&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n    babel(&#123;\n      babelHelpers: &#39;runtime&#39;,\n      include: &#39;src&#x2F;**&#39;,\n      exclude: &#39;node_modules&#x2F;**&#39;,\n      extensions:[&#39;.js&#39;, &#39;.ts&#39;]\n    &#125;),\n    typescript(),\n  ]\n&#125;\nexport default buildIndexOptions\n\n.babelrc.json：\n&#123;\n  &quot;presets&quot;: [\n    [\n      &quot;@babel&#x2F;preset-env&quot;,\n      &#123;\n        &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;,\n        &quot;useBuiltIns&quot;: &quot;usage&quot;,\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ],\n  &quot;plugins&quot;: [\n    [\n      &quot;@babel&#x2F;plugin-transform-runtime&quot;,\n      &#123;\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ]\n&#125;\n\n这个时候你再进行构建，会发现打包后的文件多出了一大堆，这其实就是 polyfill 中的代码。\n@rollup&#x2F;plugin-typescript要使用 typescript 就需要依赖这个插件，当然这个插件本身还依赖了typescript和tslib，因此我们需要导入 3 个包\npnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\nutil.ts\n&#x2F;**\n * 深拷贝\n * @param obj 需要深拷贝的对象\n * @returns 深拷贝对象\n *&#x2F;\nexport const deepClone &#x3D; &lt;T&gt;(obj: T): T &#x3D;&gt; &#123;\n  if (typeof obj !&#x3D;&#x3D; &quot;object&quot; || obj &#x3D;&#x3D;&#x3D; null) &#123;\n    return obj;\n  &#125;\n  const result: any &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\n  for (let key in obj) &#123;\n    if (obj.hasOwnProperty(key)) &#123;\n      result[key] &#x3D; deepClone(obj[key]);\n    &#125;\n  &#125;\n  return result;\n&#125;;\n\nexport const getRandomNum &#x3D; (min: number, max: number): number &#x3D;&gt; &#123;\n  let num &#x3D; Math.floor(Math.random() * (min - max) + max);\n  return num;\n&#125;;\n\nIndex.ts\nimport &#123; getRandomNum,deepClone &#125; from &#39;.&#x2F;util.ts&#39;;\nconst r &#x3D; getRandomNum(1, 10);\nconsole.log(r);\n\nconst obj &#x3D; &#123; a: 1, b: &#123; c: 3 &#125; &#125;;\nconst obj2 &#x3D; deepClone(obj);\nobj2.b.c &#x3D; 4;\n\nconsole.log(obj);\nconsole.log(obj2);\n\n当然，配置文件我们也完全可以是 ts 的\nrollup.config.ts\nimport &#123; RollupOptions &#125; from &quot;rollup&quot;\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\nimport babel from &#39;@rollup&#x2F;plugin-babel&#39;;\nimport typescript from &#39;@rollup&#x2F;plugin-typescript&#39;;\n\nconst config: RollupOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.ts&#39;,\n  output: &#123;\n    file: &#39;dist&#x2F;umd&#x2F;index.js&#39;,\n    format: &#39;umd&#39;,\n    name: &#39;rollupDemo&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n    babel(&#123;\n      babelHelpers: &#39;runtime&#39;,\n      include: &#39;src&#x2F;**&#39;,\n      exclude: &#39;node_modules&#x2F;**&#39;,\n      extensions:[&#39;.js&#39;, &#39;.ts&#39;]\n    &#125;),\n    typescript(),\n  ],\n&#125;\nexport default config;\n\ntsconfig.json\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;esnext&quot;,\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;],\n    &quot;skipLibCheck&quot;: true,\n\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;noEmit&quot;: true,\n    &quot;allowImportingTsExtensions&quot;: true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;, &quot;rollup.config.ts&quot;]\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意： 别忘记 tsconfig.json 文件中需要加入 rollup.config.ts 配置文件,不然要报错\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    ......\n  &#125;,\n+  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;rollup.config.ts&quot;],\n&#125;\n\n运行：\nnpx rollup -c rollup.config.ts --configPlugin typescript\n\n构建 react 应用node_modules# react\npnpm add react react-dom\n\n# @types&#x2F;react\npnpm add @types&#x2F;react @types&#x2F;react-dom -D\n\n# react预设\npnpm add @babel&#x2F;preset-react -D\n\n# rollup\npnpm add rollup -D\n\n# rollup常规插件\npnpm add @rollup&#x2F;plugin-node-resolve @rollup&#x2F;plugin-commonjs -D\n\n# typescript相关\npnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\n# @rollup&#x2F;plugin-babel相关\npnpm add @rollup&#x2F;plugin-babel @babel&#x2F;core @babel&#x2F;preset-env -D\n\n# @babel&#x2F;runtime相关\npnpm add @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime @babel&#x2F;runtime-corejs3 -D\n\n# html文件模板\npnpm add rollup-plugin-generate-html-template -D\n\n# 替换字符串\npnpm add @rollup&#x2F;plugin-replace -D\n\n# 开发服务器与live server\npnpm add rollup-plugin-serve rollup-plugin-livereload -D\n\n# clear插件\npnpm add rollup-plugin-clear -D\n\n# scss\npnpm add rollup-plugin-scss sass -D\n\n# postcss\npnpm add postcss rollup-plugin-postcss -D\n\n# 图片处理\npnpm add @rollup&#x2F;plugin-image -D\n\n# nodejs typescript类型\npnpm add @types&#x2F;node -D\n\n# 别名插件\npnpm add @rollup&#x2F;plugin-alias -D\n\n# terser\npnpm add @rollup&#x2F;plugin-terser -D\n\n# visualizer\npnpm add rollup-plugin-visualizer -D\n\ntsconfig.json&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;esnext&quot;,\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;],\n    &quot;skipLibCheck&quot;: true,\n\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;noEmit&quot;: true,\n    &quot;allowImportingTsExtensions&quot;: true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;jsx&quot;: &quot;preserve&quot;,\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;,\n    &quot;paths&quot;: &#123;\n      &quot;@&#x2F;*&quot;: [&quot;src&#x2F;*&quot;]\n    &#125;\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;, &quot;rollup.config.ts&quot;, &quot;global.d.ts&quot;]\n&#125;\n\n.babelrc.json&#123;\n  &quot;presets&quot;: [\n    [\n      &quot;@babel&#x2F;preset-env&quot;,\n      &#123;\n        &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;,\n        &quot;useBuiltIns&quot;: &quot;usage&quot;,\n        &quot;corejs&quot;: 3\n      &#125;\n    ],\n    [&quot;@babel&#x2F;preset-react&quot;]\n  ],\n  &quot;plugins&quot;: [\n    [\n      &quot;@babel&#x2F;plugin-transform-runtime&quot;,\n      &#123;\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ]\n&#125;\n\nrollup.config.tsimport &#123; RollupOptions &#125; from &quot;rollup&quot;;\nimport &#123; nodeResolve &#125; from &quot;@rollup&#x2F;plugin-node-resolve&quot;;\nimport commonjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\nimport babel from &quot;@rollup&#x2F;plugin-babel&quot;;\nimport typescript from &quot;@rollup&#x2F;plugin-typescript&quot;;\nimport htmlTemplate from &quot;rollup-plugin-generate-html-template&quot;;\nimport serve from &quot;rollup-plugin-serve&quot;;\nimport livereload from &quot;rollup-plugin-livereload&quot;;\nimport replace from &quot;@rollup&#x2F;plugin-replace&quot;;\nimport postcss from &quot;rollup-plugin-postcss&quot;;\nimport alias from &quot;@rollup&#x2F;plugin-alias&quot;;\nimport clear from &quot;rollup-plugin-clear&quot;;\nimport image from &quot;@rollup&#x2F;plugin-image&quot;\nimport terser from &#39;@rollup&#x2F;plugin-terser&#39;;\nimport &#123; fileURLToPath &#125; from &quot;node:url&quot;;\nimport &#123; visualizer &#125; from &quot;rollup-plugin-visualizer&quot;;\n\nconst config: RollupOptions &#x3D; &#123;\n  input: &quot;src&#x2F;main.tsx&quot;,\n  output: &#123;\n    dir: &quot;dist&#x2F;&quot;,\n    format: &quot;esm&quot;,\n    name: &quot;rollupDemo&quot;,\n    sourcemap: true,\n    plugins: [terser()],\n    entryFileNames: &quot;[name].[hash:6].js&quot;,\n    chunkFileNames: &quot;chunks&#x2F;chunk-[name]-[hash].js&quot;,\n    &#x2F;&#x2F; 代码分割\n    &#x2F;&#x2F; manualChunks: &#123;\n    &#x2F;&#x2F;   react: [&quot;react&quot;, &quot;react-dom&quot;]\n    &#x2F;&#x2F; &#125;,\n    globals: &#123;\n      react: &quot;React&quot;,\n      &quot;react-dom&quot;: &quot;ReactDOM&quot;,\n    &#125;,\n    paths: &#123;\n      react: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;react@18.2.0&#x2F;+esm&quot;,\n      &quot;react-dom&quot;: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;react-dom@18.2.0&#x2F;+esm&quot;,\n    &#125;\n  &#125;,\n  external: [&quot;react&quot;, &quot;react-dom&quot;],\n  plugins: [\n    visualizer(),\n    nodeResolve(&#123;\n      extensions: [&quot;.js&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;],\n    &#125;),\n    commonjs(),\n    typescript(),\n    babel(&#123;\n      babelHelpers: &quot;runtime&quot;,\n      include: &quot;src&#x2F;**&quot;,\n      exclude: &quot;node_modules&#x2F;**&quot;,\n      extensions: [&quot;.js&quot;, &quot;.ts&quot;, &quot;jsx&quot;, &quot;tsx&quot;],\n    &#125;),\n    alias(&#123;\n      entries: [\n        &#123;\n          find: &quot;@&quot;,\n          replacement: fileURLToPath(new URL(&quot;src&quot;, import.meta.url)),\n        &#125;,\n      ],\n    &#125;),\n    postcss(&#123;\n      extensions: [&quot;.js&quot;], &#x2F;&#x2F; 将scss解析成css\n      extract: true,\n      modules: true,\n    &#125;),\n    replace(&#123;\n      preventAssignment: true,\n      &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;), &#x2F;&#x2F; 否则会报：process is not defined的错\n    &#125;),\n    clear(&#123;\n      targets: [&quot;dist&quot;],\n    &#125;),\n    htmlTemplate(&#123;\n      template: &quot;public&#x2F;index.html&quot;,\n      target: &quot;dist&#x2F;index.html&quot;,\n      attrs: [&#39;type&#x3D;&quot;module&quot;&#39;],\n    &#125;),\n    image(),\n    serve(&quot;dist&quot;),\n    livereload(&quot;src&quot;),\n  ],\n&#125;;\nexport default config;\n\nnpm 发包npm 发布node_modules# rollup\npnpm add rollup -D\n\n# rollup常规插件\npnpm add @rollup&#x2F;plugin-node-resolve @rollup&#x2F;plugin-commonjs -D\n\n# typescript相关\npnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\n# @rollup&#x2F;plugin-babel相关\npnpm add @rollup&#x2F;plugin-babel @babel&#x2F;core @babel&#x2F;preset-env -D\n\n# lodash-es\npnpm add lodash-es\n\n# @types&#x2F;lodash-es\npnpm add @types&#x2F;lodash-es -D\n\ntsconfig.json 文件&#x2F;&#x2F; tsconfig.json\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;declaration&quot;: true,&#x2F;&#x2F; 根据ts文件自动生成.d.ts声明文件和js文件\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只输出.d.ts声明文件，不生成js文件\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 输出目录\n\t\t......\n  &#125;\n&#125;\n\n本地调试 link 安装最终打包的文件夹是 dist 文件夹，我们可以把 package.json 文件和 README.md 文件都拷贝到 dist 目录中。\nnpm link 地址其实就是全局安装地址：\nmac: /usr/local/lib/node_modules/\nWindows: c:\\用户(Users)\\你的用户名\\AppData(隐藏文件夹)\\Roaming\\npm\\node_modules\npnpm link\n在库文件的 dist 目录下执行：\npnpm link --global\n\n这个命令会读取 package.json 文件中的 name，作为包文件的名字，你可以理解为，相当于 pnpm 将我们打包的项目，全局安装在了本地\n在目标项目中，使用命令\npnpm link --global 包名\n\n进行安装。\n卸载 link pnpm unlink\n发布到 npm常用命令：\n\nnpm whoami 检测当前登录状态\nnpm config ls 显示当前 npm 配置信息\nnpm addUser 、npm login 登录\nnpm config set registry 链接地址 切换源地址\nnpm publish 发布\n\n\n\n\n\n\n\n\n\n\n注意必须使用 npm 源镜像才能发布，如果使用的是阿里源等镜像，需要切换成源镜像才能发布 https://registry.npmjs.org/\nJavaScript APIRollup 提供了一个可从 Node.js 使用的 JavaScript API。你很少需要使用它，不过通过这个 API 我们可以比较明显的知道 rollup 的构建大致流程。\n内容其实并不多，主要核心两个函数，rollup()与 watch()\n\nrollup.rollup\n\ninputOptions 对象\noutputOptions 对象\n\n\nrollup.watch\n\nwatchOptions\n\n\n\n其实用起来的基本思路和配置文件差不多。直接来看一下效果：\nconst rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nconst outputOptions &#x3D; &#123;\n  dir: &#39;dist&#39;,\n  format: &#39;esm&#39;,\n  sourcemap: true,\n  entryFileNames: &#39;[name].[hash].js&#39;\n&#125;\n\nasync function build() &#123;\n  let bundle;\n  let buildFailed &#x3D; false;\n  try &#123;\n    bundle &#x3D; await rollup.rollup(inputOptions);\n    await bundle.write(outputOptions);\n  &#125; catch (error) &#123;\n    buildFailed &#x3D; true;\n    console.error(error);\n  &#125;\n\n  if (bundle) &#123;\n    &#x2F;&#x2F; 关闭打包过程\n    await bundle.close();\n  &#125;\n  process.exit(buildFailed ? 1 : 0);\n&#125;\n\nbuild();\n\nconst watchOptions &#x3D; &#123;\n  ...inputOptions,\n  output: [outputOptions],\n  watch: &#123;\n    include: &#39;src&#x2F;**&#39;,\n    exclude: &#39;node_modules&#x2F;**&#39;\n  &#125;\n&#125;;\nconst watcher &#x3D; rollup.watch(watchOptions);\n\nwatcher.on(&#39;event&#39;, event &#x3D;&gt; &#123;\n  console.log(event);\n  &#x2F;&#x2F;确保每次打包完成后正确的关闭打包\n  if (event.result) &#123;\n    event.result.close();\n  &#125;\n&#125;)\n\n其实整个过程无非就是把我们之前配置的流程转换位了 js 代码的形式。watch api很明显就是命令行中使用 --watch 标志运行 Rollup 时的效果。\n两大构建工作流我们主要来看一下rollup()函数，从rollup()函数就可以看出，rollup 打包构建流程主要是两大步骤：\n1、build主要负责创建模块依赖，初始化哥哥模块的 AST(抽象语法树)，以及模块之间的依赖关系\nconst rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nasync function build() &#123;\n  const bundle &#x3D; await rollup.rollup(inputOptions);\n  console.log(bundle); &#x2F;&#x2F; 打印bundle对象\n  console.log(bundle.cache.modules); &#x2F;&#x2F;打印模块内容\n&#125;\n\nbuild();\n\n&#x2F;&#x2F; 打印bundle对象\n&#123;\n  cache: &#123;\n    modules: [ [Object], [Object], [Object] ],\n    plugins: [Object: null prototype] &#123;&#125;\n  &#125;,\n  close: [AsyncFunction: close],\n  closed: false,\n  generate: [AsyncFunction: generate],\n  watchFiles: [\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;\n  ],\n  write: [AsyncFunction: write]\n&#125;\n\n&#x2F;&#x2F; 打印模块内容\n[\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 262,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;&#x2F;**\\n&#39; +\n      &#39; * 随机数\\n&#39; +\n      &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n      &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n      &#39; * @returns min-max之间的随机整数\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n      &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n      &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n      &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default randomNumber&#39;,\n    customTransformCache: false,\n    dependencies: [],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;&#x2F;**\\n&#39; +\n      &#39; * 随机数\\n&#39; +\n      &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n      &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n      &#39; * @returns min-max之间的随机整数\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n      &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n      &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n      &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default randomNumber&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;&#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;,\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 349,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;&#x2F;**\\n&#39; +\n      &#39; * 深拷贝\\n&#39; +\n      &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n      &#39; * @returns 深拷贝对象\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n      &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n      &#39;    return obj\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n      &#39;  for(let key in obj) &#123;\\n&#39; +\n      &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n      &#39;      result[key] &#x3D; deepClone(obj[key])\\n&#39; +\n      &#39;    &#125;\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  return result\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;export default deepClone&#39;,\n    customTransformCache: false,\n    dependencies: [],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;&#x2F;**\\n&#39; +\n      &#39; * 深拷贝\\n&#39; +\n      &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n      &#39; * @returns 深拷贝对象\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n      &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n      &#39;    return obj\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n      &#39;  for(let key in obj) &#123;\\n&#39; +\n      &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n      &#39;      result[key] &#x3D; deepClone(obj[key])\\n&#39; +\n      &#39;    &#125;\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  return result\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;export default deepClone&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;&#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;,\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 131,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;import randomNumber from &quot;.&#x2F;randomNumber.js&quot;;\\n&#39; +\n      &#39;import deepClone from &quot;.&#x2F;deepClone.js&quot;;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default &#123; randomNumber, deepClone &#125;\\n&#39; +\n      &#39;\\n&#39;,\n    customTransformCache: false,\n    dependencies: [\n      &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n      &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;\n    ],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;import randomNumber from &quot;.&#x2F;randomNumber.js&quot;;\\n&#39; +\n      &#39;import deepClone from &quot;.&#x2F;deepClone.js&quot;;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default &#123; randomNumber, deepClone &#125;\\n&#39; +\n      &#39;\\n&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;\n      &#39;.&#x2F;randomNumber.js&#39;: [Object],\n      &#39;.&#x2F;deepClone.js&#39;: [Object]\n    &#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;\n]\n\n通过上面两个打印语句的结果，其实就可以分析出，在build阶段产生的bunlde对象，并没有模块打包，这个对象的作用在于存储各个模块的内容及依赖关系，并且提供了generate(不写入)，write(写入磁盘)方法，方便后续 output 阶段输出产物\n2、output通过 rollup()函数返回的对象 bundle 有两个重要的函数\n\ngenerate 生成打包产物，不写入磁盘\nwrite 生成打包产物，写入磁盘\n\nconst rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nconst outputOptions &#x3D; &#123;\n  dir: &#39;dist&#39;,\n  format: &#39;esm&#39;,\n  sourcemap: true,\n  entryFileNames: &#39;[name].[hash].js&#39;\n&#125;\n\nasync function build() &#123;\n  const bundle &#x3D; await rollup.rollup(inputOptions);\n  const resp &#x3D; await bundle.generate(outputOptions);\n  console.log(resp)\n&#125;\n\nbuild();\n\n执行结果：\n&#123;\n  output: [\n    &#123;\n      exports: [Array],\n      facadeModuleId: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n      isDynamicEntry: false,\n      isEntry: true,\n      isImplicitEntry: false,\n      moduleIds: [Array],\n      name: &#39;index&#39;,\n      type: &#39;chunk&#39;,\n      dynamicImports: [],\n      fileName: &#39;index.1730c9fc.js&#39;,\n      implicitlyLoadedBefore: [],\n      importedBindings: &#123;&#125;,\n      imports: [],\n      modules: [Object: null prototype],\n      referencedFiles: [],\n      code: &#39;&#x2F;**\\n&#39; +\n        &#39; * 随机数\\n&#39; +\n        &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n        &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n        &#39; * @returns min-max之间的随机整数\\n&#39; +\n        &#39; *&#x2F;\\n&#39; +\n        &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n        &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n        &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n        &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n        &#39;&#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;&#x2F;**\\n&#39; +\n        &#39; * 深拷贝\\n&#39; +\n        &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n        &#39; * @returns 深拷贝对象\\n&#39; +\n        &#39; *&#x2F;\\n&#39; +\n        &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n        &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n        &#39;    return obj\\n&#39; +\n        &#39;  &#125;\\n&#39; +\n        &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n        &#39;  for(let key in obj) &#123;\\n&#39; +\n        &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n        &#39;      result[key] &#x3D; deepClone(obj[key]);\\n&#39; +\n        &#39;    &#125;\\n&#39; +\n        &#39;  &#125;\\n&#39; +\n        &#39;  return result\\n&#39; +\n        &#39;&#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;var index &#x3D; &#123; randomNumber, deepClone &#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;export &#123; index as default &#125;;\\n&#39; +\n        &#39;&#x2F;&#x2F;# sourceMappingURL&#x3D;index.1730c9fc.js.map\\n&#39;,\n      map: [SourceMap],\n      preliminaryFileName: &#39;index.!~&#123;001&#125;~.js&#39;,\n      sourcemapFileName: &#39;index.1730c9fc.js.map&#39;\n    &#125;,\n    &#123;\n      fileName: &#39;index.1730c9fc.js.map&#39;,\n      name: undefined,\n      needsCodeReference: false,\n      source: &#96;&#123;&quot;version&quot;:3,&quot;file&quot;:&quot;index.1730c9fc.js&quot;,&quot;sources&quot;:[&quot;..&#x2F;src&#x2F;randomNumber.js&quot;,&quot;..&#x2F;src&#x2F;deepClone.js&quot;,&quot;..&#x2F;src&#x2F;index.js&quot;],&quot;sourcesContent&quot;:[&quot;&#x2F;**\\n * 随机数\\n * @param &#123;*&#125; min 最小值\\n * @param &#123;*&#125; max 最大值\\n * @returns min-max之间的随机整数\\n *&#x2F;\\nconst randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n  min &#x3D; Math.ceil(min);\\n  max &#x3D; Math.floor(max);\\n  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#125;\\n\\nexport default randomNumber&quot;,&quot;&#x2F;**\\n * 深拷贝\\n * @param obj 需要深拷贝的对象\\n * @returns 深拷贝对象\\n *&#x2F;\\nconst deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n    return obj\\n  &#125;\\n  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n  for(let key in obj) &#123;\\n    if(obj.hasOwnProperty(key)) &#123;\\n      result[key] &#x3D; deepClone(obj[key])\\n    &#125;\\n  &#125;\\n  return result\\n&#125;\\nexport default deepClone&quot;,&quot;import randomNumber from \\&quot;.&#x2F;randomNumber.js\\&quot;;\\nimport deepClone from \\&quot;.&#x2F;deepClone.js\\&quot;;\\n\\nexport default &#123; randomNumber, deepClone &#125;\\n\\n&quot;],&quot;names&quot;:[],&quot;mappings&quot;:&quot;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,KAAK;AACnC,EAAE,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACvB,EAAE,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACxB,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;AAC3D;;ACVA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,GAAG,CAAC,GAAG,KAAK;AAC3B,EAAE,GAAG,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,EAAE;AAC9C,IAAI,OAAO,GAAG;AACd,GAAG;AACH,EAAE,MAAM,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;AAC9C,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,EAAE;AACtB,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;AAChC,MAAM,MAAM,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAC;AACvC,KAAK;AACL,GAAG;AACH,EAAE,OAAO,MAAM;AACf;;ACbA,YAAe,EAAE,YAAY,EAAE,SAAS;;;;&quot;&#125;&#96;,\n      type: &#39;asset&#39;\n    &#125;\n  ]\n&#125;\n\n插件机制\n\n\n\n\n\n\n\n\n代码：github.com&#x2F;Sunny-117&#x2F;r…\nRollup 插件概述\n\n\n\n\n\n\n\n\nRollup 插件是一个对象，具有 属性、构建钩子 和 输出生成钩子 中的一个或多个，并遵循我们的 约定。插件应作为一个导出一个函数的包进行发布，该函数可以使用插件特定的选项进行调用并返回此类对象。\n简单来说，rollup 插件一般会做成一个函数，函数返回一个对象，返回的对象中包含一些属性和不同阶段的钩子函数。\n约定插件应该有一个明确的名称，并以rollup-plugin-作为前缀。\n属性name：插件的名称，用于在警告和错误消息中标识插件。\nversion：插件的版本\n钩子函数的特点\n钩子函数区分不同的调用时机\n钩子函数是有执行顺序的\n钩子函数有不同的执行方式\n钩子函数也可以是对象的形式\n对象形式的钩子函数可以改变钩子的执行，让不同插件的同名钩子函数获取不通的执行先后\n\n钩子函数的调用时机这里的调用时机，其实就是以我们上面的 API，build 和 output 两大工作流的不同阶段进行分类。根据这两个不同阶段，rollup 提供的不同的函数让我们调用\n\nconst bundle &#x3D; await rollup.rollup(inputOptions) 执行期间的构建钩子函数 - build-hooks\nawait bundle.generate(outputOptions)&#x2F;write(outputOptions) 执行期间的输出钩子函数-output-generation-hooks\n\n钩子函数的执行方式除了上面简单的划分为两个阶段的调用时机之外，我们还可以以钩子函数的执行方式来分类。\n\nasync/sync：异步&#x2F;同步钩子，async 标记的钩子可以返回一个解析为相同类型的值的 Promise；否则，该钩子被标记为 sync。\nfirst：如果有多个插件实现此钩子，则钩子按顺序运行，直到钩子返回一个不是 null 或 undefined 的值。\nsequential：如果有多个插件实现此钩子，则所有这些钩子将按指定的插件顺序运行。如果钩子是 async，则此类后续钩子将等待当前钩子解决后再运行。\nparallel：如果有多个插件实现此钩子，则所有这些钩子将按指定的插件顺序运行。如果钩子是 async，则此类后续钩子将并行运行，而不是等待当前钩子。\n\n钩子函数也可以是对象除了函数之外，钩子也可以是对象。在这种情况下，实际的钩子函数（或 banner/footer/intro/outro 的值）必须指定为 handler。这允许你提供更多的可选属性，以改变钩子的执行：\n\norder: “pre” | “post” | null\n\n如果有多个插件实现此钩子，则可以先运行此插件（&quot;pre&quot;），最后运行此插件（&quot;post&quot;），或在用户指定的位置运行（没有值或 null）。\nexport default function resolveFirst() &#123;\n  return &#123;\n    name: &quot;resolve-first&quot;,\n    resolveId: &#123;\n      order: &quot;pre&quot;,\n      handler(source) &#123;\n        console.log(source);\n        return null;\n      &#125;,\n    &#125;,\n  &#125;;\n&#125;\n\n构建钩子执行顺序\n\n通过 options 钩子读取配置，并进行配置的转换，得到处理后的配置对象\n调用 buildStart 钩子，考虑了所有 options钩子配置的转换，包含未设置选项的正确默认值，正式开始构建流程\n调用 resolveId 钩子解析模块文件路径。rollup 中模块文件的 id 就是文件地址，所以，类似 resolveId 这种就是解析文件地址的意思。从inputOption的input配置指定的入口文件开始，每当匹配到引入外部模块的语句(如：import moudleA from &#39;./moduleA&#39;)便依次执行注册插件中的每一个 resolveId 钩子，直到某一个插件中的 resolveId 执行完后返回非 null 或非 undefined 的值，将停止执行后续插件的 resolveId 逻辑并进入下一个钩子\n调用load钩子加载模块内容，resolveId中的路径一般为相对路径，load 中的路径为处理之后的绝对路径\n接着判断当前解析的模块是否存在缓存，若不存在则执行所有的 transform 钩子来对模块内容进行进行自定义的转换；若存在则判断shouldTransformCachedModule属性，true 则执行所有的 transform 钩子，false 则进入moduleParsed钩子逻辑\n拿到最后的模块内容，进行 AST 分析，调用 moduleParsed 钩子。如果内部没有imports内容，进入buildEnd环节。如果还有imports内容则继续，如果是普通的 import，则执行resolveId 钩子，继续回到步骤 3-调用 resolveId；如果是动态 import，则执行resolveDynamicImport 钩子解析路径，如果解析成功，则回到步骤 4-load加载模块，否则回到步骤 3 通过 resolveId 解析路径\n直到所有的 import 都解析完毕，Rollup 执行buildEnd钩子，Build 阶段结束\n\n&#x2F;&#x2F; rollup-plugin-example.js\n\nexport default function myExample() &#123;\n  return &#123;\n    name: &quot;my-example&quot;,\n    options(options) &#123;\n      console.log(&quot;🎉 -- options:&quot;, options);\n    &#125;,\n    buildStart(options) &#123;\n      console.log(&quot;✨ -- buildStart:&quot;, options);\n    &#125;,\n    resolveId(source, importer) &#123;\n      console.log(&quot;🚀 -- resolveId(source):&quot;, source);\n      console.log(&quot;🚀 -- resolveId(importer):&quot;, importer);\n      return null;\n    &#125;,\n    load(id) &#123;\n      console.log(&quot;🌈 ~ id:&quot;, id);\n      return null;\n    &#125;,\n    transform(code, id) &#123;\n      console.log(&quot;🌟 -- transform&quot;);\n      console.log(&quot;---&quot;, code);\n      console.log(&quot;---&quot;, id);\n    &#125;,\n    moduleParsed(info) &#123;\n      console.log(&quot;⭐️ -- moduleParsed:&quot;, info);\n    &#125;,\n    buildEnd() &#123;\n      console.log(&quot;😁 -- buildEnd&quot;);\n    &#125;,\n  &#125;;\n&#125;\n\n调用虚拟模块插件示例const virtualModuleId &#x3D; &quot;virtual-module&quot;;\n&#x2F;&#x2F; rollup约定插件使用“虚拟模块”，使用\\0前缀模块 ID。这可以防止其他插件尝试处理它。\nconst resolvedVirtualModuleId &#x3D; &quot;\\0&quot; + virtualModuleId;\nexport default function virtualModule() &#123;\n  return &#123;\n    name: &quot;virtual-module&quot;,\n    resolveId(source) &#123;\n      if (source &#x3D;&#x3D;&#x3D; &quot;virtual-module&quot;) &#123;\n        return resolvedVirtualModuleId; &#x2F;&#x2F; 告诉Rollup，这个ID是外部模块，不要在此处查找它\n      &#125;\n      return null; &#x2F;&#x2F; 其他ID应按通常方式处理\n    &#125;,\n    load(id) &#123;\n      console.log(&quot;🌈 - id:&quot;, id);\n      if (id &#x3D;&#x3D;&#x3D; resolvedVirtualModuleId) &#123;\n        &#x2F;&#x2F; return &#39;export default &quot;This is virtual!&quot;&#39;; &#x2F;&#x2F; 告诉Rollup，如何加载此模块\n        return &quot;export default function fib(n) &#123; return n &lt;&#x3D; 1 ? n : fib(n - 1) + fib(n - 2); &#125;&quot;;\n      &#125;\n      return null; &#x2F;&#x2F; 其他ID应按通常方式处理\n    &#125;,\n  &#125;;\n&#125;\n\n界面调用\nimport fib from &quot;virtual-module&quot;;\nconsole.log(fib(10));\n\nJSON 插件示例rollup 默认是不能直接读取 json 文件的内容的，我们自己写一个插件处理一下，不过写这个插件之前，有一些小知识点需要补充一下\n@rollup&#x2F;pluginutils rollup 官方提供的工具插件,里面有一些制作插件常用的方法\n安装\npnpm add @rollup&#x2F;plugin-commonjs @rollup&#x2F;plugin-node-resolve @rollup&#x2F;pluginutils -D\n\n插件上下文\n这个其实也是插件中很常用的一些 api，可以通过 this 从大多数钩子中访问一些实用函数和信息位\nrollup-plugin-json\nimport &#123; createFilter, dataToEsm &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\nimport path from &quot;path&quot;;\n\nexport default function myJson(options &#x3D; &#123;&#125;) &#123;\n  &#x2F;&#x2F; createFilter 返回一个函数，这个函数接收一个id路径参数，返回一个布尔值\n  &#x2F;&#x2F; 这个布尔值表示是否要处理这个id路径\n  &#x2F;&#x2F; rollup 推荐每一个 transform 类型的插件都需要提供 include 和 exclude 选项，生成过滤规则\n  const filter &#x3D; createFilter(options.include, options.exclude);\n  return &#123;\n    name: &quot;rollup-plugin-json&quot;,\n    transform: &#123;\n      order: &quot;pre&quot;,\n      handler(code, id) &#123;\n        if (!filter(id) || path.extname(id) !&#x3D;&#x3D; &quot;.json&quot;) return null;\n        try &#123;\n          const parse &#x3D; JSON.stringify(JSON.parse(code));\n          return &#123;\n            &#x2F;&#x2F; dataToEsm 将数据转换成esm模块\n            &#x2F;&#x2F; 其实就是 export default &quot;xxx&quot;\n            code: dataToEsm(parse),\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125; catch (err) &#123;\n          const message &#x3D; &quot;Could not parse JSON file&quot;;\n          this.error(&#123; message, id, cause: err &#125;);\n          return null;\n        &#125;\n      &#125;,\n    &#125;,\n  &#125;;\n&#125;\n\n界面调用\nimport pkg from &quot;..&#x2F;package.json&quot;;\nimport test from &quot;..&#x2F;test.json&quot;; &#x2F;&#x2F; 错误json格式演示\nconsole.log(pkg.name);\n\n插件上下文import &#123; createFilter &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\n\nexport default function customPlugin(options) &#123;\n  const filter &#x3D; createFilter(options.include, options.exclude);\n\n  return &#123;\n    name: &quot;custom-plugin&quot;,\n\n    transform(code, id) &#123;\n      if (!filter(id)) &#123;\n        return null;\n      &#125;\n\n      const parsedCode &#x3D; this.parse(code); &#x2F;&#x2F; 解析代码,获取AST\n\n      const source &#x3D; &#96;$&#123;code&#125;\\n\\n$&#123;JSON.stringify(parsedCode, null, 2)&#125;&#96;;\n\n      const fileName &#x3D; id.split(&quot;&#x2F;&quot;).pop();\n\n      if (options.emitFile) &#123;\n        this.emitFile(&#123;\n          type: &quot;asset&quot;,\n          fileName: fileName + &quot;.txt&quot;,\n          source,\n        &#125;);\n      &#125;\n    &#125;,\n  &#125;;\n&#125;\n\n图片读取import &#123; createFilter, dataToEsm &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\nimport &#123; extname, resolve, basename, relative, normalize, sep &#125; from &quot;path&quot;;\nimport fs from &quot;fs&quot;;\nimport svgToMiniDataURI from &quot;mini-svg-data-uri&quot;;\n\nconst defaults &#x3D; &#123;\n  fileSize: 1024 * 4,\n  target: &quot;.&#x2F;dist&quot;,\n  include: null,\n  exclude: null,\n&#125;;\n\nconst mimeTypes &#x3D; &#123;\n  &quot;.png&quot;: &quot;image&#x2F;png&quot;,\n  &quot;.jpg&quot;: &quot;image&#x2F;jpeg&quot;,\n  &quot;.jpeg&quot;: &quot;image&#x2F;jpeg&quot;,\n  &quot;.gif&quot;: &quot;image&#x2F;gif&quot;,\n  &quot;.svg&quot;: &quot;image&#x2F;svg+xml&quot;,\n  &quot;.ico&quot;: &quot;image&#x2F;x-icon&quot;,\n  &quot;.webp&quot;: &quot;image&#x2F;webp&quot;,\n  &quot;.avif&quot;: &quot;image&#x2F;avif&quot;,\n&#125;;\n\nconst getDataUri &#x3D; (&#123; format, isSvg, mime, source &#125;) &#x3D;&gt;\n  isSvg ? svgToMiniDataURI(source) : &#96;data:$&#123;mime&#125;;$&#123;format&#125;,$&#123;source&#125;&#96;;\n\nconst ensureDirExists &#x3D; async (dirPath) &#x3D;&gt; &#123;\n  try &#123;\n    await fs.promises.access(dirPath);\n    return true;\n  &#125; catch (err) &#123;\n    &#x2F;&#x2F; 文件夹不存在就创建文件夹\n    try &#123;\n      await fs.promises.mkdir(dirPath, &#123; recursive: true &#125;);\n      return true;\n    &#125; catch (err) &#123;\n      console.error(err);\n      return false;\n    &#125;\n  &#125;\n&#125;;\n\nexport default function myImage(opts &#x3D; &#123;&#125;) &#123;\n  const options &#x3D; Object.assign(&#123;&#125;, defaults, opts);\n  const filter &#x3D; createFilter(options.include, options.exclude);\n  return &#123;\n    name: &quot;my-image&quot;,\n    async transform(code, id) &#123;\n      if (!filter(id)) return null;\n\n      &#x2F;&#x2F; 获取后缀\n      const ext &#x3D; extname(id);\n      &#x2F;&#x2F; 判断是否是图片\n      if (!mimeTypes.hasOwnProperty(ext)) &#123;\n        return null;\n      &#125;\n\n      &#x2F;&#x2F; 获取图片的mime类型\n      const mime &#x3D; mimeTypes[ext];\n      &#x2F;&#x2F; 判断是否svg\n      const isSvg &#x3D; mime &#x3D;&#x3D;&#x3D; mimeTypes[&quot;.svg&quot;];\n      &#x2F;&#x2F; 图片format格式\n      const format &#x3D; isSvg ? &quot;utf-8&quot; : &quot;base64&quot;;\n\n      &#x2F;&#x2F; 目标路径\n      const assetsPath &#x3D; resolve(process.cwd(), options.target);\n      console.log(&quot;---&quot;, process.cwd());\n      console.log(&quot;---&quot;, options.target);\n      console.log(&quot;---&quot;, assetsPath);\n\n      &#x2F;&#x2F;获取文件名\n      const fileName &#x3D; basename(id);\n      &#x2F;&#x2F; 最终文件路径\n      const filePath &#x3D; resolve(assetsPath, fileName);\n      console.log(&quot;&#x3D;&#x3D;&#x3D;&quot;, filePath);\n\n      let relativePath &#x3D; normalize(relative(process.cwd(), filePath));\n      relativePath &#x3D; relativePath.substring(relativePath.indexOf(sep) + 1);\n\n      console.log(relativePath);\n\n      try &#123;\n        &#x2F;&#x2F; 如果图片文件过大，就应该直接拷贝文件，返回文件路径\n        &#x2F;&#x2F; 读取图片文件大小与设置的大小进行比较\n        const stat &#x3D; await fs.promises.stat(id);\n        if (stat.size &gt; options.fileSize) &#123;\n          &#x2F;&#x2F; 文件的拷贝，以及对象的返回\n          &#x2F;&#x2F; 文件拷贝，无非就是文件源路径，目标路径\n          &#x2F;&#x2F;copyFile 拷贝文件地址的文件夹必须存在\n          &#x2F;&#x2F; 如果文件夹不存在，那么就创建文件夹\n          const dirExists &#x3D; await ensureDirExists(assetsPath);\n          dirExists &amp;&amp; (await fs.promises.copyFile(id, filePath));\n          return &#123;\n            code: dataToEsm(relativePath), &#x2F;&#x2F;返回拷贝之后处理的路径\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125; else &#123;\n          &#x2F;&#x2F; 否则转换为base64格式\n          &#x2F;&#x2F; 读取文件\n          const source &#x3D; await fs.promises.readFile(id, format);\n\n          return &#123;\n            code: dataToEsm(getDataUri(&#123; format, isSvg, mime, source &#125;)),\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125;\n      &#125; catch (err) &#123;\n        const message &#x3D; &quot;图片转换失败:&quot; + id;\n        this.error(&#123; message, id, cause: err &#125;);\n        return null;\n      &#125;\n    &#125;,\n  &#125;;\n&#125;\n\n输出钩子执行顺序\n\n执行所有插件的 outputOptions 钩子函数，对 output 配置进行转换\n执行 renderStart，该钩子读取所有 outputOptions 钩子的转换之后的输出选项\n扫描 动态import 语句执行 renderDynamicImport 钩子，让开发者能自定义动态import的内容与行为\n并发执行所有插件的 banner、footer、intro、outro 钩子，这四个钩子功能简单，就是往打包产物的固定位置(比如头部和尾部)插入一些自定义的内容，比如版本号、作者、内容、项目介绍等等\n是否存在 import.meta 语句，没有就直接进入下一步，否则：对于import.meta.url调用 resolveFileUrl 来自定义 url 解析逻辑。对于import.meta调用 resolveImportMeta 来进行自定义元信息解析\n生成 chunk 调用renderChunk钩子，便于在该钩子中进行自定义操作。如果生成的 chunk 文件有 hash 值，执行 augmentChunkHash 钩子，来决定是否更改 chunk 的哈希值。\n调用 generateBundle 钩子，这个钩子的入参里面会包含所有的打包产物信息，包括 chunk (打包后的代码)、asset(最终的静态资源文件)。在这个钩子中你做自定义自己的操作，比如：可以在这里删除一些 chunk 或者 asset，最终被删除的内容将不会作为产物输出\n上节课讲解的 javascript api—rollup.rollup方法会返回一个bundle对象，bundle对象的 write 方法，会触发writeBundle钩子，传入所有的打包产物信息，包括 chunk 和 asset，与generateBundle钩子非常相似。唯一的区别是writeBundle钩子执行的时候，产物已经输出了。而 generateBundle 执行的时候产物还并没有输出。简单来说，顺序是：generateBundle---&gt;输出并保存产物到磁盘---&gt;writeBundle\n当bundle的close方法被调用时，会触发closeBundle钩子，这个 output 阶段结束\n\nexport default function myExample2() &#123;\n  return &#123;\n    name: &quot;my-example2&quot;,\n    outputOptions(options) &#123;\n      console.log(&quot;🎉 ~ options:&quot;, options);\n    &#125;,\n    renderStart(options) &#123;\n      console.log(&quot;✨ ~ renderStart:&quot;, options);\n    &#125;,\n    renderDynamicImport(options) &#123;\n      console.log(&quot;✨~ renderDynamicImport:&quot;, options);\n    &#125;,\n    banner(chunk) &#123;\n      console.log(&quot;🔥 ~ banner(chunk):&quot;, chunk);\n      return &quot;&quot;;\n    &#125;,\n    renderChunk(source) &#123;\n      console.log(&quot;🚀 ~ source:&quot;, source);\n      return null;\n    &#125;,\n    augmentChunkHash(chunk) &#123;\n      console.log(&quot;🎉 ~ augmentChunkHash:&quot;, chunk);\n    &#125;,\n    generateBundle(options, bundle) &#123;\n      console.log(&quot;🌈 ~ options:&quot;, options);\n      console.log(&quot;🌈 ~ bundle:&quot;, bundle);\n      Object.keys(bundle).forEach((key) &#x3D;&gt; &#123;\n        if (key.includes(&quot;sum&quot;)) &#123;\n          &#x2F;&#x2F;删除对象中的这个键值对\n          delete bundle[key];\n        &#125;\n      &#125;);\n    &#125;,\n    closeBundle() &#123;\n      console.log(&quot;😁 ~ closeBundle&quot;);\n    &#125;,\n  &#125;;\n&#125;\n\n打包大小和时间示例：export default function bundleStats() &#123;\n let startTime;\n return &#123;\n  name: &#39;bundle-stats&#39;,\n  options() &#123;\n   startTime &#x3D; Date.now();\n   &#125;,\n  generateBundle(_, bundle) &#123;\n   const fileSizes &#x3D; &#123;&#125;;\n​\n   for (const [fileName, output] of Object.entries(bundle)) &#123;\n    if (output.type &#x3D;&#x3D;&#x3D; &#39;chunk&#39;) &#123;\n     const content &#x3D; output.code;\n     const size &#x3D; Buffer.byteLength(content, &#39;utf8&#39;);\n     const sizeInKB &#x3D; (size &#x2F; 1024).toFixed(2);\n​\n     fileSizes[fileName] &#x3D; &#96;$&#123;sizeInKB&#125; KB&#96;;\n     &#125;\n    &#125;\n   console.log(&#39;Bundle Stats:&#39;);\n   console.log(&#39;-------------&#39;);\n   console.log(&#39;File Sizes:&#39;);\n   console.log(fileSizes);\n   console.log(&#39;-------------&#39;);\n   &#125;,\n  closeBundle() &#123;\n   const totalTime &#x3D; Date.now() - startTime;\n   console.log(&#96;Total Bundle Time: $&#123;totalTime&#125; ms&#96;);\n   console.log(&#39;-------------&#39;);\n   &#125;\n  &#125;;\n&#125;\n\n代码压缩import &#123; minify &#125; from &#39;uglify-js&#39;;\n​\nexport default function uglifyPlugin() &#123;\n return &#123;\n  name: &#39;uglify&#39;,\n​\n  renderChunk(code) &#123;\n   const result &#x3D; minify(code);\n   if (result.error) &#123;\n    throw new Error(&#96;minify error: $&#123;result.error&#125;&#96;);\n    &#125;\n   return &#123;\n    code: result.code,\n    map: &#123; mappings: &#39;&#39; &#125;\n    &#125;;\n   &#125;,\n  &#125;;\n&#125;\n","slug":"rollup","date":"2024-12-22T08:39:14.000Z","categories_index":"Academic","tags_index":"rollup","author_index":"X-29"},{"id":"6f35d21607cc4ac40e0305fd85e2df31","title":"React-Principle","content":"React-Principle此文章旨在于剖析 React 的一些基本原理，帮助读者更好地理解 React 的工作原理。并写出属于自己的 React 代码。\n前置任务搭建目录以及配置一些工具First of all！\n├── packages| ├── react| | ├── src| | ├── index.ts| | └── package.json| ├── react-reconciler| | └── package.json| └── shared| ├── package.json| ├── ReactSymbols.ts| └── ReactTypes.ts├── scripts| └── rollup| ├── react.config.js| └── utils.js├── .gitignore├── .prettier.json├── eslint.config.js├── package-lock.json├── package.json├── README.md└── tsconfig.json\n安装依赖根目录的package.json文件在根目录的package.json文件中，我们需要安装一些依赖并配置好 scripts 命令：\n&#123;\n  &quot;name&quot;: &quot;react&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;lint&quot;: &quot;eslint .&#x2F;packages&quot;,\n    &quot;build:dev&quot;: &quot;rimraf dist &amp;&amp; rollup --bundleConfigAsCjs --config scripts&#x2F;rollup&#x2F;react.config.js&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@eslint&#x2F;js&quot;: &quot;^9.15.0&quot;,\n    &quot;@rollup&#x2F;plugin-commonjs&quot;: &quot;^28.0.1&quot;,\n    &quot;@types&#x2F;node&quot;: &quot;^22.9.3&quot;,\n    &quot;@types&#x2F;rollup-plugin-generate-package-json&quot;: &quot;^3.2.9&quot;,\n    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^8.15.0&quot;,\n    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^8.15.0&quot;,\n    &quot;eslint&quot;: &quot;^9.15.0&quot;,\n    &quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,\n    &quot;eslint-plugin-prettier&quot;: &quot;^5.2.1&quot;,\n    &quot;prettier&quot;: &quot;^3.3.3&quot;,\n    &quot;rimraf&quot;: &quot;^6.0.1&quot;,\n    &quot;rollup&quot;: &quot;^4.27.3&quot;,\n    &quot;rollup-plugin-generate-package-json&quot;: &quot;^3.2.0&quot;,\n    &quot;rollup-plugin-typescript2&quot;: &quot;^0.36.0&quot;,\n    &quot;typescript&quot;: &quot;^5.6.3&quot;\n  &#125;\n&#125;\n\ntsconfig.json在根目录下创建tsconfig.json文件，并配置好编译选项：\n&#123;\n  &quot;compileOnSave&quot;: true,\n  &quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ESNext&quot;,\n    &quot;useDefineForClassFields&quot;: true,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;],\n    &quot;moduleResolution&quot;: &quot;Node&quot;,\n    &quot;strict&quot;: true,\n    &quot;sourceMap&quot;: true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;noEmit&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noImplicitReturns&quot;: false,\n    &quot;skipLibCheck&quot;: true,\n    &quot;baseUrl&quot;: &quot;.&#x2F;packages&quot;\n  &#125;\n&#125;\n\neslint.config.jsimport eslint from &quot;@eslint&#x2F;js&quot;;\nimport tseslint from &quot;@typescript-eslint&#x2F;eslint-plugin&quot;;\nimport tsparser from &quot;@typescript-eslint&#x2F;parser&quot;;\nimport prettier from &quot;eslint-plugin-prettier&quot;;\nimport eslintConfigPrettier from &quot;eslint-config-prettier&quot;;\n\nexport default [\n  &#x2F;&#x2F; 基础 ESLint 配置\n  eslint.configs.recommended,\n\n  &#x2F;&#x2F; Prettier 配置\n  eslintConfigPrettier,\n\n  &#123;\n    files: [&quot;**&#x2F;*.ts&quot;, &quot;**&#x2F;*.tsx&quot;],\n    languageOptions: &#123;\n      parser: tsparser,\n      parserOptions: &#123;\n        ecmaVersion: &quot;latest&quot;,\n        sourceType: &quot;module&quot;,\n      &#125;,\n    &#125;,\n    plugins: &#123;\n      &quot;@typescript-eslint&quot;: tseslint,\n      prettier: prettier,\n    &#125;,\n    rules: &#123;\n      &quot;prettier&#x2F;prettier&quot;: &quot;error&quot;,\n      &quot;no-case-declarations&quot;: &quot;off&quot;,\n      &quot;no-constant-condition&quot;: &quot;off&quot;,\n      &quot;@typescript-eslint&#x2F;ban-ts-comment&quot;: &quot;off&quot;,\n      &quot;@typescript-eslint&#x2F;no-var-requires&quot;: &quot;off&quot;,\n      &quot;react&#x2F;react-in-jsx-scope&quot;: &quot;off&quot;,\n      &quot;prettier&#x2F;prettier&quot;: [\n        &quot;error&quot;,\n        &#123;\n          endOfLine: &quot;auto&quot;,\n        &#125;,\n      ],\n    &#125;,\n  &#125;,\n];\n\n.prettier.json&#123;\n  &quot;printWidth&quot;: 80,\n  &quot;tabWidth&quot;: 2,\n  &quot;useTabs&quot;: true,\n  &quot;singleQuote&quot;: true,\n  &quot;semi&quot;: true,\n  &quot;trailingComma&quot;: &quot;none&quot;,\n  &quot;bracketSpacing&quot;: true\n&#125;\n\n打包脚本rollup.config.js在scripts目录下创建rollup.config.js文件，并配置打包选项：::: warning注意：rollup.config.js文件需要使用commonjs模块规范，因为rollup默认使用esm模块规范，而node环境不支持esm模块规范。并且一定要是js文件，不能是ts文件。:::\nimport &#123; getBaseRollupPlugins, getPackageJSON, resolvePkgPath &#125; from &quot;.&#x2F;utils&quot;;\n\nimport generatePackageJson from &quot;rollup-plugin-generate-package-json&quot;;\n\n&#x2F;&#x2F; 获取package.json下面的name字段\nconst &#123; name, module &#125; &#x3D; getPackageJSON(&quot;react&quot;, false); &#x2F;&#x2F; react\n&#x2F;&#x2F; react包的路径\nconst pkgPath &#x3D; resolvePkgPath(name, false);\n&#x2F;&#x2F;react 产物路劲\nconst pkgDistPath &#x3D; resolvePkgPath(name, true);\nexport default [\n  &#x2F;&#x2F; 对应react包\n  &#123;\n    input: &#96;$&#123;pkgPath&#125;&#x2F;$&#123;module&#125;&#96;,\n    output: &#123;\n      file: &#96;$&#123;pkgDistPath&#125;&#x2F;index.js&#96;,\n      name: &quot;react&quot;,\n      format: &quot;umd&quot;,\n    &#125;,\n    plugins: [\n      ...getBaseRollupPlugins(),\n      generatePackageJson(&#123;\n        inputFolder: pkgPath,\n        outputFolder: pkgDistPath,\n        baseContents: (&#123; name, description, version &#125;) &#x3D;&gt; (&#123;\n          name,\n          description,\n          version,\n          main: &quot;index.js&quot;,\n        &#125;),\n      &#125;),\n    ],\n  &#125;,\n  &#x2F;&#x2F; jsx-runtime包\n  &#123;\n    input: &#96;$&#123;pkgPath&#125;&#x2F;src&#x2F;jsx.ts&#96;,\n    output: [\n      &#x2F;&#x2F; jsx-runtime\n      &#123;\n        file: &#96;$&#123;pkgDistPath&#125;&#x2F;jsx-runtime.js&#96;,\n        name: &quot;jsx-runtime.js&quot;,\n        format: &quot;umd&quot;,\n      &#125;,\n      &#123;\n        file: &#96;$&#123;pkgDistPath&#125;&#x2F;jsx-dev-runtime.js&#96;,\n        name: &quot;jsx-dev-runtime.js&quot;,\n        format: &quot;umd&quot;,\n      &#125;,\n    ],\n    plugins: getBaseRollupPlugins(),\n  &#125;,\n];\n\nutils.js在scripts目录下创建utils.js文件，并配置一些工具函数：\nimport path from &quot;path&quot;;\nimport fs from &quot;fs&quot;;\nimport ts from &quot;rollup-plugin-typescript2&quot;;\nimport cjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\n\n&#x2F;&#x2F; 包路径\nconst pkgPath &#x3D; path.resolve(__dirname, &quot;..&#x2F;..&#x2F;packages&quot;);\n&#x2F;&#x2F; 打包产物路径\nconst distPath &#x3D; path.resolve(__dirname, &quot;..&#x2F;..&#x2F;dist&#x2F;node_modules&quot;);\n\n&#x2F;**\n * @name 获取包路径或者是打包产物路径\n * @param pkgName\n * @param isDist 是否是打包\n *&#x2F;\nexport const resolvePkgPath &#x3D; (pkgName, isDist) &#x3D;&gt; &#123;\n  return isDist ? &#96;$&#123;distPath&#125;&#x2F;$&#123;pkgName&#125;&#96; : &#96;$&#123;pkgPath&#125;&#x2F;$&#123;pkgName&#125;&#96;;\n&#125;;\n\n&#x2F;**\n * @name 解析包对应的package.json文件\n * @param pkgName\n *&#x2F;\nexport const getPackageJSON &#x3D; (pkgName, isDist) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;1. 包路径 + Package.json\n  const path &#x3D; &#96;$&#123;resolvePkgPath(pkgName, isDist)&#125;&#x2F;package.json&#96;;\n  const str &#x3D; fs.readFileSync(path, &#123; encoding: &quot;utf-8&quot; &#125;);\n  return JSON.parse(str);\n&#125;;\n\nexport const getBaseRollupPlugins &#x3D; (&#123; typeScriptConfig &#x3D; &#123;&#125; &#125; &#x3D; &#123;&#125;) &#x3D;&gt; [\n  cjs(),\n  ts(typeScriptConfig),\n];\n\npackage&#x2F;react该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;react&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;module&quot;: &quot;index.ts&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;shared&quot;: &quot;workspace:*&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;react公共方法&quot;\n&#125;\n\n其中 package&#x2F;index.ts 和 package&#x2F;src&#x2F;jsx.ts 文件先随便写点什么 ts 代码，为了npm run build:dev命令可以正常运行。package&#x2F;src&#x2F;jsx.ts 的目录和文件名在 rollup.config.js 中配置一一对应的\npackage&#x2F;shared该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;shared&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;所有公共方法以及类型定义&quot;\n&#125;\n\npackage&#x2F;react-reconciler该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;react-reconciler&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;&quot;\n&#125;\n\n至此，我们已经完成了项目的目录结构以及一些依赖的安装。在根目录下，我们可以运行npm run build:dev命令进行项目的打包。npm run lint命令可以对项目的代码进行 eslint 检查。\njsx基本介绍React 主要是将页面的结构通过 jsx 进行描述，在调和后，每一个 React element 对象的子节点都会形成一个对应的 fiberNode\n本节内容主要是实现 jsx 的生成。在 React 的源码中，jsx 的代码逻辑存在 packages 下面的 react 包中。为了兼容 React 的旧版本，我们主要是实现最后导出三个文件。\nindex.js: import React from &#39;react&#39; 这样使用jsx-runtime.js: 新版通过 babel 导入jsx-dev-runtime.js: 开发环境的包\n为了开发者方便，React 提供一种类似于 html 的方式去书写代码，然后 React 通过 babel 去进行转义。在 React 的新版本中，我们不再需要手动去引入 React, plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。\n&lt;div className&#x3D;&quot;x&quot;&gt;\n  123\n  &lt;span&gt;yx&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n\n新版Automaticimport &#123; jsx as _jsx &#125; from &quot;react&#x2F;jsx-runtime&quot;;\nimport &#123; jsxs as _jsxs &#125; from &quot;react&#x2F;jsx-runtime&quot;;\n&#x2F;*#__PURE__*&#x2F; _jsxs(&quot;div&quot;, &#123;\n  className: &quot;x&quot;,\n  children: [\n    &quot;123&quot;,\n    &#x2F;*#__PURE__*&#x2F; _jsx(&quot;span&quot;, &#123;\n      children: &quot;yx&quot;,\n    &#125;),\n  ],\n&#125;);\n\n旧版Classic&#x2F;*#__PURE__*&#x2F; React.createElement(\n  &quot;div&quot;,\n  &#123;\n    className: &quot;x&quot;,\n  &#125;,\n  &quot;123&quot;,\n  &#x2F;*#__PURE__*&#x2F; React.createElement(&quot;span&quot;, null, &quot;yx&quot;)\n);\n\n\n\n\n\n\n\n\n\n\n主要是分为三部分：1. 对应的 tag 字段， 2. 属性和 children， 3. key 等一些特殊字段。\n实现 JSX声明类型在 packages/shared/ReactTypes.ts 文件中，我们声明了 JSX 相关的类型。\n&#x2F;** 在这里集中定义React的类型 *&#x2F;\n\n&#x2F;** 定义 React 的 Type 类型 *&#x2F;\nexport type Type &#x3D; any;\n\n&#x2F;** 定义 React 的 Key 类型 *&#x2F;\nexport type Key &#x3D; string | null;\n\n&#x2F;** 定义 React 的 Ref 类型 *&#x2F;\nexport type Ref&lt;T &#x3D; any&gt; &#x3D;\n  | &#123; current: T | null &#125;\n  | ((instance: T | null) &#x3D;&gt; void)\n  | null;\n\n&#x2F;** 定义 React 的 Props 类型 *&#x2F;\nexport type Props &#x3D; &#123;\n  [key: string]: any;\n  children?: any;\n&#125;;\n\n&#x2F;** 定义 React 的 ElementType 类型 *&#x2F;\nexport type ElementType &#x3D; string | ((props: any) &#x3D;&gt; ReactElementType | null);\n\n&#x2F;** 定义 React 的 ReactElement 类型 *&#x2F;\nexport interface ReactElementType &#123;\n  $$typeof: symbol | number;\n  type: ElementType;\n  key: Key;\n  ref: Ref;\n  props: Props;\n  __mark: string;\n&#125;\n\n在 packages/shared/ReactSymbols.ts 文件中，我们声明了 JSX 相关的 symbol。\n&#x2F;**\n * 判断当前环境是否支持 Symbol 及其 for 方法\n * 1. typeof Symbol &#x3D;&#x3D;&#x3D; &#39;function&#39; 检查 Symbol 是否可用且是函数类型\n * 2. Symbol.for 检查是否支持全局 Symbol 注册表功能\n * 3. 在较老的浏览器中可能不支持 Symbol，此时返回 false\n *&#x2F;\nconst supportSymbol &#x3D; typeof Symbol &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; Symbol.for;\n\n&#x2F;**\n * 1. Symbol.for() 是什么：\n *   - 这是 JavaScript 的全局 Symbol 注册表功能\n *   - Symbol.for(&#39;react.element&#39;) 会创建一个全局唯一的 Symbol\n *   - 如果已经存在同名的 Symbol，则返回已存在的那个\n *   - 这确保了在不同的模块中使用相同的字符串创建的 Symbol 是完全相同的\n * 2.为什么需要降级方案 0xeac7：\n *   - 不是所有 JavaScript 环境都支持 Symbol（比如老版本浏览器）\n *   - 0xeac7 是一个十六进制数字，作为降级后的标识符\n *   - 这个数字是 React 团队选择的一个特定值，用来标识 React 元素\n * 3. 这个值的用途：\n *   - 用来标识一个对象是否是合法的 React 元素\n *   - 在 ReactElement 接口中，我们看到有 $$typeof 属性\n *   - $$typeof 就会被赋值为 REACT_ELEMENT_TYPE\n *   - React 内部会检查这个值来确保元素的合法性 *&#x2F;\nexport const REACT_ELEMENT_TYPE &#x3D; supportSymbol\n  ? Symbol.for(&quot;react.element&quot;)\n  : 0xeac7;\n\n实现 JSX在 packages/react/src/jsx.ts 文件中，我们实现 JSX 的逻辑。\nimport &#123; REACT_ELEMENT_TYPE &#125; from &quot;shared&#x2F;ReactSymbols&quot;;\nimport &#123;\n  ElementType,\n  Key,\n  Props,\n  ReactElementType,\n  Ref,\n  Type,\n&#125; from &quot;shared&#x2F;ReactTypes&quot;;\n\n&#x2F;**\n * 创建 React 元素的核心函数\n * @param type 元素类型 - 可以是字符串(原生 DOM 元素)或函数(组件)\n * @param key 用于标识元素的唯一键值，帮助 React 进行高效的 DOM diff\n * @param ref 引用对象，用于访问 DOM 节点或组件实例\n * @param props 元素的属性对象，包含所有传入的属性和子元素\n * @returns 返回一个 React 元素对象\n *&#x2F;\nconst ReactElement &#x3D; (\n  type: Type,\n  key: Key,\n  ref: Ref,\n  props: Props\n): ReactElementType &#x3D;&gt; (&#123;\n  &#x2F;&#x2F; 标识这是一个 React 元素的内部类型标记\n  $$typeof: REACT_ELEMENT_TYPE,\n  &#x2F;&#x2F; 元素类型（div, p, 或自定义组件等）\n  type,\n  &#x2F;&#x2F; 用于优化更新的 key 值\n  key,\n  &#x2F;&#x2F; DOM 或组件实例的引用\n  ref,\n  &#x2F;&#x2F; 元素的所有属性\n  props,\n  &#x2F;&#x2F; 自定义标记，用于标识这是我们的 React 实现\n  __mark: &quot;x-react&quot;,\n&#125;);\n\n&#x2F;**\n * 从配置对象中提取并处理 key、ref 和其他 props\n * @param &#123;Config&#125; Jsx.JsxConfig - React 元素的配置对象\n * @returns &#123;[Key, Ref, Props]&#125; 返回一个元组，包含处理后的 key、ref 和 props\n *\n * @description\n * 1. 通过解构获取 key 和 ref，设置默认值为 null\n * 2. 将 key 转换为字符串（如果存在）\n * 3. 使用 reduce 处理剩余的 props，确保只包含对象自身的属性\n * 4. 返回处理后的 [key, ref, props] 元组\n *&#x2F;\nconst extractPropsFromConfig &#x3D; (config: Jsx.JsxConfig): [Key, Ref, Props] &#x3D;&gt; &#123;\n  const &#123; key &#x3D; null, ref &#x3D; null, ...props &#125; &#x3D; config;\n  return [\n    key !&#x3D; null ? String(key) : null,\n    ref,\n    Object.keys(props).reduce((acc, prop) &#x3D;&gt; &#123;\n      if (&#123;&#125;.hasOwnProperty.call(config, prop)) &#123;\n        acc[prop] &#x3D; props[prop];\n      &#125;\n      return acc;\n    &#125;, &#123;&#125; as Props),\n  ];\n&#125;;\n\n&#x2F;**\n * 处理并合并 children 到 props 中\n * @param &#123;Props&#125; props - 原始的 props 对象\n * @param &#123;any[]&#125; children - 子元素数组\n * @returns &#123;Props&#125; 返回合并了 children 的新 props 对象\n *\n * @description\n * 1. 如果没有 children，直接返回原始 props\n * 2. 如果只有一个 child，直接使用该 child\n * 3. 如果有多个 children，保持数组形式\n * 4. 使用展开运算符创建新的 props 对象，确保不修改原始对象\n *&#x2F;\nconst processChildren &#x3D; (props: Props, children: any[]): Props &#x3D;&gt; &#123;\n  if (children.length &#x3D;&#x3D;&#x3D; 0) return props;\n\n  return &#123;\n    ...props,\n    children: children.length &#x3D;&#x3D;&#x3D; 1 ? children[0] : children,\n  &#125;;\n&#125;;\n\n&#x2F;**\n * JSX 转换函数 - 将 JSX 语法转换为 React 元素\n * @param &#123;ElementType&#125; type - 元素类型（可以是字符串或组件函数）\n * @param &#123;Config&#125; Jsx.JsxConfig - 元素的配置对象，包含 props、key、ref 等\n * @param &#123;...any&#125; children - 子元素列表\n * @returns &#123;ReactElementType&#125; 返回创建的 React 元素\n *\n * @description\n * 1. 首先从配置中提取必要的属性\n * 2. 处理并添加 children\n * 3. 使用这些处理后的值创建 React 元素\n *\n * @description\n * * 完整的处理流程：\n * 1. jsx(&#39;div&#39;, &#123; className: &#39;container&#39; &#125;, child1, child2) 被调用\n * 2. extractPropsFromConfig 处理配置对象：\n *    - 提取 key 和 ref（如果有）\n *    - 处理其余属性（如 className, onClick 等）\n * 3. processChildren 处理子元素：\n *    - 将所有子元素规范化处理\n *    - 添加到 props.children 中\n * 4. ReactElement 创建最终的 React 元素对象\n * 5. 返回的元素对象将被 React 用于后续的渲染流程\n *&#x2F;\nexport const jsx &#x3D; (\n  type: ElementType,\n  config: Jsx.JsxConfig,\n  ...children: any\n) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 第一步：提取和处理配置\n  const [key, ref, props] &#x3D; extractPropsFromConfig(config);\n  &#x2F;&#x2F; 第二步：处理子元素\n  const propsWithChildren &#x3D; processChildren(props, children);\n\n  &#x2F;&#x2F; 第三步：创建 React 元素\n  return ReactElement(type, key, ref, propsWithChildren);\n\n  &#x2F;* 返回的对象形如：\n   &#123;\n     $$typeof: Symbol(react.element),\n     type: &#39;div&#39;,\n     props: &#123;\n       className: &#39;container&#39;,\n       children: &#123;\n         $$typeof: Symbol(react.element),\n         type: &#39;span&#39;,\n         props: &#123; children: &#39;Hello&#39; &#125;\n       &#125;\n     &#125;\n   &#125; *&#x2F;\n&#125;;\n\n&#x2F;**\n * 开发环境使用的 JSX 转换函数\n * @param &#123;ElementType&#125; type - 元素类型\n * @param &#123;Config&#125; Jsx.JsxConfig - 元素配置对象\n * @returns &#123;ReactElementType&#125; 返回创建的 React 元素\n *\n * @description\n * 1. 开发环境版本，不处理 children\n * 2. 用于开发工具和调试\n * 3. 保持与生产版本相同的基本结构，但可能包含额外的开发时检查\n *\n * @description 开发环境的 JSX 转换函数\n * 与生产版本的主要区别：\n * 1. 可以进行额外的类型检查\n * 2. 可以提供更好的错误信息\n * 3. 可以进行开发时的警告提示\n * 4. 可以添加开发工具所需的调试信息\n *&#x2F;\nexport const jsxDev &#x3D; (type: ElementType, config: Jsx.JsxConfig) &#x3D;&gt; &#123;\n  const [key, ref, props] &#x3D; extractPropsFromConfig(config);\n  return ReactElement(type, key, ref, props);\n&#125;;\n\n整体 jsx 函数的调用流程\n\nJSX 代码：\n\nfunction App() &#123;\n  return (\n    &lt;div className&#x3D;&quot;container&quot;&gt;\n      &lt;span&gt;Hello&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n\nBabel 转义后的代码：\n\nfunction App() &#123;\n  return jsx(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;, jsx(&quot;span&quot;, null, &quot;Hello&quot;));\n&#125;\n\njsx 函数的作用就是接收 Babel 转换后的参数，并创建出 React 元素（虚拟 DOM 节点）\n\n最终生成的 React 元素结构：\n\n&#123;\n$$typeof: Symbol(react.element),\ntype: &#39;div&#39;,\nkey: null,\nref: null,\nprops: &#123;\n    className: &#39;container&#39;,\n    children: [\n      &#123;\n        $$typeof: Symbol(react.element),\n        type: &#39;span&#39;,\n        props: &#123; children: &#39;Hello&#39; &#125;,\n        &#x2F;&#x2F; ...\n      &#125;\n    ]\n&#125;\n&#125;\n\n\n所以整个流程是：\n\n\n开发者写 JSX 代码\nBabel 在编译时将 JSX 语法转换为 jsx() 函数调用\n运行时，jsx() 函数被调用，创建 React 元素\nReact 使用这些元素来渲染实际的 DOM 5.简单来说：Babel 的工作是：转换语法（ → jsx(‘div’)）,jsx 函数的工作是：创建虚拟 DOM 节点（jsx(‘div’) → { type: ‘div’, props: {…} }）,这就是为什么在 React 17 之后的版本中，我们不需要手动引入 React（import React from ‘react’），因为 Babel 会自动帮我们引入 jsx 函数。\n\n\n那么为什么还存在 jsxDev 函数呢？\n\njsxDev 函数的作用是为了开发环境的 JSX 转换，它的作用和 jsx 函数一样，只是它不处理 children 子元素，所以它的返回值和生产环境的 jsx 函数返回值是一样的。\n区别的具体体现：\n\nBabel 的转换会根据环境不同选择不同的函数：\n\n&#x2F;&#x2F; 开发环境下，Babel 会转换成：\njsxDev(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;);\n\n&#x2F;&#x2F; 生产环境下，Babel 会转换成：\njsx(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;);\n\n\n实际应用场景：\n\nfunction App() &#123;\n  &#x2F;&#x2F; 开发环境下，如果你这样写：\n  return &lt;div&gt;&#123;undefined.toString()&#125;&lt;&#x2F;div&gt;;\n\n  &#x2F;&#x2F; jsxDev 可以提供更友好的错误信息：\n  &#x2F;&#x2F; &quot;Cannot read property &#39;toString&#39; of undefined at App&quot;\n  &#x2F;&#x2F; 并显示具体的组件栈信息\n\n  &#x2F;&#x2F; 而在生产环境下，jsx 函数会简单地抛出错误，\n  &#x2F;&#x2F; 没有这些额外的调试信息\n&#125;\n\n\n性能考虑：\n\n&#x2F;&#x2F; 开发环境：更多的检查，更多的警告\njsxDev(&quot;div&quot;, &#123;\n  &#x2F;&#x2F; 可以检查 props 类型\n  &#x2F;&#x2F; 可以检查废弃的 API 使用\n  &#x2F;&#x2F; 可以添加更多的调试信息\n&#125;);\n\n&#x2F;&#x2F; 生产环境：更简洁的代码，更好的性能\njsx(&quot;div&quot;, &#123;\n  &#x2F;&#x2F; 只进行必要的转换\n  &#x2F;&#x2F; 没有额外的检查和警告\n  &#x2F;&#x2F; 代码体积更小，运行更快\n&#125;);\n\nSummary：\n\n开发体验：提供更好的错误信息和警告\n调试能力：支持 React DevTools 等开发工具\n性能优化：生产环境可以移除开发时的检查代码\n包体积：生产环境的代码更精简\n\n这就是为什么 React 需要维护两个版本的 JSX 转换函数，它们服务于不同的目的：jsx: 注重性能和包体积jsxDev: 注重开发体验和调试能力\nReact reconcilerReact reconciler 主要是实现了 React 的核心算法，包括调和、渲染、更新等。\n更改 packages&#x2F;react-reconciler&#x2F;package.json 文件&#123;\n  &quot;name&quot;: &quot;react-reconciler&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;react-reconciler&quot;,\n  &quot;module&quot;: &quot;index.ts&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;shared&quot;: &quot;workspace: *&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n在 packages&#x2F;react&#x2F;src&#x2F;currentBatchConfig.ts 文件中，我们声明了 currentBatchConfig 类型。\n\n\n\n\n\n\n\n\ncurrentBatchConfig.ts - React 批处理配置文件\n作用：\n\n存储当前 React 批量更新的配置信息\n主要用于 Transition 相关的功能\n在并发渲染中控制更新的优先级\n\n&#x2F;**\n * React 当前批处理配置对象\n *\n * 用途：\n * 1. 在组件更新时标记更新的类型\n * 2. 帮助 React 区分普通更新和 Transition 更新\n * 3. 影响更新的优先级和调度方式\n *\n * @type &#123;React.BatchConfig&#125;\n *\n * @example\n * &#x2F;&#x2F; React 内部使用示例\n * function scheduleUpdate(fiber, update) &#123;\n *   const transition &#x3D; ReactCurrentBatchConfig.transition;\n *   if (transition !&#x3D;&#x3D; null) &#123;\n *     &#x2F;&#x2F; 这是一个 Transition 更新，使用较低的优先级\n *     scheduleTransitionUpdate(fiber, update);\n *   &#125; else &#123;\n *     &#x2F;&#x2F; 这是一个普通更新，使用正常优先级\n *     scheduleRegularUpdate(fiber, update);\n *   &#125;\n * &#125;\n *&#x2F;\nconst ReactCurrentBatchConfig: React.BatchConfig &#x3D; &#123;\n  transition: null,\n&#125;;\n\nexport default ReactCurrentBatchConfig;\n\n\n\n\n\n\n\n\n\n\n实际应用场景：\n\nuseTransition Hook:\n\nfunction App() &#123;\n  const [isPending, startTransition] &#x3D; useTransition();\n  return (\n    &lt;button\n      onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n        startTransition(() &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 这里的更新会被标记为 Transition\n          setLargeList(generateLargeList());\n        &#125;);\n      &#125;&#125;\n    &gt;\n      Update List\n    &lt;&#x2F;button&gt;\n  );\n&#125;\n\n\n并发特性：\n\n\n允许 React 中断渲染以处理更高优先级的更新\n帮助实现更流畅的用户体验\n支持可中断的渲染过程\n\n在 packages&#x2F;react-reconciler&#x2F;src&#x2F;fiberFlags.ts 文件中\n\n\n\n\n\n\n\n\nfiberFlags.ts - React Fiber 节点的副作用（side-effects）标记定义\n作用：\n\n定义所有可能的 Fiber 节点副作用类型\n使用二进制位标记实现高效的副作用追踪\n通过位运算组合多个副作用\n\n&#x2F;**\n\n\n&#x2F;**\n * Flags 类型定义\n * 用于在 TypeScript 中标识副作用标记的类型\n *&#x2F;\nexport type Flags &#x3D; number;\n\n&#x2F;**\n * 无副作用标记\n * 表示节点不需要进行任何操作\n * 二进制：0000000\n *&#x2F;\nexport const NoFlags &#x3D; 0b0000000;\n\n&#x2F;**\n * 插入&#x2F;移动标记\n * 表示节点需要插入到 DOM 中或在 DOM 中移动位置\n * 二进制：0000001\n *&#x2F;\nexport const Placement &#x3D; 0b0000001;\n\n&#x2F;**\n * 更新标记\n * 表示节点的属性或内容需要更新\n * 二进制：0000010\n *&#x2F;\nexport const Update &#x3D; 0b0000010;\n\n&#x2F;**\n * 子节点删除标记\n * 表示需要删除子节点\n * 二进制：0000100\n *&#x2F;\nexport const ChildDeletion &#x3D; 0b0000100;\n\n&#x2F;**\n * 被动效果标记（如 useEffect）\n * 表示节点包含需要在提交阶段后异步执行的副作用\n * 二进制：0001000\n *&#x2F;\nexport const PassiveEffect &#x3D; 0b0001000;\n\n&#x2F;**\n * Ref 更新标记\n * 表示节点的 ref 需要更新\n * 二进制：0010000\n *&#x2F;\nexport const Ref &#x3D; 0b0010000;\n\n&#x2F;**\n * 可见性变更标记\n * 表示节点的显示&#x2F;隐藏状态需要更新\n * 二进制：0100000\n *&#x2F;\nexport const Visibility &#x3D; 0b0100000;\n\n&#x2F;**\n * 已捕获标记\n * 表示错误已经被捕获\n * 二进制：1000000\n *&#x2F;\nexport const DidCapture &#x3D; 0b1000000;\n\n&#x2F;**\n * 应该捕获标记\n * 表示这个节点应该尝试捕获错误\n * 二进制：01000000000\n *&#x2F;\nexport const ShouldCapture &#x3D; 0b01000000000;\n\n&#x2F;**\n * 突变阶段的标记集合\n * 包含了在 DOM 突变阶段需要处理的所有副作用\n * 通过位运算组合多个标记\n *\n * @example\n * if (fiber.flags &amp; MutationMask) &#123;\n *   &#x2F;&#x2F; 需要在突变阶段处理这个节点\n * &#125;\n *&#x2F;\nexport const MutationMask &#x3D;\n  Placement | Update | ChildDeletion | Ref | Visibility;\n\n&#x2F;**\n * 布局阶段的标记集合\n * 包含了在 DOM 布局阶段需要处理的所有副作用\n * 目前只包含 Ref 的更新\n *&#x2F;\nexport const LayoutMask &#x3D; Ref;\n\n&#x2F;**\n * 被动效果的标记集合\n * 包含了需要异步处理的副作用\n * 主要用于 useEffect 的处理\n *&#x2F;\nexport const PassiveMask &#x3D; PassiveEffect | ChildDeletion;\n\n使用示例：\n&#x2F;&#x2F; 添加副作用标记\nfiber.flags |&#x3D; Update;\n\n&#x2F;&#x2F; 检查是否包含某个副作用\nif (fiber.flags &amp; Placement) &#123;\n  &#x2F;&#x2F; 需要插入或移动节点\n&#125;\n\n&#x2F;&#x2F; 在不同阶段检查相关副作用\nif (fiber.flags &amp; MutationMask) &#123;\n  &#x2F;&#x2F; 处理 DOM 突变相关的副作用\n&#125;\n\nif (fiber.flags &amp; PassiveMask) &#123;\n  &#x2F;&#x2F; 处理 useEffect 相关的副作用\n&#125;\n\n在 packages&#x2F;react-reconciler&#x2F;src&#x2F;workTags.ts 文件中\n\n\n\n\n\n\n\n\nworkTags.ts - React Fiber 节点类型定义文件\n作用：\n\n定义所有可能的 Fiber 节点类型\n用于在 Fiber 树中标识不同类型的节点\n帮助 React 在协调过程中正确处理不同类型的组件\n\n&#x2F;**\n * 函数组件标识\n * 用于标识函数式组件创建的 Fiber 节点\n * @example\n * function App() &#123; return &lt;div&gt;Hello&lt;&#x2F;div&gt; &#125;\n * &#x2F;&#x2F; App 组件对应的 Fiber 节点的 tag 值为 FunctionComponent (0)\n *&#x2F;\nexport const FunctionComponent: React.FunctionComponent &#x3D; 0;\n\n&#x2F;**\n * 根节点标识\n * 用于标识应用的根节点（Root）\n * @example\n * ReactDOM.render(&lt;App &#x2F;&gt;, container)\n * &#x2F;&#x2F; container 对应的 Fiber 节点的 tag 值为 HostRoot (3)\n *&#x2F;\nexport const HostRoot: React.HostRoot &#x3D; 3;\n\n&#x2F;**\n * 原生 DOM 元素标识\n * 用于标识普通 HTML 元素的 Fiber 节点\n * @example\n * &lt;div&gt;Hello&lt;&#x2F;div&gt;\n * &#x2F;&#x2F; div 对应的 Fiber 节点的 tag 值为 HostComponent (5)\n *&#x2F;\nexport const HostComponent: React.HostComponent &#x3D; 5;\n\n&#x2F;**\n * 文本节点标识\n * 用于标识文本内容的 Fiber 节点\n * @example\n * &lt;div&gt;Hello World&lt;&#x2F;div&gt;\n * &#x2F;&#x2F; &quot;Hello World&quot; 对应的 Fiber 节点的 tag 值为 HostText (6)\n *&#x2F;\nexport const HostText: React.HostText &#x3D; 6;\n\n&#x2F;**\n * Fragment 标识\n * 用于标识 React.Fragment 的 Fiber 节点\n * @example\n * &lt;React.Fragment&gt;\n *   &lt;div&gt;Item 1&lt;&#x2F;div&gt;\n *   &lt;div&gt;Item 2&lt;&#x2F;div&gt;\n * &lt;&#x2F;React.Fragment&gt;\n * &#x2F;&#x2F; Fragment 对应的 Fiber 节点的 tag 值为 Fragment (7)\n *&#x2F;\nexport const Fragment: React.Fragment &#x3D; 7;\n\n&#x2F;**\n * Context Provider 标识\n * 用于标识 Context.Provider 的 Fiber 节点\n * @example\n * &lt;MyContext.Provider value&#x3D;&#123;value&#125;&gt;\n *   &#123;children&#125;\n * &lt;&#x2F;MyContext.Provider&gt;\n * &#x2F;&#x2F; Provider 对应的 Fiber 节点的 tag 值为 ContextProvider (11)\n *&#x2F;\nexport const ContextProvider: React.ContextProvider &#x3D; 11;\n\n&#x2F;**\n * Suspense 组件标识\n * 用于标识 Suspense 组件的 Fiber 节点\n * @example\n * &lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n *   &lt;SomeComponent &#x2F;&gt;\n * &lt;&#x2F;Suspense&gt;\n * &#x2F;&#x2F; Suspense 对应的 Fiber 节点的 tag 值为 SuspenseComponent (13)\n *&#x2F;\nexport const SuspenseComponent: React.SuspenseComponent &#x3D; 13;\n\n&#x2F;**\n * Offscreen 组件标识\n * 用于标识 Offscreen 组件的 Fiber 节点\n * 通常用于实现一些性能优化相关的功能\n * @example\n * &#x2F;&#x2F; React 内部使用，用于优化渲染性能\n * &#x2F;&#x2F; 对应的 Fiber 节点的 tag 值为 OffscreenComponent (14)\n *&#x2F;\nexport const OffscreenComponent: React.OffscreenComponent &#x3D; 14;\n\n\n\n\n\n\n\n\n\n\n使用示例：\nfunction processFiber(fiber: FiberNode) &#123;\n  switch (fiber.tag) &#123;\n    case FunctionComponent:\n      &#x2F;&#x2F; 处理函数组件\n      updateFunctionComponent(fiber);\n      break;\n    case HostComponent:\n      &#x2F;&#x2F; 处理 DOM 元素\n      updateHostComponent(fiber);\n      break;\n    case HostText:\n      &#x2F;&#x2F; 处理文本节点\n      updateTextContent(fiber);\n      break;\n    &#x2F;&#x2F; ... 处理其他类型\n  &#125;\n&#125;\n\n","slug":"React-Principle","date":"2024-11-23T16:50:47.000Z","categories_index":"React","tags_index":"React","author_index":"X-29"},{"id":"78c733f14091289904e8c5ab0e4b1c53","title":"前端自动化部署","content":"所谓自动化部署就是当代码触发提交的时候自动部署到服务器上\n前置准备工作\n\n服务器：需要有一台可以部署代码的服务器，比如阿里云、腾讯云、GitHub Pages 等\n代码仓库：需要有一个代码仓库，比如 GitHub、GitLab 等\n会 linux\n懂点 Ngnix\n懂点 Git\n\n买一台服务器\n不要贪便宜到不知名小平台买，之前我也有过投机取巧不想买大平台的服务器，因为觉得贵，但是贵有贵的道理，小平台的安装都会报错，可能对于当时的我技术还不够，不太能分析出错误的原因是什么，总之避雷就对了。\n\n到阿里云我买的 99&#x2F;年的，我买的是 Alibaba Cloud Linux3，和 CentOS 没差，用就行\n\n一路先确定直到支付完成就会看到有服务器的 IP 地址，记住这个 IP 地址，后面会用到。然后重置密码，记住密码，不管是脑子还是别的什么地方\n\n\n连接服务器固定模板 ssh root@服务器 IP 地址\n安装 Docker以下命令以此执行，无脑做就能成功\n**一些命令的解释: **\n\ndnf: 这是一个包管理工具，用于安装、更新和删除软件包。它是 yum 的下一代版本，提供更好的性能和依赖管理功能。\n\ninstall: 这是 dnf 的一个子命令，用于安装指定的软件包。\n\n-y: 这个选项表示自动回答“yes”给所有的提示。这意味着在安装过程中，如果有任何确认提示，使用此标志可以自动接受，避免手动干预。\n\ndocker-ce: 这是要安装的软件包的名称。在这里，docker-ce 指的是 Docker 的社区版（Community Edition）。Docker 是一个开源的容器化平台，用于自动化应用程序的部署、扩展和管理。\n\n–nobest: 这个选项告诉 dnf 在安装时不一定选择最好的（最新的）版本来进行安装，而是可以选择可用版本中的较好版本。这在某些情况下可以避免因为依赖问题而无法安装最新版本\n\n\n运行以下命令，安装Docker存储驱动的依赖包dnf install -y device-mapper-persistent-data lvm2\n\n运行以下命令，添加稳定的Docker软件源。dnf config-manager --add-repo&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n\n运行以下命令，查看已添加的Docker软件源。dnf list docker-ce\n\n正确的返回示例如下。docker-ce.x86_64        3:19.03.13-3.el7        docker-ce-stable\n\n运行以下命令安装Dockerdnf install -y docker-ce --nobest\n\n设置开机自启sudo systemctl enable docker\n\n启动dockersudo systemctl start docker\n\n检测是否安装成功 docker -v 查看版本号docker -v\n\n\n安装 docker-compose安sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -olink\n\n对二进制文件应用可执行权限sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n\n检测是否安装成功 docker-compose -v 查看版本号docker-compose -v\n\n安装 Nginx 镜像和 Jenkins 镜像安装 Nginx镜像docker pull nginx\n\n\n\n\n\n\n\n\n\n\n\nwarning: 如果报错内容是 Error response from daemon: Get “https://registry-1.docker.io/v2/“: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 就按下方命令执行\n\n修改下这个json文件，没有就创建vim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n\n写入以下内容&#123;\n  &quot;registry-mirrors&quot;: [\n    &quot;https:&#x2F;&#x2F;2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;,\n    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,\n    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;,\n    &quot;https:&#x2F;&#x2F;your_preferred_mirror&quot;,\n    &quot;https:&#x2F;&#x2F;dockerhub.icu&quot;,\n    &quot;https:&#x2F;&#x2F;docker.registry.cyou&quot;,\n    &quot;https:&#x2F;&#x2F;docker-cf.registry.cyou&quot;,\n    &quot;https:&#x2F;&#x2F;dockercf.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;docker.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;dockertest.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.aliyuncs.com&quot;,\n    &quot;https:&#x2F;&#x2F;dockerproxy.com&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;,\n    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,\n    &quot;https:&#x2F;&#x2F;docker.nju.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.mirrors.sjtug.sjtu.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.iscas.ac.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.rainbond.cc&quot;\n  ]\n&#125;\n\n重新加载配置文件systemctl daemon-reload\n\n重启docker服务systemctl restart docker\n\n检查下docker是否启动正常systemctl status docker\n\n这样再重新 pull Nginx 就正常了\n安装 Jenkins查看镜像listdocker search jenkins\n\n\n\n\n\n\n\n\n\n\nwarning:可能会报错，需要配置下镜像源无所谓，反正是查看列表的命令，往下走接着拉镜像\n拉取Jenkins镜像 本次镜像jenkins/jenkins:ltsdocker pull jenkins&#x2F;jenkins:lts\n\n\n\n\n\n\n\n\nWARNING\n就拉最新版的镜像，lts 版本是最稳定的版本，一般情况下都用这个版本，别整没有用的\n\n安装完成后执行docker images 查看已安装镜像docker images\n\n\n配置目录编写\n\n\n\n\n\n\nWARNING\n!! 注意：这里的 docker 是放在根目录的和&#x2F;root 平级的\n\n\ndocker\ncompose\ndocker-compose.yml &#x2F;&#x2F;docker-compose 配置\n\n\nhtml &#x2F;&#x2F;各环境代码目录(实际项目可能不在同一目录)\ndev &#x2F;&#x2F;dev 环境代码目录\nprod &#x2F;&#x2F;sit 环境代码目录\n\n\njenkins_home &#x2F;&#x2F;Jenkins 工程目录\nnginx &#x2F;&#x2F;nginx 工程目录\nconf\nnginx.conf &#x2F;&#x2F;nginx 配置\n\n\n\n\n\n\n\ndocker-compose.yml 配置文件version: &quot;3&quot;\n\nservices: # 容器\n  docker_jenkins:\n    privileged: true\n    user: root # root权限\n    restart: always # 重启方式\n    image: jenkins&#x2F;jenkins:lts # 使用的镜像\n    container_name: jenkins # 容器名称\n    ports: # 对外暴露的端口定义\n      - 8080:8080\n      - 50000:50000\n    volumes: # 卷挂载路径\n      - &#x2F;docker&#x2F;jenkins_home&#x2F;:&#x2F;var&#x2F;jenkins_home # 挂载到容器内的jenkins_home目录\n      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock\n      - &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n      - &#x2F;usr&#x2F;bin&#x2F;docker:&#x2F;usr&#x2F;bin&#x2F;docker\n\n  docker_nginx_dev: # nginx-dev环境\n    restart: always\n    image: nginx\n    container_name: nginx_dev\n    ports:\n      - 8001:8001\n    volumes:\n      - &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n      - &#x2F;docker&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html\n      - &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx\n\n  docker_nginx_prod: # nginx-prod环境\n    restart: always\n    image: nginx\n    container_name: nginx_prod\n    ports:\n      - 8002:8002\n    volumes:\n      - &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n      - &#x2F;docker&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html\n      - &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx\n\nnginx.conf 配置文件# nginx.conf 例：\nuser  nginx;\nworker_processes  1;\n\nerror_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;\npid        &#x2F;var&#x2F;run&#x2F;nginx.pid;\n\n\nevents &#123;\n    worker_connections  1024;\n&#125;\n\n\nhttp &#123;\n    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;\n    default_type  application&#x2F;octet-stream;\n\n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    gzip  on;\n\n    #dev环境\n    server &#123;\n            #监听的端口\n        listen  8001;\n        server_name  localhost;\n        #设置日志\n#        access_log  logs&#x2F;dev.access.log  main;\n\n        #定位到index.html\n           location &#x2F; &#123;\n               #linux下HTML文件夹,就是你的前端项目文件夹\n               root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;dev&#x2F;dist;\n#               root  &#x2F;home&#x2F;html&#x2F;dev&#x2F;dist;\n               #输入网址（server_name：port）后，默认的访问页面\n               index  index.html;\n               try_files $uri $uri&#x2F; &#x2F;index.html;\n           &#125;\n    &#125;\n\n    #prod环境\n    server &#123;\n            #监听的端口\n        listen  8002;\n        server_name  localhost;\n        #设置日志\n#        access_log  logs&#x2F;prod.access.log  main;\n\n        #定位到index.html\n           location &#x2F; &#123;\n               #linux下HTML文件夹,就是你的前端项目文件夹\n               root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;prod&#x2F;dist;\n#               root  &#x2F;home&#x2F;html&#x2F;dev&#x2F;dist;\n               #输入网址（server_name：port）后，默认的访问页面\n               index  index.html;\n               try_files $uri $uri&#x2F; &#x2F;index.html;\n           &#125;\n    &#125;\n\n\n#    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;\n\n\n&#125;\n\n\n\n\n\n\n\n\nTIP\n在 docker-compose.yml 文件所在目录下执行命令创建容器\n\n启动容器docker-compose up -d\n\n执行docker ps查看容器情况docker ps\n\nJenkins 配置爆坑来了！！！\n阿里云安全组配置\n\n\n\n\n\n\nWARNING\n此时通过 ip:8080 打不开 jenkins 的，因为阿里云那边需要手动加上要访问那个端口，就放行哪个端口\n\n防火墙配置\n\n\n\n\n\n\n\n\n输入命令开启防火墙和 8080 端口\n检查防火墙装填sudo systemctl status firewalld\n\n开启防火墙sudo systemctl start firewalld\n\nsudo systemctl enable firewalld\n\n开启8080端口sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent\n\n重启防火墙sudo firewall-cmd --reload\n\n\n\n\n\n\n\n\nWARNING\n后面每开放一个端口就要到安全组手动配置一下，然后防火墙开启端口，防火墙 reload 一下，三步，每一步都不能少\n\nJenkins 初次密码在容器启动后，可以在浏览器输入服务器 ip:8080 进入 jenkins 管理界面。至此，jenkins 配置完成。\n密码在 docker/jenkins_home/secrets/initialAdminPassword可以通过命令：\ncat &#x2F;docker&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword\n\nNginx 配置在对应目录/docker/html/dev/dist、/docker/html/prod/dist各新建一个 index.html\n经过上述步骤之后，可以通过 ip+对应的 nignx 端口访问到对应的环境的页面。\n\n\nJenkins 进入后的配置下载插件\nlocal（可选。将界面设置为中文）\nGitHub\npublish over SSH (用来连接远程服务器的)\nNodeJs\n\n下载插件后，Jenkins 需要重启地址栏输入ip:端口/restart\n\nPublish Over SSH 配置第一步\n第二步 进去找到 Publish Over SSH\n第三步 点击 Publish Over SSH 下方的 SSH Server,点击新增\n第四步 点击高级\n\n\nNodeJs 配置\n\n添加凭据添加凭据（账号密码）是为了方便后续使用\n\n\n添加 github 账号密码\n创建 job源码管理\n应用保存后，点击立即构建\n\n无论是否成功，都可以在构建记录控制台查看\n\nGithub WebHooks 配置webhooks 配置\n\n创建一个 Personal access tokens\n配置 jenkins进入一个 job\n\n\n\n\n\n\n(图片说明：描述就是取一个名称)\n\nBuild Steps在&#x2F;docker&#x2F;jenkins_home&#x2F;workspace&#x2F;gitlab_web,每次构建对应代码都会同步更新，由于代码没有在 git 上传 node_moudle 文件夹，所以后续需要在服务器重新安装 node_moudle\nExecute NodeJS script这里选的 node 是上面配置的\n点击应用后保存，然后点击立即构建，此次时间会长一点，此时构建会去自动安装对应的 nodejs 安装包到 jenkins 目录并配置好环境变量，注意尽量与本地开发环境的node版本一致，为了保持环境同步，等待构建好后再执行下一步\n\n应用保存并构建成功后，可以进入下一步\nShell 命令\n在 shell 命令这块有的执行 node -v 都报错，此时请检查环境变量是否与服务器的环境变量有差异，执行echo $PATH第一行代码一般要添加#!/bin/bash如果环境变量有问题可能要在第二行执行刷新环境变量命令\nsource ~&#x2F;.bash_profile\nsource &#x2F;etc&#x2F;profile\n\n上面哪个有效果用哪个然后执行对应命令，验证环境可用\n\n#!&#x2F;bin&#x2F;bash\n\nnode -v\nnpm -v\necho $PATH\n\n保存之后回到桌面在此构建一次上述命令如成功执行，进行下一步\n安装node_moule并build打包\n\n\n\n\n\n\nWARNING\n先自己本地build一下，看看哪里有问题\n\n修改job的shell配置\nnode -v\nnpm -v\n\nnpm i \nnpm run build:dev\n\n\n此时服务器代码出现dist文件夹目录在&#x2F;docker&#x2F;jenkins_home&#x2F;workspace&#x2F;github_test_web\n代码自动部署到对应环境项目目录同一服务器可以用cp命令，可以参考linux cp命令\n此处为另一种方式：压缩包ssh传输，因为使用cp命令到&#x2F;docker&#x2F;html&#x2F;dev目录报错了，遂采用第二种方式\n#!&#x2F;bin&#x2F;bash\n\nnode -v \nnpm -v \nnpm i\nnpm run build:dev\nrm -rf dist.tar\ntar -zcvf dist.tar .&#x2F;dist\n\n构建成功后多了个dist.tar文件\n连接SSH服务器系统配置已经设置过ssh相关配置再操作下面，如未设置，请往上翻 Publish Over SSH\n\n字段说明：Source files：准备发送的文件，该文件是相对于这个项目的workspace目录。例如要发送/docker/jenkins_home/workspace/gitlab_web/dist.tar到目标目录，则设置Source files为dist.tarRemove prefix：目标文件前缀添加，例如要操作src下面的某个文件，就设置成src,本案例是跟目录，无需设置Remote directory：目标目录，本案例要复制到dev环境下的dist文件，/docker/html/devExec command：最后执行的命令，可在这里进行解压，删除，复制等操作\n执行构建后，对应目录已经有了一个dist.tar文件\n\n这样肯定是不行的，还需要删除原有dist文件夹，解压dist.tar,再删除dist.tar,最终命令如下修改刚才配置的ssh最下方有个Exec command\ncd &#x2F;docker&#x2F;html&#x2F;dev\nrm  -rf   dist&#x2F;\ntar zxvf dist.tar\nrm dist.tar\n至此，shell命令执行结束，目前的效果是:gitlab 项目dev分支git提交后，触发jenkins自动构建，自动构建会先在服务器从gitlab的dev分支拉取最新代码，执行build打包后生成dist.tar文件，然后通过ssh将对应dist.tar发送到对应dev环境的项目目录解压dist.tar并更新对应文件，实现自动更新dev环境\n","slug":"automated-deployment","date":"2024-10-20T04:18:31.000Z","categories_index":"Academic","tags_index":"docker,nginx,jenkins,linux","author_index":"X-29"},{"id":"9668cd611991e16937a9fdd60d6dd807","title":"web多环境配置","content":"web 端多环境配置多环境无非就是请求的接口不一样所以本文将介绍如何在 web 端配置不同的请求接口的环境\n1. 准备工作npm init vite@latest\n\n完成之后长这样\n2.配置一些变量2.1 在根目录下新增 config 文件夹config\n├── plugins.ts\n├── constant.ts\n\nconstant 用于配置一些常量&#x2F;&#x2F; 基本路径\nexport const VITE_BASE_PATH &#x3D; &quot;&#x2F;&quot;;\n&#x2F;&#x2F; 应用名称\nexport const VITE_APP_TITLE &#x3D; &quot;xxx&quot;;\n&#x2F;&#x2F; 开启包依赖分析 可视化\nexport const VITE_APP_ANALYZE &#x3D; false;\n&#x2F;&#x2F; 开启Gzip压缩\nexport const VITE_APP_COMPRESS_GZIP &#x3D; false;\n&#x2F;&#x2F; 开启Gzip压缩，删除原文件\nexport const VITE_APP_COMPRESS_GZIP_DELETE_FILE &#x3D; false;\n&#x2F;&#x2F; 去除 console\nexport const VITE_DROP_CONSOLE &#x3D; true;\n&#x2F;&#x2F; 开启兼容\nexport const VITE_APP_LEGACY &#x3D; true;\n\nplugins 用于后续 vite 插件的配置npm install vite-plugin-compression vite-plugin-remove-console --save-dev\n\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\nimport viteCompression from &quot;vite-plugin-compression&quot;;\n\nimport removeConsole from &quot;vite-plugin-remove-console&quot;;\nimport &#123;\n  VITE_APP_COMPRESS_GZIP,\n  VITE_APP_COMPRESS_GZIP_DELETE_FILE,\n&#125; from &quot;.&#x2F;constant&quot;;\n\nexport const createVitePlugins &#x3D; (isBuild: boolean) &#x3D;&gt; &#123;\n  const vitePlugins &#x3D; [react(), removeConsole()];\n\n  if (isBuild) &#123;\n    if (VITE_APP_COMPRESS_GZIP) &#123;\n      vitePlugins.push(\n        viteCompression(&#123;\n          disable: true,\n          deleteOriginFile: VITE_APP_COMPRESS_GZIP_DELETE_FILE,\n        &#125;)\n      );\n    &#125;\n  &#125;\n\n  return vitePlugins;\n&#125;;\n\n3.查看 vite.config.ts 文件import &#123; defineConfig &#125; from &quot;vite&quot;;\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\n\nexport default defineConfig(&#123;\n  plugins: [react()],\n&#125;);\n\n修改 vite.config.ts 文件\n\n\n\n\n\n\n\n\n如果提示：找不到模块“path”或其相应的类型声明，智能导入一下导入类型就行，这样就报错了\nimport &#123; ConfigEnv, loadEnv, UserConfig &#125; from &quot;vite&quot;;\nimport &#123; createVitePlugins &#125; from &quot;.&#x2F;config&#x2F;plugins&quot;;\nimport &#123; resolve &#125; from &quot;path&quot;;\nimport &#123; VITE_DROP_CONSOLE &#125; from &quot;.&#x2F;config&#x2F;constant&quot;;\n\nexport default (&#123; command, mode &#125;: ConfigEnv): UserConfig &#x3D;&gt; &#123;\n  const isBuild &#x3D; command.includes(&quot;build&quot;);\n  const root &#x3D; process.cwd();\n  const env &#x3D; loadEnv(mode, root);\n  const &#123; VITE_PORT &#125; &#x3D; env;\n\n  return &#123;\n    root: process.cwd(),\n    publicDir: &quot;public&quot;,\n    base: &quot;.&#x2F;&quot;,\n    plugins: createVitePlugins(isBuild),\n    css: &#123;\n      modules: &#123;\n        generateScopedName: &quot;[name]__[local]___[hash:base64:5]&quot;,\n        hashPrefix: &quot;prefix&quot;,\n      &#125;,\n      postcss: &#123;\n        plugins: [],\n      &#125;,\n      preprocessorOptions: &#123;\n        less: &#123;\n          javascriptEnabled: true,\n        &#125;,\n      &#125;,\n    &#125;,\n    resolve: &#123;\n      alias: &#123;\n        &quot;@&quot;: &#96;$&#123;resolve(__dirname, &quot;src&quot;)&#125;&#96;,\n      &#125;,\n      mainFields: [&quot;module&quot;, &quot;jsnext:main&quot;, &quot;jsnext&quot;],\n    &#125;,\n    clearScreen: true,\n    logLevel: &quot;info&quot;,\n    server: &#123;\n      open: true,\n      host: &quot;0.0.0.0&quot;,\n      port: parseInt(VITE_PORT),\n    &#125;,\n    build: &#123;\n      target: &quot;modules&quot;,\n      outDir: &quot;build&quot;,\n      assetsDir: &quot;assets&quot;,\n      cssCodeSplit: true,\n      assetsInlineLimit: 4096,\n      sourcemap: !isBuild,\n      chunkSizeWarningLimit: 500,\n      emptyOutDir: true,\n      manifest: false,\n      terserOptions: &#123;\n        compress: &#123;\n          keep_infinity: true,\n          drop_console: VITE_DROP_CONSOLE,\n        &#125;,\n      &#125;,\n    &#125;,\n    define: &#123;\n      _GLOBAL_VARS_: JSON.stringify(&#123;\n        ...env,\n        MODE: mode,\n        BUILD_TIME: new Date().toLocaleString(),\n      &#125;),\n    &#125;,\n  &#125;;\n&#125;;\n\n4.修改 package.json 文件原先的 scripts 部分\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;vite&quot;,\n  &quot;build&quot;: &quot;tsc -b &amp;&amp; vite build&quot;,\n  &quot;lint&quot;: &quot;eslint .&quot;,\n  &quot;preview&quot;: &quot;vite preview&quot;\n&#125;,\n\n修改后的 scripts 部分\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;vite --mode dev&quot;,\n  &quot;prod&quot;: &quot;vite --mode prod&quot;,\n  &quot;build:dev&quot;: &quot;tsc -b &amp;&amp; vite build --mode dev&quot;,\n  &quot;build:prod&quot;: &quot;tsc -b &amp;&amp; vite build --mode prod&quot;,\n  &quot;lint&quot;: &quot;eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0&quot;,\n  &quot;preview&quot;: &quot;vite preview&quot;\n&#125;,\n\n5.根目录下新增 .env 文件VITE_PORT &#x3D; 7200\nVITE_HOST &#x3D; http:&#x2F;&#x2F;dev.example.com &#x2F;&#x2F; 修改为你的域名,这里就是测试环境的接口前缀\n\n6.根目录下新增 .env.prod 文件VITE_PORT &#x3D; 7200\nVITE_HOST &#x3D; http:&#x2F;&#x2F;prod.example.com &#x2F;&#x2F; 修改为你的域名,这里就是生产环境的接口前缀\n\n7.新增 types 目录，里面新增 global.d.ts 文件declare const _GLOBAL_VARS_: &#123;\n  VITE_HOST: string;\n  MODE: string;\n  &#x2F;&#x2F; 如果还有其他变量，可以在这里继续声明\n&#125;;\n\n8.修改 tsconfig.node.json 文件在 include 中加入\n&quot;compilerOptions&quot;: &#123;\n  &quot;jsx&quot;: &quot;react-jsx&quot;,\n&#125;,\n&quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;config&#x2F;*&quot;,&quot;vite.config.ts&quot;,&quot;.&#x2F;types&#x2F;global.d.ts&quot;],\n\n完整的 tsconfig.node.json 文件如下：\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;jsx&quot;: &quot;react-jsx&quot;, &#x2F;&#x2F; 为了避免识别不出jsx和避免提示需要导入react的提示\n    &quot;target&quot;: &quot;ES2022&quot;,\n    &quot;lib&quot;: [&quot;ES2023&quot;],\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;skipLibCheck&quot;: true,\n\n    &#x2F;* Bundler mode *&#x2F;\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;allowImportingTsExtensions&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;moduleDetection&quot;: &quot;force&quot;,\n    &quot;noEmit&quot;: true,\n\n    &#x2F;* Linting *&#x2F;\n    &quot;strict&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noFallthroughCasesInSwitch&quot;: true\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;, &quot;config&#x2F;*&quot;, &quot;vite.config.ts&quot;, &quot;.&#x2F;types&#x2F;global.d.ts&quot;]\n&#125;\n\n9.在 src 目录下创建 constant.ts 文件export const HOST &#x3D; _GLOBAL_VARS_.VITE_HOST;\nexport const MODE &#x3D; _GLOBAL_VARS_.MODE;\n\n查看效果npm run dev\n\n\nnpm run prod\n\n\n","slug":"multiple-environments","date":"2024-10-20T02:15:18.000Z","categories_index":"Skill","tags_index":"React,web,Vite","author_index":"X-29"}]