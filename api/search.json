[{"id":"ffa7cf41068ffc04b695667a48978a48","title":"interview-node","content":"NodeNode.js的基本概念是什么？解答: Node.js是一个基于Chrome V8 JavaScript引擎的开源跨平台运行环境，它使得JavaScript能够脱离浏览器在服务器端运行。Node.js以其事件驱动、非阻塞I&#x2F;O模型著称，擅长处理并发请求，广泛应用于构建高性能的网络应用、API服务器、实时通信系统等。\n请解释Node.js中的事件循环机制。解答: Node.js的核心是事件循环，它是一种处理异步I&#x2F;O的机制。事件循环不断检查事件队列，对于每一个事件，如果有相应的回调函数，就执行该函数。这一机制允许Node.js在等待I&#x2F;O操作（如文件读写、网络请求）完成时，不阻塞主线程，转而执行其他任务，从而实现高并发处理能力。\nNode.js的模块系统如何工作？解答: Node.js采用CommonJS模块系统，每个文件被视为一个模块。模块通过require()函数导入其他模块，使用module.exports或exports来导出功能。这样可以实现代码的复用和隔离，提高项目的可维护性。\n什么是Express框架？它在Node.js开发中的作用？**Express是Node.js中最流行的Web应用框架，它简化了路由设定、中间件使用、请求处理和视图渲染。通过Express，开发者可以快速搭建RESTful API、网站服务，实现动态网页内容生成，极大地提高了开发效率和灵活性。\n解释一下Node.js中的Promise对象及其作用。**Promise是JavaScript中用于处理异步操作的一种对象，它代表一个尚未完成但预期将来完成（或失败）的操作结果。相比于回调函数，Promise提供了链式调用、错误处理集中管理等机制，有助于解决“回调地狱”问题，使异步代码更加清晰和易于维护。\nNode.js如何处理文件系统操作？解答: Node.js通过内置的fs模块提供了一系列API来处理文件系统操作，包括文件的读取、写入、删除、重命名等。这些操作大多支持异步和同步两种模式，开发者可以根据需求选择合适的调用方式，以保证应用的响应性和性能。\n什么是Node.js的包管理器npm？它的功能有哪些？**npm(Node Package Manager)**是Node.js的默认包管理器，它让开发者能够方便地安装、共享和管理Node.js的模块（包）。npm提供了庞大的公共包库，支持包的版本控制、依赖管理、脚本执行等功能，极大促进了Node.js生态的发展和应用的快速迭代。\n解释Node.js中的Cluster模块及其在生产环境的应用。Cluster模块允许Node.js应用利用多核CPU，通过创建多个工作进程（worker）来实现负载均衡。这意味着一个应用可以在多个进程中并行运行，提高处理能力和稳定性。在生产环境中，Cluster模式是提高Node.js应用性能和容错能力的常用策略。\n什么是Node.js的Async&#x2F;Await语法？Async&#x2F;Await是ES2017引入的语法糖，用于简化基于Promise的异步代码编写。async函数会隐式地返回一个Promise，并允许在函数体内使用await关键字等待Promise的解决结果，从而使异步代码看起来更像同步代码，提高了代码的可读性和简洁性。\nNode.js如何处理HTTP请求和响应？Node.js通过内置的http模块提供HTTP服务器功能。开发者可以创建一个http服务器实例，监听特定端口，然后为不同HTTP请求（GET、POST等）设置路由处理函数。服务器接收到请求后，调用相应的处理函数，并通过response对象发送响应数据回客户端，整个过程支持完全的异步处理。\n","slug":"interview-node","date":"2024-06-10T15:12:15.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"b5dda91d1069b7a65e6c576748261ff1","title":"interview-nest","content":"NestNest较其他Node框架的优点Nest.js 相较于其他 Node.js 框架，有以下几个显著的优点，这也是很多开发者选择 Nest.js 作为开发框架的原因：\n\n渐进式和模块化：Nest 提供了一个高度模块化的架构，灵感来源于 Angular，这使得代码组织更为清晰、可维护性更强。开发者可以轻松地复用和管理代码模块。\n\nTypeScript 支持：Nest.js 完全支持 TypeScript，这在 Node.js 生态中是一个巨大的优势，因为它提供了静态类型检查、智能提示以及更好的代码编辑体验，有助于减少错误并提升开发效率。\n\n多编程范式：Nest.js 结合了面向对象编程（OOP）、函数式编程（FP）和功能反应式编程（FRP）的元素，这种混合范式在其他框架中较为少见，为开发者提供了灵活性和表达力。\n\n强大的CLI工具：Nest 提供了一个强大的命令行界面（CLI），能够快速初始化项目、生成模块、服务、控制器等，极大地加速了开发流程。\n\n内置功能丰富：Nest 自带了许多开箱即用的功能，比如异常过滤器、中间件支持、管道（Pipes）用于数据验证和转换、装饰器（Decorators）简化代码结构等，这些都减少了外部依赖和配置工作。\n\n可插拔架构：Nest 允许开发者灵活选择底层HTTP服务器，如Express或Fastify，同时在这些基础框架之上提供了一层抽象，使得切换服务器实现变得容易，且不影响业务逻辑。\n\n微服务支持：Nest.js 内置了对微服务架构的支持，使得构建分布式系统变得更加简单，支持多种通信协议，如gRPC、MQTT等。\n\n测试友好：框架本身设计时就考虑到了测试，支持简单的单元测试和端到端测试设置，便于开发者编写可测试的代码。\n\n社区和生态系统：尽管相对年轻，Nest.js 的社区正在迅速成长，提供了丰富的文档、教程和第三方库，形成了一个活跃且支持性强的开发者环境。\n\n企业级应用开发：由于其高度的可扩展性和组织结构，Nest.js 特别适合构建大型、复杂的企业级应用，满足高并发、高性能的需求。\n\n\n选择 Nest.js 作为 Node.js 开发框架，主要是因为它能够提供现代Web开发所需的高度结构化、类型安全、功能丰富的开发环境，同时保持了灵活性和高性能，特别适合追求高效开发流程和高质量产出的团队。\nNest.js是什么？它与Express的关系如何？\n解答：Nest.js是一个用于构建高效、可扩展的Node.js服务器端应用的框架，它基于 TypeScript 构建，结合了面向对象、函数式和反应式编程的元素。Nest.js底层使用了Express（或可选Fastify），但通过提供模块化架构、依赖注入、装饰器等高级特性，极大地简化了复杂应用的开发和维护。它不是简单地封装Express，而是构建在其之上，提供了一层更丰富的抽象。\n\n解释一下Nest.js中的模块化系统。\n解答：Nest.js的核心设计理念之一就是模块化。每个模块代表了应用的一个功能区域，包含了控制器（Controllers）、服务（Services）、模型（Models）等组件。模块可以导入其他模块，导出自己的服务供外部使用，实现了高内聚低耦合的设计原则。通过@Module装饰器定义模块，@Controller、@Service等装饰器标记具体的类。\n\n描述Nest.js中的依赖注入（DI）是如何工作的。\n解答：依赖注入是Nest.js中的核心特性，它允许你以声明的方式管理组件间依赖，提高代码的可测试性和灵活性。通过构造函数注入是最常见的形式，你只需在构造函数中声明依赖的服务类型，Nest会在实例化时自动提供实例。此外，Nest还支持属性注入、setter注入等多种方式。装饰器如@Injectable、@Inject用于标记可注入的服务和注入点。\n\nNest.js中如何处理异步操作？请举例说明。\n解答：Nest.js中处理异步操作主要依靠Promise和async&#x2F;await。在控制器的方法中，你可以直接返回Promise或使用async关键字使方法返回Promise，Nest会自动处理这些Promise。例如，在处理数据库查询时：   @Get()\nasync findAll(): Promise&lt;User[]&gt; &#123;\n    return this.userService.findAll();\n&#125;\n\nNest.js如何实现中间件？与Express中间件有何不同？\n解答：Nest.js通过@UseMiddleware装饰器应用中间件，它类似于Express，但提供了更好的组织结构和依赖注入支持。Nest的中间件可以是类，利用依赖注入，这比Express的纯函数式中间件更加灵活和强大。\n\n解释一下管道（Pipes）的作用，并举例说明。\n解答：管道用于处理进入控制器方法前的数据验证、变换等操作。例如，使用内置的ValidationPipe可以自动验证请求体是否符合定义的DTO（Data Transfer Object）。定义一个简单的管道如下：   import &#123; PipeTransform, Injectable, BadRequestException &#125; from &#39;@nestjs&#x2F;common&#39;;\n\n@Injectable()\nexport class ValidationPipe implements PipeTransform &#123;\n    transform(value: any) &#123;\n        if (!value) &#123;\n            throw new BadRequestException(&#39;Value is required&#39;);\n        &#125;\n        return value;\n    &#125;\n&#125;\n\nNest.js如何处理全局异常和错误？\n解答：Nest.js提供了全局异常过滤器（Global Exception Filters）来捕获和处理未被捕获的异常。你可以自定义异常过滤器并通过AppModule的providers配置全局应用。例如，定义一个简单的全局异常过滤器：   @Catch()\nexport class AllExceptionsFilter implements ExceptionFilter &#123;\n    catch(exception: unknown, host: ArgumentsHost) &#123;\n        const ctx &#x3D; host.switchToHttp();\n        const response &#x3D; ctx.getResponse();\n        response.status(HttpStatus.INTERNAL_SERVER_ERROR).json(&#123;\n            message: exception.message,\n        &#125;);\n    &#125;\n&#125;\n\n如何在Nest.js中实现身份验证和授权？\n解答：Nest.js推荐使用Passport.js进行身份验证，结合JWT（JSON Web Tokens）或其他策略。你需安装@nestjs/passport和相关策略包，然后创建策略（Strategy）、认证守卫（AuthGuard）、以及配置模块。例如，JWT认证流程涉及生成Token、验证Token等步骤。\n\nNest.js中CQRS（命令查询责任分离）模式的实践方式？\n解答：Nest.js可以通过专门的库如@nestjs/cqrs来实现CQRS。它鼓励将读操作（查询）和写操作（命令）分离到不同的类中，命令通常导致状态变更，而查询只读取状态。这有助于提高复杂系统的可维护性和可扩展性。\n\n如何在Nest.js中实现速率限制？\n解答：Nest.js可以通过安装和配置@nestjs/throttler库来轻松实现速率限制。你可以在全局或特定路由上设置请求的最大频率，以防止恶意或过度访问。例如，全局配置速率限制：import &#123; ThrottlerModule &#125; from &#39;@nestjs&#x2F;throttler&#39;;\n\n@Module(&#123;\n    imports: [\n        ThrottlerModule.forRoot(&#123;\n            ttl: 60,\n            limit: 10,\n        &#125;),\n    ],\n&#125;)\nexport class AppModule &#123;&#125;\n上述配置意味着每60秒内，同一IP地址只能发出最多10次请求。\n\nNest.js中如何实现数据库连接和ORM（如TypeORM）的集成？**\n解答：Nest.js通过模块化设计使得集成TypeORM变得简单直接。首先安装@nestjs/typeorm和数据库驱动，接着在相应的模块中导入TypeOrmModule，并配置数据库连接信息。可以在模块的forRoot方法中指定实体路径，从而自动发现和加载实体类。\n\n解释一下Nest.js的守卫（Guards）机制，并举例说明其用途。**\n解答：守卫是一种特殊类型的中间件，用于决定某个请求是否应该被执行。它们常用于实现权限控制、认证逻辑等。例如，实现一个基本的鉴权守卫，检查请求头中是否存在有效的JWT令牌：   @Injectable()\nexport class AuthGuard implements CanActivate &#123;\n    canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; &#123;\n        const request &#x3D; context.switchToHttp().getRequest();\n        const authToken &#x3D; request.headers[&#39;authorization&#39;];\n        &#x2F;&#x2F; 这里添加JWT验证逻辑\n        return !!authToken; &#x2F;&#x2F; 简化的示例，实际需要解码并验证JWT\n    &#125;\n&#125;\n\nNest.js中如何利用Swagger（OpenAPI）进行API文档自动化？\n解答：通过集成@nestjs/swagger和swagger-ui-express，Nest.js可以自动生成API文档。你只需要在模块中使用@Api装饰器标注控制器和方法，描述路由、参数、响应等信息，即可在运行时通过Swagger UI查看和测试API。\n\n如何在Nest.js应用中实现事件驱动编程？\n解答：Nest.js支持使用微内核架构中的事件总线（EventEmitter）来实现事件驱动编程。可以使用@nestjs/microservices模块创建消息模式，或者直接在应用上下文中使用@InjectEventEmitter()来注入事件发射器，发布和订阅事件。\n\n在Nest.js项目中如何进行单元测试和集成测试？\n解答：Nest.js支持Jest作为默认测试框架，可以编写单元测试和集成测试。单元测试针对单个类的功能，使用@Test()装饰器；集成测试则检验多个组件协同工作的情况，可通过启动测试应用程序并发送实际HTTP请求来完成。Nest提供了Test模块来帮助设置和清理测试环境。\n\n如何在Nest.js应用中实现CORS（跨源资源共享）？\n解答：Nest.js提供了@nestjs/common中的@Cors()装饰器来配置CORS策略。可以在全局或特定控制器级别应用此装饰器，以允许来自不同源的请求访问你的API。\n\nNest.js中如何实现多环境配置（如开发、生产环境）？\n解答：通过环境变量文件（如.env）和@nestjs/config模块，可以方便地管理不同环境下的配置。根据NODE_ENV环境变量加载相应的配置文件，确保敏感信息如数据库密码不会硬编码在代码中。\n\n解释一下Nest.js的生命周期钩子（Lifecycle Hooks），并说明其应用场景。\n解答：Nest.js的组件（如控制器、服务）支持生命周期钩子，如onModuleInit, onModuleDestroy等，让你能在组件的生命周期关键时刻执行代码。例如，在服务初始化时建立数据库连接，在销毁前关闭连接。\n\n如何利用Nest.js的拦截器（Interceptors）进行日志记录或性能监控？\n解答：拦截器可以用来修改进入和离开控制器方法的数据流。创建一个日志拦截器来记录请求和响应信息，或者计算请求处理时间，以此来进行性能监控。拦截器可以全局注册或应用于特定控制器或方法。\n\nNest.js中如何处理文件上传？\n解答：通过@nestjs/platform-express模块，可以很容易地处理文件上传。在控制器方法中使用@UploadedFile()装饰器来接收上传的文件。需要安装multer作为依赖来处理multipart&#x2F;form-data类型的请求。例如：@Post(&#39;upload&#39;)\n@UseInterceptors(FileInterceptor(&#39;file&#39;))\nuploadFile(@UploadedFile() file: Express.Multer.File) &#123;\n    console.log(file);\n    &#x2F;&#x2F; 处理上传的文件\n&#125;\n\n如何在Nest.js中实现动态路由或者基于参数的路由？\n解答：Nest.js允许动态定义路由，通过在路由路径中使用冒号（:）来标记动态部分，然后在控制器方法参数中使用@Param()装饰器来捕获这些值。例如，@Get(&#39;:id&#39;)定义了一个动态ID路由，@Param(&#39;id&#39;) id: string会在方法中接收这个动态ID。\n\nNest.js中如何使用管道（Pipes）进行数据验证和转换？\n解答：管道可用于在处理请求之前验证和&#x2F;或转换数据。内置的ValidationPipe可以与类验证器（class-validator）配合，自动验证请求体。自定义管道可以实现更复杂的逻辑。只需在控制器或具体路由上使用@UsePipes()装饰器应用管道。\n\n如何实现全局异常过滤器来统一处理错误？\n解答：通过创建一个实现了ExceptionFilter接口的类，并在main.ts中使用app.useGlobalFilters()方法注册，可以捕获整个应用的未处理异常，进行统一处理和响应。这对于定制错误消息和保持API响应一致性非常有用。\n\n在Nest.js项目中，如何实现服务间通信（例如，微服务架构）？\n解答：Nest.js支持多种微服务通信方式，包括TCP、MQTT、NATS等。使用@nestjs/microservices或@nestjs/messaging模块，可以通过消息队列或RPC（远程过程调用）实现服务间通信。配置提供者和客户端，定义消息模式，即可在服务间传递消息。\n\n如何在Nest.js中利用GraphQL构建API？\n解答：通过集成@nestjs/graphql和graphql库，可以轻松创建GraphQL API。定义GraphQL类型、查询、变异和订阅，使用装饰器来标记控制器方法，Nest会自动生成执行GraphQL操作所需的Schema。\n\n如何实现Nest.js应用的速率限制以防止API滥用？\n解答：可以借助第三方库如@nestjs/throttler来实现请求速率限制。通过在主模块中导入ThrottlerModule并配置速率限制选项，可以限制每个IP地址的请求频率。\n\n如何在Nest.js中实现API版本控制？\n解答：一种常见做法是在路由路径中包含版本号，如/api/v1/users。可以通过创建不同的模块来组织不同版本的API，或者利用路由重定向和中间件来实现更灵活的版本控制策略。\n\n如何利用Nest.js的CQRS（命令查询责任分离）模式提高应用性能和可维护性？\n解答：通过将读操作（查询）和写操作（命令）分离到不同的类或服务中，可以更清晰地组织代码并优化性能。可以利用Nest的模块化结构，为查询和命令分别创建处理程序和服务，甚至采用事件溯源等高级技术进一步增强。\n\n如何在Nest.js应用中集成WebSocket以实现实时通信？\n解答：Nest.js提供了@nestjs/websockets模块来支持WebSocket。通过创建WebSocket网关（WebSocketGateway），定义消息处理器，可以在服务器与客户端之间建立全双工通信，实现实时数据推送等功能。\n\n在Nest.js项目中如何实现持续集成和部署（CI&#x2F;CD）？\n解答：结合Git仓库（如GitHub）、CI工具（如GitHub Actions, Jenkins）和部署平台（如Heroku, Docker, Kubernetes），可以自动化测试、构建和部署流程。确保有适当的脚本（如npm scripts）来启动应用、运行测试和构建Docker镜像，然后在CI&#x2F;CD流程中配置这些步骤。\n\n","slug":"interview-nest","date":"2024-06-10T14:55:56.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"c3e9dc8578aecdc98b43e7df0e7e8d9d","title":"interview-webpack-vite","content":"Webpack &amp; Vite对Webpack的理解Webpack是一个开源的前端资源加载&#x2F;打包工具，它主要用于将JavaScript、CSS、图片等静态资源进行模块化管理和打包，以便于在现代Web应用程序中高效使用。Webpack通过使用加载器（Loaders）和插件（Plugins）的概念，可以转换、打包各种类型的资源文件，并且支持代码分割、懒加载、热更新等高级特性，从而优化加载速度和提升开发体验。\nWebpack的构建流程\n初始化配置：Webpack首先读取配置文件（如webpack.config.js）和命令行参数，合并这些配置以生成最终的构建配置。\n编译器初始化：基于合并后的配置，创建一个Compiler实例，Compiler负责整个打包的生命周期，包括加载插件、处理配置等。\n确定入口：从配置的entry点开始，Webpack解析依赖图谱，找到所有需要处理的模块。\n加载模块：对每个模块，Webpack使用对应的Loader进行转换处理，比如将CSS、TypeScript等转换为JavaScript。\n执行插件：在构建的不同阶段，Webpack会触发插件的生命周期钩子，执行插件逻辑，如压缩代码、提取公共代码等。\n输出结果：最后，Webpack将处理好的模块组合成一个或多个bundle，并输出到指定目录。\n\n常见的Loader\nbabel-loader：用于将ES6+语法转换为浏览器兼容的JavaScript代码。\ncss-loader 和 style-loader &#x2F; MiniCssExtractPlugin.loader：处理CSS文件，前者用于加载CSS到JS中，后者用于将CSS提取到单独文件。\nfile-loader 和 url-loader：处理静态资源文件，如图片、字体等，可以根据需求将它们转换为Base64编码或输出到文件系统。\nts-loader 或 awesome-typescript-loader：用于处理TypeScript文件。\n\n常见的Plugin\nHtmlWebpackPlugin：自动生成HTML文件，并自动注入打包生成的JS、CSS等资源。\nMiniCssExtractPlugin：用于将CSS从JS中提取出来，生成独立的CSS文件。\nUglifyJsPlugin 或 TerserWebpackPlugin：用于压缩JavaScript代码。\nCleanWebpackPlugin：在每次构建前清理输出目录。\nHotModuleReplacementPlugin：实现热更新功能，提高开发效率。\n\nLoader和Plugin的区别\nLoader 主要用于转换某种类型的文件，将非JavaScript资源转换为模块，使其能够被Webpack处理。\nPlugin 则提供了更广泛的灵活性，它们可以深入到Webpack构建和打包的各个阶段，执行更为复杂的任务，如改变输出结构、注入环境变量、优化资源等。\n\nWebpack的热更新原理Webpack的热更新（Hot Module Replacement, HMR）依赖于HotModuleReplacementPlugin插件。HMR的工作流程大致如下：\n\n开发服务器监听文件变化。\n文件发生变化时，Webpack重新编译受影响的模块。\n编译完成后，通过WebSocket向客户端发送更新信息。\n客户端接收到更新信息后，使用HMR API替换掉旧模块，同时保留组件状态，从而实现页面无刷新更新。\n\n如何提高Webpack的构建速度\n减少Loader和Plugin的使用：仅使用必要的Loader和Plugin。\n利用缓存：开启持久化缓存（如CachePlugin），利用浏览器缓存。\n代码拆分：合理使用SplitChunksPlugin进行代码分割。\nTree Shaking：确保代码的模块化，便于Webpack移除未使用的代码。\n并行编译：利用多核CPU，通过多进程构建。\n优化Loader配置：减少不必要的Loader链或优化Loader选项。\n\nVite与Webpack的对比Vite的优势：\n\n快速启动：Vite利用ES模块导入的原生能力，通过HTTP服务直接提供模块，无需打包即可进行开发，大大提高了开发时的启动速度。\n按需编译：在开发模式下，Vite对模块进行即时编译，只有在首次请求时才编译，之后的请求直接从内存中读取，加速了开发反馈循环。\n简化配置：Vite默认配置较Webpack简单，减少了配置复杂度，适合快速开发。\n\nVite的局限：\n\n生产环境优化：虽然Vite在开发环境下非常迅速，但在生产环境下的优化程度和灵活性相比Webpack略显不足，尤其是在大型应用的复杂配置和优化方面。\n生态成熟度：Webpack拥有庞大的生态系统和社区支持，许多成熟的插件和加载器可能尚未移植到Vite或其原生支持不如Webpack丰富。\n\n总的来说，Vite在开发速度和简便性上具有明显优势，而Webpack在生产环境的优化、生态丰富度和配置灵活性方面更胜一筹。选择哪一种取决于项目需求、团队熟悉度及对速度和灵活性的权衡。\n","slug":"interview-webpack-vite","date":"2024-06-05T15:09:16.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"4cdce0b942af62337249f099a631de6a","title":"interview-mobx","content":"MobxMobx的原理是什么，为什么选择Mobx作为状态管理工具原理MobX 6版本的核心原理仍然是基于其反应式编程模型，但在此版本中，一些实现细节和推荐的最佳实践有所变化。MobX的工作原理主要涉及以下几个关键点：\n\n可观察状态（Observables）: MobX使用makeObservable方法或者在类构造函数中定义可观察属性，将普通JavaScript对象的属性转化为可观察的。这一转变允许MobX追踪这些属性的读取和修改。在MobX 4和5中，这是通过Object.defineProperty或在MobX 5中引入的Proxy来实现的，而在MobX 6中，这一基础机制保持不变，但推荐的实践是使用makeObservable而不是装饰器。\n\n自动追踪（Automatic Tracking）: 当访问或修改可观察状态时，MobX会自动追踪这些操作，并建立一个依赖关系图。这意味着它知道哪些计算值（Computed Values）和React组件依赖于哪些状态。\n\n计算值（Computed Values）: 计算值是基于可观察状态的衍生值，它们会在依赖的状态发生改变时自动重新计算。MobX会记住这些计算值的计算过程，并在下次访问时，如果依赖未变，则直接返回缓存的结果，从而提高效率。\n\n动作（Actions）: MobX鼓励通过action来修改状态。action是一个特殊的函数，它包裹状态修改的逻辑，确保这些改变是可预测的、可追踪的，并且可以在事务中执行。这有助于维护状态的一致性，并使得状态变更易于调试。\n\n响应式渲染（Reactive Rendering）: MobX与React等框架的集成（如通过mobx-react或直接使用observer）使得组件能够自动响应状态变化并重新渲染。当可观察状态变化时，MobX会通知相关组件，触发必要的重渲染，而无需手动比较props或state。\n\n优化和最小化重渲染: MobX通过其高效的依赖追踪系统，确保只有真正依赖于改变状态的组件才会被重渲染。这减少了不必要的计算和DOM操作，提高了应用性能。\n\n\n尽管MobX 6推荐避免使用装饰器语法并引入了新的API，但其背后的原理——即通过自动追踪依赖、自动计算和自动更新UI——仍然保持一致，使得状态管理变得更加简单和高效。\nMobX 6 版本的核心特点和更新MobX 6 引入了一些关键的变化和改进，使其成为一个更加现代化和高效的状态管理库。主要特点包括：\n\n装饰器的非推荐使用：尽管装饰器语法在MobX早期版本中很流行，但在MobX 6中官方不再推荐使用装饰器，因为它们不是ES标准的一部分，且标准化过程缓慢。尽管如此，通过适当的配置（如使用Babel插件），仍然可以启用装饰器语法。\n\nmakeObservable 方法：为了替代装饰器，MobX 6 引入了 makeObservable 方法。在类的构造函数中调用此方法来定义哪些属性应该是可观察的、哪些是计算值、哪些是可自动运行的副作用等。例如：\nimport &#123; observable, action, makeObservable &#125; from &#39;mobx&#39;;\n\nclass Counter &#123;\n  count &#x3D; 0;\n\n  constructor() &#123;\n    makeObservable(this, &#123;\n      count: observable,\n      increment: action,\n    &#125;);\n  &#125;\n\n  increment() &#123;\n    this.count++;\n  &#125;\n&#125;\n\n更好的Tree-shaking和性能：MobX 6进行了优化，提高了Tree-shaking能力，这意味着在打包过程中未使用的代码会被更有效地剔除，从而减小最终应用的体积。此外，它还进行了性能优化，提升了运行时效率。\n\n更好的TypeScript支持：MobX 6增强了对TypeScript的支持，提供了更丰富的类型定义，帮助开发者在使用静态类型时获得更好的开发体验。\n\n新的API：除了 makeObservable 外，MobX 6 还引入了 runInAction、flow 等新API，以及对现有的API进行了调整，以更好地支持函数式编程风格和副作用管理。\n\n\n为什么选择 MobX 6 作为状态管理工具\n简易性：MobX 以其声明式的风格和最少的样板代码而闻名，使得状态管理变得直观且易于理解。即使在不使用装饰器的情况下，通过 makeObservable 的方式也能保持代码简洁。\n\n高效性：自动追踪依赖和优化的变更检测机制保证了只有在状态真正变化时才触发必要的更新，这大大提高了应用的性能。\n\n灵活性：MobX 支持多种编程范式，无论是面向对象还是函数式编程，都能很好地适应，提供灵活的状态管理解决方案。\n\n集成性：MobX 与React等主流前端框架有着很好的集成，特别是通过 mobx-react 库，使得状态管理和组件更新无缝连接。\n\n学习曲线低：相对于Redux等其他状态管理库，MobX的学习曲线相对平缓，开发者可以快速上手并开始构建功能。\n\n\n综上所述，MobX 6 以其简洁性、高效性和灵活性成为了很多开发者选择的状态管理工具，尤其适合那些希望快速迭代、保持代码可维护性并追求高性能的应用开发场景。\n什么是MobX及其主要特点？MobX是一个用于JavaScript应用程序的状态管理库，特别适合React和其他前端框架。它采用声明式的方法，让状态管理变得直观且易于理解。MobX的主要特点包括：\n\n简单易用：通过自动跟踪依赖关系和自动优化，MobX几乎不需要手动管理状态的更新逻辑。\n声明式：开发者只需声明状态、衍生值和更新逻辑，无需关注何时何地执行更新。\n高性能：利用高效的反应式编程模型，仅在状态真正变化时触发最小化更新。\n集成友好：与React等库深度集成，支持透明的性能优化和组件重渲染控制。\n可扩展性：适用于从小型到大型应用的各种规模，易于测试和调试。\n\n如何在MobX 6中创建一个可观察的状态（observable state）在MobX 6中，推荐避免使用装饰器语法，转而使用 makeObservable 函数来定义可观察状态。以下是一个示例：\nimport &#123; observable, makeObservable &#125; from &#39;mobx&#39;;\n\nclass Todo &#123;\n  id &#x3D; Math.random();\n  title &#x3D; &quot;&quot;;\n  completed &#x3D; false;\n\n  constructor() &#123;\n    makeObservable(this, &#123;\n      title: observable,\n      completed: observable,\n    &#125;);\n  &#125;\n&#125;\n\nMobX中的计算值（computed values）是如何工作的？计算值（Computed Values）是基于其他状态（包括其他计算值）派生的值，MobX会自动跟踪这些依赖关系，并在依赖项改变时重新计算它们。计算值是惰性的，只在被访问时计算，并且结果会被缓存直到依赖项变化。\nimport &#123; computed &#125; from &#39;mobx&#39;;\n\nclass TodoList &#123;\n  @observable todos &#x3D; []; &#x2F;&#x2F; 假设todos是一个可观察数组\n\n  get completedCount() &#123;\n    return computed(() &#x3D;&gt; &#123;\n      return this.todos.filter(todo &#x3D;&gt; todo.completed).length;\n    &#125;);\n  &#125;\n&#125;\n注意：在MobX 6中，由于装饰器的非推荐使用，上面的代码应该改写为使用 makeObservable：\nimport &#123; computed, makeObservable &#125; from &#39;mobx&#39;;\n\nclass TodoList &#123;\n  todos &#x3D; [];\n\n  constructor() &#123;\n    makeObservable(this, &#123;\n      todos: observable,\n      completedCount: computed,\n    &#125;);\n  &#125;\n\n  get completedCount() &#123;\n    return this.todos.filter(todo &#x3D;&gt; todo.completed).length;\n  &#125;\n&#125;\n\nMobX中的action是什么？为什么在修改状态时推荐使用它？action是MobX提供的一个用于修改状态的函数。它确保状态更改在一个原子操作中完成，可以被跟踪、记录、延迟执行或撤销。使用action修改状态，而非直接修改，有几个好处：\n\n事务性：确保状态的多个更改作为一个不可分割的整体执行，防止中间状态被外部观察到。\n可追踪性：便于调试，因为所有的状态改变都有迹可循。\n可撤销和重做：配合MobX的额外工具，可以实现状态更改的历史管理。\n兼容性：确保与其他MobX特性（如 reactions 和 computed values）正确交互。\n\n在MobX 6中，创建一个action如下所示：\nimport &#123; action &#125; from &#39;mobx&#39;;\n\nclass Todo &#123;\n  @observable title &#x3D; &quot;&quot;;\n\n  constructor() &#123;\n    makeObservable(this, &#123;\n      title: observable,\n      setTitle: action,\n    &#125;);\n  &#125;\n\n  setTitle(newTitle) &#123;\n    this.title &#x3D; newTitle;\n  &#125;\n&#125;\n或在不使用装饰器的情况下：\nimport &#123; observable, action &#125; from &#39;mobx&#39;;\n\nclass Todo &#123;\n  title &#x3D; &quot;&quot;;\n\n  constructor() &#123;\n    makeObservable(this, &#123;\n      title: observable,\n      setTitle: action.bound, &#x2F;&#x2F; 使用bound确保this被正确绑定\n    &#125;);\n  &#125;\n\n  setTitle(newTitle) &#123;\n    this.title &#x3D; newTitle;\n  &#125;\n&#125;\n使用action确保状态修改遵循MobX的最佳实践，提高应用的稳定性和可维护性。\n当然，很高兴继续探讨MobX 6版本的更多细节。请问您具体想了解哪些方面的问题呢？如果您没有特定问题，我可以根据MobX 6的一些高级特性和最佳实践提出并解答一些示例问题。\nMobX 6 中如何处理异步操作？在MobX 6中，处理异步操作推荐使用async/await结合actions和flow函数。flow是MobX提供的一个特殊的函数，用来创建可取消的、可追踪的异步流程。\n示例回答:\nimport &#123; flow, action &#125; from &#39;mobx&#39;;\n\nclass UserStore &#123;\n    @observable user &#x3D; null;\n\n    constructor() &#123;\n        makeObservable(this, &#123;\n            user: observable,\n            fetchUser: action,\n        &#125;);\n    &#125;\n\n    fetchUser &#x3D; flow(function* fetchUser(userId) &#123;\n        try &#123;\n            const response &#x3D; yield fetch(&#96;https:&#x2F;&#x2F;api.example.com&#x2F;users&#x2F;$&#123;userId&#125;&#96;);\n            const userData &#x3D; yield response.json();\n            this.user &#x3D; userData;\n        &#125; catch (error) &#123;\n            console.error(&quot;Error fetching user:&quot;, error);\n        &#125;\n    &#125;);\n&#125;\n\n在这个例子中，fetchUser是一个由flow定义的异步action，它可以像普通函数一样被调用，但同时支持取消、重试等高级特性，并且它的执行会被MobX自动跟踪。\nMobX 6 中如何实现状态的持久化？虽然MobX本身不直接提供状态持久化的功能，但你可以结合其他库（如localstorage或mobx-persist)来实现。\n示例回答:\n使用mobx-persist库可以轻松地将MobX状态保存到本地存储中，实现状态持久化。\n首先安装mobx-persist:\nnpm install mobx-persist --save\n\n然后在你的应用中使用:\nimport &#123; persist &#125; from &#39;mobx-persist&#39;;\nimport &#123; observable, autorun &#125; from &#39;mobx&#39;;\n\nclass AppState &#123;\n    @persist(&#39;list&#39;) @observable todos &#x3D; [];\n\n    constructor() &#123;\n        makeObservable(this);\n        &#x2F;&#x2F; 从localStorage恢复状态\n        persist.recover(this);\n        \n        &#x2F;&#x2F; 自动保存状态到localStorage\n        autorun(() &#x3D;&gt; &#123;\n            persist.save(this);\n        &#125;);\n    &#125;\n&#125;\n\n在这个例子中，@persist(&#39;list&#39;)装饰器告诉mobx-persist如何序列化和反序列化todos数组。\n如何在React组件中使用MobX 6的状态？在React中使用MobX 6，通常会用到observer高阶组件和useObserver钩子来让组件响应MobX状态的变化。\n示例回答:\n使用observer高阶组件:\nimport React from &#39;react&#39;;\nimport &#123; observer &#125; from &#39;mobx-react-lite&#39;;\nimport &#123; TodoStore &#125; from &#39;.&#x2F;TodoStore&#39;;\n\nconst TodoListView &#x3D; observer(function TodoListView() &#123;\n    const store &#x3D; new TodoStore();\n\n    return (\n        &lt;div&gt;\n            &#123;store.todos.map(todo &#x3D;&gt; (\n                &lt;div key&#x3D;&#123;todo.id&#125;&gt;&#123;todo.title&#125;&lt;&#x2F;div&gt;\n            ))&#125;\n        &lt;&#x2F;div&gt;\n    );\n&#125;);\n\n或使用useObserver钩子:\nimport React from &#39;react&#39;;\nimport &#123; useObserver &#125; from &#39;mobx-react-lite&#39;;\nimport &#123; TodoStore &#125; from &#39;.&#x2F;TodoStore&#39;;\n\nfunction TodoListView() &#123;\n    const store &#x3D; new TodoStore();\n\n    return useObserver(() &#x3D;&gt; (\n        &lt;div&gt;\n            &#123;store.todos.map(todo &#x3D;&gt; (\n                &lt;div key&#x3D;&#123;todo.id&#125;&gt;&#123;todo.title&#125;&lt;&#x2F;div&gt;\n            ))&#125;\n        &lt;&#x2F;div&gt;\n    ));\n&#125;\n\n通过上述方式，React组件会自动响应MobX状态的改变并重新渲染。\n当然，继续深入探讨MobX 6版本的其他方面：\nMobX 6中如何进行状态的细粒度控制，比如只观察某个对象的特定属性变化？在复杂的项目中，可能需要对状态的特定部分进行更精细的控制。可以通过observe函数或者在reaction、autorun中指定更具体的依赖来实现这一点。\n示例回答:\nimport &#123; observe &#125; from &#39;mobx&#39;;\n\nclass User &#123;\n    @observable name &#x3D; &quot;&quot;;\n    @observable email &#x3D; &quot;&quot;;\n    \n    constructor() &#123;\n        makeObservable(this);\n        \n        &#x2F;&#x2F; 监听name属性变化\n        observe(this, &quot;name&quot;, change &#x3D;&gt; &#123;\n            console.log(&quot;Name changed to&quot;, change.newValue);\n        &#125;);\n    &#125;\n&#125;\n\n如何在MobX 6中处理并发和冲突？虽然MobX本身主要用于状态管理，并不直接提供并发控制机制，但在处理复杂应用中的并发修改时，可以通过组合使用action、乐观更新、以及客户端&#x2F;服务器端的冲突解决策略来管理。\n示例回答:\n对于简单的并发控制，可以在action内部实施逻辑来检查和处理可能的冲突：\nclass ShoppingCart &#123;\n    @observable items &#x3D; [];\n\n    @action addItem(item) &#123;\n        &#x2F;&#x2F; 检查是否已存在相同的物品\n        if (!this.items.some(i &#x3D;&gt; i.id &#x3D;&#x3D;&#x3D; item.id)) &#123;\n            this.items.push(item);\n        &#125; else &#123;\n            console.warn(&quot;Item already in the cart&quot;);\n        &#125;\n    &#125;\n&#125;\n\n对于更复杂的并发场景，可能需要结合后端的事务处理或版本控制机制。\nMobX 6如何与其他状态管理库或工具集成，比如Redux或Context API？尽管MobX自身是一个完整的状态管理解决方案，但它也可以与其他技术栈混合使用，以适应特定项目需求。\n示例回答:\n与Redux结合使用，你可能会选择将MobX用于某些组件或功能的状态管理，而全局应用状态依然由Redux管理。这通常涉及在Redux的Reducer或Actions中使用MobX状态，或者反之，确保两者之间的数据同步。\n与React的Context API结合时，MobX的Store可以直接作为Context的Provider值传递给组件树，使得子组件能够访问和使用MobX状态，而无需显式传递props。\n如何在MobX 6中实现状态的懒加载？懒加载是一种优化策略，用于在实际需要时才加载数据。结合MobX，可以通过条件性地创建或获取数据来实现。\n示例回答:\nclass DataLoader &#123;\n    @observable data &#x3D; null;\n    @observable isLoading &#x3D; false;\n\n    @action loadData &#x3D; flow(function*() &#123;\n        if (this.isLoading || this.data) return;\n        this.isLoading &#x3D; true;\n        \n        try &#123;\n            const response &#x3D; yield fetch(&#39;data-source-url&#39;);\n            this.data &#x3D; yield response.json();\n        &#125; catch(error) &#123;\n            console.error(&quot;Error loading data&quot;, error);\n        &#125; finally &#123;\n            this.isLoading &#x3D; false;\n        &#125;\n    &#125;);\n&#125;\n\n在组件中，首次访问数据时触发loadData，实现按需加载。\n","slug":"interview-mobx","date":"2024-06-04T06:32:54.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"b868df7e10c8c1094284a225631a6d16","title":"interview-typescript","content":"TypeScript为什么要使用 TypeScript?TypeScript 是 JavaScript 的一个超集，它在 JS 的基础上添加了静态类型系统和其他一些增强功能，旨在提高代码的可维护性、可读性和开发效率。使用 TypeScript 的主要优势包括：\n\n静态类型检查：在编码阶段就能发现类型错误，减少运行时错误。\n代码编辑器支持：大多数现代IDE和编辑器对 TypeScript 提供了出色的代码补全、接口提示和错误检测。\n易于维护和团队协作：类型注解使代码意图更加清晰，有助于团队成员理解代码结构。\n未来JavaScript特性：TypeScript 支持很多即将成为标准的 ESNext 特性，如异步编程、装饰器等，让你提前享受新特性。\n模块和命名空间：提供了更好的模块化支持，有助于组织大型代码库。\n\nTypeScript 相对于 JavaScript 的优势\n类型安全性：减少因类型错误引起的运行时bug。\n开发工具集成：丰富的IDE支持，如智能提示、重构支持等。\n编译时检查：通过编译时发现潜在错误，提高代码质量。\n易于规模化：适合大型项目，有利于维护和扩展。\n\nconst 和 readonly 的区别\nconst：是一个变量声明关键字，表示声明的变量不可重新赋值，但是如果是对象或数组，其内部属性或元素是可以修改的。\nreadonly：是一个属性修饰符，用于类的属性上，表示该属性一旦被初始化后就不可更改。\n\n枚举和常量枚举的区别\n枚举（enum）：提供了一种定义一组命名常量的方式。枚举值默认是从0开始递增的数字，但也可以自定义。\n常量枚举（const enums）：在编译阶段会被替换为字面量值，不会生成任何运行时代码，提高性能。常量枚举的成员只能是字符串或数字字面量。\n\n常规枚举（Enum）示例&#x2F;&#x2F; 常规枚举定义\nenum Color &#123;\n  Red,\n  Green,\n  Blue\n&#125;\n\nconsole.log(Color.Red); &#x2F;&#x2F; 输出: 0\nconsole.log(Color[0]); &#x2F;&#x2F; 输出: &quot;Red&quot;\nfor (let color in Color) &#123;\n  console.log(color); &#x2F;&#x2F; 可以遍历枚举成员\n&#125;\n\n在这个例子中，Color是一个常规枚举，它的成员在编译后的JavaScript中会转化为一个对象，你可以在运行时通过枚举名或索引访问它们，也可以遍历枚举的所有成员。\n常量枚举（Const Enum）示例&#x2F;&#x2F; 常量枚举定义\nconst enum Size &#123;\n  Small &#x3D; &#39;S&#39;,\n  Medium &#x3D; &#39;M&#39;,\n  Large &#x3D; &#39;L&#39;\n&#125;\n\nconsole.log(Size.Small); &#x2F;&#x2F; 编译时替换为 &#39;S&#39;\nconsole.log(Size.Medium); &#x2F;&#x2F; 编译时替换为 &#39;M&#39;\n\n&#x2F;&#x2F; 尝试遍历Size会发现编译错误，因为编译后Size不会存在\n&#x2F;&#x2F; for (let size in Size) &#123; &#x2F;&#x2F; 这段代码会导致编译错误\n&#x2F;&#x2F;   console.log(size);\n&#x2F;&#x2F; &#125;\n\n在这个例子中，Size是一个常量枚举，它在编译阶段会被替换为对应的字面量值，比如Size.Small会被替换为&#39;S&#39;。这意味着在生成的JavaScript代码中，Size这个枚举本身不存在，你不能在运行时访问它或遍历其成员，但这样做的好处是减小了代码体积并提高了执行效率。\n通过这两个例子，你可以直观地看到常规枚举和常量枚举在使用和行为上的不同。\n接口和类型别名的区别\n接口（interface）：用于描述对象的形状，可以用来定义函数参数、返回值类型或实现类的契约。接口可以被继承和实现。\n类型别名（type alias）：为已存在的类型提供一个新的名字，可以是任何类型表达式，包括联合类型、元组类型等。类型别名不支持实现或继承。\n\nTypeScript 中 any 类型的作用any 类型表示可以是任意类型，使用它可以绕过类型检查。通常在不确定类型或需要兼容旧的 JavaScript 代码时使用，但过度使用会削弱类型安全。\nany、never、unknown、null &amp; undefined 和 void 的区别\nany：可以代表任何类型，绕过类型检查。\nnever：表示永远不会出现的值的类型，用于函数永远抛出异常或永不停止执行的情况。\nunknown：表示未知类型的值，比 any 更安全，因为需要显式类型断言才能使用。\nnull &amp; undefined：代表空值或未定义值，TypeScript 中可以单独或一起作为类型使用。\nvoid：表示没有任何返回值的函数的返回类型。\n\nnever的使用在TypeScript中，never类型是一个特殊类型，表示永远不会发生的值的类型。它是所有类型的子类型，但没有任何类型是它的子类型（除了never本身）。这使得它可以用于表示那些永远不应该达到的终点或者一定会抛出错误的代码路径。以下是几个使用never的例子：\n1. 函数永远抛出错误当一个函数明确地总是抛出错误，不返回任何值时，其返回类型可以标记为never。\nfunction throwError(message: string): never &#123;\n    throw new Error(message);\n&#125;\n\n&#x2F;&#x2F; 调用此函数会抛出错误，因此没有返回值\nthrowError(&quot;Something went wrong&quot;);\n\n2. 无限循环在理论上永远不会结束的循环也可以使用never来表示其循环体内的代码路径不会到达终点。\nfunction infiniteLoop(): never &#123;\n    while (true) &#123;\n        &#x2F;&#x2F; 这个循环永远不会停止，所以这里的代码路径永远不会结束\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 如果调用此函数，它将永远不会返回\n&#x2F;&#x2F; infiniteLoop();\n\n3. 类型保护与never的配合在类型守卫中，当你确定一个联合类型的变量不可能是任何一种类型时，可以使用never来表示这种不可能性。\nfunction isNumber(x: number | string | boolean): x is number &#123;\n    return typeof x &#x3D;&#x3D;&#x3D; &quot;number&quot;;\n&#125;\n\nfunction checkValue(x: number | string | boolean) &#123;\n    if (isNumber(x)) &#123;\n        &#x2F;&#x2F; 在这里，x被narrow到number类型\n    &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;\n        &#x2F;&#x2F; 在这里，x被narrow到string类型\n    &#125; else &#123;\n        &#x2F;&#x2F; 这里x只能是boolean，但为了演示never，我们假设没有这种情况\n        const _exhaustiveCheck: never &#x3D; x;\n    &#125;\n&#125;\n\n在上面的checkValue函数中，虽然实际情况下x可能是number、string或boolean，但在示例的最后else分支中，为了演示，我们假设已经排除了所有可能的类型，这时可以用never类型来表示这种情况，但实际上这会导致类型检查错误，因为我们没有排除boolean类型。正确的做法是在实际代码中处理所有可能的类型，或者确保逻辑上能够覆盖所有情况。\n4. 作为泛型约束never还可以用作泛型约束，帮助确保某些操作不可能发生。\nfunction combine&lt;A, B&gt;(a: A, b: B): A &amp; B &#123;\n    return &#123; ...a, ...b &#125;;\n&#125;\n\n&#x2F;&#x2F; 如果两个类型没有交集，结果类型将是never\ntype Result &#x3D; Combine&lt;&#39;a&#39;, 1&gt;;\n&#x2F;&#x2F; Result 类型为 never，因为字符串和数字没有公共属性\n\n通过这些示例，可以看到never类型主要用于静态类型检查，帮助开发者捕捉潜在的编程错误和逻辑不一致。\nTypeScript 中 type 和 interface 的区别\ntype：更灵活，可以定义更复杂的类型，如联合类型、元组类型、映射类型等，但不能用于实现或继承。\ninterface：主要用于描述对象结构，可以实现和继承，更适合定义对象、类或函数的形状。\n\n在TypeScript中，type和interface都用于定义类型，但它们之间存在一些关键差异，这些差异决定了在不同场景下使用它们的合适性：\n1. 声明合并（Merging）\nInterface: 支持声明合并（declaration merging），意味着如果你在不同的地方声明了同名的接口，TypeScript会自动将它们合并成一个接口，包含所有声明的成员。这对于逐步定义或扩展第三方库的接口非常有用。\n\nType Alias (type): 不支持声明合并。如果尝试在不同位置定义同名的类型别名，TypeScript会报错。每个type必须是唯一的，不允许重复定义。\n\n\n2. 应用范围\nInterface: 更倾向于描述对象的结构，可以用于类的实现，定义方法签名、属性等。可以用来描述JavaScript中的对象字面量、类以及函数的类型。\n\nType Alias: 更灵活，可以用来定义任何类型，包括但不限于对象类型、联合类型（unions）、交叉类型（intersections）、元组（tuples）、原始类型别名等。它提供了更广泛的应用场景，比如重命名现有类型、创建复杂类型等。\n\n\n3. 继承与实现\nInterface: 可以使用extends关键字实现接口间的继承，从而组合多个接口定义。类可以实现接口来强制遵循接口规定的形状。\n\nType Alias: 虽然直接的继承行为不如接口灵活，但可以通过交叉类型（&amp;）来组合类型，达到类似的效果。Type alias不支持直接继承另一个类型别名，但可以使用交叉类型来组合类型。\n\n\n4. 基础类型重命名\nType Alias: 允许你为现有的类型（如number、string等原始类型）创建别名，这是接口所不能做到的。\n\n5. 映射类型与高级类型\nType Alias: 提供了更强大的类型操作能力，如映射类型（mapped types）和条件类型（conditional types），使得创建复杂和动态类型成为可能。\n\n使用场景\n当你需要描述一个对象的结构或实现类的接口时，通常首选interface。\n当你需要定义更复杂或更灵活的类型，包括联合类型、交叉类型、类型重命名等，或需要利用TypeScript的高级类型特性时，使用type更为适合。\n\n总的来说，interface和type各有千秋，选择哪个取决于你要解决的具体问题和想要达到的类型设计目标。\n工具类型的作用\nExclude&lt;T, U&gt; ：从类型T中排除类型U的所有子类型。\nOmit&lt;T, K&gt; ：从类型T中移除指定的一组键K。\nPick&lt;T, K&gt; ：从类型T中选取指定的一组键K组成新的类型。\nMerge&lt;T, U&gt; ：合并类型T和U的属性，如果有同名属性，则U的属性会覆盖T的属性。\nIntersection&lt;T, U&gt; ：取类型T和U的交集，即同时满足T和U的所有属性。\nOverwrite&lt;T, U&gt; ：类似Merge，但U的属性会完全覆盖T的相同属性，而不是仅仅在冲突时覆盖。\n\n方法重载方法重载允许在同一个类或接口中定义多个同名方法，但这些方法的参数列表必须不同（数量或类型），从而实现不同的功能。编译器会根据调用时的实际参数自动匹配合适的方法签名。\n泛型泛型允许你在定义函数、接口或类的时候不预先指定具体的类型，而是在使用时根据传入的参数类型来推断或指定类型。这提高了代码的复用性和灵活性，减少了类型转换的需求。\nTypeScript 底层转为JSTypeScript 通过编译器（tsc）将 TypeScript 代码转换为纯 JavaScript。这个过程包括：\n\n类型检查：编译器首先检查代码中的类型错误。\n类型擦除：由于JavaScript是动态类型语言，编译后的代码会移除所有的类型注解，确保JavaScript引擎能正确执行。\n代码转换：将TypeScript的高级语法（如箭头函数、async&#x2F;await等）转换为ES5或ES6及以下版本的JavaScript，以保证浏览器或Node.js环境的兼容性。\n输出：最终生成的JavaScript代码可以直接在浏览器或Node环境中运行，无需额外的TypeScript运行时支持。\n\n","slug":"interview-typescript","date":"2024-06-04T06:31:14.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"2ced64525a6917341326d68b910b07f6","title":"interview-scence","content":"场景题在React中使用Tailwind CSS进行网站的一键换肤在React中使用Tailwind CSS进行网站的一键换肤，可以通过以下步骤实现：\n1. 安装和配置Tailwind CSS首先，确保你的React项目已经安装并配置了Tailwind CSS。如果你还没有配置，可以参考以下简要步骤（假设你使用Create React App且已安装CRACO或在Vite项目中配置了Tailwind）：\n使用Create React App (CRA)\n安装Tailwind CSS及其相关依赖：\nnpm install -D tailwindcss@latest postcss@latest autoprefixer@latest\n\n安装并配置CRACO（Create React App Configuration Override）：\nnpm install @craco&#x2F;craco\n\n修改craco.config.js以包含Tailwind CSS配置。\n\n\n使用Vite\n安装Tailwind CSS及其相关依赖：\nnpm install tailwindcss@latest postcss@latest autoprefixer@latest\n\n在vite.config.js中配置Tailwind CSS。\n\n\n2. 创建主题配置在Tailwind CSS中，你可以通过创建多个配置文件来定义不同的主题样式。首先，确保你的tailwind.config.js文件已经设置好，然后可以添加额外的配置来支持不同的皮肤。\n3. 动态切换主题\n创建主题切换逻辑：在React组件中，你可以利用React的状态（useState）来存储当前主题，并提供一个方法来改变这个状态。\n\nimport React, &#123; useState &#125; from &#39;react&#39;;\nimport &#39;.&#x2F;styles.css&#39;; &#x2F;&#x2F; 引入全局样式，包含Tailwind CSS\n\nconst themes &#x3D; &#123;\n  light: &#39;light-theme&#39;,\n  dark: &#39;dark-theme&#39;,\n&#125;;\n\nexport default function ThemeSwitcher() &#123;\n  const [theme, setTheme] &#x3D; useState(themes.light);\n\n  const toggleTheme &#x3D; () &#x3D;&gt; &#123;\n    setTheme(theme &#x3D;&#x3D;&#x3D; themes.light ? themes.dark : themes.light);\n    &#x2F;&#x2F; 可以在此处更新localStorage或通过其他方式持久化主题选择\n  &#125;;\n\n  return (\n    &lt;&gt;\n      &lt;button className&#x3D;&#123;&#96;btn $&#123;theme&#125;&#96;&#125; onClick&#x3D;&#123;toggleTheme&#125;&gt;\n        Toggle Theme\n      &lt;&#x2F;button&gt;\n      &#123;&#x2F;* 应用程序的其他组件 *&#x2F;&#125;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n\n\n应用主题：在你的全局CSS或index.html中，根据状态切换data-theme属性或类名来应用不同的Tailwind CSS主题。你可能需要在Tailwind配置中为不同的主题定义不同的颜色变量或样式。\n\n&#x2F;&#x2F; 在根组件或App组件中\ndocument.documentElement.setAttribute(&#39;data-theme&#39;, theme);\n\n\n在Tailwind配置中启用主题：根据文档，你可能需要在Tailwind配置中定义主题变体，或者为不同的主题创建独立的配置文件并通过条件逻辑动态导入。\n\n4. 维护主题状态\n可以使用localStorage来持久化用户的主题选择，以便在页面刷新或下次访问时记住用户的偏好。\n\n通过上述步骤，你就可以在React应用中实现一键切换皮肤功能，利用Tailwind CSS的强大配置能力和React的状态管理来提供动态的视觉体验。\n大文件上传在前端进行大文件上传时，需要考虑多方面的因素，包括用户体验、网络可靠性、服务器压力等。常见的解决方案包括文件分片上传、断点续传、并行上传等。以下是实现大文件上传的详细步骤和相关代码示例。\n大文件上传的关键步骤\n文件分片：将大文件分成多个小片段（chunk），逐个上传，以减少单次上传的时间和出错风险。\n并行上传：同时上传多个分片，提高上传效率。\n断点续传：上传过程中若发生中断，可以从上次中断的位置继续上传，而不需要重新上传整个文件。\n上传进度显示：实时显示上传进度，提升用户体验。\n\n实现步骤1. 文件分片首先，将大文件分割成小片段。以下代码演示了如何将文件分片：\nfunction sliceFile(file, chunkSize) &#123;\n  const chunks &#x3D; [];\n  let start &#x3D; 0;\n  while (start &lt; file.size) &#123;\n    const end &#x3D; Math.min(start + chunkSize, file.size);\n    chunks.push(file.slice(start, end));\n    start &#x3D; end;\n  &#125;\n  return chunks;\n&#125;\n\n2. 并行上传利用Promise.all同时上传多个分片，并在上传完成后通知服务器进行合并。以下是一个简单的并行上传示例：\nasync function uploadChunks(chunks, uploadUrl) &#123;\n  const uploadPromises &#x3D; chunks.map((chunk, index) &#x3D;&gt; &#123;\n    const formData &#x3D; new FormData();\n    formData.append(&#39;file&#39;, chunk);\n    formData.append(&#39;chunkIndex&#39;, index);\n    \n    return fetch(uploadUrl, &#123;\n      method: &#39;POST&#39;,\n      body: formData,\n    &#125;).then(response &#x3D;&gt; response.json());\n  &#125;);\n\n  const results &#x3D; await Promise.all(uploadPromises);\n  return results;\n&#125;\n\n3. 断点续传为了实现断点续传，需要在上传之前检查服务器上已上传的分片，并从中断的位置继续上传。\nasync function getUploadedChunks(uploadUrl, fileName) &#123;\n  const response &#x3D; await fetch(&#96;$&#123;uploadUrl&#125;&#x2F;uploadedChunks?fileName&#x3D;$&#123;fileName&#125;&#96;);\n  const uploadedChunks &#x3D; await response.json();\n  return uploadedChunks;\n&#125;\n\nasync function resumeUpload(chunks, uploadedChunks, uploadUrl) &#123;\n  const uploadPromises &#x3D; chunks.map((chunk, index) &#x3D;&gt; &#123;\n    if (uploadedChunks.includes(index)) &#123;\n      return Promise.resolve(&#123; status: &#39;already uploaded&#39;, index &#125;);\n    &#125;\n    \n    const formData &#x3D; new FormData();\n    formData.append(&#39;file&#39;, chunk);\n    formData.append(&#39;chunkIndex&#39;, index);\n    \n    return fetch(uploadUrl, &#123;\n      method: &#39;POST&#39;,\n      body: formData,\n    &#125;).then(response &#x3D;&gt; response.json());\n  &#125;);\n\n  const results &#x3D; await Promise.all(uploadPromises);\n  return results;\n&#125;\n\n4. 上传进度显示在上传过程中，实时显示上传进度，以提升用户体验。可以利用XMLHttpRequest或fetch的进度事件来实现。\nasync function uploadWithProgress(chunks, uploadUrl, onProgress) &#123;\n  const totalChunks &#x3D; chunks.length;\n  let uploadedChunks &#x3D; 0;\n\n  const uploadPromises &#x3D; chunks.map((chunk, index) &#x3D;&gt; &#123;\n    const formData &#x3D; new FormData();\n    formData.append(&#39;file&#39;, chunk);\n    formData.append(&#39;chunkIndex&#39;, index);\n\n    return fetch(uploadUrl, &#123;\n      method: &#39;POST&#39;,\n      body: formData,\n    &#125;).then(response &#x3D;&gt; &#123;\n      uploadedChunks +&#x3D; 1;\n      onProgress(Math.round((uploadedChunks &#x2F; totalChunks) * 100));\n      return response.json();\n    &#125;);\n  &#125;);\n\n  const results &#x3D; await Promise.all(uploadPromises);\n  return results;\n&#125;\n\n&#x2F;&#x2F; Usage\nuploadWithProgress(chunks, uploadUrl, (progress) &#x3D;&gt; &#123;\n  console.log(&#96;Upload progress: $&#123;progress&#125;%&#96;);\n&#125;);\n\n完整示例结合上述步骤，实现一个完整的大文件上传功能：\nconst chunkSize &#x3D; 5 * 1024 * 1024; &#x2F;&#x2F; 5MB\n\nasync function uploadFile(file, uploadUrl) &#123;\n  const chunks &#x3D; sliceFile(file, chunkSize);\n  const uploadedChunks &#x3D; await getUploadedChunks(uploadUrl, file.name);\n\n  await resumeUpload(chunks, uploadedChunks, uploadUrl);\n\n  const mergeResponse &#x3D; await fetch(&#96;$&#123;uploadUrl&#125;&#x2F;merge&#96;, &#123;\n    method: &#39;POST&#39;,\n    headers: &#123;\n      &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,\n    &#125;,\n    body: JSON.stringify(&#123; fileName: file.name, totalChunks: chunks.length &#125;),\n  &#125;);\n\n  const result &#x3D; await mergeResponse.json();\n  return result;\n&#125;\n\n&#x2F;&#x2F; File input change event handler\ndocument.getElementById(&#39;fileInput&#39;).addEventListener(&#39;change&#39;, async (event) &#x3D;&gt; &#123;\n  const file &#x3D; event.target.files[0];\n  const uploadUrl &#x3D; &#39;https:&#x2F;&#x2F;your-upload-url.com&#x2F;upload&#39;;\n\n  const result &#x3D; await uploadFile(file, uploadUrl);\n  console.log(&#39;Upload result:&#39;, result);\n&#125;);\n\n总结通过文件分片、并行上传、断点续传和上传进度显示，可以实现一个高效、可靠的大文件上传功能。前端处理大文件上传时，需要考虑到网络波动、服务器压力等因素，通过上述技术手段可以大大提升用户体验和上传成功率。\n如何理解前端工程化前端工程化是指在前端开发中应用一系列的工程化手段和工具，以提高开发效率、代码质量和团队协作能力。前端工程化的目的是将前端开发过程规范化、自动化、模块化和工具化，使得前端开发更加高效和可靠。\n前端工程化的核心要素\n模块化\n\n将代码分解成独立、可复用的模块，每个模块完成特定的功能，减少代码耦合度。\n使用ES6的模块系统（import&#x2F;export），或者使用模块打包工具（如Webpack、Rollup）来管理模块依赖。\n\n\n组件化\n\n通过将UI拆分成独立的组件，每个组件包含自己的样式、逻辑和视图，便于开发、维护和复用。\n使用现代前端框架（如React、Vue、Angular）进行组件化开发。\n\n\n自动化\n\n自动化的构建、测试、部署流程，减少人为错误，提高开发效率。\n使用构建工具（如Webpack、Gulp）进行代码打包、压缩、优化。\n使用任务管理工具（如NPM Scripts）自动化常见的开发任务。\n持续集成（CI）工具（如Jenkins、GitHub Actions）自动化测试和部署流程。\n\n\n规范化\n\n代码风格、命名规范、文件组织结构的一致性，保证团队协作中的代码质量和可维护性。\n使用代码格式化工具（如Prettier）和代码检查工具（如ESLint）来保持代码风格一致。\n\n\n版本控制\n\n使用版本控制系统（如Git）管理代码历史、分支和合并，便于多人协作和代码回溯。\n制定合理的分支策略（如Git Flow）和代码评审流程，保证代码质量和稳定性。\n\n\n性能优化\n\n通过代码拆分（Code Splitting）、懒加载（Lazy Loading）、资源压缩（Minification）、缓存（Caching）等手段优化前端性能。\n使用性能监控工具（如Lighthouse、WebPageTest）定期检查和优化应用的性能表现。\n\n\n\n前端工程化的工具和技术\n构建工具\n\nWebpack：流行的模块打包工具，支持代码拆分、热加载等功能。\nGulp：基于流的构建工具，适合处理复杂的自动化任务。\nRollup：专注于构建库的模块打包工具，生成更小的包。\n\n\n任务管理工具\n\nNPM Scripts：通过package.json中的scripts字段定义和执行常见任务。\nGrunt：基于任务的JavaScript任务管理工具。\n\n\n代码质量工具\n\nESLint：JavaScript代码检查工具，帮助发现和修复代码中的问题。\nPrettier：代码格式化工具，自动格式化代码以保持一致的代码风格。\n\n\n持续集成&#x2F;持续部署（CI&#x2F;CD）工具\n\nJenkins：开源的自动化服务器，支持各种CI&#x2F;CD流程。\nGitHub Actions：GitHub的CI&#x2F;CD服务，集成在GitHub平台上，易于配置和使用。\nTravis CI：与GitHub紧密集成的CI服务，支持多种语言和平台。\n\n\n前端框架和库\n\nReact：由Facebook开发的用于构建用户界面的库，强调组件化和声明式编程。\nVue：渐进式前端框架，易于上手，支持组件化和响应式数据绑定。\nAngular：由Google开发的前端框架，提供完整的解决方案，适合大型应用开发。\n\n\n包管理工具\n\nnpm：Node.js的包管理工具，是前端开发的基础设施之一。\nYarn：Facebook推出的包管理工具，强调速度和一致性。\npnpm：高效的包管理工具，具有更快的安装速度和更小的磁盘占用。\n\n\n\n总结前端工程化是一个系统化的过程，涉及代码的组织、工具的使用和流程的优化。通过前端工程化，可以提高开发效率、保证代码质量、增强团队协作能力，从而构建出更稳定、更高效的前端应用。了解并掌握前端工程化的各个方面和工具，对于现代前端开发者来说是至关重要的。\n如何理解大前端大前端（Full Stack Frontend）是一个涵盖了多种技术和平台的综合性概念，它突破了传统前端开发的界限，不仅仅局限于浏览器环境中的Web应用开发，而是扩展到了包括移动应用（如Android、iOS）、桌面应用、智能设备、甚至后端服务等多个层面。大前端的核心思想是通过一套技术栈或者一组通用的开发模式，实现跨平台的高效开发，以满足多样化终端和应用场景的需求。\n大前端的几个关键特征包括：\n跨平台能力：借助于诸如React Native、Flutter、Ionic等技术，开发者能够使用同一种编程语言（通常是JavaScript或Dart）编写代码，然后部署到多个平台上，实现“一次编写，到处运行”。\n\n全栈开发：大前端开发者往往具备从前端展示层到后端服务的全栈开发能力，特别是利用Node.js这样的技术，使得JavaScript成为服务端开发的可行选择，进一步模糊了前后端的界限。\n\n统一的技术栈：为了提高开发效率和维护性，大前端倡导使用统一的工具链和框架，比如Webpack作为构建工具，Babel进行代码转换，以及Vue.js、React等前端框架来构建用户界面。\n\n高度组件化和模块化：鼓励组件化开发，通过复用组件快速构建应用，同时利于维护和迭代。大前端项目通常会采用模块化的架构设计，使得代码结构清晰，易于管理和扩展。\n\n动态化与优化：大前端开发强调动态加载、按需加载以及性能优化，确保应用在不同设备和网络环境下都能提供良好的用户体验。\n\n持续集成与部署（CI&#x2F;CD）：大前端开发流程中通常会集成持续集成与部署实践，以自动化的方式进行测试、构建和部署，提高开发效率和软件质量。\n\n\n企业为什么选择Node作为后端企业需求视角：随着数字化转型的深入，企业越来越倾向于寻找能够横跨多个平台、快速迭代产品的大前端人才，以快速响应市场变化，减少开发成本，提升用户体验。因此，掌握大前端技术栈的开发者，在招聘市场中通常具有较高的竞争力。\n综上所述，大前端不仅是一种技术趋势，也是一种开发理念，它体现了前端技术栈的不断扩展和深化，以及对更高开发效率和更优用户体验的追求。\n企业在选择Node.js作为后端技术栈时，通常基于以下几个关键因素：\n\n全栈开发能力：Node.js允许使用JavaScript进行前后端开发，这意味着开发团队可以使用同一种语言处理从前端展示到后端逻辑的所有环节，简化了技术栈，提高了代码的可维护性和团队协作的效率。\n\n性能和可扩展性：Node.js采用事件驱动和非阻塞I&#x2F;O模型，这对于处理高并发连接和大规模的实时数据传输尤其有效。它能够在单线程模型下处理大量并发请求，减少了线程上下文切换的开销，从而提高了服务器的吞吐量和响应速度。\n\n快速开发：Node.js的轻量级特性和丰富的生态系统（尤其是npm包管理器及其海量的开源模块）大大加速了开发进程。开发者可以快速找到并集成所需的库和工具，减少重复造轮子的工作，快速迭代产品。\n\n跨平台兼容：Node.js是跨平台的，能在多种操作系统（如Windows、Linux和macOS）上运行，便于开发和部署，提高了开发环境和生产环境的一致性。\n\n强大的社区支持：Node.js拥有活跃的开发者社区和成熟的企业级解决方案，比如Express、Koa、Egg.js等框架，以及众多的中间件和工具，这些都为企业级应用开发提供了坚实的基础。\n\n云原生友好：随着云技术的发展，Node.js因其轻量级和微服务架构的适应性，成为了构建云原生应用的理想选择，能够更好地与其他云服务集成，支持容器化和自动化部署。\n\n技术栈现代化：对于追求技术创新和敏捷开发流程的企业，Node.js的引入有助于现代化技术栈，吸引并保留对最新技术感兴趣的开发人才。\n\n成功案例：像PayPal、Netflix、Uber等大型科技公司成功地将Node.js应用于生产环境，显著提升了开发效率和应用性能，这些案例证明了Node.js在企业级应用中的可靠性和可行性。\n\n\n综上所述，Node.js以其独特的技术优势和生态系统的成熟度，成为了许多企业在构建高性能、可扩展、快速迭代的后端服务时的首选技术。\nNode和浏览器的关联Node.js 和浏览器环境在多个层面上存在关联，同时也有一些本质上的区别。以下是它们之间的一些关键关联点：\n\n共享JavaScript语言基础：最直接的关联在于，Node.js 和浏览器都使用 JavaScript 作为主要的编程语言。这意味着开发者可以利用相同的语言知识在前端和后端编写代码，促进全栈开发。\n\nECMAScript标准：无论是 Node.js 还是浏览器，它们都遵循 ECMAScript 规范，确保了基本的语法和特性在两个环境中保持一致。这意味着很多通用的 JavaScript 代码可以在两个环境中无缝迁移。\n\n共享库和框架：许多流行的 JavaScript 库和框架，如 React、Vue、Angular、Express 等，设计时考虑了跨环境兼容性，可以在 Node.js 服务器端和浏览器客户端都能运行，促进了代码复用和项目结构的统一。\n\n工具链和构建系统：前端开发中常用的构建工具（如Webpack、Babel）和包管理工具（如npm）最初由或主要为 Node.js 生态设计，但它们同样服务于浏览器环境下的代码打包、转换和优化。\n\nWeb API 的模拟：Node.js 提供了一些库（如 JSDOM）来模拟浏览器环境中的某些 Web API（如 DOM 操作），使得在服务器端也能进行一定程度的前端逻辑测试或预处理。\n\n代码移植性：由于上述的共通性，开发者经常可以在 Node.js 和浏览器之间移植代码片段或逻辑，尤其是在处理业务逻辑和算法时。\n\n\n尽管有这些关联，Node.js 和浏览器环境的根本用途和特性仍有明显差异：\n\n环境目标：Node.js 主要用于构建服务器端应用、API、工具脚本等，而浏览器环境则是用户界面和交互的展现层。\n可用API：Node.js 提供了访问文件系统、网络、操作系统等服务器端功能的 API，而浏览器提供了 DOM 操作、AJAX 请求、Web Workers 等面向网页的功能。\n运行时环境：Node.js 运行在 V8 引擎之上，提供了非阻塞 I&#x2F;O 和事件循环机制，适合服务端高并发场景；浏览器环境则包含了渲染引擎，负责解析 HTML、CSS 和执行 JavaScript 来呈现页面。\n\n总之，Node.js 和浏览器虽然在技术和语言上有紧密的联系，但各自服务于不同的目的，形成了前端和后端开发的互补。\n","slug":"interview-scence","date":"2024-06-04T03:11:54.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"2c8643e8bed9de396ca80bda6705cbc6","title":"interview-micro-front-end","content":"微前端微前端概念详细解析微前端（Micro Frontend）是一种现代Web开发架构理念，它借鉴了微服务的思想，将原本庞大的前端应用拆分为多个小型、独立可部署的微应用集合。每个微应用都是一个完整的功能单元，拥有自己的业务逻辑、UI组件、数据管理、路由系统甚至开发团队。这些微应用可以独立开发、测试、部署，最终通过某种机制集成到同一个宿主应用中，共同构成用户面前的完整产品界面。\n关键技术点：\n\n模块化与解耦：微前端的核心在于高度模块化和业务解耦，确保每个微应用可以独立演进。\n\n通信机制：需要一套有效的跨微应用通信方案，以便微应用间能够相互通信和数据共享。\n\n资源加载与隔离：动态加载微应用资源，同时确保CSS、JavaScript的隔离，避免全局污染。\n\n路由管理：如何处理微应用内部路由与宿主应用路由的集成，保证良好的用户体验。\n\n部署策略：支持独立部署，每个微应用可以按需更新，减少整体部署风险。\n\n技术栈无关： 不同的微前端应用可以使用不同的技术栈，这为使用新技术、升级旧技术提供了可能。\n\n并行开发： 因为微前端应用是独立的，所以多个团队可以并行开发不同的应用，无需担心相互影响。\n\n\nqiankun 微前端框架工作原理深度剖析qiankun 是一个流行的微前端实现框架，它基于single-spa并进行了大量优化和封装，提供了更加简洁的API和强大的功能。其工作原理可以细致分为以下几个方面：\n应用容器化：qiankun 通过在宿主应用中创建一个或多个“沙箱”环境（容器），为每个子应用提供独立的运行空间。\n动态加载与挂载：利用动态导入（import()）API，qiankun 在需要时异步加载子应用的入口文件。加载完成后，通过特定的生命周期钩子（如bootstrap, mount, unmount）来控制子应用的初始化、挂载和卸载过程。\n沙箱机制：为了防止JavaScript全局变量冲突和CSS样式污染，qiankun 实现了沙箱机制，通过修改全局对象的原型链或代理等方式，为每个子应用创造独立的运行环境。\n路由与状态管理：qiankun 支持多种路由集成方案，包括直接使用宿主应用的路由系统、子应用自管理路由或两者的混合模式。同时，通过actions和events机制提供跨应用状态共享和通信能力。\n解决JS污染问题\n\n\n\n\n\n\n\n\nqiankun 的 js 沙箱机制主要是通过代理 window 对象来实现的，它可以有效地隔离子应用的全局变量，防止子应用之间的全局变量污染。然而，这种机制并不能解决所有的 js 污染问题。例如，如果我们使用 onclick 或 addEventListener 给  添加了一个点击事件，js 沙箱并不能消除它的影响。\nqiankun 的沙箱机制是解决JS污染的关键。它通过以下方式实现隔离：\n\n全局变量代理：为每个子应用创建一个影子全局对象，代理真实全局对象，使子应用的全局变量变更不直接影响宿主或其他子应用。\n事件委托与代理：对DOM事件监听进行代理，确保事件的注册和触发都在子应用内部完成，避免全局事件污染。\n自定义元素封装：鼓励使用Web Components或类似技术封装子应用内的组件，确保CSS和JS逻辑的隔离。\n\nCSS隔离机制与挑战qiankun 提供了多种CSS隔离方案：\n\nScoped CSS: 利用Webpack的CSS Modules或Vue、React等框架自带的Scoped CSS特性，限制样式的作用范围。\nShadow DOM: 对于支持的浏览器，利用Shadow DOM天然的样式隔离能力。\nCSS-in-JS: 使用样式注入库如styled-components，确保样式与组件紧密绑定。\n\n缺点包括：增加了开发复杂度、可能的浏览器兼容性问题、以及对开发者技能的要求提高。替代方案包括使用BEM等命名约定，或引入第三方CSS隔离库如css-modules-require-hook。\n父子项目通信在Qiankun微前端框架中，父子项目（主应用与子应用）之间的通信是通过几种内置机制来实现的，确保不同子应用之间或子应用与主应用之间能够有效地共享数据或触发事件。以下是Qiankun支持的一些通信方式：\n\nActions:Qiankun 提供了一种名为 Actions 的通信方式，这是一种基于发布&#x2F;订阅模式的通信机制。主应用可以定义一系列actions，并且子应用可以通过这些actions来触发主应用中的逻辑，反之亦然。例如，主应用可以提供一个action用于改变全局主题，子应用则可以调用这个action来改变整个应用的主题。\n\nProps:当主应用装载子应用时，可以通过props的形式向子应用传递数据。这种方式类似于React中的props传递，适用于一次性传递初始化数据的场景。\n\nGlobal State (全局状态管理):Qiankun 支持全局状态管理，允许主应用和子应用共享一个状态管理实例（如Vuex）。通过这种方式，任何应用都可以修改和响应全局状态的变化。\n\nEvent Bus:虽然不是Qiankun直接提供的功能，但你可以在主应用中设置一个全局的Event Bus（事件总线），允许主应用和子应用通过发布和订阅事件来进行通信。\n\nLocalStorage&#x2F;SessionStorage:利用浏览器的本地存储或会话存储也是一种实现跨应用通信的方式，但这种方式更多用于非实时或持久化的需求。\n\n通过路由参数:在URL中携带参数，使得子应用通过监听路由变化来获取信息，这种方式适用于较小的数据传输或导航相关的通信。\n\n\n使用Qiankun进行父子项目通信的基本步骤通常包括：\n\n主应用设置：在主应用中初始化Qiankun，并注册子应用，定义通信接口（如Actions）或全局状态。\n子应用适配：子应用需按照Qiankun的要求进行微应用的导出配置，并在需要的地方调用主应用暴露的通信API。\n通信实现：根据通信需求选择合适的通信方式，如通过Actions发送请求、监听全局状态变更或通过props接收数据。\n\n例如，使用Actions通信的一个简单示例：\n\n在主应用中定义actions：import &#123; initGlobalState &#125; from &#39;qiankun&#39;;\n\nconst actions &#x3D; initGlobalState(&#123;\n  theme: &#39;light&#39;,\n  setTheme(theme) &#123;\n    this.theme &#x3D; theme;\n  &#125;,\n&#125;);\n子应用中调用actions：&#x2F;&#x2F; 在子应用内，通过生命周期或自定义方法调用\nwindow.__POWERED_BY_QIANKUN__ &amp;&amp; actions.setTheme(&#39;dark&#39;);\n\n确保在进行通信设计时，根据实际业务需求选择最合适的通信策略，以保持代码的清晰性和维护性。\n实现一套通信机制如果要自定义一套通信机制，可以参考以下步骤：\n建立消息中心：设计一个全局的消息中心，负责事件的注册、分发与注销。可以是一个单例模式的对象，确保全局唯一。\n事件注册与触发：允许应用注册特定类型的事件及其处理器，同时提供一个触发事件的方法。事件可以携带数据，处理器根据事件类型执行相应逻辑。\n消息格式与协议：定义统一的消息格式和通信协议，确保不同来源的消息可以被正确识别和处理，比如使用JSON作为数据载体，规定消息头包含事件类型、来源等信息。\n异步支持：考虑异步场景，确保处理器可以是异步函数，并且支持Promise或async&#x2F;await，便于处理复杂的业务逻辑。\n错误处理与日志：内置错误捕获和日志记录机制，对于未能正确处理的事件或异常，提供合理的错误反馈和记录。\n性能与优化：考虑通信的性能影响，比如批量处理事件、事件节流&#x2F;防抖等策略，减少不必要的渲染和计算。\n通过这样的设计，可以构建一个灵活、高效且易于维护的通信机制，满足微前端架构下不同子应用间的协作需求。\n子项目之间通信在Qiankun微前端框架中，子项目（子应用）之间的通信并不直接由Qiankun提供开箱即用的解决方案，因为Qiankun主要关注于主应用与子应用之间的管理和通信。然而，子应用之间通信可以通过以下几种策略来实现：\n通过主应用中转：   利用Qiankun提供的全局状态管理或Actions，可以间接实现子应用间的通信。一个子应用可以更新全局状态或触发一个Action，而其他子应用则可以监听这些状态变化或Action，从而实现间接通信。\nEvent Bus：   创建一个中心化的Event Bus（事件总线），无论是放在主应用还是一个专门的公共服务子应用中，然后让所有子应用通过这个Event Bus发布和订阅事件。这样，任意子应用都可以发出事件，其他感兴趣的子应用可以监听并作出响应。\nCustom Events与PostMessage：   如果子应用是通过IFrame或者其他跨域方式集成的，可以使用window.postMessage来实现跨上下文的通信。一个子应用可以通过postMessage发送消息到另一个子应用所在窗口，后者通过监听message事件来接收这些消息。\nShared Services或微服务：   构建一个共享的服务层或微服务，子应用通过调用这些服务来交换数据或触发操作。这要求后端支持或者建立一个轻量级的服务端来处理这些交互。\n使用第三方状态管理库：   如果所有子应用都集成了如Redux、Vuex等状态管理库，可以通过某种方式共享一个Store实例，尽管这在技术上较复杂，需要特别的配置来桥接各个子应用的Store。\nLocalStorage&#x2F;SessionStorage：   虽然不够实时，但存储在本地或会话存储中的数据可以作为一种“通信”的方式，一个子应用写入数据，另一个子应用通过监听Storage事件或轮询来读取这些变化。\n每种方法都有其适用场景和限制，选择最合适的方式取决于你的具体需求、子应用的技术栈以及对性能、实时性、复杂度的考量。在实践中，通常需要结合Qiankun的特性和其他Web通信技术来定制化实现子应用间的通信方案。\n路由模式整合解决子应用路由模式不一致的问题，qiankun 提倡以下策略：\n\n统一模式：推荐所有子应用采用同一路由模式（通常是History模式），并在宿主应用层面做统一处理。\n适配层：在宿主应用中实现路由模式适配逻辑，比如通过URL重写或路由中间件，确保子应用的路由可以正常工作。\n\n组件共享方案\n父子项目间的组件共享：主项目加载时，将组件挂载到全局对象（如window）上，在子项目中直接注册使用该组件。\nnpm包共享：将共享组件封装为npm包，各子应用按需安装使用。\n微应用作为组件库：将某个微应用专门设计为组件库微应用，其他应用动态加载其组件。\n远程组件加载：利用Web Components或前端微服务技术，实现跨项目组件的远程加载和使用。\n\n依赖复用方案除了npm包，qiankun 本身并不直接提供依赖复用的机制，但可以通过以下方式间接实现：\n\n在使用webpack构建的子项目中，要实现复用公共依赖，需要配置webpack的externals，将公共依赖指定为外部依赖，不打包进子项目的代码中。\n\n子项目之间的依赖复用可以通过保证依赖的URL一致来实现。如果多个子项目都使用同一份CDN文件，加载时会先从缓存读取，避免重复加载。\n\n子项目复用主项目的依赖可以通过给子项目的index.html中的公共依赖的script和link标签添加自定义属性ignore来实现。在qiankun运行子项目时，qiankun会忽略这些带有ignore属性的依赖，子项目独立运行时仍然可以加载这些依赖。\n\n在使用qiankun微前端框架时，可能会出现子项目之间和主项目之间的全局变量冲突的问题。这是因为子项目不配置externals时，子项目的全局Vue变量不属于window对象，而qiankun在运行子项目时会先找子项目的window，再找父项目的window，导致全局变量冲突。\n\n\n解决全局变量冲突的方案有三种：\n\n方案一是在注册子项目时，在beforeLoad钩子函数中处理全局变量，将子项目的全局Vue变量进行替换，以解决子项目独立运行时的全局变量冲突问题。\n方案二是通过主项目将依赖通过props传递给子项目，子项目在独立运行时使用传递过来的依赖，避免与主项目的全局变量冲突。\n方案三是修改主项目和子项目的依赖名称，使它们不会相互冲突，从而避免全局变量冲突的问题。\n\n资源加载机制（import-html-entry）\n\n\n\n\n\n\n\n\nqiankun import-html-entry 是qiankun 框架中用于加载子应用的 HTML 入口文件的工具函数。它提供了一种方便的方式来动态加载和解析子应用的 HTML 入口文件，并返回一个可以加载子应用的 JavaScript 模块。import-html-entry是qiankun中用于加载子应用HTML入口的实用工具。其工作流程如下：\n\n加载 HTML 入口文件：import-html-entry 会通过创建一个  标签来加载子应用的 HTML 入口文件。这样可以确保子应用的资源得到正确加载，并在加载完成后进行处理。\n\n解析 HTML 入口文件：一旦 HTML 入口文件加载完成，import-html-entry 将解析该文件的内容，提取出子应用的 JavaScript 和 CSS 资源的 URL。\n\n动态加载 JavaScript 和 CSS 资源：import-html-entry 使用动态创建  和  标签的方式，按照正确的顺序加载子应用的 JavaScript 和 CSS 资源。\n\n创建沙箱环境：在加载子应用的 JavaScript 资源时，import-html-entry 会创建一个沙箱环境（sandbox），用于隔离子应用的全局变量和运行环境，防止子应用之间的冲突和污染。\n\n返回子应用的入口模块：最后，import-html-entry 返回一个可以加载子应用的 JavaScript 模块。这个模块通常是一个包含子应用初始化代码的函数，可以在主应用中调用以加载和启动子应用。\n\n\nqiankun的优缺点\n优点\n\n降低了应用改造的成本，通过html entry的方式引入子应用；\n提供了完备的沙箱方案，包括js沙箱和css沙箱；\n支持静态资源预加载能力。\n\n\n缺点\n\n适配成本较高，包括工程化、生命周期、静态资源路径、路由等方面的适配；\ncss沙箱的严格隔离可能引发问题，js沙箱在某些场景下执行性能下降；\n无法同时激活多个子应用，不支持子应用保活；\n不支持vite等esmodule脚本运行。\n\n\n\n","slug":"interview-micro-front-end","date":"2024-05-30T15:02:59.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"7dfa44f5bf9784913186c2660b6488c1","title":"interview-browser-principles","content":"浏览器原理什么是 XSS 攻击？XSS（Cross-Site Scripting）攻击，即跨站脚本攻击，是指攻击者通过在目标网站上注入恶意脚本，当用户浏览该页面时，恶意脚本会在用户的浏览器上执行，从而盗取用户信息、篡改网页内容、进行钓鱼攻击等。\n如何防御 XSS 攻击？\n输入验证与过滤：对用户提交的所有数据进行严格的输入验证，过滤特殊字符和脚本标签。\n输出编码：对输出到HTML中的数据进行适当的HTML实体编码，如&lt;转换为&amp;lt;，防止脚本执行。\n使用HTTP头部安全策略：设置Content-Security-Policy（CSP）来限制加载外部资源，减少XSS风险。\nCookie安全：对敏感的Cookie设置HttpOnly标志，禁止JavaScript访问，防止通过脚本窃取。\nDOM安全处理：使用安全的DOM操作方法，避免直接拼接字符串生成HTML。\n\n什么是 CSRF 攻击？CSRF（Cross-Site Request Forgery）跨站请求伪造，是一种攻击者利用用户已登录的身份，在用户不知情的情况下，诱使用户浏览器向目标网站发送恶意请求，执行操作如转账、修改密码等。\n如何防御 CSRF 攻击？\nToken验证：在表单或Ajax请求中加入一个随机生成且难以预测的Token，服务器验证每次请求携带的Token是否有效。\nReferer检查：检查请求的来源Referer头部，确认是否来自可信域名，但此方法不完全可靠，因为Referer可以被伪造或禁用。\nSameSite Cookie属性：为Cookie设置SameSite=Lax或SameSite=Strict，限制第三方上下文中的Cookie发送。\n双重认证：对敏感操作要求用户提供额外的身份验证信息，如短信验证码。\n\n什么是中间人攻击？中间人攻击（Man-in-the-Middle Attack, MITM）发生在攻击者拦截并可能篡改通信双方之间的数据传输过程中，通常通过监听、篡改或插入数据包来窃取敏感信息或误导通信双方。\n如何防范中间人攻击？\nHTTPS加密：强制使用HTTPS协议，SSL&#x2F;TLS加密通信，确保数据在传输过程中的保密性和完整性。\n证书验证：确保服务器证书有效且来自于受信任的CA，客户端验证服务器证书以防止中间人替换证书。\n公共Wi-Fi谨慎使用：在不安全的公共网络下尽量避免进行敏感操作。\nDNS安全：使用DNSSEC等技术防止DNS欺骗，确保域名解析的正确性。\n\n有哪些可能引起前端安全的问题?\n不安全的API使用：如未验证的第三方API调用。\n敏感信息泄露：在错误信息或日志中泄露敏感数据。\n不安全的存储：在本地存储中保存敏感信息而未加密。\n点击劫持：缺乏X-Frame-Options头部保护，导致页面被嵌入iframe中进行点击劫持。\n不安全的CORS配置：错误的CORS策略可能允许恶意站点访问API。\n\n网络劫持有哪几种，如何防范？DNS劫持\n防范：使用DNSSEC，选择信誉良好的DNS服务商，定期检查DNS设置。\n\nARP欺骗\n防范：使用静态ARP绑定，部署ARP防护设备或软件，定期检查网络设备。\n\nIP Spoofing\n防范：实施IP源地址验证，使用入侵检测系统（IDS）和防火墙规则。\n\nSSLStrip\n防范：全面采用HTTPS，启用HSTS（HTTP Strict Transport Security）策略，教育用户注意地址栏的HTTPS标志。\n\nSession Hijacking\n防范：使用安全的Session管理，定期更换Session ID，实施TLS客户端证书验证。\n\n通过这些措施，可以大大增强系统的安全性，减少被攻击的风险。\n对浏览器的缓存机制的理解浏览器缓存机制是基于HTTP协议实现的一种提高网页加载速度的技术，通过存储用户访问过的网页资源（如HTML、CSS、JavaScript文件、图片等），在后续请求时直接从本地缓存读取，无需再次向服务器发起请求，从而减少网络延迟和带宽消耗。\n浏览器资源缓存的位置有哪些？浏览器缓存可以存储在多个位置，主要包括：\n\n内存缓存：最快速的缓存方式，位于RAM中，用于存储最近和频繁访问的资源，关闭浏览器后清空。\n磁盘缓存：持久化存储，如硬盘上的某个目录，用于长期存储资源，重启浏览器后依然可用。\nService Worker缓存：一种特殊的浏览器缓存机制，允许开发者编写脚本控制缓存逻辑，为离线访问和性能优化提供更多灵活性。\nApplication Cache（AppCache，已废弃）：旧版的离线缓存机制，已被Service Worker取代，但仍可能在一些老网站中见到。\n\n协商缓存和强缓存的区别强缓存（也称作无条件缓存）：\n\n浏览器在本地有资源副本，且根据资源的Cache-Control或Expires头部判断该副本仍然有效时，直接使用本地缓存，无需向服务器发出请求。\n提高效率，减少不必要的网络交互。\n\n协商缓存（也称作有条件缓存）：\n\n当强缓存未命中时，浏览器会发送请求到服务器，并带上上次请求得到的ETag或Last-Modified等验证信息。\n服务器根据这些验证信息判断资源是否更新，如果资源未变，则返回一个304状态码，告诉浏览器继续使用本地缓存；如果资源已更新，则返回新的资源和新的验证信息。\n\n为什么需要浏览器缓存？\n加速页面加载：减少资源下载时间，提高用户体验。\n节省带宽：重复利用已下载的资源，减少数据传输量。\n减轻服务器压力：减少对服务器的请求次数，特别是在高流量时段。\n提升应用可用性：在弱网或无网络环境下，可依赖缓存资源提供基本功能。\n\n点击刷新按钮或者按 F5、按 Ctrl+F5（强制刷新）、地址栏回车有什么区别？点击刷新按钮或按 F5\n正常刷新页面，浏览器首先尝试使用强缓存，如果强缓存未命中，则进行协商缓存。这通常意味着如果资源没有改变，页面部分或全部内容可以从本地缓存加载。\n\n按 Ctrl+F5（强制刷新）\n强制刷新，绕过浏览器的强缓存和协商缓存机制，直接从服务器重新下载页面所有资源，确保获取最新版本。适用于开发中检查页面更新的情况。\n\n地址栏回车\n类似于点击刷新按钮或F5，执行普通刷新操作。浏览器会根据资源的缓存策略判断是否使用缓存。如果缓存有效（根据强缓存或协商缓存），则直接使用缓存资源；否则，从服务器重新请求资源。\n\n总结而言，正常刷新（F5或刷新按钮）和地址栏回车会遵循浏览器的缓存策略，可能使用缓存；而Ctrl+F5强制刷新则跳过这些策略，确保从服务器拉取所有内容的新鲜副本。\n对浏览器的理解浏览器是用户访问互联网内容的主要工具，它将从服务器接收的HTML、CSS、JavaScript等文件解析、渲染，并展示为可视化的网页。浏览器不仅负责页面展示，还提供了一个运行环境来执行JavaScript代码，支持用户与网页的交互，管理cookies和存储，以及实现网络通信等功能。\n对浏览器内核的理解浏览器内核，也称为渲染引擎，是浏览器的核心组件，负责解析网页内容（HTML、CSS）并将其转换为用户可见的界面。它主要由两个部分构成：渲染引擎（负责布局和绘制）和JavaScript引擎（负责执行脚本）。内核决定了浏览器如何处理网页代码，影响页面的加载速度、兼容性和渲染效果。\n常见的浏览器内核比较\nTrident（Internet Explorer）：早期Windows系统上的IE浏览器使用的内核，已逐渐被淘汰。\nGecko（Firefox）：Mozilla Firefox浏览器的内核，支持高级网页标准和较好的兼容性。\nWebKit：最初由苹果开发，用于Safari浏览器，后来成为许多移动浏览器的基础，如早期的Android浏览器。\nBlink：Google从WebKit分支出来的一个项目，现用于Chrome、Opera等现代浏览器，特点是快速迭代和高性能。\n\n常见浏览器所用内核\nChrome &#x2F; Opera：Blink\nFirefox：Gecko\nSafari：WebKit\nEdge（新版本）：Blink\nInternet Explorer（旧版本）：Trident\n\n浏览器的主要组成部分\n用户界面：地址栏、前进&#x2F;后退按钮、书签菜单等。\n浏览器引擎：协调用户界面与渲染引擎之间的交互。\n渲染引擎：解析HTML和CSS，构建页面布局并渲染。\n网络模块：处理网络请求，如HTTP&#x2F;HTTPS请求。\nJavaScript引擎：解析和执行JavaScript代码。\n数据存储：Cookie、LocalStorage、IndexedDB等。\n\n浏览器渲染原理浏览器渲染过程大致分为以下几个阶段：\n\n解析HTML：构建DOM树。\n解析CSS：构建CSSOM（CSS对象模型）。\n合并DOM与CSSOM：生成Render Tree（渲染树）。\n布局：计算每个节点的几何信息。\n绘制：将Render Tree渲染到屏幕上。\n\n浏览器渲染过程\n加载资源：请求HTML文档，然后根据文档内的引用加载CSS、JavaScript、图片等资源。\n解析与构建：解析HTML生成DOM树，解析CSS生成CSSOM，结合两者构建Render Tree。\n布局与绘制：计算布局（Layout），确定元素在视口中的位置和尺寸，然后绘制到屏幕。\n\n浏览器渲染优化\n减少HTTP请求：合并文件、使用雪碧图、开启HTTP2等。\n资源压缩：减小文件大小，如GZIP压缩。\n懒加载：只在需要时加载图片或其他资源。\n使用CDN：减少资源加载延迟。\n预加载与预读取：提前请求可能需要的资源。\n\n渲染过程中遇到 JS 文件如何处理？当浏览器遇到JavaScript文件时，通常会暂停HTML解析，加载并执行JS，这是因为JS可能修改DOM结构或CSSOM。这种行为被称为“JavaScript阻塞”，为减少其负面影响，可以使用async或defer属性异步加载脚本。\n什么是文档的预解析？文档预解析（Pre-parser）是浏览器的一个优化策略，它在主线程执行JavaScript之前，提前分析HTML文档，识别并开始加载外部资源（如CSS和JS），从而减少实际解析时的等待时间。\nCSS 如何阻塞文档解析？外部CSS文件默认是阻塞的，意味着浏览器遇到&lt;link&gt;标签加载CSS时，会暂停HTML解析，直到CSSOM构建完成，因为CSS可能影响到元素的布局。内联样式不会阻塞解析，因为它不需要额外的HTTP请求。\n如何优化关键渲染路径？\n减少关键资源数量：确保首屏加载所需资源尽可能少。\n优先加载关键CSS：内联关键CSS或使用媒体类型print加载非关键CSS。\n异步加载JavaScript：避免阻塞渲染的关键路径。\n避免使用@import：因为它会导致CSS加载延迟。\n优化图片和图标：使用合适的格式和尺寸，考虑懒加载。\n\n什么情况会阻塞渲染？\n解析中的JavaScript：同步脚本会阻塞HTML解析。\n等待外部CSS：构建Render Tree需要完整的CSSOM。\n大型图片和媒体文件：下载时间长，影响首屏渲染。\n重排与重绘：频繁的DOM操作可能导致页面多次渲染。\n网络拥塞：资源加载慢也会延后渲染过程。\n\n浏览器本地存储方式及使用场景浏览器提供了多种本地存储技术，以便开发者在客户端存储数据。这些技术包括Cookie、LocalStorage、SessionStorage和IndexedDB，每种都有其特定的用途和限制。\nCookie使用场景：\n\n会话管理：跟踪用户会话状态，如登录状态。\n用户偏好设置：存储用户的界面偏好，如语言选择。\n跨页面数据传递：在不同页面间共享少量数据。\n\nLocalStorage使用场景：\n\n持久化存储：适合长期存储大量用户数据，如用户配置。\n离线应用：缓存用户数据，支持离线浏览功能。\n客户端数据缓存：存储不敏感的应用数据，提高应用性能。\n\nSessionStorage使用场景：\n\n临时会话数据：存储仅在当前会话中有效的数据，如表单暂存。\n单页应用状态：在SPA中存储页面间跳转的状态信息。\n\nIndexedDB使用场景：\n\n大量结构化数据存储：适合存储大量复杂数据，如图片库、用户生成的内容。\n离线应用数据库：为离线应用提供数据存储解决方案。\n高性能数据检索：利用索引实现快速查询。\n\nCookie有哪些字段及其作用Cookie由多个字段组成，每个字段都有其特定的意义：\n\nName：键名，用于标识存储的数据项。\nValue：键值，存储的具体数据。\nExpires&#x2F;Max-Age：定义Cookie的有效期，过期后浏览器会自动删除。\nDomain：指定Cookie所属的域名，决定了哪些站点可以访问该Cookie。\nPath：定义了Cookie的路径，指定了浏览器发送Cookie的条件，只有访问匹配该路径的URL时才会发送Cookie。\nSecure：指示浏览器仅在HTTPS连接下发送Cookie。\nHttpOnly：标记为HttpOnly的Cookie不能被JavaScript访问，增加了安全性。\n\nCookie、LocalStorage、SessionStorage区别\n存储容量：Cookie通常限制在4KB左右，LocalStorage和SessionStorage则远大于此，通常为5MB或更多。\n有效期：Cookie可以设置过期时间，LocalStorage持久存储除非手动删除，SessionStorage仅在当前会话有效，关闭浏览器即清除。\n作用域：Cookie可跨域名（需正确设置Domain），LocalStorage和SessionStorage限于同源策略下，不能跨域。\n与服务器通信：Cookie随每次HTTP请求自动发送到服务器，LocalStorage和SessionStorage不参与网络请求。\n\n前端储存的方式前端储存方式主要包括：\n\nCookie：最早的传统存储方式，主要用于会话管理和用户偏好设置。\nLocalStorage：HTML5引入的持久化本地存储，适合长期存储大量数据。\nSessionStorage：HTML5引入的会话存储，数据仅在当前浏览器会话中有效。\nIndexedDB：一种客户端存储大量结构化数据的数据库。\nWeb SQL（已废弃）：曾是HTML5标准的一部分，但现在不推荐使用。\nCache API：用于存储资源的缓存机制，改善网页性能。\nService Worker Cache：配合Service Worker使用，为离线体验和网络请求优化提供缓存。\n\nIndexedDB的特点\n异步API：所有操作都是异步的，不会阻塞UI线程，提升用户体验。\n事务处理：支持事务，确保数据的一致性和完整性。\n灵活的数据模型：可以存储复杂的结构化数据，包括对象和数组。\n索引支持：提供索引功能，加速数据检索。\n大容量存储：能够处理大量数据，适合存储多媒体文件等大数据量。\n同源策略：遵循同源策略，但可以通过IndexedDB的API在Service Workers中实现跨域数据访问。\n\n什么是同源策略同源策略（Same-Origin Policy）是浏览器为了保证安全，实施的一种重要安全策略。它规定了一个网页脚本只能读取来自同一源（即协议、域名、端口号相同的源）的资源，而对不同源的资源进行访问则会受到限制。这意味着，一个网页上的脚本不能随意读取另一个网页的数据，除非这两个网页满足同源条件。这样做可以有效防止恶意网站通过脚本读取其他网站的敏感信息，如 cookie、localStorage 等。\n如何解决跨域问题解决跨域问题的常见方法有以下几种：\n\nCORS（跨源资源共享）：服务器通过在响应头中添加特定的 Access-Control-Allow-Origin 字段，允许特定源的请求。\nJSONP（JSON with Padding）：利用 &lt;script&gt; 标签没有同源限制的特性，通过动态插入 &lt;script&gt; 来实现跨域请求。\n代理服务器：设置一个代理服务器，将请求转发到目标服务器，从而绕过浏览器的同源策略限制。\nWebSocket：WebSocket 协议本身不遵循同源策略，可以用于跨域实时通信。\n使用 postMessage API：允许来自不同源的脚本采用异步方式进行有限制的通信。\n\n事件是什么？事件模型？事件是在用户与网页交互或在网页内部发生某些改变时，浏览器生成并传递给JavaScript代码的信号。事件模型描述了事件如何在DOM树中传播和处理，主要分为两种模型：\n\n捕获阶段：事件从根节点开始，向下传播到目标元素。\n目标阶段：事件到达实际的目标元素，并触发相应的事件处理器。\n冒泡阶段：事件从目标元素开始，向外层元素传播，直到根节点。\n\n如何阻止事件冒泡在JavaScript中，可以通过调用事件对象的 stopPropagation() 方法来阻止事件向上冒泡。例如，在事件处理函数中：\nelement.addEventListener(&#39;click&#39;, function(event) &#123;\n    event.stopPropagation();\n    &#x2F;&#x2F; 处理点击事件的代码...\n&#125;, false);\n\n对事件委托的理解事件委托（Event Delegation）是一种高效的事件处理模式，它允许将事件监听器添加到一个父元素上，而不是每个子元素上。当事件在子元素上触发时，通过判断事件对象（如 event.target）来确定实际的目标元素，并执行相应逻辑。这种方法减少了内存消耗，提高了性能，特别是在动态添加或删除子元素的场景下特别有用。\n事件委托的使用场景\n大量动态生成的元素：如列表项、表格行等，无需为每个元素单独绑定事件监听器。\n减少内存占用：适用于需要绑定大量事件处理器的场景。\n简化DOM操作：避免频繁地添加和移除事件监听器。\n\n同步和异步的区别\n同步：程序按照代码的编写顺序依次执行，每个任务必须等待前一个任务完成才能开始。这会阻塞后续任务，直到当前任务结束。\n异步：任务不立即等待结果，而是继续执行后续代码，当任务完成时通过回调、Promise、async&#x2F;await等方式通知主线程，实现非阻塞操作。\n\n对事件循环的理解事件循环（Event Loop）是JavaScript运行环境（如浏览器和Node.js）处理异步操作的核心机制。它不断地检查是否有待处理的任务，包括宏观任务（Macro Task）和微观任务（Micro Task）。执行流程大致如下：\n\n执行当前宏任务队列中的所有任务。\n清空当前微任务队列中的所有任务。\n如果还有未处理的宏任务或新的微任务产生，重复步骤1和2。\n当所有任务执行完毕，进入休眠，等待下一轮事件触发。\n\n宏任务和微任务分别有哪些\n宏任务：包括setTimeout、setInterval、I&#x2F;O、UI渲染、事件处理（如click事件）、setImmediate（Node.js特有）等。\n微任务：包括Promise的回调、MutationObserver、process.nextTick（Node.js特有）、queueMicrotask（ES2019引入）等。\n\n什么是执行栈执行栈（Call Stack）是编程中的一个概念，用于跟踪函数的调用过程和执行顺序。每当函数被调用时，都会创建一个新的栈帧（包含函数的局部变量、参数等信息）并压入栈顶；函数执行完毕后，其对应的栈帧会被弹出栈。JavaScript是单线程且使用执行栈来管理函数调用，确保函数按照调用顺序执行。\nNode.js 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？Node.js的Event Loop和浏览器中的Event Loop的主要区别在于它们处理任务队列的方式和特定的宏任务类型。Node.js中特有的宏任务类型包括I&#x2F;O操作和setImmediate，而浏览器中没有setImmediate，但有requestAnimationFrame。\nprocess.nextTick是Node.js中的一个特殊API，它将任务安排在当前执行栈的末尾，但在任何其他微任务之前执行。这意味着即使在当前函数还没有完全返回，process.nextTick的回调也会在当前事件循环迭代结束前被执行，这使得它比Promise的回调或setImmediate更快执行。\n事件触发的过程是怎样的事件触发的基本过程包括：\n\n事件产生：用户交互（如点击、键盘输入）或系统行为（如页面加载完成）导致事件产生。\n事件捕获&#x2F;目标阶段判断：根据事件模型，事件可能先经过捕获阶段向目标元素传播，然后在目标元素触发事件处理函数，最后进入冒泡阶段向上回传。\n查找事件监听器：在事件到达相应的阶段时，查找该阶段注册的事件监听器。\n调用事件处理函数：执行找到的事件处理函数，可能包括阻止默认行为、阻止事件传播等操作。\n事件循环处理：对于异步事件，事件处理可能涉及事件循环，等待特定时机执行。\n后续任务执行：事件处理完成后，根据事件循环机制继续执行其他排队的任务。\n\nV8的垃圾回收机制是怎样的V8引擎的垃圾回收机制是其高效执行JavaScript代码的关键部分，主要包括以下几个方面：\n1. 分代回收机制V8将内存分为新生代（Young Generation）和老生代（Old Generation）两部分，依据对象的生命周期长短进行管理。\n\n新生代：主要用于存放新创建的对象。新生代又分为两个子区域：From Space和To Space。当From Space区域填满时，垃圾回收器会执行Scavenge算法，将存活的对象复制到To Space，并清空From Space。这个过程会重复进行，From Space和To Space的角色会互换，以此方式快速回收短期存活的对象。\n\n老生代：长期存活或体积较大的对象会被晋升到老生代。老生代的回收相对复杂，使用标记-清除（Mark-and-Sweep）或标记-整理（Mark-Compact）算法。标记阶段遍历所有可达对象并打标记，清除阶段回收未标记的对象。整理阶段则在回收后整理内存碎片，避免内存碎片化。\n\n\n2. 引用计数虽然V8主要依赖分代回收，但它也使用引用计数作为辅助手段。引用计数会追踪每个对象的引用数量，当一个对象的引用数变为0时，该对象就被认为是不可达的，可以被回收。然而，引用计数法容易导致循环引用问题，因此在V8中不是主要的回收策略。\n3. 并发与增量回收为了减少垃圾回收对JavaScript执行的影响，V8引入了并发（Concurrent）、增量（Incremental）和并行（Parallel）回收技术。这些技术允许垃圾回收在主线程执行代码的同时进行，比如并发标记可以在主线程暂停之外的时间进行，而增量标记和清理则把回收过程分成多个小步骤，穿插在JS代码执行之间，以此减少因垃圾回收造成的页面卡顿现象。\n4. 停顿（Stop-The-World）尽管V8努力减少垃圾回收带来的暂停时间，但在某些情况下，如老生代的完整标记清除操作，仍然需要“停顿”主线程，暂停JavaScript执行以完成垃圾回收。这是因为在单线程环境下，为了保证数据一致性，回收操作必须在一个无干扰的环境中进行。\n哪些操作会造成内存泄漏1. 全局变量\n说明：将对象直接赋值给全局变量，或在闭包中不恰当地引用对象，会导致这些对象一直保持可达状态，无法被垃圾回收。\n\n2. 循环引用\n说明：两个或多个对象互相引用，形成闭环，即使这些对象不再被外部引用，只要闭环存在，垃圾回收器就不会回收它们。\n\n3. 未清理的事件监听器\n说明：为DOM元素或其他对象添加事件监听器后忘记移除，特别是当监听器引用了外部作用域的变量时，会导致这些变量和相关对象无法被回收。\n\n4. 被遗忘的定时器或回调\n说明：设置的setTimeout、setInterval或其它异步操作的回调函数中引用了不再需要的对象，若不取消这些定时器或清除回调，对象会持续被引用。\n\n5. DOM元素引用\n说明：即使从DOM树中移除了元素，但如果JavaScript中还保留着对该元素的引用，元素及其相关的子元素和数据仍然不会被回收。\n\n6. 缓存不当\n说明：无限制或不当管理的缓存（如使用Map或WeakMap存储大量对象）可能导致大量不再使用的数据占用内存，尤其是当缓存对象包含了大量子对象时。\n\n7. V8的特殊情况\n如：使用v8::Persistent对象时，如果未正确管理，可能会导致对象无法被垃圾回收，因为Persistent对象会保持对象的引用直到显式释放。\n\n解决内存泄漏通常需要识别并修正上述问题，使用开发工具（如Chrome DevTools）监控内存使用情况，定期审查代码，及时解除不再需要的引用，以及合理管理事件监听器和定时器等。\n","slug":"interview-browser-principles","date":"2024-05-30T15:01:58.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"888bd5308fbcbb0b07f6bb2fddc55ca5","title":"interview-computer-network","content":"计算机网络GET和POST的请求的区别\n数据位置：GET请求将参数附加在URL中，作为查询字符串；POST请求将参数放在请求体（request body）中。\n数据大小：GET请求受URL长度限制，不适合传输大量数据；POST请求理论上无大小限制，更适合大数据量传输。\n幂等性：GET请求是幂等的，多次请求结果相同，不会改变服务器状态；POST请求不是幂等的，可能产生不同的副作用。\n安全性：由于GET请求参数在URL中，易于被截取，相对不安全；POST请求相对更安全，但并非绝对安全，因为HTTP协议本身不加密。\n缓存：GET请求可被浏览器缓存，POST请求不会被缓存，除非手动设置。\n\nPOST和PUT请求的区别\n目的：POST用于创建新资源，或在不确定资源是否存在时发送数据；PUT用于替换已有资源，要求资源已知且具有唯一标识。\n幂等性：PUT是幂等的，多次执行具有相同效果，不会产生额外资源；POST不是幂等的，多次请求可能创建多个资源。\n请求体：两者都通过请求体传递数据，但PUT请求要求携带完整的资源表示，而POST可以传递部分更新或新增数据。\n\n常见的HTTP请求头和响应头请求头：\n\nAccept: 客户端能接受的响应内容类型。\nContent-Type: 请求体的数据类型。\nHost: 请求的主机名和端口号。\nUser-Agent: 发起请求的浏览器信息。\n\n响应头：\n\nContent-Type: 响应内容的MIME类型。\nServer: 服务器软件的信息。\nSet-Cookie: 服务器设置的Cookie信息。\nLocation: 重定向时的URL。\n\nHTTP状态码304是多好还是少好304状态码表示“未修改”，表示请求的资源未发生变化，可以直接使用缓存副本。从性能角度，304状态码多表明缓存机制工作良好，减少了不必要的数据传输，提升了效率。然而，如果过于频繁，可能意味着服务器端未正确设置缓存控制策略，导致不必要的验证请求。理想情况下，应当平衡缓存的有效期和验证频率，以达到最佳性能。\n常见的HTTP请求方法\nGET：请求指定资源。\nPOST：提交数据，用于创建或更新资源。\nPUT：替换现有资源或创建新资源。\nDELETE：删除指定资源。\nHEAD：类似GET，但只返回头部信息，不返回主体内容。\nOPTIONS：请求服务器支持的HTTP方法。\nPATCH：部分更新资源。\n\nput和patch的区别PUT和PATCH都是HTTP协议中的方法，用于资源的更新，但它们之间存在几个关键区别：\n\n更新范围:\n\nPUT: 该方法用于替换整个资源。当你发送一个PUT请求时，你需要提供资源的所有字段，即使你只想修改其中的一部分。服务器会用请求中的数据完全替换现有资源的表示。如果某些字段没有在请求体中提供，服务器可能会将其视为应该被清除或设为默认值。\nPATCH: 此方法用于对资源的部分属性进行更新。它允许客户端仅发送需要修改的那部分数据，而不是整个资源。服务器只会应用这些特定的更改，保持其它未提及属性不变。\n\n\n幂等性:\n\nPUT: 是幂等的，意味着无论你执行多少次相同的PUT请求，资源的状态将保持一致。多次执行同一PUT请求，服务器上的资源状态不会有所不同，这使得PUT非常适合用于更新操作，因为它提供了可预见的结果。\nPATCH: 不是严格的幂等操作。虽然PATCH请求可以被设计成幂等的，但实际上取决于实现。如果PATCH请求包含逻辑错误或条件判断，多次执行可能导致资源状态的不同变化，因此PATCH的幂等性依赖于具体的应用逻辑。\n\n\n安全性:\n\n两者都被认为是非安全方法，因为它们都可以改变服务器上的资源状态，但这在HTTP语境中指的是它们可能会产生副作用，而不是通常意义上的“不安全”。\n\n\n使用场景:\n\nPUT通常用于更新整个资源，如替换一个用户的全部信息。\nPATCH则更适合做增量更新，比如只修改用户的电话号码而不影响其他信息。\n\n\n\n在选择使用PUT还是PATCH时，应考虑是否需要更新资源的全部属性，以及幂等性的需求。如果只需要更新资源的部分属性，使用PATCH会更加精确和高效；而如果需要替换整个资源，或幂等性是重要考量，则应使用PUT。\nOPTIONS请求方法及使用场景OPTIONS方法用于请求服务器告知其支持的所有HTTP方法及其它通信选项。常用于 CORS（跨源资源共享）预检请求，浏览器在正式发起跨域请求前，先发送一个OPTIONS请求来询问服务器是否允许特定的HTTP方法和头部信息。\nHTTP 1.0 和 HTTP 1.1 之间的区别\n持久连接：HTTP 1.1引入了持久连接，允许复用TCP连接发送多个请求，减少连接建立和关闭的开销。\n管道化：HTTP 1.1支持请求管道化，客户端可以在收到前一个请求的响应之前发送下一个请求。\nHost头：HTTP 1.1引入了Host头字段，支持在同一IP上托管多个虚拟主机。\n错误码和原因短语：HTTP 1.1扩展了状态码和原因短语。\n\nHTTP 1.1 和 HTTP 2.0 的区别\n二进制分帧：HTTP&#x2F;2采用二进制格式而非文本，更高效地传输数据。\n多路复用：同一连接上可以同时处理多个请求和响应，无需等待。\n服务器推送：服务器可主动推送客户端未请求的资源。\n头部压缩：HPACK算法压缩头部，减少带宽消耗。\n优先级：支持请求优先级，优化资源加载顺序。\n\nHTTP和HTTPS协议的区别\n安全性：HTTPS基于SSL&#x2F;TLS协议，对HTTP数据进行加密，提供了数据的安全传输。\n端口：HTTP默认端口为80，HTTPS默认端口为443。\n证书：HTTPS需要服务器配置证书，验证服务器身份，增强信任度。\n\nGET方法URL长度限制的原因GET方法的URL长度受限于浏览器和服务器对URL的最大长度处理能力，通常是因为历史原因和协议设计限制。过长的URL可能导致解析错误、缓存问题、日志记录问题或中间件不兼容。RFC规范建议但不强制最大长度，实际限制通常在2048到8192个字符之间。\n当在浏览器中输入 Google.com 并按下回车之后发生了什么？\n域名解析：浏览器查询DNS服务器，将域名解析为IP地址。\n建立连接：使用TCP三次握手与服务器建立连接。\n发送HTTP请求：浏览器构造并发送GET请求至服务器。\n服务器处理：服务器处理请求，返回响应（HTML页面）。\n浏览器解析：浏览器解析HTML，构建DOM树，加载CSS和执行JavaScript。\n渲染页面：根据解析结果，渲染最终的可视化页面。\n\nTCP的三次握手和四次挥手TCP（三次握手和四次挥手）是传输控制协议的两个重要过程，分别用于建立和终止连接。它们确保了数据传输的可靠性和准确性。以下是对这两个过程的详细解释：\n三次握手（Three-Way Handshake）三次握手是 TCP 建立连接的过程，涉及客户端和服务器之间的三个步骤。\n\n第一次握手（SYN）\n\n客户端向服务器发送一个 SYN（同步序列号）包，表示请求建立连接。该包包含一个初始序列号（Sequence Number）。\n\nClient: SYN, Seq &#x3D; X\n\n第二次握手（SYN-ACK）\n\n服务器收到 SYN 包后，回应一个 SYN-ACK 包。SYN 表示服务器同意建立连接，并且 ACK 表示确认收到客户端的 SYN 包。该包包含服务器的初始序列号（Seq &#x3D; Y）和对客户端序列号的确认（Ack &#x3D; X + 1）。\n\nServer: SYN, ACK, Seq &#x3D; Y, Ack &#x3D; X + 1\n\n第三次握手（ACK）\n\n客户端收到服务器的 SYN-ACK 包后，发送一个 ACK 包给服务器，表示确认收到服务器的 SYN-ACK 包，并且连接建立成功。该包的确认号是服务器的序列号加 1（Ack &#x3D; Y + 1）。\n\nClient: ACK, Seq &#x3D; X + 1, Ack &#x3D; Y + 1\n\n完成三次握手后，客户端和服务器之间的连接就建立起来了，接下来可以进行数据传输。\n四次挥手（Four-Way Handshake）四次挥手是 TCP 断开连接的过程，涉及客户端和服务器之间的四个步骤。\n\n第一次挥手（FIN）\n\n客户端发送一个 FIN（结束序列号）包，表示不再发送数据，但仍然可以接收数据。该包包含一个序列号（Seq &#x3D; U）。\n\nClient: FIN, Seq &#x3D; U\n\n第二次挥手（ACK）\n\n服务器收到 FIN 包后，回应一个 ACK 包，表示确认收到客户端的 FIN 包。该包的确认号是客户端的序列号加 1（Ack &#x3D; U + 1）。\n\nServer: ACK, Seq &#x3D; V, Ack &#x3D; U + 1\n\n第三次挥手（FIN）\n\n服务器发送一个 FIN 包，表示不再发送数据。该包包含一个序列号（Seq &#x3D; W）。\n\nServer: FIN, Seq &#x3D; W\n\n第四次挥手（ACK）\n\n客户端收到服务器的 FIN 包后，回应一个 ACK 包，表示确认收到服务器的 FIN 包，并且连接终止。该包的确认号是服务器的序列号加 1（Ack &#x3D; W + 1）。\n\nClient: ACK, Seq &#x3D; U + 1, Ack &#x3D; W + 1\n\n完成四次挥手后，客户端和服务器之间的连接就断开了。\n总结\n三次握手用于建立可靠的 TCP 连接，确保双方都准备好进行数据传输。\n四次挥手用于优雅地关闭 TCP 连接，确保双方都同意断开连接，并且所有数据都已正确接收。\n\n理解三次握手和四次挥手对于掌握 TCP 协议和网络编程至关重要，能够帮助你更好地处理网络连接问题和优化网络通信。\n对keep-alive的理解Keep-Alive是HTTP协议中的一种连接复用机制，允许在一个TCP连接上发送多个HTTP请求和响应，而不是每个请求-响应对都新建连接。这减少了TCP连接建立和断开的开销，提升了网页加载速度。默认情况下，HTTP&#x2F;1.1启用Keep-Alive，可通过Connection头部字段关闭。\n页面有多张图片，HTTP是怎样的加载表现？\nHTTP&#x2F;1.1：如果没有使用pipelining（管道化），图片会按顺序加载，每个图片请求需等待前一个请求的响应结束。使用pipelining，虽可同时发送多个请求，但仍需顺序接收响应。\nHTTP&#x2F;2：由于多路复用，所有图片请求几乎同时发出，服务器并行处理并返回数据片段，显著加快页面加载速度。\n\nHTTP2的头部压缩算法是怎样的？HTTP&#x2F;2使用HPACK压缩算法压缩头部，通过静态和动态表来减少头部字段的传输大小。静态表包含了一些常用的头部字段及其编码，动态表则是通信过程中双方协商的，用于存储之前发送过的字段。通过索引、差异编码、哈夫曼编码等技术，大大减少了头部的字节开销。\nHTTP请求报文的是什么样的？一个典型的HTTP请求报文结构包括：\n\n请求行：方法、URL、协议版本。\n请求头：多个键值对，描述客户端信息和请求参数。\n空行：分割请求头和请求体的CRLF。\n请求体：可选，POST等方法时包含数据。\n\nHTTP响应报文的是什么样的？HTTP响应报文结构包括：\n\n状态行：协议版本、状态码、原因短语。\n响应头：多个键值对，描述响应信息。\n空行：分割响应头和响应体的CRLF。\n响应体：可选，具体响应数据，如HTML页面。\n\nHTTP协议的优点和缺点优点：\n\n简单快速：易于理解，客户端与服务器通信简单高效。\n灵活：支持多种类型的数据传输。\n无状态：降低服务器负担，易于扩展。\n支持缓存：减少网络传输，提高响应速度。\n\n缺点：\n\n明文传输（HTTP）：安全性低，易被窃听和篡改。\n无状态特性：每次请求都需要重新认证，增加了复杂度。\n连接无复用（HTTP&#x2F;1.0）：效率较低，尤其是高延迟网络。\n队头阻塞（HTTP&#x2F;1.x）：一个请求响应慢会影响后面请求的处理。\n\n说一下HTTP 3.0HTTP&#x2F;3是HTTP协议的最新版本，基于QUIC（Quick UDP Internet Connections）协议，而非传统的TCP。QUIC利用UDP来提供更低的延迟和更好的安全性：\n\n多路复用：改进的多路复用机制，解决了HTTP&#x2F;2中的队头阻塞问题。\n连接迁移：在不同网络间无缝切换，保持连接状态，提升用户体验。\n0-RTT：首次连接可利用之前缓存的密钥快速握手，减少延迟。\n加密：全连接加密，安全性提升，内置TLS 1.3。\n\nHTTP（Hypertext Transfer Protocol）是用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础。从最初的简单设计到如今的高性能标准，HTTP经历了多个版本的演进。以下是HTTP各主要版本的详细介绍：\nHTTP各个版本1. HTTP&#x2F;0.9 (1991)\n简介：HTTP的原始版本，极其简单，仅支持GET方法，用于请求HTML文档。\n特点：\n功能单一：只能传输HTML格式的文本，不支持请求头、响应头和状态码。\n无协议头：导致协议功能极为有限，不支持多媒体内容或其他复杂交互。\n\n\n\n2. HTTP&#x2F;1.0 (1996)\n简介：首次正式发布的HTTP版本，引入了许多关键特性和概念。\n特点：\n请求和响应结构：增加了请求头和响应头，支持GET、POST、HEAD等方法，以及状态码。\n持久连接：支持Keep-Alive选项，减少连接建立和关闭的开销，但默认情况下每个请求后仍会关闭连接。\n内容类型多样化：可以传输多种类型的资源，如图片、音频等。\n\n\n\n3. HTTP&#x2F;1.1 (1997)\n简介：目前使用最为广泛的HTTP版本，对1.0做了显著的性能和效率提升。\n特点：\n持久连接默认开启：减少了多次请求的连接成本。\n管道化请求：允许客户端在收到前一个请求的响应之前发送多个请求。\n虚拟主机支持：同一IP地址可服务于多个域名。\n内容编码和压缩：支持数据压缩，减少传输量。\n缓存控制：增强了缓存机制，改善了网络效率。\n\n\n\n4. HTTP&#x2F;2 (2015)\n简介：基于SPDY协议，对HTTP&#x2F;1.1进行了重大改进，旨在解决性能瓶颈。\n特点：\n二进制分帧层：所有数据以二进制格式传输，提高了效率和解析速度。\n多路复用：在一个TCP连接上并行处理多个请求和响应，解决了队头阻塞问题。\n头部压缩：HPACK算法压缩请求和响应头，减少网络传输量。\n服务器推送：服务器可主动推送客户端可能需要的资源。\n优先级和流控：客户端可以设置请求优先级，服务器根据优先级处理请求。\n\n\n\n5. HTTP&#x2F;3 (发布于2019年，但普及程度仍在增长)\n简介：基于QUIC协议，使用UDP而非TCP作为传输层协议。\n特点：\nQUIC基础：提供更快的连接建立时间，减少延迟。\n多路复用：继承自HTTP&#x2F;2，但在UDP上实现，进一步优化。\n加密：所有通信默认加密，提高安全性。\n更好地处理包丢失和重排序：由于QUIC的内置机制，能更高效地处理网络问题。\n\n\n\n每个版本的HTTP都是对前一版本的改进，反映了互联网发展和技术进步的需求，特别是在性能、安全性和用户体验方面。随着网络环境的不断变化，HTTP协议也在持续进化，以满足日益增长的网络应用需求。\nHTTP协议的性能怎么样HTTP协议的性能取决于版本和具体的使用环境：\n\nHTTP&#x2F;1.1：性能受限于连接数限制和队头阻塞问题。\nHTTP&#x2F;2：通过多路复用和头部压缩显著提升了性能，但依然可能遇到TCP的拥塞控制问题。\nHTTP&#x2F;3：基于QUIC的HTTP&#x2F;3进一步降低了延迟，增强了连接可靠性，提高了整体性能。\n\nURL有哪些组成部分URL（统一资源定位符）通常包括：\n\n协议：如http、https。\n域名：服务器的标识，如example.com。\n端口号：可选，如80或443，默认可省略。\n路径：资源路径，如&#x2F;path&#x2F;to&#x2F;resource。\n查询字符串：GET请求参数，如?key&#x3D;value&amp;another&#x3D;value。\n\n与缓存相关的HTTP请求头有哪些\nCache-Control：指示请求或响应的缓存策略。\nETag：资源的实体标签，用于验证资源是否改变。\nIf-Modified-Since：客户端上次获取资源的时间，用于判断资源是否更新。\nIf-None-Match：与ETag一起使用，验证资源是否未被修改。\nLast-Modified：资源最后修改的时间。\nExpires：资源过期时间，HTTP&#x2F;1.0中的缓存控制方式。\nPragma：HTTP&#x2F;1.0中的兼容性头，与Cache-Control:no-cache等效。\n\n什么是HTTPS协议？HTTPS（Hypertext Transfer Protocol Secure）是一种基于HTTP协议的、通过SSL&#x2F;TLS协议进行加密的安全通信协议。它旨在为Web通信提供安全的环境，保护数据的机密性和完整性，防止数据在传输过程中被窃取或篡改。HTTPS通过在HTTP下层加入SSL&#x2F;TLS加密层，确保了客户端与服务器之间的数据交换是加密的，从而保护了用户的隐私和敏感信息，如登录凭据、信用卡号等。\nTLS&#x2F;SSL的工作原理TLS（Transport Layer Security）和其前身SSL（Secure Sockets Layer）是一套用于保障网络通信安全的协议，它们的工作原理概括如下：\n\n握手协议：通信开始时，客户端与服务器通过一系列消息交换，协商加密套件（包括加密算法、散列函数、密钥交换算法等）、交换密钥，并验证对方身份。\n\n密钥交换：在握手过程中，使用非对称加密（如RSA）来安全地交换对称密钥。此密钥仅双方知道，后续通信将使用这个密钥进行对称加密。\n\n数据加密：一旦密钥交换完成，双方开始使用对称加密算法（如AES）对实际数据进行加密，保证数据传输的机密性。\n\n消息认证码（MAC）：为了保证数据完整性，每条消息还会附带一个MAC，它是消息的哈希值，接收方可以用共享密钥验证数据未被篡改。\n\n会话恢复：为了提高效率，TLS支持会话缓存，允许在后续连接中重用之前的密钥材料，跳过耗时的密钥交换步骤。\n\n\n数字证书是什么？数字证书是一种电子文档，由权威的第三方机构（称为证书颁发机构，CA）签发，用来证明某个实体（如网站服务器）的身份。它包含了实体的公钥、实体的名称、证书有效期、颁发机构的名称及该证书的数字签名等信息。在HTTPS通信中，服务器向客户端发送自己的数字证书，客户端通过验证证书上的数字签名来确认证书的真实性和有效性，进而信任证书中包含的公钥，用于后续的密钥交换。\nHTTPS通信（握手）过程HTTPS握手过程简述如下：\n\n客户端发起请求：客户端发送一个“Client Hello”消息，包含它支持的SSL&#x2F;TLS版本、加密套件列表等信息。\n\n服务器响应：服务器选择最合适的加密套件，并回复“Server Hello”消息，包含选定的加密套件、服务器随机数等。\n\n证书交换：服务器发送其数字证书给客户端，证明自己的身份。\n\n密钥交换与验证：客户端验证证书后，发送一个“Client Key Exchange”消息，内含一个使用服务器公钥加密的预主密钥。同时发送“Change Cipher Spec”和“Finished”消息，表示后续消息将使用协商好的密钥和算法加密。\n\n服务器确认：服务器解密得到预主密钥，计算出会话密钥，并同样发送“Change Cipher Spec”和“Finished”消息。\n\n\n至此，双方建立了安全的通信通道，可以进行加密的数据传输。\nHTTPS的特点\n安全性：通过加密数据传输，保护数据免遭窃听和篡改。\n身份验证：数字证书确保了服务器身份的可信度，防止中间人攻击。\n兼容性：基于HTTP标准，广泛支持各类Web应用和服务。\n性能影响：加密处理增加了计算负载，可能影响传输速度，但现代优化技术（如会话缓存、HTTP&#x2F;2）减轻了这种影响。\n\nHTTPS是如何保证安全的？HTTPS通过以下方式确保通信安全：\n\n加密传输：使用对称加密算法对数据进行加密，确保传输过程中数据的保密性。\n身份验证：通过数字证书和CA体系验证服务器身份，防止假冒服务器。\n数据完整性：MAC和数字签名技术确保数据在传输过程中未被篡改。\n密钥交换安全：利用非对称加密技术安全地交换对称密钥，避免密钥泄露风险。\n防中间人攻击：上述机制结合使用，使得第三方难以在不被察觉的情况下拦截或篡改数据。\n\n常见的状态码\n301 Moved Permanently: 永久重定向。表示请求的资源已经永久移动到了新的URL，浏览器会自动将请求重新指向新的位置，并且以后的请求也会直接使用新URL。\n302 Found: 临时重定向。与301相似，但这里的重定向是临时的，意味着未来请求仍应使用原始URL。浏览器同样会自动重定向，但不会更改书签或后续请求的地址。\n303 See Other: 表示请求的响应可以在另一个URI中找到，且应使用GET方法获取。主要用于POST请求之后的重定向，强制浏览器使用GET方法请求新的位置。\n307 Temporary Redirect: 类似于302，不同之处在于307会保持请求方法不变，即如果原始请求是POST，重定向后仍然是POST请求。\n308 Permanent Redirect: 类似于301，但同样保持请求方法不变，适用于永久重定向且需要保持请求方法的情况。\n\nDNS 协议DNS（Domain Name System）协议是一种用于将人类可读的域名转换为IP地址的互联网标准。它通过分布在全球的DNS服务器层级结构，提供了一种分布式数据库系统来管理这些转换。\nDNS同时使用TCP和UDP协议？是的，DNS主要使用UDP协议进行查询，因为UDP较轻量级，适合DNS查询的快速响应特性。但当回复超过UDP的最大数据包大小（512字节）时，会自动切换到TCP，以确保大块数据的完整传输。\nDNS完整的查询过程\n递归查询：客户端向本地DNS服务器发起查询请求，如果本地DNS服务器不知道答案，它会递归地向其他DNS服务器查询，直到找到结果并返回给客户端。\n迭代查询：DNS服务器如果不能直接回答查询，会指向其他可能知道答案的DNS服务器，客户端再向这些服务器发送查询，这称为迭代查询。\n\nTCP&#x2F;IP五层协议与TCP、UDPTCP&#x2F;IP模型分为应用层、传输层、网络层、数据链路层和物理层。其中，传输层包括TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）两种协议。\n\nTCP特点：面向连接的、可靠的、基于字节流、有流量控制、拥塞控制、确认机制和重传机制，适合需要高可靠性传输的应用。\nUDP特点：无连接的、不可靠的、基于数据报、速度快、无拥塞控制，适用于对实时性要求高、能容忍一定丢包的应用。\n\nTCP和UDP的使用场景\nTCP常用于Web浏览、电子邮件、文件传输等需要保证数据完整性和顺序的应用。\nUDP适用于视频流、在线游戏、DNS查询等对速度敏感且能容忍少量数据丢失的场景。\n\nUDP协议为什么不可靠？UDP不提供确认、序列号、错误检测等机制，数据包一旦发出，不关心是否到达目的地，也不进行重传，因此被认为是不可靠的。\nTCP的特性\n重传机制：通过序列号和ACK确认，未收到确认的数据包会被重传。\n拥塞控制：通过慢启动、拥塞避免、快速重传和快速恢复等算法动态调整发送速率，防止过多的数据涌入网络导致拥塞。\n流量控制：利用滑动窗口机制，接收方告知发送方其接收缓冲区的大小，以此限制发送速率。\n可靠传输：通过确认、超时重传、错误校验等机制确保数据正确无误地传输。\n三次握手和四次挥手：建立连接时需要三次握手确认，断开连接时则需要四次挥手过程。\n\nTCP粘包处理\n定长消息：每个消息固定长度，接收端按长度拆分。\n包头标识：在每个包前加包头，包含消息长度等信息，接收端根据包头解析。\n分隔符：在消息间加入特定分隔符，接收端根据分隔符拆分。\n\nUDP为何不会粘包UDP作为无连接的协议，每次发送都是独立的数据报，接收端根据UDP数据报的边界自然分离，不存在TCP中的数据流合并问题，因此不会发生粘包现象。\n对 WebSocket 的理解WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。它允许服务端主动向客户端推送数据，而无需客户端先发起请求，从而实现了低延迟的双向通信。WebSocket 通过握手协议升级从初始的 HTTP 连接转换为持久化的连接状态，提供了更轻量、高效的实时数据传输方式，广泛应用于在线聊天、游戏、协同编辑、实时交易等场景。\n即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 之间的区别短轮询 (Short Polling)\n概念：客户端以固定时间间隔向服务器发送请求，询问是否有新数据。服务器如果有更新，就立即响应；如果没有，则返回空数据或者特定的无更新标志。\n优点：实现简单，兼容所有浏览器。\n缺点：频繁的请求造成资源浪费，延迟较高，不适合实时性要求高的应用。\n\n长轮询 (Long Polling &#x2F; Comet)\n概念：客户端发起请求后，如果服务器没有新数据，会暂时挂起请求，直到有数据更新时才响应。客户端收到响应后立即再次发起请求，形成循环。\n优点：相较于短轮询减少了无效请求，提高了效率，能较好地实现实时性。\n缺点：服务器需要为每个连接维持资源，容易造成资源消耗，且在高并发下压力较大。\n\nServer-Sent Events (SSE)\n概念：一种基于HTTP的轻量级服务器到客户端的单向通信技术。客户端发起请求后，服务器通过text/event-stream内容类型持续发送数据，直至连接关闭。\n优点：简化了客户端逻辑，支持自动重新连接，适合推送通知、实时新闻等场景。\n缺点：仅支持服务器到客户端的单向通信，不支持客户端向服务器发送数据。\n\nWebSocket\n概念：提供了一个持久化的连接，允许全双工通信，即客户端和服务器都可以随时发送数据。\n优点：\n实现真正的实时双向通信。\n减少了不必要的网络延迟和带宽消耗。\n适合需要高频率、低延迟交互的应用。\n\n\n缺点：\n需要服务器支持WebSocket协议。\n对一些老旧浏览器可能不完全兼容。\n\n\n\n总结\n短轮询适合对实时性要求不高的场景，实现简单但效率较低。\n长轮询提高了效率，适合中等实时性需求，但在高并发下服务器资源消耗大。\nSSE适用于单向数据流的场景，如实时通知，实现简单且节省资源。\nWebSocket提供了最佳的实时双向通信体验，特别适合即时通讯、在线游戏等对实时性要求极高的应用，但需要专门的服务器支持。\n\nWebSocketWebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。与传统的 HTTP 协议相比，WebSocket 提供了更高效、实时的双向通信方式，使得客户端（如浏览器）和服务器之间的数据交换变得更加灵活和即时。以下是关于 WebSocket 的一些关键点和相关概念：\n核心特点\n持久连接：一旦WebSocket连接建立，客户端和服务器之间的连接会持续存在，直到任意一方主动关闭连接。这避免了HTTP中需要频繁建立和销毁连接的开销。\n\n全双工通信：WebSocket 允许数据同时在客户端和服务器之间自由流动，无需等待对方的响应，非常适合实时聊天、在线游戏、协同编辑、实时推送通知等应用场景。\n\n低延迟：相比轮询和长轮询技术，WebSocket 减少了不必要的网络请求，降低了数据传输的延迟。\n\n轻量级：WebSocket 协议本身非常精简，只有两个字节的头部，大大减少了数据传输的开销。\n\n\n工作流程\n握手：WebSocket 连接初始化时，客户端首先通过HTTP请求发起连接，请求中包含升级到WebSocket协议的特殊字段，服务器响应确认协议升级，随后双方进入WebSocket状态。\n\n数据帧传输：连接建立后，数据以“帧”的形式进行传输。每个帧包含帧头（包含操作码指示数据类型）、负载数据和可选的掩码及长度字段。\n\n心跳维护：为了检测连接是否活跃，WebSocket 实现通常会发送心跳帧，即空数据帧或特定控制帧，以维持连接状态。\n\n\n相关技术与挑战\n跨域问题：WebSocket 支持跨域连接，但需要服务器设置合适的CORS（跨源资源共享）策略。\n\n安全性：WebSocket 可以通过WSS（WebSocket Secure）使用TLS&#x2F;SSL加密通信，保障数据传输的安全性。\n\n兼容性：现代浏览器普遍支持WebSocket，但在一些较旧的浏览器或特定环境下可能需要降级方案。\n\n库与框架：为简化WebSocket的使用，有许多库和框架提供高级抽象，如 Socket.io、WebSocket-Node（Node.js环境）、SignalR（.NET环境）等，它们通常提供了自动重连、消息队列、房间（分组）管理等功能。\n\n\n总之，WebSocket 是现代Web开发中实现低延迟、实时交互应用的关键技术之一，它极大地增强了用户体验，特别是在需要实时数据交换的场景中。\n","slug":"interview-computer-network","date":"2024-05-30T15:00:54.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"315f9f443ae2dc302897ea2ae6c37f7e","title":"interview-react","content":"ReactReact 事件机制React 使用自己的事件系统，它是对浏览器原生事件系统的一个轻量级封装，旨在提高性能并提供更好的跨浏览器兼容性。下面是React事件机制的核心特点和工作原理：\n事件命名约定\n驼峰命名：React 使用驼峰命名法（camelCase）来命名事件处理器，比如onClick而不是onclick。\n\n事件处理函数\n自动绑定：在ES6类组件中，需要手动绑定this（如在构造函数中使用this.handleClick = this.handleClick.bind(this);），或者使用箭头函数来定义事件处理器以确保正确的上下文。\n合成事件（SyntheticEvent）：React 为原生事件创建了一个跨浏览器的兼容层，称为合成事件。这些合成事件与原生事件相似，但提供了一些额外的便利性，并在事件处理完毕后自动销毁，帮助避免内存泄漏。\n\n事件委托（Event Delegation）\n事件冒泡：React 利用了事件冒泡机制，实际上只在最外层的DOM节点（通常是一个根节点如&lt;div id=&quot;root&quot;&gt;）上监听所有事件，然后通过事件目标判断应该触发哪个组件的事件处理器。这种方法减少了内存消耗和事件监听器的数量。\n\n阻止默认行为\n使用event.preventDefault()方法阻止事件的默认行为，比如点击链接时不跳转或表单提交时不刷新页面。\n\n传递参数\n由于React事件处理器作为属性传递，直接在事件处理函数中添加额外参数通常需要借助箭头函数或者使用bind来传递。\n\n跨浏览器兼容\nReact合成事件确保了事件处理的一致性，隐藏了不同浏览器之间的差异，使得开发者无需担心兼容性问题。\n\n性能优化\n通过事件委托和合成事件的机制，React减少了DOM操作，提高了性能。同时，React还提供了shouldComponentUpdate生命周期方法来控制不必要的重新渲染，进一步优化性能。\n\nReact 事件与普通 HTML 事件的不同之处React 的事件处理与原生 HTML 事件在机制和用法上存在一些关键差异，主要体现在以下几个方面：\n1. 命名约定\n原生 HTML 事件：使用全小写字母，如 onclick。\nReact 事件：采用驼峰命名法，如 onClick。\n\n2. 事件处理方式\n原生 HTML：通常在元素的属性中直接使用字符串形式的函数名，如 &lt;button onclick=&quot;handleClick()&quot;&gt;Click me&lt;/button&gt;。\nReact：事件处理器是以函数形式传递给组件属性，如 &lt;button onClick=&#123;this.handleClick&#125;&gt;Click me&lt;/button&gt;。\n\n3. 事件委托与合成事件\n原生 HTML：事件直接绑定在每个DOM元素上。\nReact：采用事件委托机制，在文档（通常是根节点）上监听所有事件，利用事件冒泡机制处理事件，然后根据事件目标分发给相应的React组件。这样减少了内存占用和提高了性能。\n\n4. 阻止默认行为\n原生 HTML：可以使用 return false; 或 event.returnValue = false; 阻止默认行为。\nReact：必须显式调用 event.preventDefault(); 来阻止事件的默认行为，return false; 不起作用。\n\n5. 合成事件对象\nReact 提供了合成事件（SyntheticEvent），这是一个跨浏览器的事件模拟对象，封装了原生事件，提供了统一的接口，并在事件处理完毕后自动清理，有助于防止内存泄漏。\n\n6. 执行顺序\nReact 的合成事件会在原生事件之后执行，且合成事件依赖冒泡阶段到达document，因此，如果原生事件阻止了事件冒泡，可能会导致合成事件不触发。\n\n7. 性能优化\nReact 通过事件委托和合成事件机制，减少了DOM操作，提高了应用的性能，并且提供了生命周期方法（如 shouldComponentUpdate）来进一步控制渲染，优化性能。\n\nReact 组件中事件代理的实现与原理实现方式在React中实现事件代理，主要是通过在父组件上绑定事件处理器，利用事件冒泡机制处理子组件触发的事件。具体步骤如下：\n\n定义父组件事件处理器：在父组件中定义一个事件处理器函数，该函数将负责处理所有子组件触发的事件。\n\n在父组件的JSX中绑定事件：在父组件的渲染方法中，为包含子组件的元素（通常是直接的父容器）绑定所需的事件处理器，如onClick。\n\n事件处理器内的逻辑：在事件处理器中，通过event.target或event.currentTarget识别实际触发事件的子元素，并根据需要执行相应逻辑。\n\n条件渲染或透传数据：根据触发事件的子元素，可以在事件处理器中做出不同的响应，或者通过属性（props）将处理逻辑或数据传递给子组件。\n\n\n原理说明React的事件代理机制基于以下核心原理：\n\n事件委托（Event Delegation）：React 利用事件冒泡机制（bubbling phase），即事件从最深的节点开始，逐级向上层节点传播，直到文档根节点。父组件只需在某一层级监听事件，即可捕捉到所有子组件的事件。\n\n合成事件系统（SyntheticEvent System）：React提供了一套跨浏览器兼容的合成事件系统，它在内部对原生事件进行了封装，统一了事件接口，并且在事件处理完毕后自动清理，有助于防止内存泄漏。\n\n单一事件监听器：React在最外层（通常是ReactDOM.render()挂载的根节点）为每种类型的事件只绑定一个监听器，而非为每个子元素单独绑定。这样显著减少了DOM上的事件监听器数量，提高了性能。\n\n事件映射与分发：React维护了一个事件处理器的映射关系，当事件从子组件冒泡到监听器所在的根节点时，React根据事件类型查找对应的处理器并执行，同时确保正确的this上下文和事件对象。\n\n\n在React中如何避免不必要的render？在React的函数式组件中避免不必要的渲染，主要可以通过以下几个策略来实现：\n1. 使用 React.memoReact.memo 是一个高阶组件，可以用于优化纯函数组件，避免在props未改变时重新渲染。它类似于类组件中的 PureComponent。\nimport React, &#123; memo &#125; from &#39;react&#39;;\n\nconst MyComponent &#x3D; memo((props) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 组件逻辑...\n&#125;);\n\n2. 利用 useMemo 缓存计算结果useMemo 用于缓存昂贵计算的结果，只有当依赖项改变时才重新计算。\nimport React, &#123; useMemo &#125; from &#39;react&#39;;\n\nfunction MyComponent(&#123; a, b &#125;) &#123;\n  const expensiveCalculation &#x3D; useMemo(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 进行复杂计算...\n    return calculationResult;\n  &#125;, [a, b]); &#x2F;&#x2F; 仅当 &#39;a&#39; 或 &#39;b&#39; 改变时重新计算\n\n  &#x2F;&#x2F; ...\n&#125;\n\n3. 利用 useCallback 避免创建新的回调函数useCallback 确保传递给子组件的回调函数在依赖项不变时引用保持不变，从而避免子组件因接收新函数而重新渲染。\nimport React, &#123; useCallback &#125; from &#39;react&#39;;\n\nfunction ParentComponent() &#123;\n  const handleClick &#x3D; useCallback(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 处理点击事件...\n  &#125;, []); &#x2F;&#x2F; 空依赖数组意味着这个函数在整个组件生命周期内都只会创建一次\n\n  return &lt;ChildComponent onClick&#x3D;&#123;handleClick&#125; &#x2F;&gt;;\n&#125;\n\n4. 避免在渲染过程中产生新的引用确保在渲染过程中使用的对象或数组尽量保持引用稳定，避免因引用地址变化导致不必要的渲染。\n5. 谨慎使用 Context 和 Redux 等状态管理库当直接使用 useContext 消费Context值时，组件可能会因为Context的任何更新而重新渲染。可以通过在消费组件外包裹一层 React.memo 或者在更深层次使用 useContext 结合 useMemo&#x2F;useCallback 来减少不必要的更新。\n6. Keys 在列表渲染中的正确使用确保在列表渲染时为每个元素提供稳定的 key 属性，帮助React高效地更新列表，避免不必要的完整列表重渲染。\nReact中什么是受控组件和非控组件？在React的函数式组件中，受控组件（Controlled Components）和非受控组件（Uncontrolled Components）是处理表单输入数据的两种不同方式。\n受控组件（Controlled Components）\n定义: 受控组件是指其值由React状态（通常是useState Hook管理）控制的表单元素。每次表单元素的值发生变化时，都会通过onChange事件触发更新状态，从而确保组件的显示值与React状态保持一致。\n\n实现方式:\n\n使用useState初始化表单字段的状态。\n为表单元素设置value或checked属性，绑定到状态值。\n定义一个onChange处理器更新状态。\n\n\n\nimport React, &#123; useState &#125; from &#39;react&#39;;\n\nfunction ControlledInput() &#123;\n  const [value, setValue] &#x3D; useState(&#39;&#39;);\n\n  const handleChange &#x3D; (e) &#x3D;&gt; &#123;\n    setValue(e.target.value);\n  &#125;;\n\n  return (\n    &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;\n  );\n&#125;\n\n非受控组件（Uncontrolled Components）\n定义: 非受控组件的值不由React状态直接管理，而是存储在DOM中，通常使用ref来访问这些值。当需要获取表单数据时，直接从DOM中读取，而不是从React状态中读取。\n\n实现方式:\n\n使用useRef创建一个ref来访问DOM元素。\n不为表单元素设置value或checked属性。\n在需要时，通过ref访问DOM元素获取值。\n\n\n\nimport React, &#123; useRef, useEffect &#125; from &#39;react&#39;;\n\nfunction UncontrolledInput() &#123;\n  const inputRef &#x3D; useRef(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 可以在这里设置初始值或做其他DOM操作\n  &#125;, []);\n\n  const handleSubmit &#x3D; (e) &#x3D;&gt; &#123;\n    e.preventDefault();\n    console.log(inputRef.current.value); &#x2F;&#x2F; 获取输入值\n  &#125;;\n\n  return (\n    &lt;form onSubmit&#x3D;&#123;handleSubmit&#125;&gt;\n      &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;\n      &lt;button type&#x3D;&quot;submit&quot;&gt;Submit&lt;&#x2F;button&gt;\n    &lt;&#x2F;form&gt;\n  );\n&#125;\n\n选择哪种方式\n受控组件适合需要精细控制表单状态和验证的情况，所有状态更新都在React中管理，逻辑集中且易于控制。\n非受控组件适用于简单的表单或性能敏感的场景，减少React的状态管理负担，但可能需要更多的DOM操作来交互和获取数据。\n\nReact的函数式组件中refs的作用是什么？有哪些应用场景？在React的函数式组件中，refs的作用主要是提供一种方式来直接访问和操作DOM元素或React组件的实例。它们允许你在React的声明式编程模型之外，进行必要的直接操作，特别是在需要与DOM交互的场景下。下面是refs的一些关键应用场景：\n作用\n访问DOM元素：可以用来获取对DOM元素的直接访问权限，从而执行如聚焦输入框、测量尺寸、滚动页面等操作。\n组件实例引用：不仅可以用于DOM元素，还可以用来引用函数式或类组件的实例，进而调用组件内部的方法或访问其属性。\n集成第三方库：与非React库集成时，经常需要直接操作DOM或访问特定元素，这时refs就显得尤为重要。\n管理焦点与选择：对于表单元素，可以便捷地控制焦点管理和文本选择。\n动画控制：与CSS动画或第三方动画库结合时，可以通过refs来触发和控制动画。\n\n应用场景\n自动聚焦：页面加载后或某些操作后，自动聚焦到特定的输入框。\nconst inputRef &#x3D; useRef(null);\nuseEffect(() &#x3D;&gt; &#123;\n  inputRef.current.focus();\n&#125;, []);\nreturn &lt;input ref&#x3D;&#123;inputRef&#125; type&#x3D;&quot;text&quot; &#x2F;&gt;;\n\n滚动位置管理：控制滚动条位置或执行平滑滚动效果。\nconst scrollRef &#x3D; useRef(null);\nconst handleScrollToBottom &#x3D; () &#x3D;&gt; &#123;\n  scrollRef.current.scrollTop &#x3D; scrollRef.current.scrollHeight;\n&#125;;\nreturn &lt;div ref&#x3D;&#123;scrollRef&#125; onButtonClick&#x3D;&#123;handleScrollToBottom&#125;&gt;&#123;&#x2F;* 内容 *&#x2F;&#125;&lt;&#x2F;div&gt;;\n\n测量元素尺寸：动态调整布局或实现自适应设计。\nconst divRef &#x3D; useRef(null);\nuseEffect(() &#x3D;&gt; &#123;\n  console.log(divRef.current.offsetHeight);\n&#125;, []);\nreturn &lt;div ref&#x3D;&#123;divRef&#125;&gt;测量高度&lt;&#x2F;div&gt;;\n\n触发第三方库功能：如使用D3.js进行图形绘制，需要直接操作DOM。\nconst chartRef &#x3D; useRef(null);\nuseEffect(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 初始化D3图表\n  const chart &#x3D; new SomeD3Chart(chartRef.current);\n  &#x2F;&#x2F; 渲染图表\n  chart.render();\n  &#x2F;&#x2F; 清理函数\n  return () &#x3D;&gt; chart.destroy();\n&#125;, []);\nreturn &lt;div ref&#x3D;&#123;chartRef&#125; &#x2F;&gt;;\n\nReact.forwardRef是什么？它有什么作用？React.forwardRef 是 React 提供的一个高阶函数，它的主要作用是将父组件传递的 ref 绑定到子组件的特定 DOM 元素或子组件实例上。在 React 中，ref 是一种特殊属性，允许我们访问组件实例或其包裹的 DOM 元素。然而，默认情况下，ref 只能被传递到类组件的实例或者函数组件中由 React.createRef() 或 useRef() 创建的 DOM 元素上，不能直接传递到一个函数组件内部的元素。\n使用 React.forwardRef 的场景通常包括：\n\n需要从父组件控制子组件的 DOM 节点：例如，父组件可能需要让子组件中的某个输入框自动聚焦，或者调整子组件内部元素的滚动位置。\n\n暴露子组件的某些功能给父组件：通过 forwardRef 结合 useImperativeHandle 钩子，可以让父组件通过 ref 访问到子组件暴露出来的特定方法，从而控制子组件的行为。\n\n\n基本用法如下：\nconst MyComponent &#x3D; React.forwardRef((props, ref) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 这里可以使用 &#96;ref&#96; 并将其绑定到一个DOM元素上\n  return &lt;input ref&#x3D;&#123;ref&#125; &#123;...props&#125; &#x2F;&gt;;\n&#125;);\n\n在上述代码中，MyComponent 是一个使用了 forwardRef 的函数组件，它接受两个参数：props 和 ref。ref 会被传递到子组件内部并绑定到一个 DOM 元素（在这个例子中是一个 &lt;input&gt;），使得父组件可以通过这个 ref 来访问和操作这个 input 元素。\n类组件与函数组件的异同相同点\n目的：无论是类组件还是函数组件，它们都是React中构建用户界面的基本单元，用于描述UI的结构和行为。\n渲染：两者都可以接收props作为输入，并返回React元素来描述应该在页面上渲染的内容。\n状态管理：虽然方式不同，但现代React通过Hooks（如useState、useEffect等）使得函数组件也能管理状态和生命周期逻辑，逐渐缩小了与类组件在功能上的差距。\n优化：两者都可以通过React的内在机制（如PureComponent、React.memo等）来避免不必要的渲染。\n\n不同点\n语法结构:\n\n函数组件：以函数形式定义，更简洁，无需继承React.Component，直接接收props并返回JSX。function FunctionalComponent(props) &#123;\n  return &lt;div&gt;Hello, &#123;props.name&#125;!&lt;&#x2F;div&gt;;\n&#125;\n类组件：基于ES6类定义，需要继承React.Component，并实现render方法来返回JSX。class ClassComponent extends React.Component &#123;\n  render() &#123;\n    return &lt;div&gt;Hello, &#123;this.props.name&#125;!&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\n\n状态管理:\n\n函数组件：原本无状态，但引入Hooks后，可以使用useState、useReducer等来管理状态。\n类组件：可以直接使用this.state和this.setState来管理状态。\n\n\n生命周期:\n\n函数组件：通过Hooks（如useEffect）模拟类组件的生命周期方法，更侧重于副作用的管理而非传统生命周期的概念。\n类组件：包含完整的生命周期方法，如componentDidMount、componentDidUpdate等，适用于需要细致控制组件生命周期的场景。\n\n\n性能优化:\n\n函数组件：可以轻易地通过React.memo进行性能优化，避免不必要的渲染。\n类组件：需继承React.PureComponent或手动实现shouldComponentUpdate来优化。\n\n\n上下文访问:\n\n两者都可以使用useContext Hook来访问React Context，但类组件也可以通过contextType属性直接访问。\n\n\n内存占用:\n\n函数组件：由于没有实例，理论上内存占用更少。\n类组件：每个实例都有自己的状态和方法，可能会占用更多内存。\n\n\n测试与调试:\n\n函数组件：通常认为更易于测试，因为它们是纯粹的函数。\n类组件：由于有实例和生命周期方法，测试和调试可能稍微复杂一些。\n\n\n\nReact setState 调用的原理在React中，setState方法用于更新组件的状态，并触发组件重新渲染以反映状态变化。以下是setState调用的原理概览，以Markdown格式展示：\nsetState调用原理setState是React组件中用于更新组件状态的一个方法，它会触发组件的重新渲染。调用setState的原理涉及到几个关键步骤，这些步骤确保了状态更新的高效执行和用户界面的正确更新。下面是一个简化的流程概述：\n队列更新：当调用setState时，React并不会立即更新状态，而是将状态更新任务放入一个更新队列中。这是为了批量处理多个状态更新，避免不必要的多次渲染。\n合并状态：如果在同一个事件循环中多次调用了setState，React会将这些状态更新合并成一次，以最新的状态为准。这意味着你传入的新状态会与当前状态（this.state）合并，生成一个新的状态对象。\n计划渲染：当所有的同步代码执行完毕，React会开始处理更新队列。在确定了最终的状态后，React会判断是否需要重新渲染该组件。如果状态发生了变化，或者父组件也需要重新渲染（因为其状态或属性变化），则React会标记该组件及其子树为“需要渲染”。\n虚拟DOM对比：在实际渲染之前，React会使用虚拟DOM（Virtual DOM）来比较新状态对应的新虚拟DOM树和之前的虚拟DOM树的差异。这一过程称为Reconciliation（协调），旨在最小化实际DOM操作，提高性能。\n实际DOM更新：根据虚拟DOM的差异计算结果，React会以最高效的方式更新实际DOM，仅修改那些发生改变的部分。\n生命周期方法和副作用：在渲染过程中，相关的生命周期方法会被调用，比如getDerivedStateFromProps（在React 16.3及以后版本）、shouldComponentUpdate、render等。此外，如果有副作用需要处理（如网络请求、订阅等），可以在componentDidMount或componentDidUpdate等生命周期方法中进行。\n组件更新完成：组件及其子组件完成渲染和DOM更新后，可能会触发一些后续操作，如回调函数的执行。\n值得注意的是，随着React版本的演进，特别是引入React Hooks和Concurrent Mode之后，setState的处理机制和相关生命周期方法也有所变化，例如引入了新的Hooks API来替代部分生命周期方法，以及更复杂的并发渲染策略等。但上述基本原理依然为核心理解React组件更新的基础。\n实现细节\nenqueueSetState：内部方法，负责将新的状态加入更新队列。\nbatchingStrategy：管理批量更新的策略对象，通过其isBatchingUpdates属性控制是否批量处理更新。\nbatchedUpdates：函数，用于开启批量更新模式，通常在React控制的事件处理前后调用，以决定状态更新的时机。\n\n通过这些机制，React确保了状态更新的高效和可预测性，同时也为开发者提供了灵活的状态管理方式。\nReact中的setState批量更新的过程是什么在React中，setState批量更新的过程旨在优化性能，减少不必要的渲染，确保高效的UI更新。以下是批量更新机制的工作流程，以Markdown格式描述：\nsetState批量更新过程调用setState ：当组件调用setState方法时，React并不会立即执行状态更新和重渲染。相反，它会记录下这次状态变更的请求。\n加入更新队列：这个状态更新的请求会被加入到一个内部的更新队列中。如果在当前事件循环中有多次setState调用，它们都会被累积在这个队列里，而不是立即执行。\n合并状态：React在处理更新队列时，会检查是否有多个更新针对同一组件，并尝试合并这些更新。如果更新是对象形式，且在事件循环中连续调用，React会将这些对象合并成一个新状态，避免多次不必要的渲染。\n批量处理：React会等到当前运行的JavaScript执行栈为空（即所有同步代码执行完毕），才开始处理更新队列。这样做是为了减少UI重绘的次数，因为多次连续的状态更新可能只需要最终状态的一次渲染即可体现。\nReconciliation（协调）：在开始实际更新之前，React会执行所谓的“协调”过程，比较新旧状态和props，仅对需要更新的部分进行最小化的DOM操作，进一步优化性能。\n实际更新与渲染：根据合并后的状态和props，React计算出虚拟DOM的差异，并将这些差异应用到实际DOM上，触发必要的渲染。这个过程称为“commit”阶段。\n回调执行：如果在setState调用中指定了回调函数，这个回调会在所有状态更新和渲染完成之后被调用，这是确保DOM已经反映了最新状态的好时机。\nReact 18中的改进从React 18开始，引入了自动批处理（Automatic Batching）特性，使得在更广泛的情景下，如在事件处理程序和Promise决议期间，React都能自动地批量处理状态更新，而无需开发者手动使用unstable_batchedUpdates。这一改进进一步简化了代码，并提升了应用的性能。\n通过这一系列精心设计的步骤，React的setState批量更新机制确保了即使在面对复杂的状态变化时，也能提供流畅且高效的用户体验。\nsetState的第二种写法setState的第二种写法是函数式写法，其基本形式如下：\nthis.setState((prevState, props) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 在这里可以访问到前一个状态（prevState）和属性（props）\n  &#x2F;&#x2F; 返回一个新的状态对象来合并到现有状态\n  return &#123; someKey: prevState.someValue + 1 &#125;;\n&#125;);\n\n这种写法的作用主要体现在以下几个方面：\n\n确保状态更新的纯净性：函数式setState接收一个函数作为参数，该函数会接收到当前的state（prevState）和props作为参数。这种方式可以让你基于当前状态计算出新的状态，确保状态更新的逻辑不会受到并发更新的影响。因为React可能会将多个setState调用合并成一个调用，如果是直接使用对象进行更新，可能会导致竞态条件。\n\n依赖当前状态：当你需要根据当前状态来计算下一个状态时（例如计数器加一），这种写法特别有用，因为它保证了你总是基于最新的状态进行更新，避免了潜在的错误。\n\n避免不必要的渲染：由于函数式setState可以让React更高效地合并多个状态更新，从而减少了不必要的重新渲染。当连续调用setState时，React会自动合并这些更新，只触发一次重新渲染。\n\n支持回调函数：与对象形式的setState一样，函数式setState同样接受一个可选的回调函数作为第二个参数，该回调函数在setState导致的DOM更新完成并且组件重新渲染之后被调用。这对于执行状态更新后的操作非常有用，比如滚动到页面的某个位置或者发起网络请求等。\n\n\n总结来说，函数式setState的主要作用在于提供了一种安全且高效的方式来更新组件状态，特别是在新状态依赖于当前状态时，并且它帮助React优化了更新流程，提升了应用性能。\nReact组件的state和props有什么区别？React中State与Props的区别在React应用中，state和props都是用来管理组件数据的重要概念，但它们在用途、来源以及可控性上有所不同。下面详细阐述这些区别：\n1. 数据来源\nProps（属性）：\n\nProps是从外部传递给组件的配置数据，通常由父组件通过标签属性的方式设定。\n它们是只读的，子组件不应也不能修改父组件传递过来的props。\n代表了组件的外部输入，决定了组件如何呈现。\n\n\nState（状态）：\n\nState是组件内部维护的数据，表示组件自身的状态。\nState允许组件根据用户的交互或其他内部逻辑动态改变自身状态，从而触发重新渲染。\n由组件自身初始化并在组件内部通过setState方法进行更新。\n\n\n\n2. 控制权与可变性\nProps：\n\n控制权在父组件，子组件只能被动接收。\n不可变性保证了组件的纯功能性，使得组件表现得像纯函数，易于理解和预测。\n\n\nState：\n\n控制权在组件内部，组件可以根据需要修改自己的状态。\n可变性使得组件具有动态性，能够响应不同的状态变化。\n\n\n\n3. 影响范围\nProps：\n\n用于跨组件通信，影响所有使用这些props的子组件。\n改变props会导致使用这些props的组件重新渲染。\n\n\nState：\n\n影响范围局限于组件本身及其子组件（如果子组件依赖于该状态）。\n状态的改变会触发组件及其依赖该状态的子组件的重新渲染。\n\n\n\n4. 使用场景\nProps：\n\n用于传递数据和行为给子组件。\n当组件间需要共享数据或父组件需要控制子组件的表现时使用。\n\n\nState：\n\n用于组件内部状态的管理，如表单控件的值、加载状态等。\n当组件需要基于用户交互或异步操作改变自身行为时使用。\n\n\n\n总结简而言之，props是组件间通信的桥梁，让组件可以接收外部信息；而state则负责组件内部状态的管理和变化，使组件能响应不同的状态展现不同的UI。理解它们的区别对于构建可维护、可预测的React应用至关重要。\nReact中的props为什么是只读的？React中的props被设计为只读的，这一决策基于以下几个核心原因，旨在增强应用程序的稳定性和可维护性：\nReact中Props只读性的原因\n可预测性：\n\n只读的props确保组件接收的数据不会在组件内部被意外修改，使得组件行为更加可预测。\n开发者可以放心地假设一旦组件接收到props，这些数据就不会改变，除非父组件显式地更新它们。\n\n\n单向数据流：\n\nReact推广单向数据流（one-way data binding）模式，其中数据流动主要沿着组件树自上而下。\n只读的props强化了这一模式，简化了数据管理和错误追踪，因为数据源头清晰明确。\n\n\n组件复用与解耦：\n\n使组件成为纯函数式的，即给定相同的输入（props），总能得到相同的输出（UI）。\n这种纯粹性提高了组件的可复用性和可测试性，组件之间更加独立，易于维护和理解。\n\n\n状态管理：\n\n将状态提升至最近的共同祖先组件中管理，而非分散在各个子组件的props中。\n集中的状态管理有助于控制复杂度，避免“ prop drilling”问题，即层层传递props。\n\n\n性能优化：\n\nReact可以通过比较props和state的变化来确定是否需要重新渲染组件，只读性简化了这一过程。\n若props可变，React需要更复杂的机制来跟踪变动，可能导致不必要的渲染或遗漏必要的更新。\n\n\n\n结论综上所述，props的只读性质是React设计哲学的一部分，它鼓励构建清晰、可维护、易于推理的应用程序。通过保持数据流向的单一性和组件的纯净性，React应用能够更加健壮和高效。\n父子组件的通信方式？在React的函数式组件中，父子组件间的通信主要依靠props传递数据和回调函数实现消息回传。以下是这两种基本通信方式的说明：\n1. 父组件向子组件传递数据（Props）父组件通过将数据作为属性（props）传递给子组件，子组件通过props接收这些数据。\n父组件示例function ParentComponent() &#123;\n  const parentData &#x3D; &quot;Hello from Parent&quot;;\n\n  return (\n    &lt;ChildComponent childMessage&#x3D;&#123;parentData&#125; &#x2F;&gt;\n  );\n&#125;\n\n子组件示例function ChildComponent(&#123; childMessage &#125;) &#123;\n  return (\n    &lt;div&gt;\n      &#123;childMessage&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n2. 子组件向父组件传递信息（回调函数）子组件通过触发一个来自父组件的回调函数，将信息传递回去。这种方式常用于事件处理。\n父组件示例（包含回调）function ParentComponent() &#123;\n  const handleCallback &#x3D; (childData) &#x3D;&gt; &#123;\n    console.log(&quot;Data from Child:&quot;, childData);\n  &#125;;\n\n  return (\n    &lt;ChildComponent onChildEvent&#x3D;&#123;handleCallback&#125; &#x2F;&gt;\n  );\n&#125;\n\n子组件示例（调用回调）function ChildComponent(&#123; onChildEvent &#125;) &#123;\n  const sendDataToParent &#x3D; () &#x3D;&gt; &#123;\n    onChildEvent(&quot;Hello from Child&quot;);\n  &#125;;\n\n  return (\n    &lt;button onClick&#x3D;&#123;sendDataToParent&#125;&gt;\n      Send Data to Parent\n    &lt;&#x2F;button&gt;\n  );\n&#125;\n\n使用useContext, useReducer, useState与useEffect进行状态管理（高级通信）对于更复杂的通信需求，React提供了额外的Hooks，如useContext用于跨组件层级的状态共享，useReducer用于管理复杂的组件状态逻辑，以及useEffect可以在组件更新后执行副作用，间接实现组件间的通信。\n总结\nProps是父组件向子组件传递数据的基本手段。\n回调函数是子组件向父组件传递信息的常用方式。\n对于非直接父子关系的组件间通信，可以考虑使用Context API（特别是useContext）或状态管理库（如Redux）。\n\n通过这些机制，React函数式组件能够有效地实现灵活且可维护的父子组件间通信。\n跨级组件的通信方式？在React的函数式组件中，跨级组件通信指的是不相邻的组件之间传递数据或触发操作。为了实现这一点，React提供了几种策略，以下是最常用的几种方法：\n1. Context APIReact的Context API允许你在组件树中传递数据，而无需手动将props逐层传递。这对于跨多层的组件通信特别有用。\n创建Context&#x2F;&#x2F; MyContext.js\nimport React, &#123; createContext, useContext, useState &#125; from &#39;react&#39;;\n\nconst MyContext &#x3D; createContext();\n\nfunction MyProvider(&#123; children &#125;) &#123;\n  const [data, setData] &#x3D; useState(&#39;Initial Data&#39;);\n\n  return (\n    &lt;MyContext.Provider value&#x3D;&#123;&#123; data, setData &#125;&#125;&gt;\n      &#123;children&#125;\n    &lt;&#x2F;MyContext.Provider&gt;\n  );\n&#125;\n\nexport &#123; MyContext, MyProvider &#125;;\n\n使用Context&#x2F;&#x2F; GrandchildComponent.js\nimport React, &#123; useContext &#125; from &#39;react&#39;;\nimport &#123; MyContext &#125; from &#39;.&#x2F;MyContext&#39;;\n\nfunction GrandchildComponent() &#123;\n  const &#123; data, setData &#125; &#x3D; useContext(MyContext);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;data&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setData(&#39;Data updated!&#39;)&#125;&gt;\n        Update Data\n      &lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n2. Redux or Other State Management Libraries对于大型应用，可以使用Redux这样的状态管理库来集中管理应用状态，任何组件都可以访问和修改存储中的状态，实现跨组件通信。\n3. Custom Event Bus &#x2F; Pub-Sub虽然不是React推荐的主要方式，但在某些场景下，创建一个全局的事件总线（Event Bus）来发布和订阅事件也是一种跨组件通信的策略。\n4. React Router for URL-based Communication对于基于URL的通信，可以利用React Router传递参数或使用路由状态（route state）。\n5. useImperativeHandle and Refs for Function Communication在极少数情况下，如果需要从子组件调用父组件或兄弟组件中的特定函数，可以使用useImperativeHandle配合ref。\n总结\nContext API是推荐的跨级通信解决方案，适用于大多数场景，简单且易于理解。\n对于更复杂的状态管理，引入Redux或其他第三方库是明智的选择。\n自定义事件系统和URL传递是备选方案，适合特定场景。\nRefs可以用于功能性的交互，但应谨慎使用，确保不违反React的单项数据流原则。\n\n非嵌套关系组件的通信方式在React的函数式组件中，非嵌套关系组件之间的通信意味着两个组件没有直接的父子关系。这种情况下，可以采用以下几种方式进行通信：\n1. Context APIContext API是React提供的一种无需通过props逐层传递即可跨组件共享数据的方式。适用于简单的跨级通信或全局状态管理。\n创建Context&#x2F;&#x2F; MyContext.js\nimport React, &#123; createContext, useContext, useState &#125; from &#39;react&#39;;\n\nconst MyContext &#x3D; createContext();\n\nfunction MyContextProvider(&#123; children &#125;) &#123;\n  const [sharedValue, setSharedValue] &#x3D; useState(&#39;initialValue&#39;);\n\n  return (\n    &lt;MyContext.Provider value&#x3D;&#123;&#123; sharedValue, setSharedValue &#125;&#125;&gt;\n      &#123;children&#125;\n    &lt;&#x2F;MyContext.Provider&gt;\n  );\n&#125;\n\nexport &#123; MyContext, MyContextProvider &#125;;\n\n使用Context在任意需要通信的组件中消费Context。\n&#x2F;&#x2F; ComponentA.js\nimport React from &#39;react&#39;;\nimport &#123; MyContext &#125; from &#39;.&#x2F;MyContext&#39;;\n\nfunction ComponentA() &#123;\n  const &#123; sharedValue &#125; &#x3D; useContext(MyContext);\n\n  return &lt;div&gt;Shared Value: &#123;sharedValue&#125;&lt;&#x2F;div&gt;;\n&#125;\n\n&#x2F;&#x2F; ComponentB.js\nimport React from &#39;react&#39;;\nimport &#123; MyContext &#125; from &#39;.&#x2F;MyContext&#39;;\n\nfunction ComponentB() &#123;\n  const &#123; setSharedValue &#125; &#x3D; useContext(MyContext);\n\n  const updateValue &#x3D; () &#x3D;&gt; &#123;\n    setSharedValue(&#39;newValue&#39;);\n  &#125;;\n\n  return (\n    &lt;button onClick&#x3D;&#123;updateValue&#125;&gt;\n      Update Shared Value\n    &lt;&#x2F;button&gt;\n  );\n&#125;\n\n2. Redux or Other State Management Libraries对于大型应用，使用Redux或其他状态管理库可以更高效地管理跨组件、跨模块的状态共享和通信。\n3. Event Bus &#x2F; Pub-Sub Pattern创建一个全局的Event Bus，允许组件订阅和发布事件，以此进行非直接关联组件间的通信。\n4. Use Callback Refs在某些场景下，可以通过useRef结合useEffect或forwardRef及useImperativeHandle，暴露子组件的某些方法给父组件或外部，实现更灵活的交互控制。\n5. URL State (with React Router)通过URL传递状态，利用路由库（如React Router）的特性，在不同组件间通过导航和查询参数共享信息。\n总结选择哪种通信方式取决于应用的复杂度、团队偏好及具体需求。对于简单的数据共享，Context API通常是首选；而对于复杂的状态管理，则可能需要引入Redux。其他方法如Event Bus和Callback Refs则适用于更特殊的需求场景。\nReact-Router的实现原理是什么？React Router 是一个用于在 React 应用程序中实现客户端路由的库。它使得用户能够在不重新加载页面的情况下浏览不同的界面。以下是 React Router 的核心实现原理，以 Markdown 格式展示：\n基本概念React Router 主要依赖于以下概念和技术实现：\n\nHistory API: 利用 HTML5 History API（pushState, replaceState）来改变浏览器的 URL 而不需要刷新页面。对于不支持这些 API 的旧浏览器，可以退回到基于 hash 的路由。\n\n动态组件渲染: 根据当前 URL 路径，React Router 会匹配预先定义好的路由规则，并渲染对应的组件。\n\nContext API: React Router v6 之后，大量使用 React 的 Context API 来全局管理路由状态，确保路由信息能被应用程序中的任何组件访问。\n\n\n实现机制\n路由定义: 开发者通过 &lt;Route&gt; 组件定义一系列路由规则，每个 &lt;Route&gt; 组件指定一个路径（path）和要渲染的组件（element）。\n&lt;Route path&#x3D;&quot;&#x2F;about&quot; element&#x3D;&#123;&lt;AboutPage &#x2F;&gt;&#125; &#x2F;&gt;\n\n路由匹配: 当浏览器的 URL 变化时，React Router 会使用 history 库监听这些变化，并与已定义的路由规则进行匹配。匹配成功后，相应组件会被渲染。\n\n导航: 提供 &lt;Link&gt; 组件用于导航，它实际上生成一个指向指定路由的 &lt;a&gt; 标签，点击时通过 History API 更新 URL，而不是导致页面刷新。\n&lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;About Us&lt;&#x2F;Link&gt;\n\n状态管理: React Router 使用 Context 传递路由状态，使得任何组件都能访问到当前的 location、navigate 等路由信息，无需显式地通过 props 逐层传递。\n\n高阶组件与 Hooks: React Router 提供如 &lt;BrowserRouter&gt;, &lt;HashRouter&gt; 等高阶组件封装应用，并通过 useParams, useNavigate, useLocation 等 Hooks 简化组件对路由功能的使用。\n\n动态路由和参数: 支持路径参数和查询参数，通过 :param 语法定义动态段，并通过 useParams() Hook 获取参数值。\n\n\n小结React Router 的实现基于现代浏览器的 History API 和 React 的高级特性，如 Context API 和 Hooks，以声明式的方式简化了客户端路由的管理，使开发者能够专注于构建应用逻辑，而非路由的底层实现。通过组件化的路由定义和自动的组件切换，React Router 实现了高度解耦和灵活的路由控制。\nReact-Router的路由有几种模式？React Router 提供了几种不同的路由模式来适应不同的应用场景和需求。以下是主要的几种路由模式，以Markdown格式列出：\n1. BrowserRouter\n特点：这是React Router的默认模式，利用HTML5的History API（包括pushState, replaceState以及popstate事件）来管理浏览器的历史记录。它使得URL看起来更干净，没有#符号。\n适用场景：现代Web应用，且服务器已正确配置以支持HTML5 History API。\n\n2. HashRouter\n特点：在URL中添加#符号作为路由的标识符。通过监听hashchange事件来响应路由变化。\n适用场景：需要兼容老版本浏览器或不希望服务器端处理路由的情况，因为服务器仅需返回单个HTML文件即可。\n\n3. MemoryRouter\n特点：不与URL交互，所有的路由状态保留在内存中，通常用于非Web环境，如测试用例或React Native开发。\n适用场景：单元测试、服务器端渲染（SSR）预渲染时的客户端接管等无需持久化路由状态的场景。\n\n4. NativeRouter\n特点：主要配合React Native使用，针对原生移动应用的路由解决方案。\n适用场景：React Native开发的移动应用程序。\n\n5. StaticRouter\n特点：用于服务器端渲染（Server Side Rendering, SSR），它接收一个location对象并提供静态的路由信息，不维护路由状态。\n适用场景：服务端渲染应用，需要在服务器上确定要渲染的组件。\n\n总结React Router通过这些不同的路由器组件提供了灵活性，使得开发者可以根据项目需求选择最合适的路由模式。从基本的Web应用到移动应用，再到需要特定服务器端渲染的场景，React Router均能提供支持。\nReact-Router6有什么新特性React Router v6 引入了许多新特性和改进，旨在简化路由配置和提高性能。以下是一些关键的新特性概览：\n1. 简化组件结构\n移除 &lt;Switch&gt;: 替换为 &lt;Routes&gt;，用于定义路由规则集合，只渲染第一个匹配到的路由。\n&lt;Route&gt; 的变更: &lt;Route&gt; 组件现在直接接受 element 属性来渲染组件，替代了之前的 render 或 component 属性。\n\n2. 更直观的路由声明\n嵌套路由: 路由可以直接在 &lt;Route&gt; 组件内嵌套，支持更自然的路由层次结构。\nindex 属性: 在 &lt;Route&gt; 上使用 index 属性来定义默认路由，替代了之前在 &lt;Switch&gt; 中的无路径 &lt;Route&gt;。\n\n3. 新的导航API\nuseNavigate 和 useLocation: 新增Hooks，允许组件轻松地进行导航和获取当前路由信息。\n移除 &lt;Redirect&gt;: 使用新的 &lt;Navigate&gt; 组件进行导航和重定向。\n\n4. 改进的参数处理\n改进的参数解析: 更简洁地处理URL参数，使用 useParams Hook更容易获取动态路由参数。\n\n5. 更好的组合能力\nHooks和Context: 更广泛地利用React Hooks和Context API，简化状态管理和组件间通信。\n\n6. 路由组和布局\n更灵活的布局管理: 支持更复杂的布局模式，无需额外的第三方库，通过嵌套路由直接实现。\n\n7. 简化API和配置\n减少API surface: 整体上减少了API的数量，使得学习曲线更加平缓，提高了开发效率。\n改进的默认导出: 重要组件如 &lt;BrowserRouter&gt;、&lt;Route&gt; 现在作为默认导出，简化了导入语句。\n\n8. 更好的类型支持\n对TypeScript的支持得到加强，提供了更精确的类型定义，帮助开发者避免错误并提升开发体验。\n\nReact Router v6通过这些改进，致力于提供一个更简洁、强大且易于维护的路由解决方案，进一步提升了React应用的开发体验和性能。\n对 React Hook 的理解，它的实现原理是什么React Hooks 是 React 16.8 版本引入的一个重要特性，它们允许你在不编写 class 的情况下使用 state 和其他 React 特性。Hooks 使得函数组件的功能更加丰富，可以管理状态、执行副作用操作、复用逻辑等，从而减少了对 class 组件的依赖。下面是关于 React Hooks 的理解和实现原理的概述。\n对 React Hook 的理解\n目的: Hooks 设计的初衷是为了简化状态逻辑并在函数组件中引入生命周期方法等功能，同时促进代码的复用和可维护性。\n种类: 主要有两类基础 Hook：内置 Hook（如 useState, useEffect, useContext, useRef 等）和自定义 Hook，后者允许你封装和复用状态逻辑。\n使用限制: Hooks 必须在函数组件或自定义 Hook 中调用，并且总是在组件的最外层调用，不能在循环、条件或嵌套函数中调用。\n\n实现原理\n闭包: Hooks 的实现依赖于 JavaScript 的闭包特性。每次组件渲染时，React 会维护一个 Hook 调用序列，确保每次渲染时按照相同的顺序调用 Hook，以此来维护 Hook 之间的状态关联。\n\nFiber 架构: Hooks 的状态管理与 Fiber 架构紧密相关。Fiber 是 React 内部用于调度渲染和更新的一种数据结构。每个函数组件都有一个 Fiber 节点，Hook 状态会被附着在这个 Fiber 上，随着 Fiber 树的遍历和更新，React 能够准确地追踪和更新 Hook 状态。\n\nuseState: useState Hook 内部使用了一个数组来保存状态值和更新状态的函数。每当状态更新时，React 会安排组件重新渲染，并在下次渲染时使用新的状态值。\n\nuseEffect: useEffect 用于处理副作用，如数据获取、订阅或者手动修改DOM等。它通过注册一个在渲染完成后执行的函数，并根据依赖数组来决定何时重新执行副作用逻辑，确保副作用与依赖项的变化同步。\n\n其他 Hook: 如 useContext, useReducer, useCallback, useMemo 等，各有特定用途，但实现原理大都基于闭包和Fiber节点上的状态管理。\n\n\n总结React Hooks 的实现原理是建立在 JavaScript 闭包、React 的 Fiber 架构之上，通过精心设计的API，使得状态管理和生命周期逻辑能够在函数组件中得以实现，极大地增强了React应用的开发效率和组件的可维护性。\nHooks的工作原理React Hooks 的工作原理主要依赖于一个全局状态数组和一个当前 Hook 的索引。在函数组件中，React 使用这些状态数组和索引来跟踪和更新每个 Hook 的状态。这种机制使得函数组件可以在多次渲染之间保持状态。\nHooks 的调用栈React 通过一个内部的 Hook 调用栈来记录每个 Hook 的调用。每次组件渲染时，React 会依次调用每个 Hook 并更新它们的状态。\n基本实现示例\n状态管理：React 使用一个全局数组来存储每个组件的 Hook 状态。\n索引管理：React 使用一个全局变量 currentHookIndex 来跟踪当前执行到第几个 Hook。\n渲染机制：每次组件渲染时，React 会重置 currentHookIndex，并依次调用每个 Hook。\n\nuseState 的实现原理useState 是一个函数，它接受一个初始状态值，并返回一个包含当前状态值和更新状态函数的数组。其核心在于如何在函数组件中保持状态。\nlet currentHookIndex &#x3D; 0;\nconst hooks &#x3D; [];\n\nfunction useState(initialValue) &#123;\n  const hookIndex &#x3D; currentHookIndex;\n\n  if (!hooks[hookIndex]) &#123;\n    hooks[hookIndex] &#x3D; initialValue;\n  &#125;\n\n  const setState &#x3D; (newValue) &#x3D;&gt; &#123;\n    hooks[hookIndex] &#x3D; newValue;\n    render();\n  &#125;;\n\n  currentHookIndex++;\n  return [hooks[hookIndex], setState];\n&#125;\n\nuseEffect 的实现原理useEffect 是一个用于处理副作用的 Hook，它会在组件渲染后执行指定的副作用函数。React 会在每次渲染后运行传给 useEffect 的函数，并在重新渲染前清除之前的副作用。\nfunction useEffect(effect, deps) &#123;\n  const hookIndex &#x3D; currentHookIndex;\n\n  const hasNoDeps &#x3D; !deps;\n  const depsChanged &#x3D; hasNoDeps || deps.some((dep, i) &#x3D;&gt; dep !&#x3D;&#x3D; hooks[hookIndex]?.[1][i]);\n\n  if (depsChanged) &#123;\n    hooks[hookIndex] &#x3D; [effect, deps];\n    effect();\n  &#125;\n\n  currentHookIndex++;\n&#125;\n\n使用示例function MyComponent() &#123;\n  currentHookIndex &#x3D; 0;\n\n  const [count, setCount] &#x3D; useState(0);\n  useEffect(() &#x3D;&gt; &#123;\n    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;\n  &#125;, [count]);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;Click me&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction render() &#123;\n  &#x2F;&#x2F; 假设这是重新渲染组件的逻辑\n  ReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.getElementById(&#39;root&#39;));\n&#125;\n\n处理多个 HooksReact 通过在每次渲染时重置 currentHookIndex 的索引，并按顺序执行所有 Hooks 来处理多个 Hooks。\nfunction Component() &#123;\n  currentHookIndex &#x3D; 0;\n\n  const [state1, setState1] &#x3D; useState(0);\n  const [state2, setState2] &#x3D; useState(0);\n\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(&#39;Effect for state1&#39;);\n  &#125;, [state1]);\n\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(&#39;Effect for state2&#39;);\n  &#125;, [state2]);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;state1&#125;&lt;&#x2F;p&gt;\n      &lt;p&gt;&#123;state2&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n总结\n状态存储：React 使用一个状态数组来存储每个 Hook 的状态。\n索引跟踪：通过一个全局的 currentHookIndex 来跟踪当前执行的 Hook。\n依赖追踪：对于 useEffect 等带有依赖的 Hook，React 会追踪依赖变化，并在依赖变化时重新执行副作用。\n\n了解这些原理有助于开发者更好地理解和使用 React Hooks，避免在复杂应用中出现问题。\n为什么Hoos有使用限制React Hooks 的使用规则之一是不能在循环、条件判断或嵌套函数中调用 Hook。这是因为 Hooks 的调用顺序必须在每次渲染时保持一致，以确保 React 能够正确地跟踪每个 Hook 的状态。\n为什么 Hooks 不能在循环或条件判断中使用Hooks 调用顺序必须一致React 依赖于 Hooks 的调用顺序来将状态与相应的 Hook 关联起来。如果在循环或条件判断中调用 Hooks，Hooks 的调用顺序在每次渲染时可能会不同，这会导致 React 无法正确地匹配当前状态与相应的 Hook。\n示例：在条件判断中使用 Hookfunction MyComponent() &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  if (count &gt; 5) &#123;\n    const [isVisible, setIsVisible] &#x3D; useState(true); &#x2F;&#x2F; 这行代码会在 count &gt; 5 时才执行\n  &#125;\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;Increment&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n在上述代码中，useState 只有在 count &gt; 5 时才会被调用。这会导致 Hooks 的调用顺序在不同的渲染中不一致，使得 React 无法正确匹配状态。\n示例：在循环中使用 Hookfunction MyComponent() &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  for (let i &#x3D; 0; i &lt; count; i++) &#123;\n    const [value, setValue] &#x3D; useState(i); &#x2F;&#x2F; 这行代码会根据 count 的值执行多次\n  &#125;\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;Increment&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n在上述代码中，useState 会在每次循环时被调用多次。这会导致 Hooks 的调用顺序在每次渲染时不同，无法保证一致性。\nHooks 调用规则为了解决这些问题，React 规定了以下两个规则：\n\n只在顶层调用 Hook：不要在循环、条件判断或嵌套函数中调用 Hook。要保证每次渲染时 Hooks 的调用顺序一致。\n只在 React 函数组件或自定义 Hook 中调用 Hook：不要在普通的 JavaScript 函数中调用 Hook。\n\n正确的 Hooks 使用方式以下是如何正确使用 Hooks 的示例：\nfunction MyComponent() &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const [isVisible, setIsVisible] &#x3D; useState(true);\n\n  &#x2F;&#x2F; 使用 useEffect 处理副作用\n  useEffect(() &#x3D;&gt; &#123;\n    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;\n  &#125;, [count]);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;Increment&lt;&#x2F;button&gt;\n      &#123;isVisible &amp;&amp; &lt;p&gt;Visible Text&lt;&#x2F;p&gt;&#125;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n结论保持 Hooks 调用顺序的一致性对于 React 正确管理组件的状态至关重要。通过遵守 Hooks 的使用规则，可以避免在复杂组件中出现难以调试的错误。\n为什么 useState 要使用数组而不是对象useState Hook 选择返回数组而不是对象，主要基于以下几个原因：\n\n解构赋值的灵活性:\n\n数组解构允许开发者自由命名解构后的变量。使用数组时，你可以按需命名状态变量和更新函数，比如 const [count, setCount] = useState(0);，这提高了代码的可读性和易用性。\n\n\n顺序一致性:\n\n数组元素的位置固定，这确保了状态值和其对应的更新函数之间有一一对应的关系，避免了因属性名错误导致的问题。对象属性没有固定的顺序，可能会引发意外的错误或混乱。\n\n\n简洁性和一致性:\n\n数组结构简洁明了，易于理解和使用，符合函数式编程风格，与React Hooks推崇的简洁API设计理念相契合。\n\n\n避免命名冲突:\n\n如果 useState 返回的是对象，那么每次使用都需要关心对象的键名，可能需要重命名以避免覆盖其他Hook的返回值，尤其是在使用多个状态Hook时。\n\n\n便于记忆和教学:\n\n习惯JavaScript的开发者对数组解构很熟悉，这降低了学习曲线，使得新开发者能更快上手。\n\n\nES6特性利用:\n\n利用了ES6的解构赋值特性，促进了现代JavaScript语法的采用，数组解构比对象解构在某些场景下更为直观和灵活。\n\n\n\n总结来说，通过使用数组，useState 提供了一种既简洁又强大的方式来管理组件状态，同时也充分利用了JavaScript语言特性，提升了开发者的编码体验。\nReact Hooks 解决了哪些问题？React Hooks 解决了前端开发中遇到的几个关键问题，主要体现在以下几个方面：\n\n状态逻辑复用困难：\n\n在 Hooks 之前，状态逻辑（如状态管理、生命周期方法）通常绑定在类组件中，难以在组件间共享。Hooks 允许将状态逻辑抽象成独立的函数（自定义 Hooks），使得状态逻辑可以在多个组件间轻松复用，提高了代码的模块化和可维护性。\n\n\n类组件复杂性：\n\n类组件结合了状态、生命周期方法和呈现逻辑，随着功能增加，组件变得越来越复杂，难以理解和维护。Hooks 通过将这些关注点分离到不同的函数中，使得组件更简洁，专注于 UI 的呈现，同时保持功能性代码的组织清晰。\n\n\n函数组件功能受限：\n\n早期的函数组件只能作为纯粹的呈现组件，无法直接管理状态或执行副作用操作。Hooks 引入后，函数组件获得了与类组件相同的能力，包括状态管理（useState）、生命周期操作（useEffect）、上下文消费（useContext）等，使得函数组件成为构建组件的主要方式。\n\n\n测试复杂度：\n\n类组件的 this 关键字和生命周期方法增加了测试的复杂度。Hooks 由于其纯粹的函数性质，使得组件更容易测试，因为它们不依赖于实例或生命周期方法。\n\n\n性能优化难题：\n\nHooks 提供了如 useCallback 和 useMemo 这样的工具，帮助开发者更细粒度地控制组件的渲染性能，避免不必要的计算和重新渲染。\n\n\n代码可读性和可维护性：\n\n通过减少类和生命周期方法的使用，Hooks 促使代码更加扁平化，逻辑分块更加清晰，便于阅读和维护。\n\n\n\n综上所述，React Hooks 不仅简化了状态逻辑的管理，还促进了组件的复用，降低了复杂度，提升了开发效率和代码质量，是现代 React 开发不可或缺的一部分。\nReact Hook 的使用限制有哪些？React Hooks 的使用有一些明确的限制，这些限制旨在保持代码的可预测性和避免潜在的错误。主要的使用限制包括：\n\n只在函数组件或自定义 Hook 中调用：Hooks 不能在普通的 JavaScript 函数中或类组件中使用。它们专为 React 函数组件设计，以提供状态管理和副作用处理等功能。\n\n调用顺序固定：在一个组件的渲染过程中，Hooks 必须按照完全相同的顺序被调用。React 使用这个顺序来对应每次渲染时的状态。这意味着你不能在条件语句、循环或嵌套函数中随意调用 Hooks，因为这可能导致 Hook 调用顺序在不同渲染之间发生变化。\n\n不要在循环、条件或嵌套函数中调用 Hook：由于 Hooks 依赖于调用顺序，任何可能改变 Hooks 调用顺序的逻辑都是不允许的。这意味着你需要将 Hook 调用放在组件的最外层，避免在条件判断、循环或递归等动态控制流中使用。\n\n\n这些限制确保了 React 能够准确地跟踪每个 Hook 的状态，并在重新渲染时恢复到正确的状态，即使组件在多次渲染之间可能经历了不同的代码路径。违反这些规则将会导致错误，React 会在开发模式下抛出警告或错误来帮助开发者识别并修正问题。\nuseEffect 与 useLayoutEffect 的区别useEffect 和 useLayoutEffect 都是 React Hooks 中用于执行副作用操作的函数，但它们之间存在一些关键区别，主要体现在执行时机和对浏览器渲染流程的影响上：\n\n执行时机：\n\nuseEffect: 它是异步执行的，意味着它不会阻塞浏览器渲染。useEffect 的回调函数会在浏览器完成所有 DOM 更新并且准备绘制到屏幕上之后的微任务队列中执行。这使得它适合执行那些不需要立即影响渲染结果的操作，如数据获取、设置定时器、事件监听器的添加&#x2F;移除等。\n\nuseLayoutEffect: 相比之下，它是同步执行的，会在所有 DOM 变更完成后立即执行，但在浏览器实际绘制之前。这意味着它会阻塞浏览器渲染，直到其回调函数执行完毕。因此，useLayoutEffect 适用于那些需要在渲染结果中立即体现的副作用操作，比如测量布局或者同步更新DOM以避免视觉上的闪烁或跳变。\n\n\n\n对渲染流程的影响：\n\nuseEffect: 因为它是异步的，不会延迟页面的渲染，用户界面可以更快地展示给用户，尽管之后可能因为副作用的执行而发生更新。\nuseLayoutEffect: 由于同步执行且发生在浏览器渲染之前，它会阻塞渲染过程，直到副作用处理完成。这可能会导致用户感受到界面渲染的延迟，但确保了副作用执行后界面的一致性。\n\n\n应用场景：\n\n通常情况下，大多数副作用处理应使用 useEffect，因为它不会影响用户体验的流畅性。\n当需要在渲染结果中立刻反映出某些副作用（例如调整DOM以保证UI的一致性）时，应使用 useLayoutEffect。\n\n\n\n总之，两者之间的选择取决于你的副作用是否需要在渲染流程中同步完成，以及是否能够接受潜在的渲染阻塞。\n对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？虚拟 DOM（Virtual DOM）是一种编程概念，主要在现代前端开发框架如React、Vue中被广泛应用，其核心目标是为了提高Web应用的性能和开发效率。以下是关于虚拟 DOM 的几个关键点，帮助您加深理解：\n虚拟 DOM 本身是什么？虚拟 DOM 是一种轻量级的内存数据结构，它使用普通的 JavaScript 对象来模拟真实 DOM（Document Object Model）树。这些对象代表了实际 DOM 元素及其属性，如标签名、属性、子元素等，但它们存在于内存中而非实际渲染到页面上。由于是纯数据结构，对虚拟 DOM 的操作相比直接操作真实 DOM 更为高效。\n虚拟 DOM 主要做了什么？\n减少 DOM 操作：通过在内存中操作虚拟 DOM 而不是直接操作真实的浏览器 DOM，可以减少昂贵的 DOM 操作次数。DOM 操作是耗时的，频繁操作会影响页面性能。\n\n高效更新：当应用状态改变时，框架会重新生成新的虚拟 DOM 树，然后通过“diff”算法比较新旧虚拟 DOM 之间的差异。这个差异计算过程非常快速，因为它仅在内存中进行。计算出最小的变更集后，框架仅将这些差异应用到真实 DOM 上，从而更新用户界面。\n\n批量处理：一些框架利用虚拟 DOM 进行批量更新，收集一段时间内的多个状态变更，然后一次性应用到真实 DOM，进一步减少重绘和回流的次数。\n\n简化开发：开发者无需直接关注如何手动更新 DOM，而是专注于描述应用的状态和 UI 如何响应状态变化，提高了代码的可读性和可维护性。\n\n\n为什么需要虚拟 DOM？在React、Vue等框架出现之前，直接操作DOM往往涉及大量的遍历和更新操作，这不仅效率低下，而且容易出错。虚拟 DOM 的引入，通过在内存中对DOM结构的抽象表示，实现了对DOM操作的优化，极大提升了Web应用的渲染性能和开发体验。它让开发者能够以声明式的方式编写视图逻辑，而将复杂的DOM管理留给框架处理。\nReact diff 算法的原理是什么？React diff 算法，也称为 Reconciliation（调和）过程，是React框架中用于比较新旧虚拟DOM树并高效更新UI的核心机制。其主要目的是通过识别出最小必要变更，减少对实际DOM的操作，从而提升应用性能。以下是React diff算法的一些核心原理和策略：\n\n分层比较：React的diff算法并非对整个DOM树进行遍历比较，而是采用分层的策略，从根节点开始逐层比较。如果某一层的节点没有变化，则其下的子树也会被认为是不变的，这样可以跳过这些子树的比较，大大减少了比较的范围。\n\n同层节点比较：对于同层级的节点，React会按顺序比较它们。如果遇到相同的节点类型和key值，则认为这两个节点可以复用，只需比较它们的属性是否有变化。如果有不同类型的节点或者key值不匹配的节点，则认为需要替换该节点及其所有子节点。\n\nKey的作用：React允许开发者为列表中的每个元素指定一个唯一的key属性。利用这些key，diff算法能更高效地识别哪些元素是新增的、删除的或是移动的，而不是简单地认为整个列表都发生了变化。\n\nWeb Components的优化：对于Web Components这样的自封闭组件，React假设它们内部的实现不会影响外部，因此除非组件自身标记为dirty，否则不会进入其内部进行diff。\n\n性能优化策略：React的diff算法经过优化，其平均时间复杂度从原本理论上的O(n^3)降低到了接近O(n)。这是通过上述策略以及一些内部优化实现的，比如对非文本节点的变更记录、避免不必要的深度遍历等。\n\n中断与调度：React的diff和更新过程可以通过scheduler进行中断和调度，使得UI更新可以按照优先级或者批处理进行，进一步优化性能和用户体验。\n\n\n总之，React diff算法的设计围绕着最小化DOM操作和优化更新性能，通过一系列智能的比较策略和优化手段，确保应用能够快速响应状态变化并高效渲染用户界面。\nReact key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的React中的key属性主要用于以下目的：\n\n高效更新列表: 当React需要更新一个元素列表时，如在遍历数组并渲染列表项时，key帮助React识别哪些元素是新增的、修改过的或被移除的。没有key，React将不得不逐个比较每个子元素来找出差异，这会非常低效。而通过使用key，React可以快速定位到变化的部分，只更新必要的元素，从而优化性能。\n\n元素复用策略: React利用key来决定如何复用已经存在的元素。当列表中的元素顺序发生变化时，React会尝试根据key来移动现有元素而不是销毁并重新创建，这能减少DOM操作，提高性能。如果没有key，React可能无法正确识别哪些元素应该被移动，从而导致不必要的组件销毁和重建。\n\n避免原地复用副作用: 在列表渲染中，若不使用key或使用不恰当的key，React可能会错误地复用组件，导致组件状态混乱。正确的key值确保每个组件实例与其对应的数据一一对应，防止状态交叉污染。\n\n辅助Diff算法: key是React diff算法的一个重要输入。它帮助算法快速识别哪些部分的DOM树需要被更新，哪些可以保持不变。通过比较元素的key，React可以跳过没有变化的部分，直接聚焦于有变动的地方，从而显著提高渲染效率。\n\n\n总结来说，key主要是解决列表渲染中的性能和状态管理问题，确保用户界面能够迅速响应数据变化的同时，维持良好的性能表现和正确的组件状态。正确的使用key是React应用性能优化的关键实践之一。\nReact 设计思路，它的理念是什么？React 的设计思路和理念主要围绕以下几个核心概念：\n\n组件化开发：React 鼓励将用户界面分解为可复用的组件。每个组件负责管理自己的状态（state）和行为（通过props接收外部输入），这有助于提高代码的模块化、可维护性和可测试性。\n\n声明式编程：React 推崇声明式编程风格，开发者只需描述应用的最终状态（即UI应当如何展现），而不用详细说明如何达到那个状态。这种编程方式使得代码逻辑更加清晰，易于理解和维护。\n\n虚拟 DOM：React 引入虚拟 DOM 作为真实 DOM 的轻量级内存表示，通过对比新旧虚拟 DOM 的差异来最小化实际的 DOM 操作，从而提高性能。\n\n单向数据流：React 应用倾向于使用单向数据流，父组件向子组件传递数据（通过props），子组件通过回调通知父组件状态变化，这有助于追踪数据变化的源头，简化数据管理。\n\n状态管理：React 自身并不直接提供全局状态管理方案，但鼓励通过外部库（如 Redux）或使用 React 自带的 Context API 来集中管理应用状态，保持组件间通信的清晰和高效。\n\n函数式编程和Hooks：React 通过引入Hooks，使得函数组件也能拥有生命周期方法和状态管理能力，鼓励函数式编程风格，使得组件更简洁、易于测试。\n\n渐进式增强：React 可以逐步引入到现有项目中，不需要全盘重构，支持逐步迁移至现代Web开发模式。\n\n重视性能：React 设计了许多性能优化手段，如PureComponent、React.memo、shouldComponentUpdate等，帮助开发者构建高性能的应用。\n\n\n综上所述，React 的设计理念在于通过组件化、声明式编程、虚拟 DOM 和现代JavaScript特性，提供了一套高效、灵活且可维护的前端开发框架，使得开发者能够更专注于构建用户界面和逻辑，而不必过多担心底层细节。\nReact必须使用JSX吗？React 不强制要求使用 JSX，但它被广泛推荐并已成为React开发中的标准实践，主要原因在于JSX提供了更加清晰和便捷的方式来描述组件的结构。JSX 是一种语法糖，它允许你以类似HTML的语法编写代码，实际上这些代码会被转换成调用 React.createElement() 方法的JavaScript代码。\n如果不使用JSX，你仍然可以使用React通过纯JavaScript方式来创建元素和组件，比如使用 React.createElement() 函数来手动构建虚拟DOM节点。例如，一个简单的React组件可以用下面两种方式编写：\n使用JSX:\nfunction Welcome(props) &#123;\n  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;\n&#125;\n\n不使用JSX:\nfunction Welcome(props) &#123;\n  return React.createElement(\n    &#39;h1&#39;,\n    null,\n    &#96;Hello, $&#123;props.name&#125;&#96;\n  );\n&#125;\n\n尽管不使用JSX完全可行，但在大多数情况下，JSX提供的简洁性和可读性使得开发效率更高，因此成为React开发者首选的编写方式。然而，在某些特定场景下，如在不能或不希望使用JSX转换工具的环境，或者对性能有极高度要求且需手动优化的情况，直接使用 React.createElement() 或其他方法来构造元素也是合理的。\n","slug":"interview-react","date":"2024-05-30T14:59:54.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"f16f712f5af1584293fcdaa3e7e5676d","title":"interview-react-native","content":"React NativeReact Native (RN) 的主要优势有哪些？\n跨平台开发：允许使用单一代码库为iOS和Android创建原生应用，显著降低开发成本和时间。\n原生性能：虽然使用JavaScript编写，但通过桥接调用原生代码，能够接近原生应用的性能体验。\n热重载：提高开发效率，修改代码后几乎即时查看效果，无需频繁构建和部署。\n强大的生态系统：背靠React社区，拥有丰富的第三方库和插件，解决各种开发需求。\nReact一致性：对于熟悉React.js的Web开发者来说，学习曲线较低，可以快速上手移动开发。\n组件化开发：支持组件复用，提高代码可维护性和开发效率。\n\nReact Native与原生客户端应用之间的关系是什么？React Native不是替代原生开发的工具，而是与之协同工作。RN应用的核心逻辑和UI用JavaScript编写，然后通过JavaScript桥接调用原生API和模块，实现与原生平台的交互。这意味着RN应用能够利用原生平台的所有功能，同时享受跨平台开发的好处。原生客户端应用可以包含React Native模块作为其中一部分，实现特定功能或页面。\nReact Native存在哪些劣势？\n性能限制：虽然接近原生，但在复杂动画或大规模列表渲染等场景下，性能可能不如纯原生应用。\n调试难度：跨平台特性增加了调试的复杂度，特别是涉及到原生模块和桥接代码的问题。\n第三方库依赖：由于不是所有功能都内置，对第三方库的依赖较高，可能导致版本兼容性问题。\n更新问题：原生依赖的更新可能需要手动集成，尤其是操作系统大版本升级时。\n学习曲线：对于没有React经验的开发者来说，需要同时学习React、React Native以及原生开发知识。\n\nReact Native中基础样式（Style）的使用方法React Native使用JavaScript对象来定义样式，类似于CSS，但有其独特之处。样式属性通常为驼峰命名，如backgroundColor而非background-color。样式可以直接作为组件的属性，或者通过StyleSheet.create批量定义。\nimport &#123; StyleSheet, Text, View &#125; from &#39;react-native&#39;;\n\nexport default function App() &#123;\n  return (\n    &lt;View style&#x3D;&#123;styles.container&#125;&gt;\n      &lt;Text style&#x3D;&#123;styles.text&#125;&gt;Hello, world!&lt;&#x2F;Text&gt;\n    &lt;&#x2F;View&gt;\n  );\n&#125;\n\nconst styles &#x3D; StyleSheet.create(&#123;\n  container: &#123;\n    flex: 1,\n    backgroundColor: &#39;#fff&#39;,\n    alignItems: &#39;center&#39;,\n    justifyContent: &#39;center&#39;,\n  &#125;,\n  text: &#123;\n    color: &#39;blue&#39;,\n    fontSize: 20,\n  &#125;,\n&#125;);\n\nFlexBox在React Native中的基本用法FlexBox是React Native布局的核心，用于创建响应式和灵活的界面布局。关键属性包括：\n\nflex: 控制元素在父容器中的占比。\nflexDirection: 决定主轴的方向（row, row-reverse, column, column-reverse）。\njustifyContent: 控制主轴上的对齐方式（flex-start, center, flex-end, space-between, space-around）。\nalignItems: 控制交叉轴上的对齐方式（flex-start, center, flex-end, stretch）。\n\n示例代码：\n&lt;View style&#x3D;&#123;&#123;flex: 1, flexDirection: &#39;row&#39;, justifyContent: &#39;space-between&#39;&#125;&#125;&gt;\n  &lt;View style&#x3D;&#123;&#123;width: 50, height: 50, backgroundColor: &#39;powderblue&#39;&#125;&#125; &#x2F;&gt;\n  &lt;View style&#x3D;&#123;&#123;width: 50, height: 50, backgroundColor: &#39;skyblue&#39;&#125;&#125; &#x2F;&gt;\n  &lt;View style&#x3D;&#123;&#123;width: 50, height: 50, backgroundColor: &#39;steelblue&#39;&#125;&#125; &#x2F;&gt;\n&lt;&#x2F;View&gt;\n\nReact Native的核心组件有哪些？\nView: 布局的基本容器，相当于HTML的div。\nText: 用于展示文本，替代HTML的&lt;p&gt;、&lt;span&gt;等。\nImage: 用于显示图片资源。\nTextInput: 提供文本输入功能。\nScrollView: 允许内容滚动的容器。\nFlatList: 高效渲染长列表数据。\nTouchableOpacity&#x2F;TouchableWithoutFeedback&#x2F;TouchableHighlight: 提供触摸反馈的组件。\nSafeAreaView: 确保内容不会被设备的刘海屏或导航栏遮挡。\n\nReact Native中的路由和导航解决方案React Native本身不直接提供路由系统，但推荐使用第三方库，如react-navigation。react-navigation支持多种导航模式，包括：\n\nStack Navigator：实现堆栈式的页面导航，有后退历史记录。\nTab Navigator：底部选项卡切换多个页面。\nDrawer Navigator：侧滑菜单导航。\nSwitch Navigator：用于不保留状态的页面跳转。\n\n在React Native中，编程式路由导航主要是通过react-navigation库来实现的。react-navigation是React Native应用中最常用的导航解决方案，它提供了一系列导航器（Navigators）来管理屏幕（Screens）的堆叠、切换和导航。下面是一个基本的实现步骤和概念介绍：\n安装和配置首先，你需要安装react-navigation及其依赖库：\nnpm install @react-navigation&#x2F;native react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community&#x2F;masked-view\n\n然后安装适合的导航器，例如堆栈导航（Stack）：\nnpm install @react-navigation&#x2F;stack\n\n创建StackNavigator接着，在你的应用中创建一个StackNavigator，这是最基础的导航方式，可以管理多个屏幕，并且允许用户通过“后退”操作返回之前的屏幕。\nimport React from &#39;react&#39;;\nimport &#123; createStackNavigator &#125; from &#39;@react-navigation&#x2F;stack&#39;;\nimport HomeScreen from &#39;.&#x2F;HomeScreen&#39;;\nimport DetailsScreen from &#39;.&#x2F;DetailsScreen&#39;;\n\nconst Stack &#x3D; createStackNavigator();\n\nfunction App() &#123;\n  return (\n    &lt;NavigationContainer&gt;\n      &lt;Stack.Navigator&gt;\n        &lt;Stack.Screen name&#x3D;&quot;Home&quot; component&#x3D;&#123;HomeScreen&#125; &#x2F;&gt;\n        &lt;Stack.Screen name&#x3D;&quot;Details&quot; component&#x3D;&#123;DetailsScreen&#125; &#x2F;&gt;\n      &lt;&#x2F;Stack.Navigator&gt;\n    &lt;&#x2F;NavigationContainer&gt;\n  );\n&#125;\n\nexport default App;\n\n编程式导航实现在任一屏幕组件内部，你可以通过导航道具（navigation prop）来进行编程式导航。当你想要从一个屏幕导航到另一个屏幕时，可以调用navigation.navigate()方法。\n例如，在HomeScreen中有一个按钮，点击后导航到DetailsScreen：\nimport React from &#39;react&#39;;\nimport &#123; Button &#125; from &#39;react-native&#39;;\n\nfunction HomeScreen(&#123; navigation &#125;) &#123;\n  return (\n    &lt;Button\n      title&#x3D;&quot;Go to Details&quot;\n      onPress&#x3D;&#123;() &#x3D;&gt; navigation.navigate(&#39;Details&#39;)&#125;\n    &#x2F;&gt;\n  );\n&#125;\n\n参数传递你还可以向下一个屏幕传递参数，这在navigate方法的第二个参数中完成：\nnavigation.navigate(&#39;Details&#39;, &#123; itemId: 86, otherParam: &#39;anything&#39; &#125;);\n\n在DetailsScreen中，可以通过route.params访问这些参数：\nfunction DetailsScreen(&#123; route &#125;) &#123;\n  &#x2F;* ... *&#x2F;\n  console.log(route.params.itemId, route.params.otherParam);\n  &#x2F;* ... *&#x2F;\n&#125;\n\n结论编程式导航允许开发者根据特定条件或用户交互动态改变应用程序的导航状态，提供了高度的灵活性和控制力。通过使用react-navigation及其各种导航器，React Native应用可以构建复杂的导航流程，同时保持代码的清晰和可维护性。\nReact Native的架构原理概述React Native的架构设计围绕着跨平台开发的核心理念，旨在提供一种高效的方式来构建原生级别的移动应用程序，同时保持代码的可复用性和开发效率。以下是React Native架构的更详细说明：\n1. 核心组件与层次\nJavaScript层：\n\nReact组件: 开发者编写的业务逻辑和UI组件，使用React语法，运行在JavaScript虚拟机中（通常是JavaScriptCore或V8）。\nReact Native库: 提供了一套与原生平台交互的API，允许JavaScript代码控制原生组件和系统功能。\n\n\n原生层：\n\n原生模块: 实现具体平台功能的原生代码（Objective-C&#x2F;Swift在iOS上，Java&#x2F;Kotlin在Android上），这些模块通过Bridge暴露给JavaScript调用。\nUI组件: 每个原生平台都有对应的一套UI组件，如UIView和UIViewController在iOS，View和Activity在Android，它们接收来自JavaScript的指令并渲染界面。\n\n\nBridge (桥接):\n\n负责JavaScript和原生代码之间的通信，实现了双向消息传递。使用异步消息队列来处理跨语言的调用，确保两个线程（JavaScript线程和原生主线程）之间的安全交互。\n\n\n\n2. 线程模型\nJavaScript线程：运行React组件的更新逻辑和用户代码。\n主线程（UI线程）：在iOS上是主线程，在Android上是UI线程，负责处理UI更新、事件分发等。\nShadow Thread（影子线程）：在某些版本中存在，主要用于计算布局，生成Shadow Tree（影子树），这是一个轻量级的原生表示，用于优化布局计算，减少主线程负担。新架构可能对此有所调整。\n\n3. 渲染机制\nReconciliation &amp; Virtual DOM：React Native利用React的虚拟DOM思想，通过Diff算法计算出最小变更集，决定哪些UI需要更新。\nShadow Tree：计算视图布局，生成一个即将渲染的视图结构的表示，不涉及实际渲染，优化布局计算。\n原生渲染：最终的UI更新指令由JavaScript线程通过Bridge传递给原生线程，原生线程根据这些指令创建或更新实际的原生视图组件。\n\n4. 新架构（Fabric &amp; TurboModule）近年来，React Native引入了Fabric和TurboModule等新特性，旨在进一步优化架构，提升性能和开发体验：\n\nFabric：新的渲染引擎，它改变了React Native的渲染和布局系统，减少了渲染层级，提高了性能，简化了渲染逻辑。\nTurboModule：更快的原生模块加载和调用机制，通过预编译和直接调用原生代码，减少了Bridge的开销，提升了调用速度。\n\n5. 事件处理\n事件由原生端捕获并通过Bridge传递给JavaScript线程处理，使用RCTEventDispatcher来分发事件到对应的React组件。\n\n综上所述，React Native的架构设计高度关注于如何高效地在JavaScript和原生环境之间架起沟通的桥梁，同时保持应用的高性能和开发的灵活性。随着技术的演进，React Native不断引入新的特性来克服传统架构的限制，优化开发者体验并提升应用质量。\n常见的React Native第三方库有哪些？\nReact Navigation: 导航解决方案。\nRedux &#x2F; MobX &#x2F; Context API: 状态管理库。\naxios: 网络请求库。\nstyled-components: 动态样式库。\nlodash: JavaScript实用函数库。\nReact Native Elements &#x2F; Native Base: UI组件库。\nReact Native Vector Icons: 图标库。\nreact-native-image-picker: 图片选择器。\nreact-native-push-notification: 本地和远程通知支持。\nreact-native-webview: 渲染网页内容。\n\nRN中有哪些原生的API可供调用React Native 提供了一系列原生模块，允许开发者通过JavaScript调用底层原生平台（iOS和Android）的功能。以下是一些常用的React Native原生API示例，包括获取地理位置等：\n1. 地理位置（Geolocation）React Native 自带了Geolocation模块，用于获取设备的地理位置信息，包括经度、纬度、海拔、速度等。\nimport &#123; Geolocation &#125; from &#39;react-native&#39;;\n\nGeolocation.getCurrentPosition(\n  (position) &#x3D;&gt; &#123;\n    console.log(position.coords.latitude, position.coords.longitude);\n  &#125;,\n  (error) &#x3D;&gt; console.error(error),\n  &#123; enableHighAccuracy: true, timeout: 15000, maximumAge: 10000 &#125;\n);\n\n2. 网络请求（fetch）虽然不是严格意义上的原生模块，但fetch API是React Native中用于执行网络请求的标准方法，它基于原生平台的网络栈。\nfetch(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;)\n  .then((response) &#x3D;&gt; response.json())\n  .then((data) &#x3D;&gt; console.log(data))\n  .catch((error) &#x3D;&gt; console.error(&#39;Error:&#39;, error));\n\n3. 存储（AsyncStorage）AsyncStorage是React Native提供的一个简单的异步键值存储系统，用于在设备上持久化数据。\nimport &#123; AsyncStorage &#125; from &#39;react-native&#39;;\n\nAsyncStorage.setItem(&#39;key&#39;, &#39;value&#39;)\n  .then(() &#x3D;&gt; console.log(&#39;Data saved&#39;))\n  .catch((error) &#x3D;&gt; console.log(&#39;Error saving data&#39;, error));\n\nAsyncStorage.getItem(&#39;key&#39;)\n  .then((value) &#x3D;&gt; console.log(value))\n  .catch((error) &#x3D;&gt; console.log(&#39;Error getting data&#39;, error));\n\n4. 设备信息（DeviceInfo）可以获取设备的硬件和操作系统信息。\nimport &#123; DeviceInfo &#125; from &#39;react-native&#39;;\n\nconsole.log(DeviceInfo.getUniqueID()); &#x2F;&#x2F; 获取设备唯一标识符\n\n5. 相机与相册（CameraRoll）访问设备的相册和照片。\nimport &#123; CameraRoll &#125; from &#39;@react-native-community&#x2F;cameraroll&#39;;\n\nCameraRoll.getPhotos(&#123;\n  first: 20,\n  assetType: &#39;Photos&#39;,\n&#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(data.edges.map((e) &#x3D;&gt; e.node.image.uri));\n  &#125;)\n  .catch((err) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; Handle error\n  &#125;);\n\n6. 用户权限（Permissions）请求访问如相机、位置、通知等权限。\nimport &#123; PermissionsAndroid &#125; from &#39;react-native&#39;;\n\nasync function requestLocationPermission() &#123;\n  try &#123;\n    const granted &#x3D; await PermissionsAndroid.request(\n      PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,\n      &#123;\n        title: &#39;Location Permission&#39;,\n        message: &#39;This app needs access to your location.&#39;,\n      &#125;\n    );\n    if (granted &#x3D;&#x3D;&#x3D; PermissionsAndroid.RESULTS.GRANTED) &#123;\n      console.log(&#39;You can use the location&#39;);\n    &#125; else &#123;\n      console.log(&#39;Location permission denied&#39;);\n    &#125;\n  &#125; catch (err) &#123;\n    console.warn(err);\n  &#125;\n&#125;\n\n除了上述API，React Native还支持更多原生模块，如ImagePicker、NetInfo（网络状态）、PushNotificationIOS（iOS推送通知）、Linking（打开URL或拨打电话）等，以及通过自定义原生模块来扩展功能。\n","slug":"interview-react-native","date":"2024-05-30T14:59:22.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"4a7b4bd5c9b6fe1d1c2302e2f1ecfc49","title":"interview-next","content":"Next当然，以下是关于Next.js的十个面试题目及其答案，采用Markdown格式：\n什么是Next.js？它解决了什么问题？Next.js是一个基于React的框架，用于构建服务器渲染（SSR）和静态站点生成（SSG）的应用程序。它简化了设置、路由、代码拆分、服务器端渲染等复杂功能，让开发者能更快速地开发高性能的web应用。Next.js解决了React应用的SEO优化、首屏加载速度及路由管理等问题。\nNext.js中页面是如何定义的？在Next.js中，页面是由位于pages目录下的.js, .jsx, .ts, 或 .tsx文件自动识别的。每个文件名映射到一个URL路径，例如，创建一个名为pages/about.js的文件将自动为/about路径提供页面。\n什么是动态路由？如何在Next.js中实现？动态路由是指根据变量参数来动态生成页面URL。在Next.js中，通过在页面文件名中使用中括号[]来定义动态段，例如创建一个[id].js文件，就可以匹配任何/some-id形式的URL，其中id是动态部分。\nNext.js中如何进行API路由设置？Next.js允许你在pages/api目录下定义API路由。创建如pages/api/myendpoint.js的文件，就创建了一个可以访问的API端点/api/myendpoint。Next.js会自动处理请求和响应。\n什么是ISR（Incremental Static Regeneration）？它的好处是什么？Incremental Static Regeneration是Next.js提供的一个功能，允许静态生成的页面在一定时间间隔或特定事件触发时自动或手动更新。ISR结合了SSG和实时数据的优点，能保持大部分页面为静态以提高性能，同时允许关键页面适时更新，提高了内容的时效性。\n如何在Next.js中配置环境变量？在Next.js中，你可以通过.env文件来配置环境变量。创建.env.local文件（不被提交到版本控制），并在其中添加形如NEXT_PUBLIC_API_KEY=value的行。在代码中使用process.env.NEXT_PUBLIC_API_KEY来访问这些变量。注意，以NEXT_PUBLIC_开头的变量可以在客户端访问，其他仅限于服务器端。\nNext.js的页面过渡效果如何实现？Next.js支持页面过渡效果，主要通过&lt;Link&gt;组件的prefetch属性预加载页面，并结合CSS动画或第三方库（如react-transition-group）来实现过渡效果。Next.js 12引入了内置的Transition API，提供更直接的方式来管理页面切换时的过渡效果。\n什么是getStaticProps和getServerSideProps？它们的区别是什么？\ngetStaticProps: 用于静态生成页面的props。它在构建时运行，从API或其他源获取数据，并将其作为props传递给页面。适合内容不频繁变化的页面。\n\ngetServerSideProps: 在每次请求时运行，用于服务器端渲染页面并获取动态数据。适用于需要实时数据或每次访问都可能不同的页面。\n\n\n主要区别在于数据获取时间和页面生成方式：getStaticProps用于预先生成静态页面，而getServerSideProps在每次请求时动态生成。\n如何在Next.js中实现国际化（i18n）支持？Next.js提供了官方的国际化插件next-i18next，用于轻松地实现多语言支持。首先安装此包，然后配置next-i18next.config.js文件来指定语言目录和默认语言。接着，在页面中使用useTranslation钩子或withTranslation高阶组件来实现多语言文本的切换。\n什么是 _app.js 和 _document.js 文件？它们的作用是什么？\n_app.js: 这是一个特殊的组件，用于包裹应用程序中的所有页面组件。它是定制应用程序级别配置（如全局样式、布局组件、Redux store注入）的地方。\n\n_document.js: 允许你自定义文档的&lt;head&gt;部分和初始化的&lt;body&gt;标签。这对于注入meta标签、自定义样式链接或脚本非常有用，特别是在进行SEO优化时。\n\n\nNext.js中如何实现页面级别的CSS模块化？在Next.js中，可以通过在组件文件同级创建一个具有相同名称但以.module.css为后缀的CSS文件来实现页面或组件级别的CSS模块化。例如，对于Component.js，创建一个Component.module.css文件，然后在组件中导入并使用类名，Next.js会自动处理模块化，确保类名唯一，避免样式冲突。\n&#x2F;&#x2F; Component.js\nimport styles from &#39;.&#x2F;Component.module.css&#39;;\n\nfunction Component() &#123;\n  return &lt;div className&#x3D;&#123;styles.myStyle&#125;&gt;Hello World&lt;&#x2F;div&gt;;\n&#125;\n\nexport default Component;\n\n解释一下Next.js的动态导入（dynamic imports）及其好处。动态导入是Next.js中一种按需加载模块的方法，允许你将代码分割成更小的chunks，仅在需要时加载。这通过在import语句前加上import()函数实现。这样做可以显著提升应用的初次加载速度和后续交互体验，因为用户不必等待整个应用的所有代码下载完毕。\nimport dynamic from &#39;next&#x2F;dynamic&#39;;\n\nconst DynamicComponent &#x3D; dynamic(() &#x3D;&gt; import(&#39;.&#x2F;HeavyComponent&#39;));\n\nfunction MyPage() &#123;\n  return &lt;DynamicComponent &#x2F;&gt;;\n&#125;\n\n如何在Next.js中实现客户端路由状态保持？客户端路由状态保持通常涉及useEffect和useState或useContext等React Hooks。当使用next/link或自定义的路由跳转时，可以在组件的useEffect中监听路由变化，并根据需要更新状态。此外，可以使用next/router的beforePopState事件来监听浏览器的前进和后退按钮操作，从而维护状态。\nimport &#123; useEffect &#125; from &#39;react&#39;;\nimport &#123; useRouter &#125; from &#39;next&#x2F;router&#39;;\n\nfunction MyComponent() &#123;\n  const router &#x3D; useRouter();\n  const [data, setData] &#x3D; useState(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; fetch data based on router.query or other route parameters\n    fetchData(router.query.id).then(setData);\n\n    &#x2F;&#x2F; Listen for popstate events (back button)\n    const handleRouteChange &#x3D; (url) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; Update state or fetch data again if needed\n    &#125;;\n    \n    router.events.on(&#39;routeChangeStart&#39;, handleRouteChange);\n    return () &#x3D;&gt; &#123;\n      router.events.off(&#39;routeChangeStart&#39;, handleRouteChange);\n    &#125;;\n  &#125;, [router.query]);\n\n  &#x2F;&#x2F; Render component using data\n&#125;\n\n谈谈你对Next.js中的ISR（Incremental Static Regeneration）与SSG（Static Site Generation）的理解，以及它们适用场景的差异。ISR和SSG都是Next.js用于生成静态页面的技术，但各有侧重：\n\nSSG：在构建时生成所有静态页面，适合内容相对稳定、更新频率低的网站。SSG优化了首屏加载时间，且因为内容在构建时就已经生成，所以即使在高流量时段也能提供快速的响应。\n\nISR：结合了SSG的快速加载和动态数据的需求，允许页面在首次访问或按预定时间间隔重新生成。适用于需要定期或按需更新数据的页面，如新闻文章、社交媒体动态等。ISR确保了内容的新鲜度，同时也保留了大部分静态页面的优势。\n\n\n在Next.js项目中，如何配置和使用自定义的webpack配置？虽然Next.js自身已经内置了webpack配置，但有时可能需要进行自定义。可以通过在项目根目录下创建next.config.js文件来覆盖或扩展默认配置。在这个文件里，可以使用webpack和webpackDevMiddleware配置项来自定义webpack配置。\n&#x2F;&#x2F; next.config.js\nconst withPlugins &#x3D; require(&#39;next-compose-plugins&#39;);\nconst optimizedImages &#x3D; require(&#39;next-optimized-images&#39;);\n\nmodule.exports &#x3D; withPlugins([\n  [\n    optimizedImages, \n    &#123;\n      &#x2F;* optimizedImages 的配置选项 *&#x2F;\n    &#125;\n  ],\n  &#123;\n    webpack(config, options) &#123;\n      &#x2F;&#x2F; 在这里可以修改webpack配置\n      &#x2F;&#x2F; 例如，添加新的loader或plugins\n      config.module.rules.push(&#123;\n        test: &#x2F;\\.mycustom$&#x2F;,\n        use: [&#39;my-custom-loader&#39;],\n      &#125;);\n\n      return config;\n    &#125;,\n  &#125;,\n]);\n\n解释一下Next.js的API路由与传统的Node.js Express服务器相比有什么优势和局限性？优势：\n\n简易性：Next.js内置API路由，无需额外配置服务器，简化了开发流程。\n一体化：前端和后端逻辑可以放在同一个项目中，便于管理和部署。\n类型安全：支持TypeScript，提供更好的类型检查和错误预防。\n\n局限性：\n\n灵活性：相对于Express，Next.js的API路由功能较为基础，对于复杂的API逻辑可能不够灵活。\n中间件支持：虽然Next.js 12开始支持 Middleware，但在功能和生态系统上仍不如成熟的Express中间件丰富。\n性能：对于某些特定需求，自定义Express服务器可能提供更细粒度的性能优化。\n\n如何在Next.js应用中集成Redux？集成Redux通常涉及安装redux、react-redux和@reduxjs/toolkit等库，创建store、reducer、actions，并通过Provider组件将store包裹在应用的最外层。在Next.js中，推荐在_app.js中设置Provider，以便全局共享store。\n&#x2F;&#x2F; pages&#x2F;_app.js\nimport &#123; Provider &#125; from &#39;react-redux&#39;;\nimport store from &#39;..&#x2F;redux&#x2F;store&#39;;\n\nfunction MyApp(&#123; Component, pageProps &#125;) &#123;\n  return (\n    &lt;Provider store&#x3D;&#123;store&#125;&gt;\n      &lt;Component &#123;...pageProps&#125; &#x2F;&gt;\n    &lt;&#x2F;Provider&gt;\n  );\n&#125;\n\nexport default MyApp;\n\n如何在Next.js中处理错误边界（Error Boundaries）？Next.js允许在页面级别或全局使用错误边界来捕获JavaScript错误并优雅降级。可以通过定义一个继承自React.Component的类组件，并在其componentDidCatch生命周期方法中处理错误。\n&#x2F;&#x2F; ErrorBoundary.js\nclass ErrorBoundary extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; hasError: false &#125;;\n  &#125;\n\n  static getDerivedStateFromError(error) &#123;\n    &#x2F;&#x2F; 更新 state 使下一次渲染能够显示降级后的 UI\n    return &#123; hasError: true &#125;;\n  &#125;\n\n  componentDidCatch(error, errorInfo) &#123;\n    &#x2F;&#x2F; 可以记录错误日志等操作\n    logErrorToMyService(error, errorInfo);\n  &#125;\n\n  render() &#123;\n    if (this.state.hasError) &#123;\n      &#x2F;&#x2F; 你可以自定义降级后的UI 并渲染\n      return &lt;h1&gt;Something went wrong.&lt;&#x2F;h1&gt;;\n    &#125;\n\n    return this.props.children; \n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用错误边界包裹可能会抛出错误的组件\nfunction MyPage() &#123;\n  return (\n    &lt;ErrorBoundary&gt;\n      &#123;&#x2F;* 页面内容 *&#x2F;&#125;\n    &lt;&#x2F;ErrorBoundary&gt;\n  );\n&#125;\n\n如何利用Next.js的静态导出功能进行SEO优化？Next.js的SSG（Static Site Generation）功能允许预先生成HTML文件，这对SEO极其友好。搜索引擎爬虫可以直接读取完整的HTML内容，提高索引效率。为了进一步优化：\n\n确保每个页面有唯一的meta标签：如title、description等，可以通过getStaticProps或getServerSideProps动态生成。\n使用next-seo等库：方便管理页面SEO元数据。\n预渲染动态路由：对动态页面使用getStaticPaths和getStaticProps生成静态版本。\n**合理使用robots.txt和sitemap.xml**：引导搜索引擎正确抓取网站内容。\n\n如何在Next.js应用中实现服务端渲染（SSR）的性能监控？性能监控可以通过集成第三方服务如Google Analytics、Segment、New Relic等实现，也可以自建监控系统。具体实施时：\n\n安装必要的库：例如，使用react-ga集成Google Analytics。\n在_app.js中初始化监控工具：确保每次页面加载时都能正确发送页面视图。\n跟踪关键性能指标：如首次渲染时间（TTFB）、页面完全加载时间、客户端渲染时间等。\n错误追踪：利用window.onerror和unhandledrejection事件捕捉并上报错误。\n考虑使用专用的SSR监控工具：如Vercel的Analytics，专门针对Next.js应用提供详细的性能报告。\n\n","slug":"interview-next","date":"2024-05-30T14:58:58.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"cf0441f16ce9f9e8f078668d5a3bf9e5","title":"interview-javascript","content":"JavaScriptJavaScript有哪些数据类型，它们的区别？\n原始数据类型：\nUndefined：表示变量已被声明但未被赋值，只有一个值undefined。\nNull：表示一个空对象指针，用于表示缺少值，只有一个值null。\nBoolean：逻辑类型，只有两个值true和false。\nNumber：用于表示整数和浮点数，支持NaN（非数字）和Infinity。\nString：用于表示文本，由零个或多个字符组成，可以用单引号(‘ ‘)或双引号(“ “)包围。\nSymbol（ES6引入）：唯一且不可变的数据类型，常用于对象的唯一属性键。\nBigInt（ES10引入）：用于处理超过Number安全整数范围的大整数。\n\n\n引用数据类型：\nObject：复合数据类型，可以是一组键值对的集合（普通对象）、数组、函数、正则表达式、日期等。存储在堆内存中，并且变量实际存储的是指向这些数据的引用（地址）。\n\n\n区别：\n存储方式：原始数据类型存储在栈内存中，直接存储值；引用数据类型存储在堆内存中，栈中存储的是指向堆内存中实际数据的引用。\n值传递：原始数据类型的变量之间传递时，传递的是值的副本，互不影响；引用数据类型变量间传递的是引用的副本，修改其中一个变量可能会影响到原始数据。\n内存占用：原始数据类型占用内存较少，复制成本低；引用数据类型由于存储的是引用，占用内存较大，复制时实际上是复制引用，可能导致数据共享。\n操作方式：原始数据类型的比较是值的比较；引用数据类型的比较是引用（地址）的比较，即使内容相同，不同实例也不相等。\n\n\n\n数据类型检测的方式有哪些\ntypeof运算符用途：用于检测基本数据类型，如字符串(String)、数字(Number)、布尔(Boolean)、undefined、symbol、以及函数(Function)。对于对象(Object)和数组(Array)，**typeof会返回”object”，对于null，它会返回”object”**，这是typeof的一个常见陷阱。\n\ninstanceof运算符用途：用于检测一个对象是否属于某个构造函数的实例。例如，可以用来检测一个对象是否是Array、Function等的实例。但它依赖于构造函数，对于基本类型和原型被修改的对象可能不准确。\n\nArray.isArray()用途：专门用于检测一个值是否为数组类型，返回布尔值。这是检测数组最准确的方法。\n\nObject.prototype.toString.call()用途：这是最全面也是最推荐的检测数据类型的方法。通过调用Object.prototype.toString.call()并传递待检测的值作为上下文，可以得到一个表示该值类型的标准字符串，如”[object Array]”、”[object Object]”等。这种方法几乎能准确区分所有内置类型，包括数组、正则表达式等。\n\n\nnull和undefined区别\n含义与用途：\nnull 表示一个刻意的空值，意味着变量被设置为“什么都没有”，或者说是一个空的对象指针。当你想要表示一个变量的值是“空”或者“无对象”时，可以使用 null。它是一个关键字，用来表示空对象或者空指针。\nundefined 表示一个变量声明了但未被赋值时的默认值，或者访问一个对象上不存在的属性时返回的值。这意味着变量存在，但没有具体的值关联到它，是一种未定义的状态。\n\n\n数据类型：\nnull 是一个独立的数据类型，称为 Null 类型。\nundefined 也是一个独立的数据类型，称为 Undefined 类型。\n\n\n类型检查：\n使用 typeof 操作符时，null 返回 &quot;object&quot;（这被认为是一个历史遗留的错误），而 undefined 返回 &quot;undefined&quot;。使用严格相等运算符 (&#x3D;&#x3D;&#x3D;) 比较时，null &#x3D;&#x3D;&#x3D; null 和 undefined &#x3D;&#x3D;&#x3D; undefined 都为 true，但 null === undefined 为 false，说明它们在值上不等，尽管都代表“无值”。\n\n\n转换为布尔值：\n在条件语句中，两者都会被自动转换为 false，但原因不同：null 是因为它是对象的空值，而 undefined 是因为它是未定义的值。\n\n\n\n如何获取安全的 undefined 值？\n使用 void 0: 这是最常用的获取undefined值的方法，因为void操作符返回一个undefined值，并且void 0是恒定的，不会受到外部影响。\nlet safeUndefined &#x3D; void 0;\n\n函数式接口或自定义函数: 可以定义一个函数，它总是返回undefined，这样做的好处是可以控制返回值，并且易于理解代码意图\nfunction getSafeUndefined() &#123;\n    return undefined;\n&#125;\nlet safeUndefined &#x3D; getSafeUndefined();\n\ntypeof NaN 的结果是什么？  typeof NaN 的结果是 &quot;number&quot;。在 JavaScript 中，尽管 NaN 代表 “Not a Number”，表示一个本应为数值但实际并非有效数值的特殊值，它的类型仍然是 “number”\n&#x3D;&#x3D; 操作符的强制类型转换规则？\n数字与非数字比较：非数字类型（字符串、布尔值、对象等）会转换为数字进行比较。布尔值true转为1，false转为0；字符串尝试解析为数字，无法解析时转为NaN。\n\n对象与非对象比较：对象会先转换为原始值（通常通过toString或valueOf方法），然后再进行比较。\n\nnull与undefined比较：它们之间相等（null &#x3D;&#x3D; undefined），与其他类型比较都不相等。\n\n字符串与数字比较：字符串会被转换为数字进行比较。\n\n符号类型比较：Symbol类型与任何非Symbol类型比较（包括另一个不同的Symbol）都返回false。\n\n\nObject.is() 与比较操作符 &#x3D;&#x3D;&#x3D;，&#x3D;&#x3D;的区别？\nObject.is():  类似于&#x3D;&#x3D;&#x3D;，但有两个关键差异：\n对于NaN，Object.is(NaN, NaN)返回true，这是与&#x3D;&#x3D;&#x3D;最大的不同，它认为两个NaN值是相等的。\n对于+0和-0，虽然它们在JavaScript中通常被视为相等（+0 &#x3D;&#x3D;&#x3D; -0为true），但Object.is(+0, -0)会返回false，区分了这两种零值。\n\n\n\nJavaScript 中如何进行隐式类型转换？\n字符串与数字相加:当字符串与数字相加时，数字会被转换为字符串，然后进行拼接。\nlet num &#x3D; 5;\nlet str &#x3D; &quot;3&quot;;\nconsole.log(num + str); &#x2F;&#x2F; 输出 &quot;53&quot;\n\n布尔值参与算术运算:布尔值在进行算术运算时，true会被转换为1，false会被转换为0。\nlet boolTrue &#x3D; true;\nlet result &#x3D; 4 + boolTrue; &#x2F;&#x2F; true 转换为 1\nconsole.log(result); &#x2F;&#x2F; 输出 5\n\n比较运算中的类型转换:在使用&#x3D;&#x3D;比较操作符时，会发生类型转换以比较值。\n\n数字与字符串比较时，字符串会被转换为数字。\n布尔值参与比较时，true变为1，false变为0。\n对象与非对象比较时，对象会通过toString()或valueOf()方法转换为原始值。\n\n\n条件语句中的转换:在条件语句如if中，非布尔值会被转换为布尔值进行判断，类似于使用Boolean()函数。\n\n\n为什么会有BigInt的提案BigInt 类型的提案被提出，主要是为了解决 JavaScript 中传统 Number 类型无法安全、精确表示极大整数的问题。在 JavaScript 中，Number 类型使用 IEEE 754 双精度浮点数格式存储数值，这限制了它可以安全表示的最大整数范围大约在 -(2^53 - 1) 到 2^53 - 1 之间。超过这个范围，整数可能会失去精度，导致不准确的计算结果。\nBigInt 类型的引入，使得开发者能够安全地处理任意大小的整数，这对于诸如加密算法、科学计算、大规模数据分析等领域尤为重要，这些领域经常需要处理超大整数且对精度有严格要求。BigInt 提供了对大整数的原生支持，可以进行精确的算术运算，避免了浮点数运算可能带来的精度损失。\nobject.assign和扩展运算法是深拷贝还是浅拷贝，两者区别\nObject.assign和扩展运算符（…）都是执行浅拷贝，意味着它们只会复制对象的顶层属性，而不会递归复制嵌套对象。如果对象中有属性是另一个对象或数组，这些属性将会共享同一份引用，修改时会影响原对象。\n主要区别在于语法使用上：Object.assign是一个方法，可以合并多个源对象到目标对象；扩展运算符更适用于构造新对象或在模板字面量中展开对象。两者都不适合需要完全独立拷贝对象结构的深拷贝场景。\n\nlet、const、var的区别\n作用域\n\nvar: 具有函数作用域或全局作用域，无块级作用域。在函数内声明的var变量对整个函数可见，块外部也可访问。\nlet &amp; const: 引入了块级作用域，只在声明它们的块内有效。\n\n\n变量提升\n\nvar: 存在变量提升，可在声明前使用，值为undefined。\nlet &amp; const: 无变量提升，声明前引用会导致TDZ（Temporal Dead Zone）错误。\n\n\n重复声明\n\nvar: 允许在同一作用域内重复声明，可能导致意料之外的行为。\nlet: 不允许在相同作用域或块内重复声明，否则报错。\nconst: 同样不允许重复声明，且声明时必须初始化，值不可变。\n\n\n可变性\n\nvar &amp; let: 声明的变量值可以改变。\nconst: 声明常量，值一旦设定不可更改。但对于对象或数组等复杂数据类型，内部属性或元素可修改。\n\n\n\nconst对象的属性可以修改吗？当使用const声明一个对象时，实际上是使该对象的引用不可改变，也就是说，你不能让这个变量指向另一个不同的对象。但是，这并不意味着对象本身的属性是不可修改的。如果对象的属性是可写的，你可以修改其属性值，增加新的属性，甚至删除已有属性。这是因为const限制的是变量的赋值操作，而非对象内容的变更。\nconst obj &#x3D; &#123; prop: &quot;value&quot; &#125;;\nobj.prop &#x3D; &quot;new value&quot;; &#x2F;&#x2F; 这是允许的，修改属性值\nobj.newProp &#x3D; &quot;added&quot;; &#x2F;&#x2F; 也可以，添加新属性\ndelete obj.prop; &#x2F;&#x2F; 删除属性也是可以的\n\n如果new一个箭头函数的会怎么样箭头函数不能作为构造函数使用，所以你不能用 new 操作符来实例化箭头函数。尝试这么做会抛出错误。\n示例代码const ArrowFunction &#x3D; () &#x3D;&gt; &#123;&#125;;\nconst instance &#x3D; new ArrowFunction(); &#x2F;&#x2F; 这是错误的用法\nTypeError: ArrowFunction is not a constructor\n\n箭头函数与普通函数的区别\n语法\n\n普通函数：使用function关键字定义，可具名也可匿名。\n箭头函数：使用=&gt;符号定义，总是匿名，语法更为简洁。\n\n\nthis绑定\n\n普通函数：this值在运行时确定，受调用上下文影响。\n箭头函数：不绑定自己的this，继承自外层作用域，提供固定的this引用。\n\n\narguments对象\n\n普通函数：提供arguments对象访问所有传入参数。\n箭头函数：不支持arguments，推荐使用剩余参数...args。\n\n\n构造函数\n\n普通函数：可用作构造函数，通过new实例化。\n箭头函数：不可用作构造函数，new实例化会抛错。\n\n\n原型\n\n普通函数：具有prototype属性，用于定义对象原型。\n箭头函数：无prototype属性。\n\n\ncall(), apply(), bind()方法\n\n普通函数：可改变this指向。\n箭头函数：使用这些方法不影响this，维持外层作用域的this。\n\n\nGenerator函数\n\n普通函数：支持通过yield定义为Generator，实现迭代。\n箭头函数：不支持yield，不能定义为Generator。\n\n\n适用场景\n\n箭头函数：适合简洁表达式、回调函数，适合不需独立this或arguments的场景。\n普通函数：更广泛用途，特别是需要灵活this绑定、原型继承或生成器功能时。\n\n\n\n箭头函数的this指向哪里？箭头函数的this关键字指向在其定义时所在的上下文环境，即采用词法绑定（lexical binding）方式确定。具体规则概括如下：\n\n全局作用域：箭头函数中的this指向全局对象，浏览器环境下通常是window，Node.js中是global或globalThis。\n\n非箭头函数内部：若箭头函数位于另一个函数内部，它将继承最近一层非箭头函数的this值，不论该箭头函数如何被调用。\n\n对象方法中：当箭头函数作为对象的属性方法被定义时，其this仍由包含它的最近一层非箭头函数确定，而非指向该对象。\n\n事件处理器、定时器等：在事件监听器、setTimeout等异步回调中，箭头函数维持外层作用域的this，避免了传统函数因执行环境改变导致的this变化问题。\n\n\n扩展运算符（Spread Operator）的作用及使用场景\n作用扩展运算符（...）在JavaScript中是一个非常强大的特性，主要用于以下几个方面：\n\n数组解构与合并：\n\n解构：可以将数组的元素分解到单独的变量中。\n合并：合并数组，将一个数组的元素插入到另一个数组中，或创建数组的新副本。\n\n\n函数参数传递：\n\n将数组作为参数传递给接收多个参数的函数，自动展开数组元素为独立参数。\n\n\n对象属性复制与合并：\n\n复制对象，快速创建新对象作为原对象的浅拷贝。\n合并对象，将一个对象的可枚举属性复制到另一个对象中。\n\n\n替换apply()方法：\n\n在调用函数时，用扩展运算符替代Function.prototype.apply()方法传递数组作为参数。\n\n\n\n\n使用场景\n\n数组操作：\n\n快速克隆数组：let arrClone = [...arr];\n合并多个数组：let combined = [...arr1, ...arr2, ...arr3];\n数组合并与去重：结合Set实现数组去重后合并。\n\n\n函数调用：\n\n传递数组为函数参数：func(...arrayArgs);\n在类的构造函数中使用扩展运算符继承父类的属性和方法。\n\n\n对象操作：\n\n快速复制对象：let newObj = &#123; ...originalObj &#125;;\n合并对象属性：let mergedObj = &#123; ...obj1, ...obj2 &#125;;\n用于解构赋值时忽略某些属性或添加默认值。\n\n\n字符串与迭代器：\n\n将字符串或Map&#x2F;Set等可迭代对象转换为数组：[...str] 或 [...map]。\n\n\n\n\n\nnew操作符的实现原理在JavaScript中，new操作符用于实例化对象，其背后的实现原理大致可以分为以下四个步骤：\n\n创建新对象： 当使用new关键字调用一个函数时，JavaScript引擎首先会在内存中创建一个新的空对象。此对象将作为构造函数的实例。\n\n设置原型链： 新创建的对象的[[Prototype]]（或可访问的__proto__属性）会被设置为构造函数的prototype属性所指向的对象。这样，新对象就可以继承构造函数原型上的属性和方法。\n\n绑定this值： 在构造函数内部，this关键字会被绑定到新创建的对象上。这意味着通过this可以访问和修改新对象的属性和方法。\n\n执行构造函数体： 接着，构造函数的代码体被执行，其中可以使用this来初始化新对象的属性和方法。任何在构造函数中返回的非原始值（即不是基本类型如数字、字符串、布尔值、null或undefined）都将被忽略，除非构造函数显式地返回了一个对象，这时new表达式的结果就是这个返回的对象。\n\n返回新对象： 如果构造函数没有显式返回一个对象，new操作符最终会自动返回步骤1中创建的那个新对象。\n\n\n以伪代码形式表示，new操作符的工作流程大致如下：\nfunction newInstance(Constructor, ...args) &#123;\n  &#x2F;&#x2F; 创建新对象\n  var instance &#x3D; Object.create(Constructor.prototype);\n  &#x2F;&#x2F; 绑定this并执行构造函数\n  var result &#x3D; Constructor.apply(instance, args);\n  &#x2F;&#x2F; 检查构造函数是否返回了一个对象\n  return typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; result !&#x3D;&#x3D; null ? result : instance;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nfunction Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\nvar person &#x3D; newInstance(Person, &#39;Alice&#39;);\n\n\nMap与Object的区别\n键的类型：\n\nObject：键值（Key）只能是字符串或Symbol类型。即使你使用非字符串作为键，它们也会被转换成字符串（例外是使用Symbol作为键）。\nMap：键可以是任意类型，包括对象、函数、基本类型等。这意味着Map提供了更灵活的键值对存储方式。\n\n\n迭代顺序：\n\nObject：键值对的迭代顺序不确定，尽管ES2015引入了迭代器，但具体顺序可能受实现和环境影响。\nMap：保持插入时的顺序，键值对的迭代顺序是确定的，按照插入的顺序进行。\n\n\n大小属性：\n\nObject：没有内置的属性可以直接获取对象的大小，需要手动计算或遍历键值对。\nMap：提供了一个内置的size属性，可以快速获取键值对的数量。\n\n\n原型链：\n\nObject：拥有原型链，可能会导致意外的键冲突，如hasOwnProperty等方法可能存在于用户数据中。\nMap：没有原型链上的默认属性，因此不会发生这种键冲突问题。\n\n\n默认值：\n\nObject：由于原型的存在，可能会有默认的属性和方法。\nMap：默认为空，不包含任何额外的默认属性或方法。\n\n\n性能：\n\nMap：在频繁增删键值对的场景下，由于其底层实现（通常基于哈希表），性能往往优于普通的Object。\n\n\n创建方式：\n\nObject：可以通过字面量&#123;&#125;或Object.create方法创建。\nMap：使用new Map()构造函数创建，并可以传入迭代器初始化。\n\n\n\nJavaScript有哪些内置对象\n基础内置对象\nObject：所有对象的基类，其他对象都继承自此。\nFunction：函数对象，JavaScript中的函数也是对象。\nArray：用于构建数组数据结构。\nString：处理字符串数据。\nNumber：数字相关的操作与属性。\nBoolean：布尔值，表示真&#x2F;假状态。\nSymbol（ES6引入）：创建独一无二的符号，通常作为对象的键。\nBigInt（ES10引入）：用于处理超过Number.MAX_SAFE_INTEGER的大整数。\n\n\n数学与日期\nMath：包含数学运算相关的静态方法。\nDate：处理日期和时间。\n\n\n正则表达式\nRegExp：用于文本匹配和替换操作。\n\n\n集合类型\nMap：存储键值对的集合，键可以是任意类型。\nSet：存储唯一值的集合。\nWeakMap：类似于Map，但其键是弱引用，易被垃圾回收。\nWeakSet：类似于Set，成员为弱引用对象。\n\n\n迭代与异步\nPromise：处理异步操作的结果。\nIterator 和 可迭代协议：使对象可被迭代。\nGenerator：生成器函数，控制迭代过程。\n\n\n二进制数据处理\nArrayBuffer：二进制数据缓冲区。\nTypedArray：视图对象，访问ArrayBuffer的不同数据类型。\nDataView：提供灵活读写ArrayBuffer数据的方式。\nWebAssembly相关\nWebAssembly：在JavaScript中使用WebAssembly模块。\n\n\n\n数组有哪些原生方法\n修改原数组的方法\npush(…items)：在数组末尾添加一个或多个元素，并返回新数组长度。\npop()：移除数组最后一个元素，并返回该元素。\nshift()：移除数组第一个元素，并返回该元素。\nunshift(…items)：在数组开头添加一个或多个元素，并返回新数组长度。\nsplice(start, deleteCount, …items)：从数组中添加&#x2F;删除元素，可修改原数组。start指定开始位置，deleteCount指定删除数量，后续参数为要添加的元素。\nreverse()：反转数组中的元素顺序。\nsort([compareFn])：对数组元素排序，默认按字典顺序，可通过比较函数自定义排序规则。\n\n\n不修改原数组的方法\nconcat(…arrays)：合并当前数组与其他数组或值，返回新数组。\nslice(start, end)：返回从start到end（不包括end）的数组片段，生成新数组。\nindexOf(searchElement[, fromIndex])：查找元素首次出现的位置，未找到返回-1。\nlastIndexOf(searchElement[, fromIndex])：查找元素最后一次出现的位置，未找到返回-1。\njoin([separator])：将数组元素连接成字符串，可选分隔符，默认为,。\nincludes(searchElement[, fromIndex])：检查数组是否包含指定元素，返回布尔值。\nentries() &#x2F; keys() &#x2F; values()：返回迭代器，分别用于遍历键值对、键、值。\n\n\n高级操作方法\nmap(callback[, thisArg])：对每个元素执行函数，返回新数组，原数组不变。\nfilter(callback[, thisArg])：筛选符合条件的元素，组成新数组返回。\nreduce(callback[, initialValue]) &#x2F; reduceRight(callback[, - initialValue])：从左&#x2F;右遍历数组，累计执行函数，可用于求和、计数等。\nsome(callback[, thisArg])：检测数组中是否有元素满足条件，返回布尔值。\nevery(callback[, thisArg])：检测数组中所有元素是否都满足条件，返回布尔值。\n\n\n迭代方法\nforEach(callback[, thisArg])：对每个元素执行函数，无返回值，主要用于副作用操作。\nfind(callback[, thisArg])：返回数组中满足提供的测试函数的第一个元素的值，否则返回undefined。\nfindIndex(callback[, thisArg])：返回数组中满足提供的测试函数的第一个元素的索引，否则返回-1。\n\n\n\n为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?\n为什么是类数组？\n灵活性：允许JavaScript函数接受可变数量的参数，而无需预先定义参数个数。\n兼容性历史：在JavaScript早期设计时，这样设计是为了简化语言并保持向后兼容性。\n性能与内存考虑：直接使用类数组对象减少了创建完整数组实例的需求，可能在某些场景下更轻量级。\n\n\n如何遍历类数组？\nfor循环\n  for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123;\n  console.log(arguments[i]);\n&#125;\n\nforEach方法（借助Array.prototype.call）\n  Array.prototype.forEach.call(arguments, function(item, index) &#123;\n console.log(item);\n&#125;);\n转换为真正的数组再遍历\n  const argsArray &#x3D; [...arguments];\nargsArray.forEach(item &#x3D;&gt; console.log(item));\n\n\n\nJavaScript为什么要进行变量提升，它导致了什么问题\n为什么进行变量提升？JavaScript进行变量提升主要是因为其设计之初为了简化编程模型，让开发者能够更加灵活地在函数内部声明变量，不必严格在使用前声明。这一机制允许在声明之前访问变量，给予开发者更多自由。此外，它也反映了JavaScript的解释器在执行前进行的两个阶段：预编译（解析变量和函数声明）和执行（运行代码）。\n\n导致的问题\n\n代码可读性和维护性下降：变量可以在声明之后使用，可能导致逻辑混乱，特别是当变量声明远离使用位置时。\n潜在的错误和误解：未初始化的变量默认为 undefined，在声明前访问可能会导致意外行为或错误。\n作用域混淆：在ES6之前，由于变量提升，var 声明的变量会提升到全局或函数作用域顶部，可能导致无意中覆盖已有的变量。\n与let和const的差异：引入块级作用域的 let 和 const 不具备变量提升特性，这可能导致开发者在使用不同声明方式时产生混淆。\n\n\n\n什么是尾调用，使用尾调用有什么好处？尾调用（Tail Call）是函数式编程中的一个概念，指的是一个函数的最后操作是调用另一个函数，并且将这个调用的结果直接返回，不做任何进一步的计算。换句话说，当一个函数的最后一个动作是调用另一个函数时，这种情况就称为尾调用。\n使用尾调用的好处：\n\n内存优化：尾调用优化（Tail Call Optimization, TCO）是一种编译器优化技术。在支持此优化的环境中，当函数以尾调用方式结束时，编译器或解释器可以复用当前函数的调用帧（call frame），而不是在调用栈上为新函数分配新的栈帧。这样可以避免栈溢出（stack overflow）问题，尤其是在进行深度递归时，极大节省了内存空间。\n提高性能：由于减少了调用栈的深度，程序执行的效率得到提升，尤其是在递归算法中，能够显著减少执行时间。\n简洁代码：尾调用使得代码更加简洁清晰，易于理解，尤其是当用于实现递归逻辑时，可以帮助开发者写出更优雅的解决方案。\n\n需要注意的是，尽管尾调用优化在理论上很有吸引力，但在JavaScript中，尾调用优化是有条件的，通常只在使用严格模式（use strict）的情况下才有可能生效，而且并非所有JavaScript引擎都实现了这一优化。因此，在依赖尾调用优化来避免栈溢出或提升性能时，需要确认运行环境是否支持这一特性。\nuse strict是什么意思 ? 使用它区别是什么？use strict 是一个放在JavaScript代码文件或函数开头的字符串字面量，用于指示代码应当在严格模式（strict mode）下执行。这一特性首次出现在 ECMAScript 5 标准中，目的是通过改变 JavaScript 的某些行为，使得代码编写更加安全、严谨并易于调试。\n使用 use strict 的区别主要包括：\n\n变量声明：在严格模式下，未声明就使用的变量会抛出错误，而不是默认创建全局变量，这有助于避免因拼写错误导致的意外全局变量。\n\n禁止删除变量或函数：尝试删除不可配置的属性（如变量、函数）会抛出错误。\n\n禁止八进制字面量：不允许使用八进制数字字面量，除非采用ES6引入的0o前缀。\n\n禁止with语句：with 语句在严格模式下被禁用，因为它可能导致变量作用域的混乱。\n\n更严格的函数调用：函数调用时，this 值不会被自动绑定到全局对象，如果上下文中没有明确的this，它将是undefined（在非箭头函数中）。\n\n更严格的错误检查：某些在非严格模式下可能静默通过的操作会抛出错误，比如给非对象使用delete操作符。\n\neval的行为变化：在严格模式中，eval代码不能修改其外部作用域的变量，它要么在全局作用域中执行，要么有自己的作用域。\n\n\nfor…in和for…of的区别\nfor…in\n\n用途：主要用于遍历对象的可枚举属性（包括原型链上的属性）。\n输出：循环变量获取的是对象的键名（key）。\n问题：因为遍历包括原型链上的属性，可能导致意料之外的结果，特别是在遍历数组时可能遍历到数组原型上的方法。因此，在使用 for…in 遍历数组时，通常需要结合 hasOwnProperty 检查来过滤掉原型链上的属性。let obj &#x3D; &#123;a: 1, b: 2&#125;;\nfor(let key in obj) &#123;\n    console.log(key); &#x2F;&#x2F; 输出 &#39;a&#39;, &#39;b&#39;\n&#125;\n\n\nfor…of\n\n用途：主要用于遍历可迭代对象（如数组、Set、Map、字符串、生成器等）的元素值。\n输出：循环变量直接获取的是元素值（value）。\n特点：不会遍历对象的键名，也不会遍历原型链。对于普通对象，直接使用 for…of 会报错，需要配合 Object.keys()、Object.values() 或 Object.entries() 等方法使用。\n优势：提供了一种更简洁、直观的遍历集合的方式，且能够正确响应 break、continue 和 return 语句。let arr &#x3D; [1, 2, 3];\nfor(let value of arr) &#123;\n    console.log(value); &#x2F;&#x2F; 输出 1, 2, 3\n&#125;\n\n\n\n数组循环的方法\nfor循环\nconst arr &#x3D; [1, 2, 3];\nfor (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  console.log(arr[i]);\n&#125;\n\nforEach():\narr.forEach((element, index, array) &#x3D;&gt; &#123;\n  console.log(element);\n&#125;);\nfor…of:\nfor (const element of arr) &#123;\n  console.log(element);\n&#125;\nmap():\nconst newArr &#x3D; arr.map((element, index, array) &#x3D;&gt; &#123;\n  return element * 2;\n&#125;);\nfilter():\nconst filteredArr &#x3D; arr.filter((element, index, array) &#x3D;&gt; &#123;\n  return element &gt; 1;\n&#125;);\nreduce():\nconst sum &#x3D; arr.reduce((accumulator, currentValue, currentIndex, array) &#x3D;&gt; &#123;\n  return accumulator + currentValue;\n&#125;, 0);\nsome()、every()、find()、findIndex()\n\n\nforEach和map方法有什么区别\nforEach方法不返回任何值（返回undefined）。它主要用于执行某种操作，如打印数组元素，但不对原数组进行修改（除非函数内部显式修改了数组元素）。\nmap方法则会返回一个新的数组，这个新数组的元素是原数组中每个元素经过回调函数处理后的结果。这意味着map可以用来转换数组，而不影响原始数组。\n\n对原型、原型链的理解\n原型（Prototype）\n\n在JavaScript中，函数 的一个核心特性是它们拥有一个名为 prototype 的属性，该属性是一个对象，我们称之为原型对象。原型对象的主要目的是实现属性和方法的共享。当你使用一个构造函数（用于初始化新创建对象的函数）来生成新对象时，这个新对象会自动地与该构造函数的原型对象相连接。如此一来，新对象就能够访问并继承原型对象上的所有属性和方法，形成了简单的继承关系。\n\n原型链（Prototype Chain）\n\n原型链 是JavaScript实现继承的一个核心概念。实际上，不仅仅是新创建的对象，每一个对象（包括原型对象自身）都有一个内部链接指向其对应的原型对象，这个链接通常称为[[Prototype]]。在一些环境中，可以通过非标准但广泛支持的__proto__属性来访问这个链接。当试图访问一个对象的属性或方法时，如果该对象本身没有定义，JavaScript引擎会继续在其[[Prototype]]链接指向的原型对象中查找，如果还没有找到，则继续向上追溯原型链，直到找到该属性或方法，或者到达原型链的末端（通常是Object.prototype）。这一连串的查找过程就构成了所谓的原型链。\n简而言之，原型机制让对象能够继承功能，而原型链则是这一继承过程中查找属性和方法的路径。\n原型修改、重写在JavaScript中，原型对象并非静态不变的。开发者可以根据需要对原型对象进行修改或重写，以便为基于特定构造函数创建的所有实例添加、修改或删除方法及属性。这进一步体现了原型继承的灵活性。以下是原型修改和重写的一些关键点：\n\n添加属性或方法\n\n可以直接在构造函数的原型对象上添加新的属性或方法，这些改动会影响到所有现有及未来通过该构造函数创建的对象。\nfunction Person(name) &#123;\n    this.name &#x3D; name;\n&#125;\n\nPerson.prototype.sayHello &#x3D; function() &#123;\n    console.log(&quot;Hello, my name is &quot; + this.name);\n&#125;;\n\n\n修改已有属性或方法\n\n对于原型对象上已存在的属性或方法，可以直接赋值以修改其内容或行为。\nPerson.prototype.sayHello &#x3D; function() &#123;\n    console.log(&quot;Greetings, I am &quot; + this.name);\n&#125;;\n\n\n重写原型对象\n\n有时可能需要完全替换原有的原型对象。这通常涉及两步操作：首先创建一个新的原型对象，然后将其设置为原构造函数的原型。重要提示：这样做会断开与原原型链的联系，因此在新原型上应手动设置或链回Object.prototype，以保持基本的对象行为。\nPerson.prototype &#x3D; &#123;\n    constructor: Person, &#x2F;&#x2F; 重要！确保constructor属性正确指向\n    sayHello: function() &#123;\n        console.log(&quot;Salutations, the name&#39;s &quot; + this.name);\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; 确保新原型链不断开，可选操作：\nObject.setPrototypeOf(Person.prototype, Object.prototype);\n\n原型链指向\nJavaScript中的原型链指向在JavaScript中，每个对象都有一个内部属性[[Prototype]]（可通辻__proto__访问，尽管不建议直接使用），它形成了对象之间的原型链。原型链是实现继承机制的基础，允许一个对象可以从另一个对象继承属性和方法。以下是原型链指向的相关概念和示例：\n\n原型链基础\n\n**原型对象(prototype)**：每个函数自动具有一个名为prototype的属性，该属性是一个对象，用于存储所有由该构造函数创建的对象所共享的属性和方法。\n原型链：当试图访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript引擎会继续在其[[Prototype]]（即__proto__）所指向的对象中查找，这个过程会一直向上追溯，直到找到该属性或方法，或者到达原型链的末端（通常是Object.prototype）。\n\n\n示例说明\n\n\n假设我们有如下的构造函数和对象关系：\nfunction Animal(name) &#123;\n    this.name &#x3D; name;\n&#125;\n\nAnimal.prototype.speak &#x3D; function() &#123;\n    console.log(&quot;Some sound&quot;);\n&#125;;\n\nfunction Dog(name) &#123;\n    Animal.call(this, name); &#x2F;&#x2F; 继承Animal属性\n&#125;\n\nDog.prototype &#x3D; Object.create(Animal.prototype); &#x2F;&#x2F; 设置Dog的原型为Animal的实例\nDog.prototype.constructor &#x3D; Dog; &#x2F;&#x2F; 修复constructor属性\n\nDog.prototype.speak &#x3D; function() &#123;\n    console.log(&quot;Woof, my name is &quot; + this.name);\n&#125;;\n\nvar myDog &#x3D; new Dog(&quot;Buddy&quot;);\n\n上述代码中，myDog对象的原型链可以表示为：\nmyDog -&gt; Dog.prototype -&gt; Animal.prototype -&gt; Object.prototype -&gt; null\n\n原型链的终点是什么？如何打印出原型链的终点？原型链的终点是null。在JavaScript中，每个对象的原型链最终都会指向null，标志着不再有更上一层的原型对象。\n要打印出一个对象的原型链终点，你可以检查一个对象的原型链直到遇到null。以下是如何在JavaScript中打印出原型链终点的一个简单示例：\nfunction printPrototypeChainEnd(obj) &#123;\n    while (obj) &#123;\n        obj &#x3D; Object.getPrototypeOf(obj); &#x2F;&#x2F; 获取对象的原型\n        if (obj &#x3D;&#x3D;&#x3D; null) &#123;\n            console.log(&quot;原型链的终点是: null&quot;);\n            return;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nlet anyObject &#x3D; new Object(); &#x2F;&#x2F; 或者使用其他对象\nprintPrototypeChainEnd(anyObject);\n\n\n如何获得对象非原型链上的属性？要获得JavaScript对象非原型链上的属性，可以使用hasOwnProperty()方法配合循环遍历对象的属性。以下是一个典型示例：\nfunction getOwnProperties(obj) &#123;\n    let ownProps &#x3D; [];\n    for (let key in obj) &#123;\n        if (obj.hasOwnProperty(key)) &#123;\n            ownProps.push(key);\n        &#125;\n    &#125;\n    return ownProps;\n&#125;\n\n&#x2F;&#x2F; 使用示例\nlet obj &#x3D; &#123;\n    name: &quot;Alice&quot;,\n    age: 30,\n&#125;;\n\n&#x2F;&#x2F; 假设有一个原型扩展\nObject.prototype.country &#x3D; &quot;Wonderland&quot;;\n\nconsole.log(getOwnProperties(obj)); &#x2F;&#x2F; 输出: [&#39;name&#39;, &#39;age&#39;]\n在这个例子中，getOwnProperties函数遍历对象obj的所有属性。对于每个属性，它使用hasOwnProperty()方法检查该属性是否直接定义在对象实例上，而不是从原型链继承来的。如果是对象自身的属性，则将其添加到ownProps数组中。最后，函数返回包含所有非原型链上属性名称的数组。\n对闭包的理解在JavaScript中，闭包是一个核心且强大的特性，它使得函数能够访问并记住其自身作用域以外的变量。具体来说，闭包指的是有权访问另一个函数作用域中的变量的函数，通常这种情况发生在内层函数访问外层函数的变量时。闭包由两部分组成：内部函数以及该函数被创建时的词法环境（作用域链）。\n\n关键特点\n\n\n变量访问: 内部函数可以访问其外部函数的局部变量，即使外部函数已经执行完毕。\n\n持久化存储: 闭包可以使得局部变量不随外部函数的执行结束而销毁，达到数据隐藏和封装的目的。\n\n内存管理: 由于闭包会维持对外部变量的引用，因此可能会导致这些变量不会被垃圾回收机制回收，进而占用更多内存。\n\n\n\n应用场景\n\n封装变量: 通过闭包，可以创建私有变量，防止外部直接修改内部状态。\n\n异步处理: 如setTimeout中使用闭包确保回调函数能正确访问外部函数的变量。\n\n函数工厂: 利用闭包创建一系列具有特定状态的函数。\n\n实现模块化: 封装相关功能和数据，避免全局变量污染。\n\n\nfunction outerFunction(outerVariable) &#123;\n    return function innerFunction(innerVariable) &#123;\n        console.log(&#39;outerVariable:&#39;, outerVariable);\n        console.log(&#39;innerVariable:&#39;, innerVariable);\n    &#125;;\n&#125;\n\nconst closureExample &#x3D; outerFunction(&#39;outside&#39;);\nclosureExample(&#39;inside&#39;); &#x2F;&#x2F; 输出: outerVariable: outside, innerVariable: inside\n\n对作用域、作用域链的理解\n作用域(Scope)\n\n在JavaScript中，作用域定义了变量、函数以及对象的可访问性范围。作用域主要有两种类型：\n\n全局作用域: 在代码的任何地方都能访问到的变量拥有全局作用域。全局作用域中的变量在浏览器环境中通常作为window对象的属性存在。\n\n局部作用域&#x2F;函数作用域: 当一个变量在一个函数内部声明时，它就拥有了局部作用域，这意味着这个变量只能在该函数内部被访问。\n\n\n\n作用域链(Scope Chain)\n\n作用域链是JavaScript引擎用来解决变量访问权限的一种机制。每个函数在创建时，都会生成一个作用域链，这个作用域链用于决定函数执行时如何查找变量。作用域链的构成遵循以下原则：\n\n静态作用域: JavaScript采用静态作用域（也称词法作用域），意味着函数的作用域链在函数定义时确定，而非运行时。\n\n链条构造: 作用域链的首端是当前函数的局部作用域，之后是包含当前函数的外部函数的作用域（如果有的话），以此类推，直到全局作用域为止。这条链定义了变量查找的顺序。\n\n\nvar globalVar &#x3D; &#39;global&#39;;\n\nfunction outer() &#123;\n    var outerVar &#x3D; &#39;outer&#39;;\n    \n    function inner() &#123;\n        var innerVar &#x3D; &#39;inner&#39;;\n        console.log(globalVar); &#x2F;&#x2F; 访问全局作用域变量\n        console.log(outerVar); &#x2F;&#x2F; 访问外部函数作用域变量\n        console.log(innerVar); &#x2F;&#x2F; 访问当前函数作用域变量\n    &#125;\n    \n    inner();\n&#125;\n\nouter();\n\n对this对象的理解在JavaScript中，this关键字是一个非常重要且有时可能引起混淆的概念。this的值取决于函数调用的上下文，即函数是如何被调用的，而不是函数在哪里被定义。\n基本概念\n动态绑定: this的值是在运行时基于函数的调用方式动态确定的，并非在编写代码时静态决定。\n上下文依赖: 它通常指向函数执行时的环境对象——调用该函数的对象。\n\n不同场景下的this值\n全局上下文\n在全局执行环境中（非严格模式下），this指向全局对象。在浏览器中是window对象，在Node.js中是global对象。\n使用严格模式（’use strict’;声明），全局上下文中的this会是undefined。\n\n\n函数调用\n普通函数调用: 如果函数不是作为某个对象的方法被调用，非严格模式下this默认指向全局对象；严格模式下this为undefined。\n方法调用: 当函数作为某个对象的属性（方法）被调用时，this指向该对象。const obj &#x3D; &#123;\n  method: function() &#123;\n    console.log(this); &#x2F;&#x2F; this指向obj\n  &#125;\n&#125;;\nobj.method();\n\n\n构造函数调用: 使用new关键字调用函数时，this指向新创建的实例对象。function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\nconst person &#x3D; new Person(&#39;Alice&#39;);\nconsole.log(person.name); &#x2F;&#x2F; &#39;Alice&#39;\n箭头函数: 箭头函数不绑定自己的this，它会从外层（词法作用域）继承this值。const obj &#x3D; &#123;\n  normalFunc: function() &#123;\n    console.log(this); &#x2F;&#x2F; obj\n  &#125;,\n  arrowFunc: () &#x3D;&gt; &#123;\n    console.log(this); &#x2F;&#x2F; 全局对象或undefined（严格模式）\n  &#125;\n&#125;;\nobj.normalFunc(); \nobj.arrowFunc();\nFunction.prototype.call(), apply(), bind(): 这些方法可以显式地设置函数调用时的this值。function greet(greeting) &#123;\n  console.log(&#96;$&#123;greeting&#125;, $&#123;this.name&#125;!&#96;);\n&#125;\n\nconst user &#x3D; &#123; name: &#39;Bob&#39; &#125;;\ngreet.call(user, &#39;Hello&#39;); &#x2F;&#x2F; Hello, Bob!\n\ncall() 和 apply() 、bind()的区别？call()\n用途: call()方法用于调用一个函数，并指定函数内部this的值，同时可以传递给函数独立的参数。\n参数: 第一个参数是你希望函数内部this所指向的对象，之后可以依次传入函数执行时需要的参数，这些参数必须一一列出。\n立即执行: call()会立即调用函数。\n\nfunction greet(name, greeting) &#123;\n    console.log(&#96;$&#123;greeting&#125;, $&#123;this.title&#125; $&#123;name&#125;!&#96;);\n&#125;\n\nconst person &#x3D; &#123; title: &#39;Mr.&#39; &#125;;\n\ngreet.call(person, &#39;John&#39;, &#39;Hello&#39;); &#x2F;&#x2F; 输出: Hello, Mr. John!\napply()\n用途: 类似于call(), apply()也是为了改变函数的调用上下文并立即执行函数，但它接收参数的方式不同。\n参数: 第一个参数同样用于指定this的值，第二个参数则是一个数组或类数组对象，包含了传递给函数的参数列表。\n参数形式: 由于使用数组，apply()适用于参数不确定或需要从数组中传递的情况。\n\ngreet.apply(person, [&#39;John&#39;, &#39;Hello&#39;]); &#x2F;&#x2F; 输出: Hello, Mr. John!\n\nbind()\n用途: bind()方法创建一个新的函数，其this值被永久地绑定到传给bind()的第一个参数，但并不立即执行这个函数。\n返回值: 返回一个新函数，当这个新函数被调用时，里面的this值会被永久绑定到bind()的第一个参数。\n参数: 同样可以传入额外的参数，这些参数将被预置，作为新函数的一部分，当调用这个新函数时，传入的额外参数会排在bind()指定的参数之前。\n\nconst boundGreet &#x3D; greet.bind(person, &#39;John&#39;);\nboundGreet(&#39;Hello&#39;); &#x2F;&#x2F; 输出: Hello, Mr. John!\n\n&#x2F;&#x2F; 绑定并预置部分参数\nconst greetJohn &#x3D; greet.bind(person, &#39;John&#39;);\ngreetJohn(&#39;Good morning&#39;); &#x2F;&#x2F; 输出: Good morning, Mr. John!\n总结\n立即执行 vs. 延迟执行: call()和apply()会立即调用函数，而bind()返回一个新函数供后续调用。\n参数传递: call()和apply()都可以改变函数的调用上下文，区别在于参数的传递方式——call()接受单独的参数列表，而apply()接受一个参数数组。\n绑定用途: bind()常用于创建一个具有特定this上下文和预置参数的函数副本，适用于需要多次调用或作为事件处理器的情况。\n\n异步编程的实现方式？异步编程是JavaScript中处理并发和非阻塞操作的关键技术，旨在提高程序响应性和性能。\n回调函数\n概念: 最传统的异步处理方式，将一个函数（回调函数）作为参数传递给另一个函数，待异步操作完成后调用该回调函数。\n优点: 实现简单，无需额外库。\n缺点: 回调地狱（Callback Hell），当多个异步操作需要嵌套时，代码可读性和可维护性大大降低。\n\nfs.readFile(&#39;file.txt&#39;, &#39;utf8&#39;, (err, data) &#x3D;&gt; &#123;\n    if (err) throw err;\n    console.log(data);\n&#125;);\n\nPromise\n概念: 一种解决回调地狱的异步编程模式，代表一个异步操作的最终完成（成功或失败）及其结果。\n状态: Pending（等待中）、Fulfilled（已完成，成功）、Rejected（已拒绝，失败）。\n方法: .then()处理成功结果，.catch()处理错误，.finally()无论结果如何都会执行。\n优点: 链式调用，易于理解和维护，支持并发执行（Promise.all()）和竞态执行（Promise.race()）。\n\nfetch(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;)\n    .then(response &#x3D;&gt; response.json())\n    .then(data &#x3D;&gt; console.log(data))\n    .catch(error &#x3D;&gt; console.error(&#39;Error:&#39;, error));\n\nasync&#x2F;await\n概念: 基于Promise的语法糖，使异步代码看起来更像同步代码。\n关键字: async定义异步函数，await等待Promise结果，暂停函数执行直到Promise解决。\n优点: 代码更简洁、直观，易于理解和维护。\n注意: 必须在async函数内部使用await，且await后的表达式通常是一个Promise。\n\nasync function fetchData() &#123;\n    try &#123;\n        const response &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;);\n        const data &#x3D; await response.json();\n        console.log(data);\n    &#125; catch (error) &#123;\n        console.error(&#39;Error:&#39;, error);\n    &#125;\n&#125;\nfetchData();\n\nPromise的理解与应用概述Promise 是 JavaScript 中用于处理异步操作的一种编程模型，它提供了一种标准化的方式来处理异步操作的成功或失败，并且支持链式调用，从而使得异步代码更加结构化和易于阅读。Promise 对象代表一个现在、将来或永远可能可用，或者永远不会可用的异步操作的结果。\n状态Promise 有三种状态：\n\nPending（等待中）：初始状态，既没有被兑现，也没有被拒绝。\nFulfilled（已成功）：表示操作成功完成，此时 Promise 的值就是 resolve 方法传递的参数。\nRejected（已失败）：表示操作失败，此时 Promise 的值是 reject 方法传递的参数。\n一旦 Promise 转变为 Fulfilled 或 Rejected 状态，它就会一直保持这个状态，不会再改变。\n\n基本用法创建一个 Promise 实例：\nconst myPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 异步操作\n&#125;);\n\nresolve 与 reject\nresolve(value)：用于改变 Promise 的状态为 Fulfilled，传递一个可选的 value 参数作为异步操作的结果。\nreject(reason)：用于改变 Promise 的状态为 Rejected，并传递一个 reason 参数表示失败的原因。\n\n链式调用通过 .then() 和 .catch() 方法实现链式调用，处理 Promise 的不同状态：\nmyPromise\n  .then(result &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 成功处理逻辑\n    console.log(&#39;Success:&#39;, result);\n  &#125;)\n  .catch(error &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 失败处理逻辑\n    console.error(&#39;Error:&#39;, error);\n  &#125;);\n\nfinallyfinally() 方法无论 Promise 的结果是 fulfilled 还是 rejected，都会执行指定的回调函数，常用于清理操作。\nmyPromise\n  .then(...)\n  .catch(...)\n  .finally(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 清理或通知操作\n  &#125;);\n\n并行与串行\n并行执行：使用 Promise.all() 可以同时执行多个 Promise，并在所有 Promise 完成（不论成功或失败）后返回一个新的 Promise。\n\nconst promise1 &#x3D; Promise.resolve(3);\nconst promise2 &#x3D; 42;\nconst promise3 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  setTimeout(resolve, 100, &#39;foo&#39;);\n&#125;);\n\nPromise.all([promise1, promise2, promise3]).then((values) &#x3D;&gt; &#123;\n  console.log(values); &#x2F;&#x2F; [3, 42, &quot;foo&quot;]\n&#125;);\n\n\n串行执行：通过在每个 Promise 的 .then() 中返回一个新的 Promise，可以实现按顺序执行异步操作\n\ndoSomething()\n  .then(result1 &#x3D;&gt; doSomethingElse(result1))\n  .then(result2 &#x3D;&gt; doThirdThing(result2))\n  .catch(error &#x3D;&gt; console.error(error));\n\n对象创建的方式有哪些？对象字面量特点：最直接、简洁的创建单个对象的方式。\nlet obj &#x3D; &#123;\n    key1: &#39;value1&#39;,\n    key2: &#39;value2&#39;,\n    method: function() &#123;\n        console.log(&#39;这是一个方法&#39;);\n    &#125;\n&#125;;\n\n构造函数特点：通过函数来创建特定类型的对象，可以重复使用，支持new操作符。\nfunction Person(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.sayHello &#x3D; function() &#123;\n        console.log(&#39;Hello, I am &#39; + this.name);\n    &#125;;\n&#125;\n\nlet person1 &#x3D; new Person(&#39;Alice&#39;, 30);\n\n工厂模式特点：通过函数来创建特定类型的对象，可以重复使用，支持new操作符。\nfunction Person(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.sayHello &#x3D; function() &#123;\n        console.log(&#39;Hello, I am &#39; + this.name);\n    &#125;;\n&#125;\n\nlet person1 &#x3D; new Person(&#39;Alice&#39;, 30);\n\n原型模式特点：通过构造函数的prototype属性共享方法，减少内存消耗。\nfunction PersonProto(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n&#125;\n\nPersonProto.prototype.sayHello &#x3D; function() &#123;\n    console.log(&#39;Hello, I am &#39; + this.name);\n&#125;;\n\nlet person3 &#x3D; new PersonProto(&#39;Carol&#39;, 28);\n\nClass（ES6+）特点：基于原型但语法更接近面向对象语言的类实现，支持继承、静态方法等。\nclass PersonClass &#123;\n    constructor(name, age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n\n    sayHello() &#123;\n        console.log(&#39;Hello, I am &#39; + this.name);\n    &#125;\n&#125;\n\nlet person4 &#x3D; new PersonClass(&#39;David&#39;, 32);\n\nObject.create特点：直接从一个对象原型创建新对象，不通过构造函数。\nlet personPrototype &#x3D; &#123;\n    sayHello: function() &#123;\n        console.log(&#39;Hello from prototype&#39;);\n    &#125;\n&#125;;\n\nlet person5 &#x3D; Object.create(personPrototype);\nperson5.name &#x3D; &#39;Eva&#39;;\n\n\n浏览器的垃圾回收机制浏览器的垃圾回收机制（GC）是自动管理内存资源的重要组成部分，它负责回收不再被使用的内存空间，确保内存的有效利用。以下是关于浏览器垃圾回收机制的详细说明，采用Markdown格式呈现：\n浏览器垃圾回收机制概览浏览器垃圾回收机制旨在自动回收JavaScript代码运行过程中分配的、不再被任何变量引用的内存空间。这一过程主要依赖于两种基本算法：标记-清除（Mark-and-Sweep） 和 引用计数（Reference Counting），现代浏览器通常采用更复杂的策略来优化这一过程，比如 分代收集（Generational Collection） 和 增量回收（Incremental Collection）。\n标记-清除算法\n标记阶段：从根对象（通常是全局对象）出发，遍历所有可达的对象，将它们标记为“活着”。\n清除阶段：遍历堆内存，未被标记的对象被视为垃圾，其占用的内存空间被回收。\n\n引用计数\n每个对象有一个引用计数，每当一个地方引用它时计数加一，引用被移除时减一。\n当对象的引用计数降为零时，该对象被认为是垃圾，可以被回收。\n\n分代收集\n新生代（Young Generation）：存放短期存活的对象，通常使用Scavenge算法快速回收。\n老生代（Old Generation）：存放长期存活的对象，回收成本较高，采用标记-清除或更复杂的算法。\n对象在经历一定次数的回收后若仍存活，会被晋升至老生代。\n\n增量回收\n为了避免长时间的垃圾回收导致页面冻结，现代浏览器采用增量回收策略，将回收过程拆分成多个小步骤穿插在JavaScript执行之间执行。\n\n内存管理注意事项\n避免内存泄漏：确保不再使用的对象能够被适时地解除引用，防止无意识的循环引用导致内存无法释放。\n优化代码：减少大对象的创建和销毁，合理使用闭包，注意定时器和事件监听器的清理。\n\n触发时机\n浏览器自动管理GC触发，无需开发者直接干预，但过度分配内存或复杂的对象关系可能频繁触发GC，影响性能。\n\n结论浏览器的垃圾回收机制是一个复杂而智能的过程，旨在平衡内存的有效利用与程序的执行效率。开发者应关注内存管理最佳实践，以辅助垃圾回收机制高效运作，避免因不当编码导致的性能瓶颈。\n哪些情况会导致内存泄漏在JavaScript中，尽管有自动垃圾回收机制来管理内存，但不当的编码实践仍可能导致内存泄漏。以下是可能导致JavaScript内存泄漏的常见情况，以Markdown格式展示：\nJavaScript内存泄漏常见场景\n意外的全局变量\n\n未使用var、let或const声明的变量会自动成为全局对象的属性，导致无法被垃圾回收。\n\n\n闭包中的引用\n\n闭包可能长期持有对外部变量的引用，如果这些变量包含大量数据或对象，会阻止它们被回收。\n\n\n未清理的定时器和回调函数\n\n使用setTimeout或setInterval后未调用clearTimeout或clearInterval来清理，导致回调函数持续占用内存。\n\n\nDOM元素引用\n\n即使DOM元素已从页面中移除，若JavaScript中仍有对该元素的引用，该元素及其相关资源将不会被回收。\n\n\n事件监听器\n\n未正确解除的事件监听器会持续持有DOM元素的引用，阻止元素和相关上下文被回收。\n\n\n循环引用\n\n两个或更多对象互相引用，形成循环链，若没有外部引用指向这个循环，垃圾回收器可能无法释放它们。\n\n\n未释放的资源\n\n如网络请求、Web Workers、Image对象等未正确关闭或释放，可能导致资源泄露。\n\n\n大型数据结构\n\n大型数组或对象若长期保存在内存中且不再使用，若没有适时清空或重新分配，会占用大量内存。\n\n\n\nsetTimeout、setInterval、requestAnimationFrame 各有什么特点？setTimeout、setInterval、和requestAnimationFrame都是JavaScript中用于处理延时或周期性执行任务的功能，但它们各有特点，适用于不同的场景：\nsetTimeout\n特点：\n一次性执行：setTimeout用于在指定的时间（延迟时间）之后执行一次指定的函数或代码块。\n非阻塞：它不会阻塞代码的执行，而是将回调函数加入到任务队列，待到时间到了再执行。\n不精确：实际执行时间可能晚于指定时间，因为JavaScript是单线程且执行环境是事件驱动的。\n应用场景：适合执行一次性、延迟执行的任务，例如用户操作后的反馈延迟显示、定时任务的启动等。\n\n\n\nsetInterval\n特点：\n周期性执行：按指定的时间间隔重复执行函数或代码块，直到被明确停止（通过clearInterval）。\n可能存在累积延迟：如果某个执行周期的代码执行时间超过了间隔时间，后续执行可能会被推迟，导致累积延迟。\n资源占用：如果间隔设置不合理或忘记清除，可能导致CPU占用过高、页面卡顿等问题。\n应用场景：适用于需要重复执行的定时任务，如实时更新时钟、轮播图自动切换等。\n\n\n\nrequestAnimationFrame\n特点：\n与重绘同步：它会在浏览器下一次重绘之前执行回调函数，确保动画与页面渲染同步，提供平滑的视觉效果。\n自动调整频率：根据设备的屏幕刷新率自动调整执行频率，一般接近60fps，有助于节省系统资源。\n暂停后台标签页：在非当前活动的标签页中，requestAnimationFrame会暂停执行，避免消耗不必要的计算资源。\n应用场景：特别适合于创建高性能的动画效果，如页面滚动、元素移动、CSS动画增强等，以达到流畅的用户体验。\n\n\n\nasync&#x2F;await的优势async/await 是现代JavaScript中处理异步操作的强有力工具，相比传统的回调函数和Promise，它带来了多方面的优势，使得异步编程变得更加简洁、直观和易于维护。以下是async/await的主要优点：\n1. 代码可读性和简洁性\n清晰的流程控制：通过使用类似于同步代码的编写方式，async/await极大地提高了代码的可读性和可维护性。开发者可以使用熟悉的顺序、条件和循环结构来组织异步逻辑，而不需要嵌套回调或复杂的Promise链。\n\n2. 错误处理的简化\n集中错误处理：使用try&#x2F;catch块可以直接在异步函数内部捕获错误，这种方式与同步代码中的错误处理一致，使得错误处理逻辑更加集中和易于理解。\n\n3. 更自然的异常传播\n自动Promise封装：async函数会自动将非Promise的返回值转换为resolved的Promise，并且任何未被捕获的异常都会被自动封装成一个rejected的Promise，这使得异常处理和Promise链的组合更加自然。\n\n4. 更少的回调地狱\n减少嵌套：避免了传统异步编程中常见的“回调地狱”现象，使得代码结构更加扁平，易于阅读和调试。\n\n5. 更好的代码调试体验\n步进执行：在支持的开发工具中，可以逐步执行async函数内的代码，包括跨await点，这使得调试异步代码就像调试同步代码一样直观。\n\n6. 易于理解和协作\n普遍易接受：对于新手和经验丰富的开发者而言，async/await模式都更加直观，减少了学习和团队协作的成本。\n\n7. 灵活性与兼容性\n与Promise兼容：虽然async/await是基于Promise实现的，但它本身并不排斥Promise的使用。在需要更复杂的异步控制流时，可以灵活地混合使用两者。\n\n对async&#x2F;await 的理解async 和 await 是 ES2017 引入的JavaScript关键字，用于简化基于Promise的异步编程，使得异步代码更加易于理解和维护。\nasync\n定义: async 是一个在函数声明前使用的修饰符，它标志着该函数是一个异步函数。\n返回值: 异步函数总是返回一个Promise。即使函数内部没有显式地返回Promise，函数也会隐式地将其非Promise返回值包装成一个 resolved 状态的Promise。\n错误处理: 如果异步函数内部抛出了一个错误，这个错误会被异步函数捕获并返回一个rejected状态的Promise。\n\nawait\n使用场景: await 关键字只能在 async 函数内部使用。\n作用: 让JavaScript引擎等待一个Promise的结果，即等待Promise resolve或reject，然后继续执行后面的代码。\n当 await 后面的Promise resolve时，await 表达式的值就是Promise的resolve值。\n如果Promise被reject，那么await表达式会抛出错误，可以使用try&#x2F;catch语句来捕获这个错误。\n\n\n非阻塞: 虽然await会让代码“等待”，但实际上它并不会阻塞其他任务的执行。JavaScript引擎会在这期间处理其他任务，只有当await的Promise完成时才会回到当前async函数继续执行。\n\n宏任务和微任务的区别宏任务（Macro Task）和微任务（Micro Task）是JavaScript中任务调度的一部分，用于处理异步操作。它们在事件循环（Event Loop）中起到不同的作用，影响了代码执行的顺序和性能。\n宏任务（Macro Task）宏任务是相对较大的任务，包括主代码块（全局脚本）、setTimeout、setInterval、I&#x2F;O操作、UI rendering等。每个宏任务在执行时会处理所有同步代码，以及在宏任务队列中排队等待的任务。\n微任务（Micro Task）微任务是相对较小的任务，通常用于处理比宏任务优先级更高的任务。微任务主要包括 Promise 的回调函数、MutationObserver 和 process.nextTick（Node.js 中）。微任务会在当前宏任务执行完后立即执行。\n事件循环（Event Loop）JavaScript 是单线程执行的，事件循环机制帮助管理异步操作的执行顺序。事件循环的基本步骤如下：\n\n执行一个宏任务（如果有的话）。\n执行所有的微任务（依次执行，直到微任务队列为空）。\n更新渲染（如果需要的话）。\n重复上述步骤。\n\n示例解释console.log(&#39;Start&#39;);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;Timeout&#39;);\n&#125;, 0);\n\nPromise.resolve().then(() &#x3D;&gt; &#123;\n  console.log(&#39;Promise&#39;);\n&#125;);\n\nconsole.log(&#39;End&#39;);\n\n执行顺序如下：\n\n首先执行同步代码：console.log(&#39;Start&#39;) 和 console.log(&#39;End&#39;)，输出为：\nStart\nEnd\n\n同步代码执行完后，事件循环开始处理微任务队列中的任务，即 Promise.resolve().then(...)，输出：\nPromise\n\n最后，事件循环处理宏任务队列中的任务，即 setTimeout 回调，输出：\nTimeout\n\n完整输出顺序为：\nStart\nEnd\nPromise\nTimeout\n\n总结\n宏任务 包括主代码块、setTimeout、setInterval、I&#x2F;O操作等，影响了异步操作的执行顺序。\n微任务 包括 Promise 的回调、MutationObserver、process.nextTick 等，具有比宏任务更高的优先级。\n事件循环 按顺序执行宏任务和微任务，保证异步代码按预期执行。\n\n理解宏任务和微任务有助于优化JavaScript代码的性能和预期行为。\nMVVM和MVC的区别MVC（Model-View-Controller）和 MVVM（Model-View-ViewModel）是两种常见的架构模式，用于分离应用程序的关注点，使代码更加模块化和可维护。尽管它们有相似之处，但它们在结构和数据绑定方面有显著的区别。\nMVC（Model-View-Controller）1. Model（模型）\n\n负责应用程序的业务逻辑和数据处理。\n与数据库交互，执行CRUD操作。\n通知视图更新数据。\n\n2. View（视图）\n\n负责展示数据给用户。\n从模型中获取数据，并将其呈现给用户。\n通常是被动的，只负责显示数据。\n\n3. Controller（控制器）\n\n负责处理用户输入和操作。\n将用户的输入转发给模型进行处理。\n更新视图以反映模型的变化。\n\n工作流程：\n用户在视图中触发一个事件（如点击按钮）。\n控制器捕获事件并处理它，可能会调用模型进行数据更新。\n模型更新数据后通知视图进行更新。\n视图从模型获取最新数据并重新渲染。\n\nMVVM（Model-View-ViewModel）1. Model（模型）\n\n与MVC中的模型类似，负责应用程序的业务逻辑和数据处理。\n\n2. View（视图）\n\n与MVC中的视图类似，负责展示数据给用户。\n通常绑定到ViewModel。\n\n3. ViewModel（视图模型）\n\n负责在视图和模型之间进行通信。\n包含表示视图数据的逻辑。\n通过双向数据绑定与视图进行交互，即视图的变化自动更新ViewModel，ViewModel的变化自动更新视图。\n\n工作流程：\n用户在视图中触发一个事件。\n事件通过数据绑定机制自动传递给ViewModel。\nViewModel处理事件，可能会调用模型进行数据更新。\n模型更新数据后，ViewModel接收并更新自身状态。\nViewModel的变化通过数据绑定自动更新视图。\n\n主要区别\n数据绑定\n\nMVC：通常是单向数据绑定，视图依赖于模型的通知来更新数据。\nMVVM：通常是双向数据绑定，视图和ViewModel之间自动同步数据变化。\n\n\n中介者角色\n\nMVC：控制器充当视图和模型之间的中介者。\nMVVM：ViewModel充当视图和模型之间的中介者，并处理视图的逻辑。\n\n\n关注点分离\n\nMVC：控制器包含视图的逻辑，有时导致视图逻辑分散在多个控制器中。\nMVVM：ViewModel包含视图的逻辑，使视图逻辑更集中，更容易测试。\n\n\n适用场景\n\nMVC：适用于传统的服务器端渲染应用程序，例如许多Web应用。\nMVVM：适用于现代前端框架，如Angular、React和Vue，它们有强大的数据绑定和组件系统。\n\n\n\n总结\nMVC 强调的是控制器的作用，通过控制器处理视图和模型之间的交互。\nMVVM 强调的是双向数据绑定，通过ViewModel来处理视图逻辑和模型数据的同步。\n\n这两种模式各有优缺点，选择使用哪种模式通常取决于应用的具体需求和开发团队的偏好。\n实现图片懒加载的方式有哪些图片懒加载是一种优化页面性能的技术，通过延迟加载页面中非可视区域的图片，减少初始加载时间和网络带宽消耗。实现图片懒加载的方式有多种，以下是一些常见的实现方法：\n1. 原生 loading 属性现代浏览器支持通过 loading 属性直接实现图片懒加载。\n&lt;img src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;example&quot; loading&#x3D;&quot;lazy&quot;&gt;\n\n2. 使用 Intersection Observer APIIntersection Observer API 是一种高效的观察元素是否在视口内的方式，适用于实现懒加载。\n&lt;img class&#x3D;&quot;lazy&quot; data-src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;example&quot;&gt;\n\n&lt;script&gt;\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;\n  const lazyImages &#x3D; document.querySelectorAll(&#39;img.lazy&#39;);\n\n  if (&#39;IntersectionObserver&#39; in window) &#123;\n    const lazyImageObserver &#x3D; new IntersectionObserver(function(entries, observer) &#123;\n      entries.forEach(function(entry) &#123;\n        if (entry.isIntersecting) &#123;\n          const lazyImage &#x3D; entry.target;\n          lazyImage.src &#x3D; lazyImage.dataset.src;\n          lazyImage.classList.remove(&#39;lazy&#39;);\n          lazyImageObserver.unobserve(lazyImage);\n        &#125;\n      &#125;);\n    &#125;);\n\n    lazyImages.forEach(function(lazyImage) &#123;\n      lazyImageObserver.observe(lazyImage);\n    &#125;);\n  &#125; else &#123;\n    &#x2F;&#x2F; Fallback for browsers that don&#39;t support IntersectionObserver\n    let lazyLoadThrottleTimeout;\n    function lazyLoad() &#123;\n      if (lazyLoadThrottleTimeout) &#123;\n        clearTimeout(lazyLoadThrottleTimeout);\n      &#125;    \n\n      lazyLoadThrottleTimeout &#x3D; setTimeout(function() &#123;\n        const scrollTop &#x3D; window.pageYOffset;\n        lazyImages.forEach(function(img) &#123;\n          if (img.offsetTop &lt; (window.innerHeight + scrollTop)) &#123;\n            img.src &#x3D; img.dataset.src;\n            img.classList.remove(&#39;lazy&#39;);\n          &#125;\n        &#125;);\n        if (lazyImages.length &#x3D;&#x3D;&#x3D; 0) &#123; \n          document.removeEventListener(&quot;scroll&quot;, lazyLoad);\n          window.removeEventListener(&quot;resize&quot;, lazyLoad);\n          window.removeEventListener(&quot;orientationChange&quot;, lazyLoad);\n        &#125;\n      &#125;, 20);\n    &#125;\n\n    document.addEventListener(&quot;scroll&quot;, lazyLoad);\n    window.addEventListener(&quot;resize&quot;, lazyLoad);\n    window.addEventListener(&quot;orientationChange&quot;, lazyLoad);\n  &#125;\n&#125;);\n&lt;&#x2F;script&gt;\n\n3. 使用第三方库一些第三方库提供了简便的懒加载实现，例如 lazysizes。\n使用 lazysizes&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;lazysizes&#x2F;5.2.2&#x2F;lazysizes.min.js&quot; async&gt;&lt;&#x2F;script&gt;\n&lt;img data-src&#x3D;&quot;image.jpg&quot; class&#x3D;&quot;lazyload&quot; alt&#x3D;&quot;example&quot;&gt;\n\n4. 监听滚动事件 (不推荐)直接监听滚动事件虽然也能实现懒加载，但性能较差，不推荐使用。\n&lt;img class&#x3D;&quot;lazy&quot; data-src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;example&quot;&gt;\n\n&lt;script&gt;\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;\n  const lazyImages &#x3D; document.querySelectorAll(&#39;img.lazy&#39;);\n  \n  function lazyLoad() &#123;\n    lazyImages.forEach(function(img) &#123;\n      if (img.getBoundingClientRect().top &lt; window.innerHeight) &#123;\n        img.src &#x3D; img.dataset.src;\n        img.classList.remove(&#39;lazy&#39;);\n      &#125;\n    &#125;);\n  &#125;\n\n  document.addEventListener(&#39;scroll&#39;, lazyLoad);\n&#125;);\n&lt;&#x2F;script&gt;\n\n5. 结合 React 和 React-Lazy-Load 库在 React 项目中，可以使用 react-lazy-load 库。\n使用 react-lazy-loadnpm install react-lazy-load\n\nimport React from &#39;react&#39;;\nimport LazyLoad from &#39;react-lazy-load&#39;;\n\nconst LazyImage &#x3D; () &#x3D;&gt; (\n  &lt;LazyLoad height&#x3D;&#123;200&#125; offsetVertical&#x3D;&#123;300&#125;&gt;\n    &lt;img src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;example&quot; &#x2F;&gt;\n  &lt;&#x2F;LazyLoad&gt;\n);\n\nexport default LazyImage;\n\n6. 使用 react-intersection-observer 库在 React 中也可以使用 react-intersection-observer 库来实现懒加载。\n使用 react-intersection-observernpm install react-intersection-observer\n\nimport React from &#39;react&#39;;\nimport &#123; useInView &#125; from &#39;react-intersection-observer&#39;;\n\nconst LazyImage &#x3D; () &#x3D;&gt; &#123;\n  const &#123; ref, inView &#125; &#x3D; useInView(&#123;\n    triggerOnce: true, &#x2F;&#x2F; 只触发一次\n    rootMargin: &#39;100px&#39;, &#x2F;&#x2F; 提前加载\n  &#125;);\n\n  return (\n    &lt;img\n      ref&#x3D;&#123;ref&#125;\n      src&#x3D;&#123;inView ? &#39;image.jpg&#39; : &#39;&#39;&#125;\n      alt&#x3D;&quot;example&quot;\n    &#x2F;&gt;\n  );\n&#125;;\n\nexport default LazyImage;\n\n总结实现图片懒加载有多种方法，选择合适的方法可以根据项目需求和浏览器支持情况。原生 loading 属性简单易用，Intersection Observer API 性能优越，第三方库提供了便捷的解决方案。在 React 项目中，可以使用相应的库来实现懒加载功能。\n用户访问页面白屏了，原因是啥，如何排查用户访问页面出现白屏的情况，可能是由多种原因导致的。排查这个问题需要逐步分析和调试，以下是一些常见原因及排查方法：\n常见原因\nJavaScript 错误\n\nJavaScript 执行时出错，阻止了页面的正常渲染。\n\n\n资源加载失败\n\n关键资源（如 CSS、JavaScript 文件、图片等）未能成功加载。\n\n\nHTML 结构问题\n\nHTML 结构错误或未正确加载，导致页面内容无法渲染。\n\n\n网络问题\n\n网络连接问题导致资源加载失败。\n\n\n权限问题\n\n资源受权限限制，导致无法加载。\n\n\n\n排查步骤\n检查浏览器控制台\n\n打开浏览器开发者工具（通常按 F12 或 Ctrl + Shift + I）。\n查看控制台（Console）中是否有报错信息。通常，JavaScript 错误会在控制台中显示，帮助定位问题。\n\n\n检查网络请求\n\n在开发者工具中，切换到“网络”标签页（Network）。\n刷新页面，查看是否有资源加载失败。注意 404（未找到）或 500（服务器错误）状态码的请求。\n检查资源加载时间，是否有请求超时或加载时间过长。\n\n\n查看 HTML 结构\n\n在开发者工具的“元素”标签页（Elements）中查看页面的 HTML 结构。\n确认 HTML 结构是否正确，是否有内容被渲染。\n\n\n查看 CSS 样式\n\n确认 CSS 文件是否加载成功。\n在“样式”标签页（Styles）中查看应用的 CSS 样式，确保样式正确应用且不会导致元素不可见（如 display: none 或 visibility: hidden）。\n\n\n禁用浏览器扩展\n\n某些浏览器扩展可能会干扰页面的正常加载。尝试禁用所有扩展后重新加载页面。\n\n\n查看服务器日志\n\n检查服务器日志，确认没有服务器端的错误。\n\n\n检查代码部署\n\n确认代码是否正确部署到服务器，版本是否正确。\n\n\n\n示例排查假设你在控制台中看到以下错误信息：\nUncaught SyntaxError: Unexpected token &#39;&lt;&#39;\n\n这种错误通常表明 JavaScript 文件未正确加载，可能是返回了 HTML 文件。接下来可以：\n\n在“网络”标签页中查看对应的 JavaScript 文件请求，确认其内容是否正确。\n确认服务器配置是否正确，确保 JavaScript 文件请求未被错误地重定向或返回 HTML 内容。\n\n进一步调试如果上述方法未能解决问题，可以尝试：\n\n在本地环境复现问题\n\n尝试在本地环境复现问题，便于调试和查看详细错误信息。\n\n\n使用断点调试\n\n在开发者工具中设置断点，逐步调试 JavaScript 代码，定位导致白屏的具体代码。\n\n\n回滚到上一个版本\n\n如果问题出现在最新版本，可以回滚到上一个版本，检查是否为最新更改引入的问题。\n\n\n\n预防措施\n错误捕获\n\n使用全局错误处理器捕获并记录未处理的错误，例如：\nwindow.addEventListener(&#39;error&#39;, function(event) &#123;\n  console.error(&#39;Error occurred:&#39;, event.message, event.filename, event.lineno, event.colno);\n&#125;);\n\nwindow.addEventListener(&#39;unhandledrejection&#39;, function(event) &#123;\n  console.error(&#39;Unhandled rejection:&#39;, event.reason);\n&#125;);\n\n\n测试覆盖\n\n编写单元测试和集成测试，确保代码变更不会引入新的问题。\n\n\n日志记录\n\n在关键代码位置添加日志，帮助定位和分析问题。\n\n\n\n通过以上方法，可以逐步排查和解决用户访问页面出现白屏的问题。\n组件封装的基本原则是什么组件封装的基本原则是为了提高代码的复用性、可维护性和可测试性。以下是组件封装的基本原则：\n\n单一职责原则 (Single Responsibility Principle)\n\n组件应该专注于单一功能或责任，而不是包含过多的功能。这样可以使组件更加清晰、易于理解和维护。\n\n\n高内聚低耦合 (High Cohesion, Low Coupling)\n\n高内聚指组件内部各部分的功能相关性强，低耦合指组件与其他组件之间的依赖关系尽量降低。这样可以提高组件的独立性和灵活性，使其易于替换、修改和测试。\n\n\n可配置性 (Configurability)\n\n组件应该具有一定的可配置性，允许用户通过配置参数来定制组件的行为和外观。这样可以增强组件的灵活性和适用性。\n\n\n接口清晰明确 (Clear and Explicit Interfaces)\n\n组件的接口应该清晰明确，包括输入参数、输出结果和事件回调等。这样可以使组件的使用方式清晰可见，降低误用的可能性。\n\n\n可扩展性 (Extensibility)\n\n组件应该具有一定的可扩展性，允许在不修改核心代码的情况下进行功能扩展。这可以通过插件机制、钩子函数等方式实现。\n\n\n适应性 (Adaptability)\n\n组件应该具有一定的适应性，能够适应不同的使用场景和环境。这可以通过响应式设计、自适应布局等方式实现。\n\n\n易用性 (Usability)\n\n组件应该易于使用，提供良好的文档和示例，并且具有良好的用户体验。这可以通过良好的设计、交互效果和反馈等方式实现。\n\n\n可测试性 (Testability)\n\n组件应该易于测试，具有良好的测试覆盖率和测试可用性。这可以通过模块化设计、依赖注入、单元测试等方式实现。\n\n\n\n总体而言，组件封装的基本原则是为了提高代码的质量、可维护性和可重用性，使得组件能够在各种场景下被广泛应用，并且能够快速、安全地进行修改和扩展。\njs的设计模式都有哪些并简单举例JavaScript设计模式是面向对象编程中重复出现的解决方案，它可以帮助开发者编写更清晰、可维护和可扩展的代码。以下是JavaScript中常见的几种设计模式，以及每个模式的简要说明和一个简单的例子：\n1. 单例模式 (Singleton)目的：确保一个类只有一个实例，并提供一个全局访问点。例子：\nlet Singleton &#x3D; (function () &#123;\n    let instance;\n    \n    function createInstance() &#123;\n        return &#123;\n            someMethod: function () &#123;\n                console.log(&quot;Singleton instance method called.&quot;);\n            &#125;\n        &#125;;\n    &#125;\n    \n    return &#123;\n        getInstance: function () &#123;\n            if (!instance) &#123;\n                instance &#x3D; createInstance();\n            &#125;\n            return instance;\n        &#125;\n    &#125;;\n&#125;)();\n\nlet instance1 &#x3D; Singleton.getInstance();\nlet instance2 &#x3D; Singleton.getInstance();\n\nconsole.log(instance1 &#x3D;&#x3D;&#x3D; instance2); &#x2F;&#x2F; true，证明是同一个实例\n\n2. 工厂模式 (Factory)目的：隐藏创建对象的具体逻辑，让对象的创建过程和使用过程分离。例子：\nfunction createPerson(type) &#123;\n    switch (type) &#123;\n        case &#39;student&#39;:\n            return new Student();\n        case &#39;teacher&#39;:\n            return new Teacher();\n        default:\n            throw new Error(&#39;Invalid type&#39;);\n    &#125;\n&#125;\n\nfunction Student() &#123;\n    this.sayRole &#x3D; function() &#123;\n        console.log(&#39;I am a student.&#39;);\n    &#125;;\n&#125;\n\nfunction Teacher() &#123;\n    this.sayRole &#x3D; function() &#123;\n        console.log(&#39;I am a teacher.&#39;);\n    &#125;;\n&#125;\n\nlet person &#x3D; createPerson(&#39;student&#39;);\nperson.sayRole(); &#x2F;&#x2F; 输出: I am a student.\n\n3. 观察者模式 (Observer)目的：定义对象间的一种一对多依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。例子：\nclass Subject &#123;\n    constructor() &#123;\n        this.observers &#x3D; [];\n    &#125;\n    \n    addObserver(observer) &#123;\n        this.observers.push(observer);\n    &#125;\n    \n    removeObserver(observer) &#123;\n        this.observers &#x3D; this.observers.filter(obs &#x3D;&gt; obs !&#x3D;&#x3D; observer);\n    &#125;\n    \n    notify(data) &#123;\n        this.observers.forEach(observer &#x3D;&gt; observer.update(data));\n    &#125;\n&#125;\n\nclass Observer &#123;\n    update(data) &#123;\n        console.log(&#96;Received data: $&#123;data&#125;&#96;);\n    &#125;\n&#125;\n\nlet subject &#x3D; new Subject();\nlet observer1 &#x3D; new Observer();\nlet observer2 &#x3D; new Observer();\n\nsubject.addObserver(observer1);\nsubject.addObserver(observer2);\n\nsubject.notify(&#39;Hello World!&#39;); &#x2F;&#x2F; observer1 和 observer2 都会接收到通知\n\n4. 装饰器模式 (Decorator)目的：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更为灵活。例子：\nfunction logDecorator(targetFunction) &#123;\n    return function(...args) &#123;\n        console.log(&#96;Calling $&#123;targetFunction.name&#125; with arguments:&#96;, args);\n        let result &#x3D; targetFunction.apply(this, args);\n        console.log(&#96;Returned from $&#123;targetFunction.name&#125;:&#96;, result);\n        return result;\n    &#125;;\n&#125;\n\nfunction add(a, b) &#123;\n    return a + b;\n&#125;\n\nadd &#x3D; logDecorator(add);\n\nconsole.log(add(2, 3)); &#x2F;&#x2F; 会打印调用和返回的日志\n\n5. 模块模式 (Module)目的：为了解决命名空间污染和封装私有变量及方法。例子：\nvar module &#x3D; (function () &#123;\n    var privateVar &#x3D; &quot;Hello, I&#39;m private!&quot;;\n    \n    function privateMethod() &#123;\n        console.log(privateVar);\n    &#125;\n    \n    return &#123;\n        publicMethod: function() &#123;\n            privateMethod();\n        &#125;\n    &#125;;\n&#125;)();\n\nmodule.publicMethod(); &#x2F;&#x2F; 输出: Hello, I&#39;m private!\n\n这只是JavaScript设计模式中的冰山一角，其他还包括但不限于策略模式、代理模式、适配器模式、建造者模式、原型模式、命令模式等。每种模式都有其适用场景，理解并合理运用这些模式可以极大地提升代码的结构和质量。当然，JavaScript设计模式非常丰富，除了之前提到的那些，这里再列举一些其他重要且常用的设计模式及其简短示例：\n6. 策略模式 (Strategy)目的：定义一系列算法，将每一个算法封装起来，并使它们可以相互替换，让算法独立于使用它的客户。例子：\nfunction Strategy(context) &#123;\n    this.execute &#x3D; function() &#123;\n        console.log(&#39;Default strategy execution&#39;);\n    &#125;;\n&#125;\n\nfunction ConcreteStrategyA() &#123;\n    Strategy.call(this);\n    this.execute &#x3D; function() &#123;\n        console.log(&#39;ConcreteStrategyA execution&#39;);\n    &#125;;\n&#125;\n\nConcreteStrategyA.prototype &#x3D; Object.create(Strategy.prototype);\n\nfunction ConcreteStrategyB() &#123;\n    Strategy.call(this);\n    this.execute &#x3D; function() &#123;\n        console.log(&#39;ConcreteStrategyB execution&#39;);\n    &#125;;\n&#125;\n\nConcreteStrategyB.prototype &#x3D; Object.create(Strategy.prototype);\n\nfunction Context(strategy) &#123;\n    this.strategy &#x3D; strategy;\n    this.executeStrategy &#x3D; function() &#123;\n        this.strategy.execute();\n    &#125;;\n&#125;\n\nlet context &#x3D; new Context(new ConcreteStrategyA());\ncontext.executeStrategy(); &#x2F;&#x2F; 输出: ConcreteStrategyA execution\n\ncontext.strategy &#x3D; new ConcreteStrategyB();\ncontext.executeStrategy(); &#x2F;&#x2F; 输出: ConcreteStrategyB execution\n\n7. 代理模式 (Proxy)目的：为另一个对象提供一个替身或占位符，以控制对这个对象的访问。例子：\nfunction ExpensiveObject() &#123;\n    this.processData &#x3D; function(data) &#123;\n        console.log(&#39;Expensive object processing data:&#39;, data);\n    &#125;;\n&#125;\n\nfunction ProxyObject() &#123;\n    this.realObject &#x3D; null;\n\n    this.processData &#x3D; function(data) &#123;\n        if (!this.realObject) &#123;\n            this.realObject &#x3D; new ExpensiveObject();\n        &#125;\n        this.realObject.processData(data);\n    &#125;;\n&#125;\n\nlet proxy &#x3D; new ProxyObject();\nproxy.processData(&#39;some data&#39;); &#x2F;&#x2F; 在第一次调用时创建 ExpensiveObject\nproxy.processData(&#39;more data&#39;); &#x2F;&#x2F; 使用已创建的 ExpensiveObject\n\n8. 迭代器模式 (Iterator)目的：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。例子：\nclass Collection &#123;\n    constructor() &#123;\n        this.items &#x3D; [];\n    &#125;\n\n    addItem(item) &#123;\n        this.items.push(item);\n    &#125;\n\n    [Symbol.iterator]() &#123;\n        let index &#x3D; 0;\n        return &#123;\n            next: () &#x3D;&gt; &#123;\n                if (index &lt; this.items.length) &#123;\n                    return &#123; value: this.items[index++], done: false &#125;;\n                &#125; else &#123;\n                    return &#123; done: true &#125;;\n                &#125;\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\nlet collection &#x3D; new Collection();\ncollection.addItem(&#39;a&#39;);\ncollection.addItem(&#39;b&#39;);\ncollection.addItem(&#39;c&#39;);\n\nfor (let item of collection) &#123;\n    console.log(item); &#x2F;&#x2F; 输出: a, b, c\n&#125;\n\n9. 适配器模式 (Adapter)目的：将一个类的接口转换成客户期望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。例子:\nclass EuropeanSocket &#123;\n    voltage() &#123;\n        return 230;\n    &#125;\n&#125;\n\nclass USASocket &#123;\n    voltage() &#123;\n        return 120;\n    &#125;\n&#125;\n\nclass Adapter &#123;\n    constructor(socket) &#123;\n        this.socket &#x3D; socket;\n    &#125;\n\n    voltage() &#123;\n        return this.socket.voltage() &#x2F; 2;\n    &#125;\n&#125;\n\nlet europeanSocket &#x3D; new EuropeanSocket();\nlet adapter &#x3D; new Adapter(europeanSocket);\nconsole.log(adapter.voltage()); &#x2F;&#x2F; 输出: 115，适配欧洲插座电压到美国标准\n\n10. 备忘录模式 (Memento)目的：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态。例子:\nclass EditorState &#123;\n    constructor(content) &#123;\n        this.content &#x3D; content;\n    &#125;\n&#125;\n\nclass Editor &#123;\n    constructor() &#123;\n        this.history &#x3D; [];\n        this.content &#x3D; &#39;&#39;;\n    &#125;\n\n    type(content) &#123;\n        this.content +&#x3D; content;\n        this.history.push(new EditorState(this.content));\n    &#125;\n\n    undo() &#123;\n        if (this.history.length &gt; 0) &#123;\n            let prevState &#x3D; this.history.pop();\n            this.content &#x3D; prevState.content;\n        &#125;\n    &#125;\n&#125;\n\nlet editor &#x3D; new Editor();\neditor.type(&quot;Hello, &quot;);\neditor.type(&quot;world!&quot;);\nconsole.log(editor.content); &#x2F;&#x2F; 输出: Hello, world!\neditor.undo();\nconsole.log(editor.content); &#x2F;&#x2F; 输出: Hello, \n\n以上只是继续列举了一些设计模式的例子，JavaScript设计模式种类繁多，每种模式都有其独特应用场景，掌握它们能显著提升开发效率和代码质量。\nTree Shaking工作原理Tree shaking 是一种用于移除 JavaScript 中未使用代码的优化技术，通常应用于模块化的代码库，比如 ES6 模块（ESM）。其核心原理是通过静态分析代码的模块依赖关系，识别并移除那些在应用中没有实际使用到的代码，从而减少打包后的文件大小，提高加载和运行的性能。\nTree Shaking 的原理\n静态分析：\n\nTree shaking 基于静态分析代码的导入和导出（import&#x2F;export）语句来确定哪些代码是未使用的。因为 ES6 模块的 import&#x2F;export 是静态的，所以在编译时可以准确地进行分析。\n\n\n标记（Marking）：\n\n编译器首先标记所有导出的模块和函数。\n然后，编译器会从入口模块开始，递归地追踪所有被使用的导出，标记它们为“已使用”。\n\n\n删除（Elimination）：\n\n在标记过程中未被标记为“已使用”的代码会被认为是未使用的。\n最后，编译器会移除这些未使用的代码。\n\n\n\n示例代码假设我们有以下两个模块：\nmath.js：\nexport function add(a, b) &#123;\n  return a + b;\n&#125;\n\nexport function subtract(a, b) &#123;\n  return a - b;\n&#125;\n\nmain.js：\nimport &#123; add &#125; from &#39;.&#x2F;math.js&#39;;\n\nconsole.log(add(2, 3));\n\n在这个例子中，subtract 函数没有被使用，因此在 tree shaking 过程中会被移除。\nTree Shaking 在 Webpack 中的实现Webpack 是一个流行的打包工具，它通过使用 Terser（一个 JavaScript 压缩工具）来实现 tree shaking。以下是一个简单的 Webpack 配置示例：\nwebpack.config.js：\nconst path &#x3D; require(&#39;path&#39;);\n\nmodule.exports &#x3D; &#123;\n  entry: &#39;.&#x2F;src&#x2F;main.js&#39;,\n  output: &#123;\n    filename: &#39;bundle.js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;),\n  &#125;,\n  mode: &#39;production&#39;, &#x2F;&#x2F; Tree shaking 在生产模式下启用\n  optimization: &#123;\n    usedExports: true, &#x2F;&#x2F; 启用 tree shaking\n  &#125;,\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;\\.js$&#x2F;,\n        exclude: &#x2F;node_modules&#x2F;,\n        use: &#123;\n          loader: &#39;babel-loader&#39;,\n          options: &#123;\n            presets: [&#39;@babel&#x2F;preset-env&#39;],\n          &#125;,\n        &#125;,\n      &#125;,\n    ],\n  &#125;,\n&#125;;\n\nTree Shaking 的局限性和挑战\n动态引入：\n\n由于 tree shaking 依赖于静态分析，动态引入的代码（如 require() 语句或 import() 函数）可能无法被正确地分析和处理。\n\n\n副作用：\n\n某些模块在导入时会有副作用，比如在导入时立即执行某些代码。如果编译器无法确定这些副作用，它可能会保留整个模块。\n\n\n命名空间导入：\n\n使用命名空间导入（如 import * as math from &#39;./math&#39;）时，所有导出的内容都会被视为已使用，导致 tree shaking 无法移除未使用的代码。\n\n\n\n解决副作用的问题为了帮助编译器更好地进行 tree shaking，开发者可以在 package.json 中使用 sideEffects 字段来声明模块是否有副作用：\npackage.json：\n&#123;\n  &quot;name&quot;: &quot;my-package&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;sideEffects&quot;: false\n&#125;\n\n如果某些文件确实有副作用，可以显式列出：\n&#123;\n  &quot;name&quot;: &quot;my-package&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;sideEffects&quot;: [\n    &quot;.&#x2F;src&#x2F;some-side-effect-file.js&quot;\n  ]\n&#125;\n\n总结Tree shaking 是通过静态分析代码的导入和导出来确定哪些代码是未使用的，并在打包过程中移除这些未使用的代码。它可以显著减少打包后的文件大小，提高应用的性能。然而，它也有一些局限性，如处理动态引入和副作用代码时的挑战。通过合理地使用工具和配置，可以最大限度地利用 tree shaking 的优势。\nJS Bridge是什么JS Bridge（JavaScript Bridge）是一种用于在不同的编程环境之间建立通信的技术，通常用于移动应用开发中，使 JavaScript 代码与原生代码（例如 Android 和 iOS 代码）进行互操作。JS Bridge 在混合应用（Hybrid App）和跨平台开发框架（如 React Native、Cordova 等）中非常常见。\nJS Bridge 的主要用途\n混合应用开发：在混合应用中，部分功能使用网页技术（HTML、CSS、JavaScript）实现，部分功能使用原生代码实现。JS Bridge 允许 JavaScript 与原生代码相互调用，使得应用可以同时利用网页和原生技术的优势。\n\n跨平台框架：在 React Native 或其他跨平台框架中，JS Bridge 用于在 JavaScript 运行时（如 React Native 的 JavaScriptCore 或 V8）与原生平台（Android 或 iOS）之间传递数据和指令。\n\n\n工作原理JS Bridge 的基本工作原理是通过消息传递机制在 JavaScript 和原生代码之间进行通信。以下是基本的实现步骤：\n\nJavaScript 调用原生代码：\n\nJavaScript 通过特定的接口（如 window 对象上的方法或特定的全局对象）发送消息。\n原生代码监听这些消息并根据需要执行相应的原生功能。\n原生代码可以返回执行结果给 JavaScript。\n\n\n原生代码调用 JavaScript：\n\n原生代码通过特定的接口向 JavaScript 发送消息。\nJavaScript 监听这些消息并执行相应的操作。\nJavaScript 可以返回执行结果给原生代码。\n\n\n\n示例：React Native 中的 JS Bridge在 React Native 中，JS Bridge 通过 Native Modules 实现。以下是一个简单的例子，展示如何创建一个原生模块，并通过 JS Bridge 从 JavaScript 调用原生代码。\n1. 创建原生模块（Android）Java代码（Android）：\n&#x2F;&#x2F; MyNativeModule.java\npackage com.myapp;\n\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.bridge.Callback;\n\npublic class MyNativeModule extends ReactContextBaseJavaModule &#123;\n\n    MyNativeModule(ReactApplicationContext context) &#123;\n        super(context);\n    &#125;\n\n    @Override\n    public String getName() &#123;\n        return &quot;MyNativeModule&quot;;\n    &#125;\n\n    @ReactMethod\n    public void showToast(String message) &#123;\n        Toast.makeText(getReactApplicationContext(), message, Toast.LENGTH_SHORT).show();\n    &#125;\n&#125;\n\n注册模块（Android）：\n&#x2F;&#x2F; MyAppPackage.java\npackage com.myapp;\n\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.uimanager.ViewManager;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MyAppPackage implements ReactPackage &#123;\n\n    @Override\n    public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123;\n        List&lt;NativeModule&gt; modules &#x3D; new ArrayList&lt;&gt;();\n        modules.add(new MyNativeModule(reactContext));\n        return modules;\n    &#125;\n\n    @Override\n    public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123;\n        return Collections.emptyList();\n    &#125;\n&#125;\n\n配置（Android）：\n&#x2F;&#x2F; MainApplication.java\nimport com.myapp.MyAppPackage;\n\n@Override\nprotected List&lt;ReactPackage&gt; getPackages() &#123;\n  return Arrays.&lt;ReactPackage&gt;asList(\n      new MainReactPackage(),\n      new MyAppPackage() &#x2F;&#x2F; Add this line\n  );\n&#125;\n\n2. JavaScript 调用原生模块JavaScript 代码：\n&#x2F;&#x2F; App.js\nimport React from &#39;react&#39;;\nimport &#123; NativeModules, Button, View &#125; from &#39;react-native&#39;;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n  const showToast &#x3D; () &#x3D;&gt; &#123;\n    NativeModules.MyNativeModule.showToast(&#39;Hello from JavaScript!&#39;);\n  &#125;;\n\n  return (\n    &lt;View&gt;\n      &lt;Button title&#x3D;&quot;Show Toast&quot; onPress&#x3D;&#123;showToast&#125; &#x2F;&gt;\n    &lt;&#x2F;View&gt;\n  );\n&#125;;\n\nexport default App;\n\nJS Bridge 的优点和挑战优点\n灵活性：允许开发者在应用中同时使用 JavaScript 和原生代码，实现高性能的功能和良好的用户体验。\n代码复用：通过 JS Bridge，可以在多个平台上复用相同的业务逻辑代码，减少开发和维护成本。\n\n挑战\n复杂性：处理 JavaScript 和原生代码之间的通信和数据传递可能比较复杂，尤其是在处理异步操作和错误处理时。\n性能问题：频繁的跨语言调用可能会引入性能开销，需要仔细优化和管理。\n调试困难：由于涉及多个环境和语言，调试 JS Bridge 通信问题可能比纯 JavaScript 或纯原生代码更具挑战性。\n\n总结JS Bridge 是一种在 JavaScript 和原生代码之间建立通信桥梁的技术，广泛应用于混合应用和跨平台开发中。通过了解其工作原理和应用场景，开发者可以更好地利用这一技术，实现高性能、跨平台的应用。\n当然，让我们通过实例来分别说明高阶函数、函数柯里化、回流与重绘，以及Webpack的构建流程。\n高阶函数和函数柯里化的区别高阶函数示例假设我们要创建一个函数，该函数接收一个函数logger作为参数，并在调用时打印一条消息后执行该函数。\nfunction logAndExecute(func) &#123;\n  console.log(&#39;Executing function...&#39;);\n  return func();\n&#125;\n\nfunction sayHello() &#123;\n  console.log(&#39;Hello, world!&#39;);\n&#125;\n\nlogAndExecute(sayHello); &#x2F;&#x2F; 输出: Executing function... \\n Hello, world!\n在这个例子中，logAndExecute是一个高阶函数，因为它接收另一个函数sayHello作为参数，并执行它。\n函数柯里化示例考虑一个计算两个数之和的函数，我们将其柯里化：\nfunction add(a) &#123;\n  return function(b) &#123;\n    return a + b;\n  &#125;;\n&#125;\n\nconst addFive &#x3D; add(5);\nconsole.log(addFive(3)); &#x2F;&#x2F; 输出: 8\n这里，add函数被柯里化，首先调用add(5)返回一个新的函数，该函数等待第二个参数b，当调用addFive(3)时，计算并返回两数之和。\n","slug":"interview-javascript","date":"2024-05-30T14:58:24.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"22d898182469a084004dd0b5135b46c1","title":"interview-css","content":"CSSCSS选择器及其优先级\n内联样式：直接在HTML元素上使用style属性定义的样式具有最高优先级，权值为1000。\nID选择器：形如#idName的选择器，权值为100。\n类选择器、属性选择器、伪类选择器：包括.className、[attribute&#x3D;value]和:hover等，权值均为10。\n标签选择器、伪元素选择器：如div、:before、:after等，权值为1。\n\nCSS中可继承与不可继承属性有哪些\n可继承的属性（通常会影响到文档的文本内容和外观）\n字体系列属性\n文本系列属性\n元素可见性\n\n\n不可继承的属性（通常影响元素的盒模型、布局或绝对定位）\n盒模型属性\n背景属性\n定位属性\n显示属性\n宽高属性\n\n\n\ndisplay的属性值及其作用\nblock\n元素会作为一个块级元素显示，独占一行，可以设置宽度、高度以及内外边距。这是大多数块级元素的默认display值。\n\n\ninline\n元素作为行内元素显示，与其他行内元素在同一行显示，宽度和高度由内容决定，不能直接设置，但可以设置水平内外边距，垂直只有外边距有效。\n\n\ninline-block\n兼具行内元素和块级元素的特点，即可以和其他行内元素同行显示，同时也能设定宽度、高度以及所有四个方向的内外边距。\n\n\nnone\n元素不会被显示，并且不会占据任何空间，连同它原来的位置也会被忽略。\n\n\nlist-item\n元素会作为一个列表项显示，类似于元素，会生成一个标记（通常是项目符号），并且像块级元素一样独占一行。\n\n\nflex\n将元素变为一个弹性容器，其子元素会按照弹性布局的规则排列，适合创建响应式和动态布局。\n\n\ngrid\n将元素变为一个网格容器，子元素按照网格布局排列，适合构建二维布局系统。\n\n\ninherit:\n元素的display值继承自其父元素。\n\n\n\n隐藏元素的方法有哪些\ndisplay: none;\n作用: 完全从页面流中移除元素，不占据任何空间，也不会触发重排或重绘。元素变得不可见且无法与用户交互。\n\n\nvisibility: hidden;\n作用: 元素隐藏但仍占据原来的空间，影响布局流。元素不可见，不触发重排但可能触发重绘，且不能与用户交互。\n\n\nopacity: 0;\n作用: 通过设置透明度为0使元素不可见，元素仍占据页面空间并参与布局，可以与用户交互（如点击事件可能穿透到下面的元素）。\n\n\nheight: 0; width: 0; overflow: hidden;\n作用: 通过将元素尺寸缩小至0并隐藏溢出内容来隐藏元素，元素仍存在于页面流中，但视觉上不可见。\n\n\nposition: absolute; left: -9999px; (或其他远离屏幕位置)\n作用: 将元素移出可视窗口，使其在屏幕上不可见，但依然保持在文档流中，可能会影响布局。\n\n\nclip-path: inset(100%);\n作用: 使用剪裁路径将元素完全剪裁掉，元素依然占据空间，但内容不可见。\n\n\ntransform: scale(0);\n作用: 通过缩放变换将元素缩小到0，使其不可见，但元素仍保留其在布局中的空间。\n\n\n\nCSS 优化和提高性能的方法有哪些？减少CSS文件大小:\n优化加载性能:\n避免重排和重绘:\n选择器优化:\n模块化CSS: 将CSS分解为可管理的模块或组件，便于维护和复用。\nSass、Less 是什么？为什么要使用他们？Sass和Less是CSS预处理器，它们扩展了CSS的功能，引入变量、嵌套、混合、函数等特性，使得样式代码更易读、更模块化、更易于维护。\nz-index属性在什么情况下会失效\n父元素的 position 不是 absolute 或 fixed。\n元素本身未设置 position: relative, absolute, 或 fixed。\n元素应用了浮动（float）样式，可能需要清除浮动或改用其他布局方式。\n\n常见的CSS布局单位\n像素 (px)：绝对单位，用于精确控制元素尺寸和位置。\n百分比 (%)：相对单位，基于父元素的尺寸进行计算，适用于响应式设计。\nem：相对单位，等于当前字体大小，常用于字体大小和响应式布局调整。\nrem：相对单位，基于根元素（通常是）的字体大小，适用于全局样式调整和响应式设计。\n视窗单位 (vw, vh, vmin, vmax)：视口相关的单位，vw代表视口宽度的1%，vh代表视口高度的1%，适应窗口大小变化。\n\n为什么需要清除浮动？清除浮动的方式\n高度塌陷：当一个容器内的所有子元素都设置了浮动，这些子元素会脱离容器，使得容器高度计算为0，表现为容器没有包围住浮动的子元素，这就是所谓的“高度塌陷”。\n影响后续元素布局：浮动元素不占用原来的位置，可能导致后面的非浮动元素提前显示在其之前，影响页面布局。\n\n可以采用以下几种清除浮动的方式：\n\n父级添加overflow属性：给包含浮动元素的父级容器设置overflow:hidden或overflow:auto，这可以触发BFC（块格式化上下文），从而自动包含浮动的子元素，解决高度塌陷问题。\n使用伪元素：在浮动元素的父容器上应用:after伪元素，并设置内容为一个空白字符（如content: &#39;&#39;;），同时指定display:block和clear:both，这样既不需要额外的HTML标签也能清除浮动。\nCSS Flexbox或Grid布局：使用现代布局方式如Flexbox（display:flex）或Grid（display:grid），它们天然支持子元素对齐，通常不需要手动清除浮动。\n\n对BFC的理解，如何创建BFCBFC（Block Formatting Context，块级格式化上下文）是Web页面布局中的一个核心概念，它定义了一个独立的渲染区域，内部的元素布局不会影响外部，同样外部元素也不会影响内部。这意味着BFC可以用来防止外边距折叠、包含浮动元素、防止某些类型的重叠等布局问题。\n创建BFC有多种方式，以下是一些常见的方法：\n\n浮动元素：给元素设置 float 属性为 left 或 right。\n绝对定位：将元素的 osition 设置为 absolute 或 fixed。\n显示类型改变：将元素的 display 属性设置为 inline-block、flex\n溢出设置：给元素设置 overflow 为 hidden、auto 或 scroll\n\n什么是margin重叠问题？如何解决？Margin重叠，是指在CSS布局中，当两个或多个垂直相邻的块级元素的外边距相遇时，并不是简单地相加，而是会合并成一个较大的外边距。\n解决Margin重叠问题的方法有以下几种：\n\n使用BFC（块格式化上下文）：为发生Margin重叠的元素创建一个新的BFC，可以防止外边距重叠。可以通过设置 overflow: auto 或 overflow: hidden、display: flow-root、float: left 或 right、position: absolute 或 fixed等属性来实现。\n添加透明边框：给元素添加一个非常小的透明边框（例如 border-top: 1px solid transparent），可以阻止与其上方元素的外边距重叠。\n使用padding或height：为元素添加一个非零的padding或明确设置height，即使是很小的值，也可以阻止外边距重叠，因为此时元素有了实际的内容区域。\n使用负margin：在某些情况下，可以通过为一个元素设置负的外边距来补偿由于重叠造成的空间缺失，但这要求对布局有精确的控制并可能导致其他布局问题。\n结构调整：在DOM结构中插入一个空的块级元素，并为这个新元素清除浮动或设置适当的外边距，以物理分隔原本会发生重叠的元素。\n\nposition的属性有哪些，区别是什么\nstatic：元素按照正常文档流排列，忽略top, bottom, left, right属性。\nrelative：元素相对于其正常位置（在文档流中的位置）进行定位，不影响其他元素布局，仍保留原空间。\nabsolute：元素相对于最近的非static定位的祖先元素定位，完全脱离文档流，不保留原空间。\nfixed：元素相对于浏览器窗口定位，不随滚动条滚动，完全脱离文档流。\nsticky：根据用户的滚动位置，在达到特定阈值时，表现为相对定位与固定定位之间切换，部分浏览器支持。\n\n伪元素和伪类的区别和作用？\n伪类（Pseudo-Classes）\n作用：伪类主要用于选择元素基于状态或位置的特定部分，比如元素的:hover状态，表示当鼠标悬停在元素上时的样式。\n特点：伪类不创造新的元素，而是选择已有元素的特定状态。\n示例：:hover, :active, :first-child等。\n\n\n伪元素（Pseudo-Elements）：\n作用：伪元素用于在文档树中插入新的内容或选择元素的特定部分，比如为一个元素添加前缀或后缀内容。\n特点：伪元素创建了文档树中不存在的虚拟元素，用于装饰或内容插入，如:before和:after用来插入内容。\n示例：::before, ::after等。\n\n\n\n对盒模型的理解CSS盒模型是网页设计中的一个核心概念，用于描述元素在页面布局中占用空间的方式。它将每个HTML元素视为一个矩形盒子，这个盒子由四个部分组成：\n\n内容区域（Content）：盒子的核心部分，包含元素的实际内容，如文本、图片等。内容区域的大小由width和height属性定义。\n\n内边距（Padding）：围绕在内容区域外部的空白区域，可以设置背景颜色或图片。内边距不影响盒子与其他元素的距离，仅增加盒子的可见大小。\n\n边框（Border）：紧挨内边距外部，可以设置宽度、样式和颜色，界定盒子的界限。\n\n外边距（Margin）：位于边框外部，是透明的，用来定义元素与其他元素之间的距离，不影响盒子背景色。\n\n\n盒模型有两种布局方式：\n\n标准盒模型（W3C盒模型）：宽度和高度只包含内容区域，边框和内边距会额外增加盒子的总宽度和高度。\n怪异盒模型（IE盒模型）：宽度和高度包含内容、内边距和边框，使用box-sizing: border-box;可以启用这种模式。\n\n画一条0.5px的线.thin-line &#123;\n    border-top: 1px solid rgba(0, 0, 0, 0.5); \n    transform: scaleY(0.5); \n&#125;\n\n如何解决 1px 问题？.hairline &#123;\n    border: 1px solid #000;\n    transform: scale(0.5);\n    transform-origin: left top;\n&#125;\n\n实现一个三角形.triangle-down &#123;\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid black;\n&#125;\n回流与重绘假设你有一个网页，其中包含一个按钮，当你点击按钮时，会修改一个&lt;div&gt;元素的宽度。\n\n重绘：如果只是修改了&lt;div&gt;的背景色，这将触发重绘，因为元素的布局未变，只是外观变了。\n回流：如果你修改了&lt;div&gt;的宽度，导致周围元素的位置也发生变化，这时不仅需要重绘元素的颜色或背景，还需要重新计算布局，这就触发了回流。\n\n","slug":"interview-css","date":"2024-05-30T14:57:57.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"3aa405af8114bdbedccc4d79b50ad9ac","title":"interview-html","content":"HTMLsrc和href的区别\n用途不同  src（Source 的缩写）用于嵌入外部资源到当前文档中。这些资源是文档结构或功能的一部分，浏览器会暂停页面渲染来加载这些资源，并将其内容直接插入到文档中相应的位置。href（Hypertext Reference 的缩写）用于定义一个超链接到其他文档或资源的链接\n引用方式和必要性\nsrc 引用的资源对于元素是必需的，缺少 src 属性或其值无效，会导致元素无法正常显示或工作。\nhref 引用的资源在某些情况下可能是可选的，例如对于装饰性链接，即使没有 href 或其值为空，链接依然可以呈现并具有交互样式，尽管没有实际的跳转效果\n\n\n\nscript标签中defer和async的区别\ndefer属性:\n脚本的加载是异步的，不会阻塞页面的渲染。\n所有带有defer属性的脚本会在HTML解析完成后，DOMContentLoaded事件触发之前，按照在文档中出现的顺序依次执行。\n适合那些不依赖文档中其他元素且执行顺序重要的脚本。\n\n\nasync属性:\n脚本的加载也是异步的，同样不会阻塞页面渲染。\n加载完成后，脚本会立即执行，不保证执行顺序，也不保证与HTML解析的顺序一致。\n适用于不需要按照特定顺序执行且不会影响DOM构建的独立脚本，比如分析脚本或延迟加载功能的脚本。\n\n\n\n常⽤的meta标签有哪些\n\n\n\n\n\n\n\n\nimg的srcset属性的作用？\n用于提供图片源的集合，使得浏览器可以根据设备的特性，如视口大小、屏幕像素密度等，自动选择最合适的图片版本进行加载。这样可以实现图像的响应式加载，提升网页性能，\n\n行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\n行内元素 (Inline Elements)\n (锚点)\n (粗体文本，不推荐用于语义强调，可用代替)\n (通用内联容器)\n (图片)\n (各种输入控件)\n (下拉选择框)\n (强调文本，加粗显示)\n (表单控件的关联标签)\n (强调文本，通常斜体显示)\n (可点击按钮)\n (多行文本输入控件)\n\n\n块级元素 (Block-level Elements)\n (通用块级容器)\n (无序列表)\n (有序列表)\n (列表项)\n (定义列表)\n (定义术语)\n (定义描述)\n 至  (六级标题)\n (段落)\n (块引用)\n\n\n空(void)元素 (Void Elements)\n (换行)\n (水平线)\n (图片，尽管是行内元素，但它也是空元素，因为它在标签内部自我闭合)\n (页面元数据)\n (引入外部资源，如样式表)\n (某些类型的输入控件，如文本输入框，也是自封闭的)\n\n\n\niframe 有那些优点和缺点？\niframe的优点包括：\n独立性：iframe可以在页面上独立显示一个页面或内容，与主页面的其他元素相互隔离，减少样式和脚本间的冲突。\n可重用性：相同的iframe代码可以嵌套在多个页面中，便于内容的复用，减少重复代码。\n异步加载：iframe的加载不会阻塞页面主体的加载，提高了页面的初步渲染速度。\n跨域支持：iframe能够轻松实现跨域内容的嵌入，对于需要集成第三方服务或内容的场景非常有用。\n沙盒效应：iframe内的文档和脚本运行在一个独立的环境中，减少对主页面安全的影响。\n\n\niframe的缺点包括：\n性能降低：每个iframe都是一个独立的HTTP请求，增加了页面的总加载时间和服务器负担。\nSEO问题：搜索引擎通常不会抓取iframe中的内容，影响页面的搜索引擎优化。\n安全风险：iframe可能被用于点击劫持等安全攻击，尤其是在嵌入不受信任的第三方内容时。\n用户体验：过多的iframe可能导致页面布局复杂，出现滚动条，影响用户体验。同时，iframe内的导航不会影响浏览器的前进和后退按钮，可能造成用户困惑。\n兼容性问题：一些旧的或特定的移动设备可能无法很好地支持iframe，影响内容的正确显示。\n资源限制：iframe与主页面共享连接限制，可能影响页面其他资源的并行加载。\n\n\n\nHTML5有哪些更新\n语义化标签：\n引入了如&lt;header&gt;、&lt;footer&gt;、&lt;nav&gt;、&lt;article&gt;、&lt;section&gt;、&lt;aside&gt;等标签，有助于搜索引擎优化（SEO）\n\n\n多媒体支持：\n直接在浏览器中播放音频和视频，无需插件，通过和标签实现。\n\n\nCanvas与SVG：\n离线存储：\n通过localStorage和IndexedDB等Web Storage API，网站可以在用户本地存储数据，实现离线访问。\n\n\n响应式设计支持：\n结合CSS3媒体查询，更容易创建适应不同屏幕尺寸和设备的响应式网页。\n\n\nWeb Components：\n一套允许开发者创建自定义、可复用的UI组件的技术集合。\n\n\n\n","slug":"interview-html","date":"2024-05-30T14:53:42.000Z","categories_index":"","tags_index":"","author_index":"X-29"},{"id":"8f54f0fd54caedd7dc4853b9b087c3d8","title":"New Stage","content":"机遇、憧憬、恐惧、稳定人生的第三个阶段——杭州逝者如斯夫，不知从何时起，时间永远不像以前那样经得起消磨，随着一个又一个阶段的到来，时间的流逝仿佛也像是九九八十一难的妖怪愈演愈烈。\n","slug":"hangzhou","date":"2023-08-26T08:58:24.000Z","categories_index":"Essays","tags_index":"随笔","author_index":"X-29"},{"id":"0af45ef14bc511045b195273be18640c","title":"Redux","content":"Redux\n我们先明晰 Redux 的作用 ，实现集中式状态管理。\nRedux 适用于多交互、多数据源的场景。简单理解就是复杂\n从组件角度去考虑的话，当我们有以下的应用场景时，我们可以尝试采用 Redux 来实现\n某个组件的状态需要共享时\n一个组件需要改变其他组件的状态时\n一个组件需要改变全局的状态时\n除此之外，还有很多情况都需要使用 Redux 来实现\n\n\n\n这张图，非常形象的将纯 React 和 采用 Redux 的区别体现了出来\nRedux 的工作流程\n\n首先组件会在 Redux 中派发一个 action 方法，通过调用 store.dispatch 方法，将 action 对象派发给 store ，当 store 接收到 action 对象时，会将先前的 state 与传来的 action 一同发送给 reducer ，reducer 在接收到数据后，进行数据的更改，返回一个新的状态给 store ，最后由 store 更改 state\n\n\nRedux 三个核心概念Store\n\n\n\n\n\n\n\n\nstore 是 Redux 的核心，可以理解为是 Redux 的数据中台，我们可以将任何我们想要存放的数据放在 store 中，在我们需要使用这些数据时，我们可以从中取出相应的数据。因此我们需要先创建一个 store ，在 Redux 中可以使用 createStore API 来创建一个 store\n在生产中，我们需要在 src 目录下的 redux 文件夹中新增一个 store.js 文件，在这个文件中，创建一个 store 对象，并暴露它\n因此我们需要从 redux 中暴露两个方法\nimport &#123;\n    createStore,\n    applyMiddleware\n&#125; from &#39;redux&#39;\n\n并引入为 count 组件服务的 reducer\nimport countReducer from &#39;.&#x2F;count_reducer&#39;\n最后调用 createStore 方法来暴露 store\nexport default createStore(countReducer, applyMiddleware(thunk))\n\n在 store 对象下有一些常用的内置方法\n获取当前时刻的 store ，我们可以采用 getStore 方法\nconst state &#x3D; store.getState();\n\n在前面我们的流程图中，我们需要通过 store 中的 dispatch 方法来派生一个 action 对象给 store\nstore.dispatch(&#96;action对象&#96;)\n\n最后还有一个 subscribe 方法，这个方法可以帮助我们订阅 store 的改变，只要 store 发生改变，这个方法的回调就会执行\n为了监听数据的更新，我们可以将 subscribe 方法绑定在组件挂载完毕生命周期函数上，但是这样，当我们的组件数量很多时，会比较的麻烦，因此我们可以直接将 subscribe 函数用来监听整个 App组件的变化\nstore.subscribe(() &#x3D;&gt; &#123;\n    ReactDOM.render( &lt; App &#x2F;&gt; , document.getElementById(&#39;root&#39;))\n&#125;)\n\nActionaction 是 store 中唯一的数据来源，一般来说，我们会通过调用 store.dispatch 将 action 传到 store我们需要传递的 action 是一个对象，它必须要有一个 type 值例如，这里我们暴露了一个用于返回一个 action 对象的方法\nexport const createIncrementAction &#x3D; data &#x3D;&gt; (&#123;\n    type: INCREMENT,\n    data\n&#125;)\n我们调用它时，会返回一个 action 对象\nReducer在 Reducer 中，我们需要指定状态的操作类型，要做怎样的数据更新，因此这个类型是必要的。reducer 会根据 action 的指示，对 state 进行对应的操作，然后返回操作后的 state如下，我们对接收的 action 中传来的 type 进行判断\nexport default function countReducer(preState &#x3D; initState, action) &#123;\n    const &#123;\n        type,\n        data\n    &#125; &#x3D; action;\n    switch (type) &#123;\n        case INCREMENT:\n            return preState + data\n        case DECREMENT:\n            return preState - data\n        default:\n            return preState\n    &#125;\n&#125;\n更改数据，返回新的状态\n创建 constant 文件在我们正常的编码中，有可能会出现拼写错误的情况，但是我们会发现，拼写错误了不一定会报错，因此就会比较难搞。\n我们可以在 redux 目录下，创建一个 constant 文件，这个文件用于定义我们代码中常用的一些变量，例如\nexport const INCREMENT &#x3D; &#39;increment&#39;\nexport const DECREMENT &#x3D; &#39;decrement&#39;\n\n将这两个单词写在 constant 文件中，并对外暴露，当我们需要使用时，我们可以引入这个文件，并直接使用它的名称即可\n直接使用 INCREMENT 即可\n实现异步 action一开始，我们直接调用一个异步函数，这虽然没有什么问题，但是难道 redux 就不可以实现了吗？\nincrementAsync &#x3D; () &#x3D;&gt; &#123;\n    const &#123; value &#125; &#x3D; this.selectNumber\n    const &#123; count &#125; &#x3D; this.state;\n    setTimeout(() &#x3D;&gt; &#123;\n        this.setState(&#123; count: count + value * 1 &#125;)\n    &#125;, 500);\n&#125;\n\n我们可以先尝试将它封装到 action 对象中调用\nexport const createIncrementAsyncAction &#x3D; (data, time) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 无需引入 store ，在调用的时候是由 store 调用的\n    return (dispatch) &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n            dispatch(createIncrementAction(data))\n        &#125;, time)\n    &#125;\n&#125;\n\n当我们点击异步加操作时，我们会调用这个函数，在这个函数里接收一个延时加的时间，还有action所需的数据，和原先的区别只在于返回的时一个定时器函数\n但是如果仅仅这样，很显然是会报错的，它默认需要接收一个对象\n如果我们需要实现传入函数，那我们就需要告诉：你只需要默默的帮我执行以下这个函数就好！\n这时我们就需要引入中间件，在原生的 redux 中暴露出 applyMiddleware 中间件执行函数，并引入 redux-thunk 中间件（需要手动下载）\nimport thunk from &#39;redux-thunk&#39;\n\n通过第二个参数传递下去就可以了\nexport default createStore(countReducer, applyMiddleware(thunk))\n\n\n\n\n\n\n\n\n\n\n注意：异步 action 不是必须要写的，完全可以自己等待异步任务的结果后再去分发同步action\n::: warn采用 react-thunk 能让异步代码像同步代码一样执行，在 redux 中我们也是可以实现异步的，但是这样我们的代码中会有很多异步的细节，这不是我们想看到的，利用 react-thunk 之类的库，就能让我们只关心我们的业务:::\nRedux 三大原则第一个原则单向数据流：整个 Redux 中，数据流向是单向的\nUI 组件 —&gt; action —&gt; store —&gt; reducer —&gt; store\n第二个原则state 只读：在 Redux 中不能通过直接改变 state ，来控制状态的改变，如果想要改变 state ，则需要触发一次 action。通过 action 执行 reducer\n第三个原则纯函数执行：每一个reducer 都是一个纯函数，不会有任何副作用，返回是一个新的 state，state 改变会触发 store 中的 subscribe\n容器组件和 UI 组件\n所有的 UI 组件都需要有一个容器组件包裹\n容器组件来负责和 Redux 打交道，可以随意使用 Redux 的API\nUI 组件无任何 Redux API\n容器组件用于处理逻辑，UI 组件只会负责渲染和交互，不处理逻辑\n\n\n\n在我们的生产当中，我们可以直接将 UI 组件写在容器组件的代码文件当中，这样就无需多个文件\n首先，我们在 src 目录下，创建一个 containers 文件夹，用于存放各种容器组件，在该文件夹内创建 Count 文件夹，即表示即将创建 Count 容器组件，再创建 index.jsx 编写代码\n要实现容器组件和 UI 组件的连接，我们需要通过 connect 来实现\n&#x2F;&#x2F; 引入UI组件\nimport CountUI from &#39;..&#x2F;..&#x2F;components&#x2F;Count&#39;\n&#x2F;&#x2F; 引入 connect 连接UI组件\nimport &#123;connect&#125; from &#39;react-redux&#39;\n&#x2F;&#x2F; 建立连接\nexport default connect()(CountUI)\n\nProvider由于我们的状态可能会被很多组件使用，所以 React-Redux 给我们提供了一个 Provider 组件，可以全局注入 redux 中的 store ，只需要把 Provider 注册在根部组件即可\n例如，当以下组件都需要使用 store 时，我们需要这么做，但是这样徒增了工作量，很不便利\n&lt;Count store&#x3D;&#123;store&#125;&#x2F;&gt;\n&#123;&#x2F;* 示例 *&#x2F;&#125;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n&lt;Demo1 store&#x3D;&#123;store&#125;&#x2F;&gt;\n\n我们可以这么做：在 src 目录下的 index.js 文件中，引入 Provider ，直接用 Provider 标签包裹 App 组件，将 store 写在 Provider 中即可\nReactDOM.render(\n  &lt;Provider store&#x3D;&#123;store&#125;&gt;\n    &lt;App &#x2F;&gt;\n  &lt;&#x2F;Provider&gt;,\n  document.getElementById(&quot;root&quot;)\n);\n\n这样我们在 App.jsx 文件中，组件无需手写指定 store ，即可使用 store\nConnect在前面我们看到的 react-redux 原理图时，我们会发现容器组件需要给 UI 组件传递状态和方法，并且是通过 props 来传递，看起来很简单。但是，我们会发现容器组件中似乎没有我们平常传递 props 的情形\n这时候就需要继续研究一下容器组件中的唯一一个函数 connect\nconnect 方法是一个连接器，用于连接容器组件和 UI 组件，它第一次执行时，接收4个参数，这些参数都是可选的，它执行的执行的结果还是一个函数，第二次执行接收一个 UI 组件\n第一次执行时的四个参数：mapStateToProps 、mapDispatchToProps 、mergeProps、options\nmapStateToPropsconst mapStateToProps &#x3D; state &#x3D;&gt; (&#123; count: state &#125;)\n\n它接收 state 作为参数，并且返回一个对象，这个对象标识着 UI 组件的同名参数，\n返回的对象中的 key 就作为传递给 UI 组件 props 的 key，value 就作为 props 的 value\n如上面的代码，我们可以在 UI 组件中直接通过 props 来读取 count 值\n&lt;h1&gt;当前求和为：&#123;this.props.count&#125;&lt;&#x2F;h1&gt;\n\nmapDispatchToPropsconnect 接受的第二个参数是 mapDispatchToProps 它是用于建立 UI 组件的参数到 store.dispacth 方法的映射\n我们可以把参数写成对象形式，在这里面定义 action 执行的方法，例如 jia 执行什么函数，jian 执行什么函数？\n我们都可以在这个参数中定义，如下定义了几个方法对应的操作函数\n&#123;\n    jia: createIncrementAction,\n    jian: createDecrementAction,\n    jiaAsync: createIncrementAsyncAction\n&#125;\n\n似乎少了点什么，我们在这里调用了函数，创建了 action 对象，但是好像 store 并没有执行 dispatch ，那是不是断了呢？执行不了呢？\n其实这里 react-redux 已经帮我们做了优化，当调用 actionCreator 的时候，会立即发送 action 给 store 而不用手动的 dispatch\n\n自动调用 dispatch\n\n完整开发首先我们在 containers 文件夹中，直接编写我们的容器组件，无需编写 UI 组件\n先打 rcc 打出指定代码段，然后暴露出 connect 方法\nimport &#123; connect &#125; from &#39;react-redux&#39;\n\n从 action 文件中暴露创建 action 的方法\nimport &#123;createIncrementAction&#125; from &#39;..&#x2F;..&#x2F;redux&#x2F;count_action&#39;\n\n编写 UI 组件，简单写个 demo，绑定 props 和方法\nreturn (\n    &lt;div&gt;\n        &lt;h2&gt;当前求和为：&#123;this.props.count&#125;&lt;&#x2F;h2&gt;\n        &lt;button onClick&#x3D;&#123;this.add&#125;&gt;点我加1&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n);\n\n调用 connect 包装暴露 UI 组件\nexport default connect(\n    state &#x3D;&gt; (&#123; count: state &#125;),&#x2F;&#x2F; 状态\n    &#123; jia: createIncrementAction &#125; &#x2F;&#x2F; 方法\n)(Count);\n\n第一次执行的参数就直接传递 state 和一个指定 action 的对象\n数据共享编写 Person 组件首先我们需要编写 index.jsx 文件，在这个文件里面编写 Person 组件的 UI 组件，并使用 connect 函数将它包装，映射它的状态和方法\n&lt;div&gt;\n    &lt;h2&gt;我是 Person 组件,上方组件求和为:&#123;this.props.countAll&#125;&lt;&#x2F;h2&gt;\n    &lt;input ref&#x3D;&#123;c &#x3D;&gt; this.nameNode &#x3D; c&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;输入名字&quot; &#x2F;&gt;\n    &lt;input ref&#x3D;&#123;c &#x3D;&gt; this.ageNode &#x3D; c&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;输入年龄&quot; &#x2F;&gt;\n    &lt;button onClick&#x3D;&#123;this.addPerson&#125;&gt;添加&lt;&#x2F;button&gt;\n    &lt;ul&gt;\n        &#123;\n            this.props.persons.map((p) &#x3D;&gt; &#123;\n                return &lt;li key&#x3D;&#123;p.id&#125;&gt; &#123;p.name&#125;--&#123;p.age&#125;&lt;&#x2F;li&gt;\n            &#125;)\n        &#125;\n    &lt;&#x2F;ul&gt;\n&lt;&#x2F;div&gt;\n\n我们可以看到这里采用了 ref 来获取到当前事件触发的节点，并通过 this.addPerson 的方式给按钮绑定了一个点击事件\n编写点击事件回调\naddPerson &#x3D; () &#x3D;&gt; &#123;\n    const name &#x3D; this.nameNode.value\n    const age &#x3D; this.ageNode.value\n    const personObj &#x3D; &#123; id: nanoid(), name, age &#125;\n    this.props.add(personObj)\n    this.nameNode.value &#x3D; &#39;&#39;\n    this.ageNode.value &#x3D; &#39;&#39;\n&#125;\n\n在这里我们需要处理输入框中的数据，并且将这些数据用于创建一个 action 对象，传递给 store 进行状态的更新\n在这里我们需要回顾的是，这里我们使用了一个 nanoid 库，这个库我们之前也有使用过\n下载，引入，暴露\nimport &#123; nanoid &#125; from &#39;nanoid&#39;\n\n暴露的 nanoid 是一个函数，我们每一次调用时，都会返回一个不重复的数，用于确保 id 的唯一性，同时在后面的 map 遍历的过程中，我们将 id 作为了 key 值，这样也确保了 key 的唯一性，关于 key 的作用，可以看看 diffing 算法的文章\n状态管理在这里我们需要非常熟练的采用 this.props.add 的方式来更新状态\n那么它是如何实现状态更新的呢？我们来看看\n在我们调用 connect 函数时，我们第一次调用时传入的第二个参数，就是用于传递方法的，我们传递了一个 add 方法\nexport default connect(\n    state &#x3D;&gt; (&#123; persons: state.person, countAll: state.count &#125;),&#x2F;&#x2F;映射状态\n    &#123; add: createAddPersonAction &#125;\n)(Person);\n\n它的原词是：mapDispatchToProps\n我的理解是，传入的东西会被映射映射成 props 对象下的方法，这也是我们能够在 props 下访问到 add 方法的原因\n\n\n\n\n\n\n\n\n\n对于这一块 connect ，我们必须要能够形成自己的理解，这里非常的重要，它实现了数据的交互，不至于一个组件，而是全部组件\n\n\n\n\n\n\n\n\n\n想象一个 store 仓库，在我们这个案例当中，Count 组件需要存放 count 值在 store 中，Person 组件需要存放新增用户对象在 store 中，我们要把这两个数据存放在一个对象当中。当某个组件需要使用 store 中的值时，可以通过 connect 中的两个参数来获取，例如这里我们需要使用到 Count 组件的值，可以通过 .count 来从 store 中取值。\n也就是说，所有的值都存放在 store 当中，通过点运算符来获取，所有的操作 store 的方法都需要通过 action 来实现。当前组件需要使用的数据都需要在 connect 中暴露\n编写 reducer首先，我们需要明确 reducer 的作用，它是用来干什么的？\n根据操作类型来指定状态的更新\n也就是说当我们点击了添加按钮后，会将输入框中的数据整合成一个对象，作为当前 action 对象的 data 传递给 reducer\n我们可以看看我们编写的 action 文件，和我们想的一样\nimport &#123; ADD_PERSON &#125; from &quot;..&#x2F;constant&quot;;\n&#x2F;&#x2F; 创建一个人的action 对象\nexport const createAddPersonAction &#x3D; (personObj) &#x3D;&gt; (&#123;\n  type: ADD_PERSON,\n  data: personObj,\n&#125;);\n\n当 reducer 接收到 action 对象时，会对 type 进行判断\nexport default function personReducer(preState &#x3D; initState, action) &#123;\n  const &#123; type, data &#125; &#x3D; action;\n  switch (type) &#123;\n    case ADD_PERSON:\n      return [data,...preState]\n    default:\n      return preState\n  &#125;\n&#125;\n\n一般都采用 switch 来编写\n这里有个值得注意的地方是，这个 personReducer 函数是一个纯函数，什么是纯函数呢？这个是高阶函数部分的知识了，纯函数是一个不改变参数的函数，也就是说，传入的参数是不能被改变的。\n为什么要提这个呢？在我们 return 时，有时候会想通过数组的 API 来在数组前面塞一个值，不也可以吗？\n但是我们要采用 unshirt 方法，这个方法是会改变原数组的，也就是我们传入的参数会被改变，因此这样的方法是不可行的！\n打通数据共享采用 Redux 来进行组件的数据交互真的挺方便。\n我们可以在 Count 组件中引入 Person 组件存在 store 中的状态。\nexport default connect(state &#x3D;&gt; (&#123; count: state.count, personNum: state.person.length &#125;),\n    &#123;\n       ...\n    &#125;\n)(Count)\n\n在这里我们将 store 中的 person 数组的长度暴露出来这样 Count 组件就可以直接通过 props 来使用了\n同样的我们也可以在 Person 组件中使用 Count 组件的值\n从而实现了我们的这个 Demo\n最终优化\n利用对象的简写方法，将键名和键值同名，从而只写一个名即可\n合并 reducer ，我们可以将多个 reducer文件 写在一个 index 文件当中，需要采用 combineReducers 来合并\n\n","slug":"redux","date":"2023-03-24T12:29:23.000Z","categories_index":"Tecnology,React","tags_index":"tecnology","author_index":"X-29"},{"id":"1b063f23855641c095e348bf57d4f4f2","title":"React-Router-Dom","content":"React-Router-Dom 5查看印记中文网站关于 React-Router-Dom 的介绍\n路由的基本使用index.js&#x2F;index.ts 入口文件中\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &#123;&#x2F;* &lt;App&gt; 外侧包裹一个 &lt;BrowserRouter&gt; 或 &lt;HashRouter&gt; *&#x2F;&#125;\n    &lt;BrowserRouter&gt;\n      &lt;App &#x2F;&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  &lt;&#x2F;React.StrictMode&gt;,\n  document.getElementById(&quot;root&quot;)\n);\n\nApp.jsx 中\n&lt;div className&#x3D;&quot;container-wrap&quot;&gt;\n  &lt;div className&#x3D;&quot;left&quot;&gt;\n    &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;Link&gt;\n    &lt;hr &#x2F;&gt;\n    &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;home&lt;&#x2F;Link&gt;\n  &lt;&#x2F;div&gt;\n  &lt;div className&#x3D;&quot;main&quot;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&gt;&lt;&#x2F;Route&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n路由组件与一般组件\n写法不同：\n一般组件：\n路由组件：\n\n\n存放位置不同：\n一般组件：components\n路由组件：pages\n\n\n接收到的 props 不同：\n一般组件：写组件时传递什么就收到什么\n路由组件：\nhistory:\ngo、goBack、goForward、push、replace\n\n\nlocation：\npathname、search、state\n\n\nmatch：\nparams、path、url\n\n\n\n\n\n\n\n 的使用及其封装导航链接如果使用 ，那么跳转到当前页面时，会自动给当前  添加一个 class：active也可以通过 activeClassName 属性指定 class\n使用\n&lt;NavLink to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;NavLink&gt;\n\n&lt;NavLink activeClassName&#x3D;&quot;current&quot; to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;NavLink&gt;\n\n封装标签体内容是一个特殊的标签属性，可以通过 this.props.children 拿到，设置 children 属性相当于设置了标签体内容\nimport React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; NavLink &#125; from &quot;react-router-dom&quot;;\n\nexport default class MyNavLink extends Component &#123;\n  render() &#123;\n    return &lt;NavLink className&#x3D;&quot;link&quot; &#123;...this.props&#125; &#x2F;&gt;;\n  &#125;\n&#125;\n\n封装后使用\n&lt;MyNavLink to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;MyNavLink&gt;\n\n的使用&#x2F;&#x2F; 2个组件都会展示\n&lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Test&#125;&gt;&lt;&#x2F;Route&gt;\n\n&#x2F;&#x2F; 用 &lt;Switch&gt; 包裹一下，匹配到了就不继续匹配了\n&lt;Switch&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;&#x2F;Switch&gt;\n\n路由的模糊匹配与严格匹配默认模糊匹配，尽量不开启严格匹配/home/a/b 可以匹配 /home/a/home/b 不能匹配 /home 中的 to 属性，必须以  中指定的 path 开头，才能匹配成功\n&#x2F;&#x2F; 开启严格匹配，必须完全相等\n&lt;Route exact path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n\nRedirect 的使用&lt;Switch&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n\t&#x2F;&#x2F; 重定向 写在最下面  如果前面的都没匹配到，就重定向到 &lt;Redirect&gt; 指定的路径，兜底作用\n  &lt;Redirect to&#x3D;&quot;&#x2F;about&quot;&#x2F;&gt;\n&lt;&#x2F;Switch&gt;\n\n嵌套路由注册子路由时要在前面加上父路由路由的匹配顺序是按注册顺序进行的\n&lt;&gt;\n  &lt;div&gt;\n    &lt;h3&gt;home&lt;&#x2F;h3&gt;\n    &lt;MyNavLink to&#x3D;&quot;&#x2F;home&#x2F;message&quot;&gt;message&lt;&#x2F;MyNavLink&gt;\n    &lt;MyNavLink to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;news&lt;&#x2F;MyNavLink&gt;\n  &lt;&#x2F;div&gt;\n  &lt;Switch&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;message&quot; component&#x3D;&#123;Message&#125;&gt;&lt;&#x2F;Route&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;news&quot; component&#x3D;&#123;News&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;&#x2F;Switch&gt;\n&lt;&#x2F;&gt;\n\n向路由组件传递参数\nparams 参数 路由中包含参数， /xx/val1/val2\nsearch 参数 /xx?key1=val1&amp;key2=val2\nstate 参数 路由中不显示参数 HashRouter 时，刷新页面会丢失参数\n\n\n三种参数的举例\n&lt;div&gt;\n  &#123;messageArr.map((msg) &#x3D;&gt; &#123;\n    return (\n      &lt;div key&#x3D;&#123;msg.id&#125;&gt;\n        &#123;&#x2F;* 传递 params 参数 *&#x2F;&#125;\n        &#123;&#x2F;* &lt;Link to&#x3D;&#123;&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;msg.id&#125;&#x2F;$&#123;msg.title&#125;&#96;&#125;&gt;&#123;msg.title&#125;&lt;&#x2F;Link&gt; *&#x2F;&#125;\n\n        &#123;&#x2F;* 传递 search 参数 *&#x2F;&#125;\n        &#123;&#x2F;* &lt;Link to&#x3D;&#123;&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;$&#123;msg.id&#125;&amp;title&#x3D;$&#123;msg.title&#125;&#96;&#125;&gt;&#123;msg.title&#125;&lt;&#x2F;Link&gt; *&#x2F;&#125;\n\n        &#123;&#x2F;* 传递 state 参数 *&#x2F;&#125;\n        &lt;Link\n          to&#x3D;&#123;&#123;\n            pathname: &quot;&#x2F;home&#x2F;message&#x2F;detail&quot;,\n            state: &#123; id: msg.id, title: msg.title &#125;,\n          &#125;&#125;\n        &gt;\n          &#123;msg.title&#125;\n        &lt;&#x2F;Link&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;)&#125;\n  &lt;hr &#x2F;&gt;\n  &#123;&#x2F;* 声明接收 params 参数 *&#x2F;&#125;\n  &#123;&#x2F;* &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;:id&#x2F;:title&quot; component&#x3D;&#123;Detail&#125;&#x2F;&gt; *&#x2F;&#125;\n\n  &#123;&#x2F;* search 参数无需声明接收 *&#x2F;&#125;\n  &#123;&#x2F;* &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&quot; component&#x3D;&#123;Detail&#125;&#x2F;&gt; *&#x2F;&#125;\n\n  &#123;&#x2F;* state 参数无需声明接收 *&#x2F;&#125;\n  &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&quot; component&#x3D;&#123;Detail&#125; &#x2F;&gt;\n&lt;&#x2F;div&gt;;\n\n&#x2F;&#x2F; 接收 params 参数\n&#x2F;&#x2F; const &#123;id, title&#125; &#x3D; this.props.match.params\n\n&#x2F;&#x2F; 接收 search 参数\n&#x2F;&#x2F; const &#123;search&#125; &#x3D; this.props.location\n&#x2F;&#x2F; const &#123;id, title&#125; &#x3D; qs.parse(search.slice(1))\n\n&#x2F;&#x2F; 接收 search 参数\nconst &#123; id, title &#125; &#x3D; this.props.location.state || &#123;&#125;;\n\n\n\nkey=value&amp;key2=value2 形式叫 urlencode 编码\nimport qs from &quot;querystring&quot;;\n\nlet obj &#x3D; &#123; a: 1, b: 2 &#125;;\n\nlet str &#x3D; qs.string(obj);\n\nobj &#x3D; qs.parse(str);\n\nPush&amp;Replace\n&lt;Link to&#x3D;&#123;&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;msg.id&#125;&#x2F;$&#123;msg.title&#125;&#96;&#125;&gt;&#123;msg.title&#125;&lt;&#x2F;Link&gt;\n\n&lt;Link replace&#x3D;&#123;true&#125; to&#x3D;&#123;&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;msg.id&#125;&#x2F;$&#123;msg.title&#125;&#96;&#125;&gt;&#123;msg.title&#125;&lt;&#x2F;Link&gt;\n\n编程式路由导航\n编程式路由导航举例\npushShow &#x3D; (id, title) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; push 跳转 + 携带 params 参数\n    &#x2F;&#x2F; this.props.history.push(&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;id&#125;&#x2F;$&#123;title&#125;&#96;)\n\n    &#x2F;&#x2F; push 跳转 + 携带 search 参数\n    &#x2F;&#x2F; this.props.history.push(&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;$&#123;id&#125;&amp;title&#x3D;$&#123;title&#125;&#96;)\n\n    &#x2F;&#x2F; push 跳转 + 携带 state 参数\n    this.props.history.push(&#96;&#x2F;home&#x2F;message&#x2F;detail&#96;, &#123;id, title&#125;)\n&#125;\n\nreplaceShow &#x3D; (id, title) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; replace 跳转 + 携带 params 参数\n    &#x2F;&#x2F; this.props.history.replace(&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;id&#125;&#x2F;$&#123;title&#125;&#96;)\n\n    &#x2F;&#x2F; replace 跳转 + 携带 search 参数\n    &#x2F;&#x2F; this.props.history.replace(&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;$&#123;id&#125;&amp;title&#x3D;$&#123;title&#125;&#96;)\n\n    &#x2F;&#x2F; replace 跳转 + 携带 state 参数\n    this.props.history.replace(&#96;&#x2F;home&#x2F;message&#x2F;detail&#96;, &#123;id, title&#125;)\n&#125;\n\n&lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.pushShow(msg.id, msg.title)&#125;&gt;push 查看&lt;&#x2F;button&gt;\n&lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.replaceShow(msg.id, msg.title)&#125;&gt;replace 查看&lt;&#x2F;button&gt;\n\n&#x2F;&#x2F; 前进一步\nthis.props.history.goForward()\n&#x2F;&#x2F; 后退一步\nthis.props.history.goBack()\n&#x2F;&#x2F; 前进一步\nthis.props.history.go(1)\n\n\n\nWitshRouter 的使用withRouter 可以加工一般组件，让一般组件具有路由组件特有的 API，history 等withRouter 返回值是一个新组件\n\nWitshRouter 的使用\nimport React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; withRouter &#125; from &quot;react-router-dom&quot;;\n\nclass Header extends Component &#123;\n  go &#x3D; () &#x3D;&gt; &#123;\n    this.props.history.goForward();\n  &#125;;\n\n  back &#x3D; () &#x3D;&gt; &#123;\n    this.props.history.goBack();\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;react-router-dom&lt;&#x2F;h2&gt;\n        &lt;button onClick&#x3D;&#123;this.go&#125;&gt;前进&lt;&#x2F;button&gt;\n        &lt;button onClick&#x3D;&#123;this.back&#125;&gt;后退&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default withRouter(Header);\n\n\n\nBrowserRouter 与 HashRouter\n底层原理不一样：\nBrowserRouter 使用的是 H5 的 history API，不兼容 IE9 及以下版本\nHashRouter 使用的是 URL 的哈希值\n\n\npath 表现形式不一样：\nBrowserRouter 的路径中没有 #\nHashRouter 的路径中包含 #\n\n\n刷新后对 state 参数的影响：\nBrowserRouter 没有任何影响，因为 state 保存在 history 对象中\nHashRouter 刷新后会导致路由 state 参数的丢失\n\n\nHashRouter 可以解决一些路径错误相关的问题，比如多级路径刷新页面后样式丢失\n\nReact-Router-Dom 6与 v5 版本区别\n内置组件的变化：移除 ,新增\n语法的变化：注册组件时，component&#x3D;{Demo} 变为 element&#x3D;{}\n新增多个 hook:useParams,useNavigate,useMatch 等\n官方推荐使用函数式组件了\n\n&lt;Routes&gt;\n  &#123;&#x2F;* caseSensitive 设置path是否大小写敏感 *&#x2F;&#125;\n  &lt;Route path&#x3D;&quot;&#x2F;EXTENSION&quot; caseSensitive&#x3D;&#123;true&#125; element&#x3D;&#123;&lt;LazyDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;extension&quot; element&#x3D;&#123;&lt;ExtensionDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;lazy-demo&quot; element&#x3D;&#123;&lt;LazyDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;react-router-v6&quot; element&#x3D;&#123;&lt;ReactRouterDomV6 &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &#123;&#x2F;* 这里不会继续往下匹配 *&#x2F;&#125;\n  &lt;Route path&#x3D;&quot;&#x2F;react-router-v6&quot; element&#x3D;&#123;&lt;ExtensionDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;&#x2F;Routes&gt;\n\n路由懒加载import Loading from &quot;.&#x2F;components&#x2F;Loading&quot;;\nimport &#123;lazy()&#125; from &#39;react&#39;\n&#x2F;&#x2F; 路由懒加载 1. 调用lazy\nconst LazyDemo &#x3D; lazy(() &#x3D;&gt; import(&quot;.&#x2F;pages&#x2F;ExtensionDemo&#x2F;02_lazy&quot;));\n&#123;\n  &#x2F;* 路由懒加载 2.使用Suspense *&#x2F;\n&#125;\n&lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n  &#123;&#x2F;* v5:使用的是 Switch *&#x2F;&#125;\n  &lt;Routes&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;lazy-demo&quot; element&#x3D;&#123;&lt;LazyDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;&#x2F;Routes&gt;\n&lt;&#x2F;Suspense&gt;;\n\n重定向v6 使用替代 v5 的\n&lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;react-router-v6&quot;&gt;&lt;&#x2F;Navigate&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n\n使用 useRoutes 配置路由链路表&#x2F;&#x2F; 根据配置生成链路表\nconst allElement &#x3D; useRoutes(routes);\n&lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n  &#123;&#x2F;* 路由链路表 *&#x2F;&#125;\n  &#123;allElement&#125;\n&lt;&#x2F;Suspense&gt;;\n\n嵌套路由路由链路表父路由添加 children 字段（和 vue-router 类似）\n&#123;\n  path: &#39;&#x2F;react-router-v6&#39;,\n    element: &lt;ReactRouterDomV6 &#x2F;&gt;,\n    &#x2F;&#x2F; 嵌套路由，父组件需要一个位置&lt;Outlet &#x2F;&gt;来展示\n    children: [\n      &#123;\n        path: &#39;child&#39;,\n        element: &lt;Child &#x2F;&gt;,\n      &#125;,\n    ],\n  &#125;,\n\n路由传参 params定义路由参数\n&#123;\n   path: &#39;use-params&#x2F;:id&#x2F;:name&#39;,\n   element: &lt;UseParamsDemo &#x2F;&gt;,\n &#125;\n\n获取路由参数第一种：useParams()\n&#x2F;&#x2F; 返回值：\n&#123;\n  &quot;id&quot;: &quot;id1&quot;,\n  &quot;name&quot;: &quot;name2&quot;\n&#125;\n\n第二种：useMatch()\n&#x2F;&#x2F; 返回值\n&#123;\n  &quot;params&quot;: &#123;\n    &quot;id&quot;: &quot;id1&quot;,\n    &quot;name&quot;: &quot;name2&quot;\n  &#125;,\n  &quot;pathname&quot;: &quot;&#x2F;react-router-v6&#x2F;use-params&#x2F;id1&#x2F;name2&quot;,\n  &quot;pathnameBase&quot;: &quot;&#x2F;react-router-v6&#x2F;use-params&#x2F;id1&#x2F;name2&quot;,\n  &quot;pattern&quot;: &#123;\n    &quot;path&quot;: &quot;&#x2F;react-router-v6&#x2F;use-params&#x2F;:id&#x2F;:name&quot;,\n    &quot;caseSensitive&quot;: false,\n    &quot;end&quot;: true\n  &#125;\n&#125;\n\n路由参数 search传参\n&lt;NavLink className&#x3D;&#123;linkClass&#125; to&#x3D;&quot;.&#x2F;use-search-params?id&#x3D;1&amp;name&#x3D;abc&amp;title&#x3D;xxx&quot;&gt;\n  useSearchParams\n&lt;&#x2F;NavLink&gt;\n\n取值\n\n取值示例\nimport React from &quot;react&quot;;\nimport &#123; useLocation, useSearchParams &#125; from &quot;react-router-dom&quot;;\n\nexport default function useSearchParamsDemo() &#123;\n  const [search, setSearch] &#x3D; useSearchParams();\n  const id &#x3D; search.get(&quot;id&quot;);\n  const name &#x3D; search.get(&quot;name&quot;);\n  const title &#x3D; search.get(&quot;title&quot;);\n  console.log(id, name, title);\n  &#x2F;&#x2F; 也可从location获取\n  const location &#x3D; useLocation();\n  console.log(location);\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 会替换url?后面所有参数\n    setSearch(&quot;id&#x3D;1&amp;name&#x3D;abc&amp;title&#x3D;xxx&quot;);\n  &#125;;\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;useSearchParams&lt;&#x2F;h3&gt;\n      &lt;div&gt;\n        &#123;id&#125;,&#123;name&#125;,&#123;title&#125;\n      &lt;&#x2F;div&gt;\n      &lt;div&gt;\n        &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;设置search&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n\n\n路由参数 state传参\n&lt;NavLink\n  className&#x3D;&#123;linkClass&#125;\n  to&#x3D;&#123;&#123; pathname: &quot;.&#x2F;state-params&quot;, state: &#123; name: &quot;curry&quot; &#125; &#125;&#125;\n&gt;\n  传入state路由参数\n&lt;&#x2F;NavLink&gt;\n\n取值通过 useLocation().state获取\n编程式导航v6 版本中，不区分普通组件还是路由组件，都使用 const navigete = useNavigete(),普通组件不再使用withRouter()\n额外的 Hooks\nuseInRouterContext()：判断是否在路由环境下，一般用于第三方组件库封装\nuseNavigeteType(): 返回跳转模式 PUSH | REPLACE | POP (刷新时)\nuseOutlet():用来呈现当前组件中渲染的嵌套路由（路由对象）\nuseResolvedPath(‘&#x2F;react-router-v6&#x2F;use-params&#x2F;id1&#x2F;name2?title&#x3D;解析 url#hashcode123’),用来解析任何路径\n\n&#123;\n  &quot;pathname&quot;: &quot;&#x2F;react-router-v6&#x2F;use-params&#x2F;id1&#x2F;name2&quot;,\n  &quot;search&quot;: &quot;?title&#x3D;解析url&quot;,\n  &quot;hash&quot;: &quot;#hashcode123&quot;\n&#125;\n\n","slug":"react-router-dom","date":"2023-03-22T14:10:34.000Z","categories_index":"Tecnology,React","tags_index":"tecnology","author_index":"X-29"},{"id":"d9e53d39e48f5c5aa42bf2e7c031bcd1","title":"React","content":"React 入门点我去官网\nReact 的基本使用需要的相关依赖文件\nreact.js：React 核心库。\nreact-dom.js：提供操作 DOM 的 react 扩展库。\nbabel.min.js：解析 JSX 语法代码转为 JS 代码的库\n\n\n\n\n\n\n\n\n\n\n引入顺序为：1.react.js2.react-dom.js3.babel.min.js\n创建虚拟 DOM 的两种方式\n纯 JS 方式(一般不用)\nJSX 方式\n\n虚拟 DOM 与真实 DOM\nReact 提供了一些 API 来创建一种 “特别” 的一般 js 对象\nconst VDOM = React.createElement(&#39;xx&#39;,&#123;id:&#39;xx&#39;&#125;,&#39;xx&#39;)\n上面创建的就是一个简单的虚拟 DOM 对象\n\n\n虚拟 DOM 对象最终都会被 React 转换为真实的 DOM\n我们编码时基本只需要操作 react 的虚拟 DOM 相关数据, react 会转换为真实 DOM 变化而更新界。\n\nJSXJSX\n全称: JavaScript XML\n\nreact 定义的一种类似于 XML 的 JS 扩展语法: JS + XML 本质是 React.createElement(component, props, …children)方法的语法糖\n\n作用: 用来简化创建虚拟 DOM\n\n写法：var ele = &lt;h1&gt;Hello JSX!&lt;/h1&gt;\n注意 1：它不是字符串, 也不是 HTML&#x2F;XML 标签\n注意 2：它最终产生的就是一个 JS 对象\n\n\n标签名任意: HTML 标签或其它标签\n\n标签属性任意: HTML 标签属性或其它\n\n基本语法规则\n\n遇到 &lt;开头的代码, 以标签的语法解析: html 同名标签转换为 html 同名元素, 其它标签需要特别解析\n遇到以&#123; 开头的代码，以 JS 语法解析: 标签中的 js 表达式必须用&#123; &#125;包含\n\n\nbabel.js 的作用\n\n浏览器不能直接解析 JSX 代码, 需要 babel 转译为纯 JS 的代码才能运行\n只要用了 JSX，都要加上type&#x3D;”text&#x2F;babel”, 声明需要 babel 来处理\n\n渲染虚拟 DOM（元素）\n语法: ReactDOM.render(virtualDOM, containerDOM)\n\n作用: 将虚拟 DOM 元素渲染到页面中的真实容器 DOM 中显示\n\n参数说明\n\n参数一: 纯 js 或 jsx 创建的虚拟 dom 对象\n参数二: 用来包含虚拟 DOM 元素的真实 dom 元素对象（一般是个&lt;div&gt;&lt;/div&gt;）\n\n\nExample: ReactDOM.render(&lt;Test /&gt;,document.getElementById(&#39;root&#39;))\n\n\nJSX 语法\n定义虚拟 DOM，不能使用“”\n标签中混入 JS 表达式的时候使用&#123;&#125;\nid = &#123;myId.toUpperCase()&#125;\n样式的类名指定不能使用class，使用className\n内敛样式要使用&#123;&#123;&#125;&#125;包裹\nstyle=&#123;&#123;color:'skyblue',fontSize:'24px'&#125;&#125;\n不能有多个根标签，只能有一个根标签\n标签必须闭合，自闭合也行\n如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错；如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错\n\n注释写法写在大括号里ReactDOM.render(\n  &lt;div&gt;\n    &lt;h1&gt;小丞&lt;&#x2F;h1&gt;\n    &#123;&#x2F;*注释...*&#x2F;&#125;\n  &lt;&#x2F;div&gt;,\n  document.getElementById(&quot;example&quot;)\n);\n\n数组插入并遍历\nJSX 允许在模板中插入数组，数组自动展开全部成员\n\nvar arr &#x3D; [&lt;h1&gt;小丞&lt;&#x2F;h1&gt;, &lt;h2&gt;同学&lt;&#x2F;h2&gt;];\nReactDOM.render(&lt;div&gt;&#123;arr&#125;&lt;&#x2F;div&gt;, document.getElementById(&quot;example&quot;));\n\n\n根据动态数据生成 \n\nconst data &#x3D; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\nconst VDOM &#x3D; (\n  &lt;div&gt;\n    &lt;ul&gt;\n      &#123;data.map((item, index) &#x3D;&gt; &#123;\n        return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;;\n      &#125;)&#125;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;div&gt;\n);\nReactDOM.render(VDOM, document.querySelector(&quot;.test&quot;));\n\nReact 面向组件编程Tips\n组件名必须首字母大写\n虚拟 DOM 元素只能有一个根元素\n虚拟 DOM 元素必须有结束标签\n\n渲染类组件标签的基本流程\nReact 内部会创建组件实例对象\n调用 render()得到虚拟 DOM, 并解析为真实 DOM\n插入到指定的页面元素内部\n\n函数式组件&#x2F;&#x2F;1.先创建函数，函数可以有参数，也可以没有，但是必须要有返回值 返回一个虚拟DOM\nfunction Welcome(props) &#123;\n  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;\n&#125;\n&#x2F;&#x2F;2.进行渲染\nReactDOM.Render(&lt;Welcom name&#x3D;&quot;ljc&quot; &#x2F;&gt;, document.getElementById(&quot;div&quot;));\n\n类式组件class MyComponent extends React.Component &#123;\n  state &#x3D; &#123; isHot: false &#125;;\n  render() &#123;\n    const &#123; isHot &#125; &#x3D; this.state;\n    return (\n      &lt;h1 onClick&#x3D;&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;&lt;&#x2F;h1&gt;\n    );\n  &#125;\n  changeWeather &#x3D; () &#x3D;&gt; &#123;\n    const isHot &#x3D; this.state.isHot;\n    this.setState(&#123; isHot: !isHot &#125;);\n  &#125;;\n&#125;\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.querySelector(&quot;.test&quot;));\n\n\n组件中的 render 方法中的 this 为组件实例对象\n组件自定义方法中由于开启了严格模式，this 指向 undefined 如何解决\n通过 bind 改变 this 指向\n推荐采用箭头函数，箭头函数的 this 指向\n\n\nstate 数据不能直接修改或者更新\n\n组件实例三大属性StateReact 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）\nclass Weather extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n  &#125;\n  state &#x3D; &#123;\n    weather: &quot;炎热&quot;,\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;当前季节为：&#123;this.state.weather&#125;&lt;&#x2F;h2&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n\n使用的时候通过this.state调用 state 里面的值\n修改 state 里面的值通过调用this.setState(partialState, [callback])\npartialState: 需要更新的状态的部分对象\ncallback: 更新完状态后的回调函数&#x2F;直接要修改的值\nsetState 是一种合并操作，不是替换操作\n在执行 setState 操作后，React 会自动调用一次 render()\nrender() 的执行次数是 1+n (1 为初始化时的自动调用，n 为状态更新的次数)\n\n\n\nProps与state不同，state是组件自身的状态，而props则是外部传入的数据\nclass Person extends React.Component &#123;\n  render() &#123;\n    return (\n      &lt;ul&gt;\n        &lt;li&gt;&#123;this.props.name&#125;&lt;&#x2F;li&gt;\n        &lt;li&gt;&#123;this.props.age&#125;&lt;&#x2F;li&gt;\n        &lt;li&gt;&#123;this.props.sex&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    );\n  &#125;\n  &#x2F;&#x2F; 对 props传过来的数据进行数据类型的限制\n  static propTypes &#x3D; &#123;\n    name: propTypes.string.isRequired,\n    sex: PropTypes.string,\n    speak: PropTypes.func,\n  &#125;;\n  &#x2F;&#x2F; 对没有传的数据进行一个默认的填充\n  static defaultProps &#x3D; &#123;\n    sex: &quot;male&quot;,\n    age: 18,\n  &#125;;\n&#125;\n    const p &#x3D;&#123;\n        name:&quot;Lisa&quot;,\n        age:&#123;19&#125; ,\n        sex:&quot;female&quot;\n    &#125;\n\nReactDOM.render(\n  &lt;Person &#123;...p&#125;&#x2F;&gt;,document.getElementById(&quot;root&quot;)\n);\n\n\n在使用的时候可以通过 this.props 来获取值 类式组件的 props:\n通过在组件标签上传递值，在组件中就可以获取到所传递的值\n在构造器里的 props 参数里可以获取到 props\n可以分别设置 propTypes 和 defaultProps 两个属性来分别操作 props 的规范和默认值，两者都是直接添加在类式组件的原型对象上的（所以需要添加 static）\n同时可以通过…运算符来简化\n\n\n\nRefsRefs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。\n\n有三种操作 refs 的方法，分别为：\n字符串形式\n回调形式\ncreateRef 形式\n\n\n\n字符串形式 refs\n()&#x3D;&gt;&#123;\n    alert(this.refs.inp1)\n&#125;\nrender()&#123;return(&lt;input ref&#x3D;&quot;inp1&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;)&#125;\n\n回调形式的 refs组件实例的 ref 属性传递一个回调函数 c &#x3D;&gt; this.input1 &#x3D; c （箭头函数简写），这样会在实例的属性中存储对 DOM 节点的引用，使用时可通过 this.input1 来使用\n&lt;input\n  ref&#x3D;&#123;(c) &#x3D;&gt; (this.input1 &#x3D; c)&#125;\n  type&#x3D;&quot;text&quot;\n  placeholder&#x3D;&quot;点击按钮提示数据&quot;\n&#x2F;&gt;\n\ncreateRef 形式React 给我们提供了一个相应的 API，它会自动的将该 DOM 元素放入实例对象中\nDOM&lt;input ref&#x3D;&#123;this.MyRef&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;\n&lt;input ref&#x3D;&#123;this.MyRef1&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;\n\nMyRef &#x3D; React.createRef();\nMyRef1 &#x3D; React.createRef();\n\n使用&#x2F;&#x2F;调用\nbtnOnClick &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F;创建之后，将自身节点，传入current中\n  console.log(this.MyRef.current.value);\n&#125;;\n\n高阶函数及函数的柯里化以下例子即可知道，只可意会不可言传\n\n函数柯里化\nclass MyComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    username: &quot;&quot;,\n    password: &quot;&quot;,\n  &#125;;\n  saveFormInformation &#x3D; (dataType) &#x3D;&gt; &#123;\n    return (event) &#x3D;&gt; &#123;\n      console.log(dataType, event.target.value);\n      this.setState(&#123; [dataType]: event.target.value &#125;);\n    &#125;;\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;函数柯里化Example&lt;&#x2F;h1&gt;\n        &lt;form&gt;\n          &lt;div&gt;\n            &lt;input\n              onChange&#x3D;&#123;this.saveFormInformation(&quot;username&quot;)&#125;\n              type&#x3D;&quot;text&quot;\n              placeholder&#x3D;&quot;请输入用户名&quot;\n            &#x2F;&gt;\n            &lt;br &#x2F;&gt;\n            &lt;br &#x2F;&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div&gt;\n            &lt;input\n              onChange&#x3D;&#123;this.saveFormInformation(&quot;password&quot;)&#125;\n              type&#x3D;&quot;password&quot;\n              placeholder&#x3D;&quot;请输入密码&quot;\n            &#x2F;&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;form&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.getElementById(&quot;test&quot;));\n\n\n\n\n避免函数柯里化\nclass MyComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    username: &quot;&quot;,\n    password: &quot;&quot;,\n  &#125;;\n  saveInfomation &#x3D; (name, value) &#x3D;&gt; &#123;\n    this.setState(&#123; [name]: value &#125;);\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;div&gt;\n          &lt;input\n            onChange&#x3D;&#123;(event) &#x3D;&gt; &#123;\n              this.saveInfomation(&quot;username&quot;, event.target.value);\n            &#125;&#125;\n            type&#x3D;&quot;text&quot;\n            placeholder&#x3D;&quot;请输入用户名&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n        &lt;br &#x2F;&gt;\n        &lt;br &#x2F;&gt;\n        &lt;div&gt;\n          &lt;input\n            onChange&#x3D;&#123;(event) &#x3D;&gt; &#123;\n              this.saveInfomation(&quot;password&quot;, event.target.value);\n            &#125;&#125;\n            type&#x3D;&quot;password&quot;\n            placeholder&#x3D;&quot;请输入密码&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.getElementById(&quot;test&quot;));\n\n\n\n生命周期React 生命周期主要包括三个阶段：初始化阶段，更新阶段，销毁阶段\n旧的生命周期流程\n\n\n初始化阶段: 由 ReactDOM.render()触发—初次渲染\nconstructor()\ncomponentWillMount()\nrender()\ncomponentDidMount()\n\n\n更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发\nshouldComponentUpdate()\ncomponentWillUpdate()\nrender()\ncomponentDidUpdate()\n\n\n卸载组件: 由ReactDOM.unmountComponentAtNode()触发\ncomponentWillUnmount\n\n\n\n新的生命周期流程\n\n\n初始化阶段: 由 ReactDOM.render()触发—初次渲染\nconstructor()\ngetDerivedStateFromProps\nrender()\ncomponentDidMount()\n\n\n更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发\ngetDerivedStateFromProps\nshouldComponentUpdate()\nrender()\ngetSnapshotBeforeUpdate\ncomponentDidUpdate()\n\n\n卸载组件: 由 ReactDOM.unmountComponentAtNode()触发\ncomponentWillUnmount()\n\n\n\n重要的钩子\nrender：初始化渲染或更新渲染调用\ncomponentDidMount：开启监听, 发送 ajax 请求\ncomponentWillUnmount：做一些收尾工作, 如: 清理定时器\n\n废弃的钩子\ncomponentWillMount\ncomponentWillReceiveProps\ncomponentWillUpdate\n\nReact 脚手架安装脚手架WebPack\n\n第一步：全局安装create-react-app npm install create-react-app -g\n第二步：创建项目create-react-app hello-react\n\nVite\n\nnpm init vite照着提示一步一步来就行\n\n脚手架项目结构WebPack\n\nhello-react\n.gitignore 自动创建本地仓库\npackage.json 相关配置文件\npublic 公共资源\nfavicon.ico 浏览器顶部的 icon 图标\nindex.html 应用的 index.html 入口\nlogo192.png 在 manifest 中使用的 logo 图\nlogo512.png 同上\nmanifest.json 应用加壳的配置文件\nrobots.txt 爬虫的协议文件\n\n\nsrc 源码文件夹\nApp.css &#x2F;&#x2F; pp 组件的样式\nApp.js App 组件\nApp.test.js 用于给 APP 做测试\nindex.css 样式\nindex.js 入口文件\nlogo.svg logo 图\nreportWebVitals.js 页面性能分析文件\nsetupTests.js 组件单元测试文件\n\n\nyarn.lock\n\n\n\n消息订阅与发布解决兄弟组件之间需要&lt;App/&gt;帮助的问题\n\n首先安装 pubsub-js\nyarn add pubsub-js\nnpm install pubsub-js\n\n\n引入\nimport PubSub from &#39;pubsub-js&#39;\n\n\n\n订阅消息我们通过 subscribe 来订阅消息，它接收两个参数，第一个参数是消息的名称，第二个是消息成功的回调，回调中也接受两个参数，一个是消息名称，一个是返回的数据\nPubSub.subscribe(&quot;search&quot;, (msg, data) &#x3D;&gt; &#123;\n  console.log(msg, data);\n&#125;);\n\n发布消息我们采用 publish 来发布消息\n&#x2F;&#x2F; 之前的写法\nthis.props.updateAppState(&#123; isFirst: false, isLoading: true &#125;);\n&#x2F;&#x2F; 改为发布订阅方式\nPubSub.publish(&quot;search&quot;, &#123; isFirst: false, isLoading: true &#125;);\n\n这样我们就能成功的在请求之前发送消息，我们只需要在 List 组件中订阅一下这个消息即可，并将返回的数据用于更新状态即可\nPubSub.subscribe(&quot;search&quot;, (msg, stateObj) &#x3D;&gt; &#123;\n  this.setState(stateObj);\n&#125;);\n\n同时上面的代码会返回一个 token ，这个就类似于定时器的编号的存在，我们可以通过这个 token 值，来取消对应的订阅\n通过 unsubscribe 来取消指定的订阅\nPubSub.unsubscribe(this.token);\n\n\n","slug":"react","date":"2023-03-22T14:07:08.000Z","categories_index":"Tecnology,React","tags_index":"tecnology","author_index":"X-29"},{"id":"d5f81ad13155fc328e81b1032965290d","title":"Vuex","content":"Vuex介绍What’s the Vuex?\n\n\n\n\n\n\n\n\n概念：专门在Vue中实现集中式状态（数据）管理的一个Vue插，对Vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信\n\n\n\n核心流程\nstore： 每一个Vuex应用的核心就是store(仓库),store基本上就是一个容器，它包含着应用中大部分的状态 (state)。\nstate ： 共同维护的一个状态，state里面可以是很多个全局状态\ngetters：获取数据并渲染\nactions：数据的异步操作\nmutations：处理数据的唯一途径，state的改变或赋值只能在这里\n\n实际体验配置vuex\n下载安装vuex  npm install vuex\n创建src/store/index.js该文件用于创建Vuex最为核心的store\n\nsrc/store/index.jsimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39; &#x2F;&#x2F;引入Vuex\n\nVue.use(Vuex) &#x2F;&#x2F;应用Vuex插件\n\nconst actions &#x3D; &#123;&#125;      &#x2F;&#x2F; 准备actions用于响应组件中的动作\nconst mutations &#x3D; &#123;&#125;    &#x2F;&#x2F; 准备mutations用于操作数据state\nconst state &#x3D; &#123;&#125;        &#x2F;&#x2F; 准备state用于存储数据\n\n&#x2F;&#x2F;创建并暴露store\nexport default new Vuex.Store(&#123;\n    actions,\n    mutations,\n    getters,\n    state\n&#125;)\n\n\n在src&#x2F;main.js中创建vm时传入store配置项src/store/index.jsimport Vue from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport store from &#39;.&#x2F;store&#39;\n\nVue.config.productionTip &#x3D; false\n\nnew Vue(&#123;\n    el:&#39;#app&#39;,\n    render:h &#x3D;&gt; h(App),\n    store,\n\n&#125;)\n\n使用Vuex\n初始化数据state、配置actions、mutations、操作文件store.js\n组件中读取Vuex中的数据：$store.state.数据\n组件中修改Vuex中的数据：this.$store.dispatch(&#39;action中的方法名&#39;,数据)或者this.$store.commit(&#39;mutations中的方法名&#39;,数据)\n\n\n\n\n\n\n\n\n如果没有网络请求或其他业务逻辑，组件中也可以 越过actions，即不写dispatch,直接写commmit\n\n\nGetters 配置项\n\n\n\n\n\n\n\n\n当state中的数据需要经过加工后再使用是，可以使用getters加工,，相当于全局计算属性\n\n组件中想读取getters中的数据则$store.getters.函数名\n\nMapState 辅助函数当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。可以使用mapstate()辅助函数帮助生成计算属性Example\nexport default &#123;\n    comuted:&#123;\n        ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;)&#x2F;&#x2F;写法一 对象\n        ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;])&#x2F;&#x2F;写法二 数组\n    &#125;\n&#125;\n\nMapGettersExample\nexport default &#123;\n    comuted:&#123;\n        ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;)&#x2F;&#x2F;写法一 对象\n\n        ...mapGetters([&#39;bigSum&#39;])&#x2F;&#x2F;写法二 数组\n    &#125;\n&#125;\n\nMapActions用于帮助生成与actions对话的方法，即包含了$store.dispatch(xx)的函数\nexport default &#123;\n    methods:&#123;\n        &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（对象形式）\n        ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;&#125;,incrementWait:&#39;jiaWait&#39;)\n\n        &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（数组形式）\n         ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])\n    &#125;\n&#125;\n\nMapMutations用于帮助生成与mutations对话的方法，即包含$store.commit(xx)的函数\nexport default &#123;\n    methods:&#123;\n        &#x2F;&#x2F;靠mapMutations生成：increment、decreament（对象形式）\n        ...mapMutations(&#123;increment:&#39;JIA&#39;&#125;,decreament:&#39;JIAN&#39;)\n\n        &#x2F;&#x2F;靠mapMutations生成：increment、decreament（数组形式）\n         ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;])\n    &#125;\n&#125;\n\n模块化&amp;命名空间\n目的：让代码更好维护，让多种数据分类更加明确\n修改store.js：为了解决不同模块命名冲突的问题，设置不同模块的namespaced:true,之后在不同页面引入geeter、actions、mutations时，需要加上所属模块名\n\nExample\n\nDetails\nconst countAbout &#x3D; &#123;\n    naspaced:true,\n    state:&#123;&#125;,\n    mutaitons:&#123;&#125;,\n    actions:&#123;&#125;,\n    getters:&#123;&#125;\n&#125;\nconst personAbout &#x3D; &#123;\n    naspaced:true,\n    state:&#123;&#125;,\n    mutaitons:&#123;&#125;,\n    actions:&#123;&#125;,\n    getters:&#123;&#125;\n&#125;\nconst store &#x3D; new Vuex.Store(&#123;\n    modules:&#123;\n        countAbout,\n        personAbout\n    &#125;\n&#125;)\n\n\n开启命名空间后组件中读取state数据&#x2F;&#x2F; 方式一：直接读取\nthis.$store.state.personAbout.list\n&#x2F;&#x2F; 方式二：mapState\n...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;])\n\n开启命名空间后组件中读取getters数据&#x2F;&#x2F; 方式一：直接读取\nthis.$store.getters[&#39;perAbout&#x2F;firstPersonName&#39;]\n&#x2F;&#x2F; mapGetters\n...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])\n\n开启命名空间后组件中调用dispatch&#x2F;&#x2F; 方式一：直接读取\nthis.$store.getters[&#39;perAbout&#x2F;addPersonWang&#39;,person]\n&#x2F;&#x2F; mapActions\n...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiawait&#39;&#125;)\n\n开启命名空间后组件中调用commit&#x2F;&#x2F; 方式一：直接读取\nthis.$store.commit[&#39;perAbout&#x2F;ADD_PERSON&#39;,person]\n&#x2F;&#x2F; mapActions\n...mapActions(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;)\n","slug":"vuex","date":"2023-03-21T15:29:07.000Z","categories_index":"Tecnology,Vue,Gadgets","tags_index":"tecnology","author_index":"X-29"},{"id":"21b9d275999a54f82cbd29d23f792608","title":"Vue-Router","content":"介绍\n理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n前端路由：key 是路径，value 是组件。\n\n基本使用\n安装 vue-router，命令：npm i vue-router\n应用插件：Vue.use(VueRouter)\n编写 router 配置项:\n\n&#x2F;&#x2F;引入VueRouter\nimport VueRouter from &quot;vue-router&quot;;\n&#x2F;&#x2F;引入Luyou 组件\nimport About from &quot;..&#x2F;components&#x2F;About&quot;;\nimport Home from &quot;..&#x2F;components&#x2F;Home&quot;;\n\n&#x2F;&#x2F;创建router实例对象，去管理一组一组的路由规则\nconst router &#x3D; new VueRouter(&#123;\n  routes: [\n    &#123;\n      path: &quot;&#x2F;about&quot;,\n      component: About,\n    &#125;,\n    &#123;\n      path: &quot;&#x2F;home&quot;,\n      component: Home,\n    &#125;,\n  ],\n&#125;);\n\n&#x2F;&#x2F;暴露router\nexport default router;\n\n\n实现跳转\n\n&lt;router-link active-class&#x3D;&quot;active&quot; to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;\n\n\n用于展示的容器这个超级容易忘，没有它写半天东西出不来\n\n&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n\nTips\n路由组件通常存放在 pages 文件夹，一般组件通常存放在 components 文件夹。\n通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。\n每个组件都有自己的$route 属性，里面存储着自己的路由信息。\n整个应用只有一个 router，可以通过组件的$router 属性获取到。\n\n多级路由\n配置路由规则，使用 children 配置项：\n\nroutes: [\n  &#123;\n    path: &quot;&#x2F;about&quot;,\n    component: About,\n  &#125;,\n  &#123;\n    path: &quot;&#x2F;home&quot;,\n    component: Home,\n    children: [\n      &#x2F;&#x2F;通过children配置子级路由\n      &#123;\n        path: &quot;news&quot;, &#x2F;&#x2F;此处一定不要写：&#x2F;news\n        component: News,\n      &#125;,\n      &#123;\n        path: &quot;message&quot;, &#x2F;&#x2F;此处一定不要写：&#x2F;message\n        component: Message,\n      &#125;,\n    ],\n  &#125;,\n];\n\n\n跳转（要写完整路径）：\n\n&lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;News&lt;&#x2F;router-link&gt;\n\n路由的参数传递参数&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;666&amp;title&#x3D;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;\n&lt;router-link\n  :to&#x3D;&quot;&#123;\n    path: &#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,\n    query: &#123;\n      id: 666,\n      title: &#39;你好&#39;,\n    &#125;,\n  &#125;&quot;\n&gt;跳转&lt;&#x2F;router-link&gt;\n\n接收参数$route.query.id;\n$route.query.title;\n\n命名路由\n可以简化路由的跳转。\n\n给路由命名&#123;\n\tpath:&#39;&#x2F;demo&#39;,\n\tcomponent:Demo,\n\tchildren:[\n\t\t&#123;\n\t\t\tpath:&#39;test&#39;,\n\t\t\tcomponent:Test,\n\t\t\tchildren:[\n\t\t\t\t&#123;\n                      name:&#39;hello&#39; &#x2F;&#x2F;给路由命名\n\t\t\t\t\tpath:&#39;welcome&#39;,\n\t\t\t\t\tcomponent:Hello,\n\t\t\t\t&#125;\n\t\t\t]\n\t\t&#125;\n\t]\n&#125;\n\n简化跳转&lt;!--简化前，需要写完整的路径 --&gt;\n&lt;router-link to&#x3D;&quot;&#x2F;demo&#x2F;test&#x2F;welcome&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n&lt;!--简化后，直接通过名字跳转 --&gt;\n&lt;router-link :to&#x3D;&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n&lt;!--简化写法配合传递参数 --&gt;\n&lt;router-link\n  :to&#x3D;&quot;&#123;\n\t\tname:&#39;hello&#39;,\n\t\tquery:&#123;\n\t\t   id:666,\n            title:&#39;你好&#39;\n\t\t&#125;\n\t&#125;&quot;\n  &gt;跳转&lt;&#x2F;router-link\n&gt;\n\n路由的 params 参数配置路由，声明接收 params 参数&#123;\n\tpath:&#39;&#x2F;home&#39;,\n\tcomponent:Home,\n\tchildren:[\n\t\t&#123;\n\t\t\tpath:&#39;news&#39;,\n\t\t\tcomponent:News\n\t\t&#125;,\n\t\t&#123;\n\t\t\tcomponent:Message,\n\t\t\tchildren:[\n\t\t\t\t&#123;\n\t\t\t\t\tname:&#39;xiangqing&#39;,\n\t\t\t\t\tpath:&#39;detail&#x2F;:id&#x2F;:title&#39;, &#x2F;&#x2F;使用占位符声明接收params参数\n\t\t\t\t\tcomponent:Detail\n\t\t\t\t&#125;\n\t\t\t]\n\t\t&#125;\n\t]\n&#125;\n\n传递参数&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;666&#x2F;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;\n&lt;router-link\n  :to&#x3D;&quot;&#123;\n\t\tname:&#39;xiangqing&#39;,\n\t\tparams:&#123;\n\t\t   id:666,\n            title:&#39;你好&#39;\n\t\t&#125;\n\t&#125;&quot;\n  &gt;跳转&lt;&#x2F;router-link\n&gt;\n\n接收参数$route.params.id;\n$route.params.title;\n\n路由的 props 配置\n作用：让路由组件更方便的收到参数\n\n&#123;\n\tname:&#39;xiangqing&#39;,\n\tpath:&#39;detail&#x2F;:id&#39;,\n\tcomponent:Detail,\n\n\t&#x2F;&#x2F;第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\n\t&#x2F;&#x2F; props:&#123;a:900&#125;\n\n\t&#x2F;&#x2F;第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\n\t&#x2F;&#x2F; props:true\n\n\t&#x2F;&#x2F;第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\n\tprops(route)&#123;\n\t\treturn &#123;\n\t\t\tid:route.query.id,\n\t\t\ttitle:route.query.title\n\t\t&#125;\n\t&#125;\n&#125;\n\n的 replace 属性\n作用：控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写入方式：分别为 push 和 replace，push 是追加历史记录，replace 是替换当前记录。路由跳转时候默认为 push\n如何开启 replace 模式：&lt;router-link replace …….&gt;News\n\n编程式路由导航&#x2F;&#x2F;$router的两个API\nthis.$router.push(&#123;\n  name: &quot;xiangqing&quot;,\n  params: &#123;\n    id: xxx,\n    title: xxx,\n  &#125;,\n&#125;);\n\nthis.$router.replace(&#123;\n  name: &quot;xiangqing&quot;,\n  params: &#123;\n    id: xxx,\n    title: xxx,\n  &#125;,\n&#125;);\nthis.$router.forward(); &#x2F;&#x2F;前进\nthis.$router.back(); &#x2F;&#x2F;后退\nthis.$router.go(); &#x2F;&#x2F;可前进也可后退\n\n缓存路由组件\n作用：让不展示的路由组件保持挂载，不被销毁。\n\n&lt;keep-alive include&#x3D;&quot;News&quot;&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n\n两个新的生命周期钩子\n作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n具体名字：\nactivated路由组件被激活时触发。\ndeactivated路由组件失活时触发。\n\n\n\n路由守卫\n作用：对路由进行权限控制\n分类：全局守卫、独享守卫、组件内守卫\n\n全局守卫&#x2F;&#x2F;全局前置守卫：初始化时执行、每次路由切换前执行\nrouter.beforeEach((to, from, next) &#x3D;&gt; &#123;\n  console.log(&quot;beforeEach&quot;, to, from);\n  if (to.meta.isAuth) &#123;\n    &#x2F;&#x2F;判断当前路由是否需要进行权限控制\n    if (localStorage.getItem(&quot;school&quot;) &#x3D;&#x3D;&#x3D; &quot;atguigu&quot;) &#123;\n      &#x2F;&#x2F;权限控制的具体规则\n      next(); &#x2F;&#x2F;放行\n    &#125; else &#123;\n      alert(&quot;暂无权限查看&quot;);\n      &#x2F;&#x2F; next(&#123;name:&#39;guanyu&#39;&#125;)\n    &#125;\n  &#125; else &#123;\n    next(); &#x2F;&#x2F;放行\n  &#125;\n&#125;);\n\n&#x2F;&#x2F;全局后置守卫：初始化时执行、每次路由切换后执行\nrouter.afterEach((to, from) &#x3D;&gt; &#123;\n  console.log(&quot;afterEach&quot;, to, from);\n  if (to.meta.title) &#123;\n    document.title &#x3D; to.meta.title; &#x2F;&#x2F;修改网页的title\n  &#125; else &#123;\n    document.title &#x3D; &quot;vue_test&quot;;\n  &#125;\n&#125;);\n\n独享守卫beforeEnter(to,from,next)&#123;\n\tconsole.log(&#39;beforeEnter&#39;,to,from)\n\tif(to.meta.isAuth)&#123; &#x2F;&#x2F;判断当前路由是否需要进行权限控制\n\t\tif(localStorage.getItem(&#39;school&#39;) &#x3D;&#x3D;&#x3D; &#39;atguigu&#39;)&#123;\n\t\t\tnext()\n\t\t&#125;else&#123;\n\t\t\talert(&#39;暂无权限查看&#39;)\n\t\t\t&#x2F;&#x2F; next(&#123;name:&#39;guanyu&#39;&#125;)\n\t\t&#125;\n\t&#125;else&#123;\n\t\tnext()\n\t&#125;\n&#125;\n\n组件内守卫&#x2F;&#x2F;进入守卫：通过路由规则，进入该组件时被调用\nbeforeRouteEnter (to, from, next) &#123;\n&#125;,\n&#x2F;&#x2F;离开守卫：通过路由规则，离开该组件时被调用\nbeforeRouteLeave (to, from, next) &#123;\n&#125;\n\n路由的两种工作模式\n对于一个 url 来说，什么是 hash 值？—— #及其后面的内容就是 hash 值。\nhash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。\nhash 模式：\n地址中永远带着#号，不美观 。\n若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。\n兼容性较好。\n\n\nhistory 模式：\n地址干净，美观 。\n兼容性和 hash 模式相比略差。\n应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题\n\n\n\n","slug":"vue-router","date":"2023-03-21T15:26:07.000Z","categories_index":"Tecnology,Vue","tags_index":"tecnology","author_index":"X-29"},{"id":"6a13b89bc1d9db16e3bd75ad19728f7b","title":"Pinia","content":"介绍但 Pinia 适用于 Vue 2 和 Vue 3 ，并且不需要您使用组合 API。\nBenefit\n开发工具支持\n跟踪操作、突变的时间表\n商店出现在使用它们的组件中\n时间旅行和更容易的调试\n\n\n热模块更换\n无需重新加载页面即可修改您的商店\n在开发时保持任何现有状态\n\n\n为 JS 用户提供适当的 TypeScript 支持或自动补全\n服务器端渲染支持\n\n与 VueX ≤ 4 对比\nMutation不再存在。他们经常被认为非常冗长。他们最初带来了 devtools 集成，但这不再是问题。\n无需创建自定义的复杂包装器来支持TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能地利用 TS 类型推断。\n不再需要注入、导入函数、调用它们，享受自动补全！\n无需动态添加store，默认情况下它们都是动态的\n不再有模块的嵌套结构。您仍然可以通过在另一个store中导入和使用store来隐式嵌套store\n\n安装yarn add pinia\n&#x2F;&#x2F; or with npm\nnpm install pinia\n\n\n\n\n\n\n\n\n\n\n如果使用的是Vue2，但还是想用 pinia，就要npm install @vue/composition-api\n项目引入Vue2import &#123; createPinia, PiniaVuePlugin &#125; from &#39;pinia&#39;\n\nVue.use(PiniaVuePlugin)\nconst pinia &#x3D; createPinia()\n\nnew Vue(&#123;\n  el: &#39;#app&#39;,\n  &#x2F;&#x2F; other options...\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F; note the same &#96;pinia&#96; instance can be used across multiple Vue apps on\n  &#x2F;&#x2F; the same page\n  pinia,\n&#125;)\n\nVue3import &#123; createPinia &#125; from &#39;pinia&#39;\n\napp.use(createPinia())\n\n核心概念Pinia 中的 Store 是一个保存状态和业务逻辑的实体，它不绑定到你的组件树。换句话说，它承载全局 state。它有点像一个始终存在的组件，每个人都可以读取和写入。它有三个概念，state, getters and actions可以看作为Vue2中的data()&#123;return&#123;&#125;&#125;、Computed()、Methods相对应\n具体实例运用在 Store&#x2F;index.js 中\n\n具体写法代码\nimport &#123; defineStore &#125; from &#39;pinia&#39;\n\n&#x2F;*  useStore could be anything like useUser, useCart\n [以use开头命名接收【defineStore】的返回值的变量] *&#x2F;\n&#x2F;* the first argument is a unique id of the store across your application\n[【defineStore】函数中需要放入的第一个参数必须是唯一的名字在当前的所有项目中，起到了一个ID的作用] *&#x2F;\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n&#x2F;* 第一种：以options的方式使用 *&#x2F;\n    &#x2F;&#x2F;推荐箭头函数的形式，有利于TypeScript推断变量类型\n      state:() &#x3D;&gt;&#123;\n        return&#123;\n            age:30\n        &#125;\n    &#125;,\n    getters:&#123;\n        ageComputed(state)&#123;\n            return state.age + 5\n        &#125;\n    &#125;,\n    actions:&#123;\n        ageMethod()&#123;\n            this.age +&#x3D; 5\n        &#125;\n    &#125;\n&#125;)\n&#x2F;* 第一种：以options的方式使用 *&#x2F;\n\n&#x2F;* 第二种：以setup()&#123;&#125;的方式使用 *&#x2F;\nexport const useConterStore &#x3D; defineStore(&#39;countStore&#39;,()&#x3D;&gt;&#123;\n    const counter &#x3D; ref(30)\n    const getterCounter &#x3D; computed(()&#x3D;&gt;&#123;\n        return counter.value + 5\n    &#125;)\n    const addCounter &#x3D; () &#x3D;&gt;&#123;\n        counter.value +&#x3D; 5\n    &#125;\n    return&#123;\n        counter,\n        getterCounter,\n        addCounter\n    &#125;\n&#125;)\n&#x2F;* 第二种：以setup()&#123;&#125;的方式使用 *&#x2F;\n\n\n\n可以根据需要定义任意数量的商店，并且您应该在不同的文件中定义每个商店以充分利用 pinia\n一旦商店被实例化，你可以访问定义的任何财产state，getters以及actions直接在店里。\n直接解构赋值是不被允许的需要借助storeToRefs()\n\n\n\n\n\n\n\n\n\n\n为了保证结构之后仍具有响应式数据的特点需要用到storeToRefs()\n&lt;script setup&gt;\n  import &#123; storeToRefs &#125; from &#39;pinia&#39;;\n  import &#123; useStore &#125; from &#39;&#x2F;Stroes&#x2F;index.js&#39;\n\n  const store &#x3D; useStore();\n  const &#123; name, doubleCount &#125; &#x3D; storeToRefs(store);\n&lt;&#x2F;script&gt;\n\nState定义state是store的核心部分在 Pinia 中，state被定义为返回初始状态的函数。这样Pinia 在服务器端和客户端都工作。使用箭头函数返回状态 更好的有利于TypeScript进行 类型推断\nimport &#123; defineStore &#125; from &#39;pinia&#39;\n\nconst useStore &#x3D; defineStore(&#39;storeId&#39;, &#123;\n  &#x2F;&#x2F; arrow function recommended for full type inference\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      &#x2F;&#x2F; all these properties will have their type inferred automatically\n      counter: 0,\n      name: &#39;Eduardo&#39;,\n      isAdmin: true,\n    &#125;\n  &#125;,\n&#125;)\n\n访问State[setup]import &#123; useUserStore &#125; from &#39;@&#x2F;stores&#x2F;user&#39;\nimport &#123; computed &#125; from &#39;vue&#39;\nimport &#123; storeToRefs &#125; from &#39;pinia&#39;\n&#x2F;&#x2F; 方式1,计算属性方式\nconst userid &#x3D; computed(() &#x3D;&gt; useUserStore().userid)\n&#x2F;&#x2F; 方式2, 通过user.userid的方式使用\nconst user &#x3D; useUserStore()\n&#x2F;&#x2F; 方式3, 使用toRef获取userid\nconst userid &#x3D; toRef(useUserStore(), &#39;userid&#39;)\n&#x2F;&#x2F; 方式4, 借助pinia提供的api: storeToRefs 实现\nconst &#123; userid &#125; &#x3D; storeToRefs(useUserStore())\n\n\n重置状态通过调用store 上的方法将状态重置为其初始值$reset()：\nconst store &#x3D; useStore()\n\nstore.$reset()\n\n修改状态[setup]import &#123; useUserStore &#125; from &#39;@&#x2F;stores&#x2F;user&#39;\n\nconst user &#x3D; useUserStore()\n&#x2F;&#x2F; 方式1: 直接修改,vuex不允许这种方式(需要提交mutation),但pinia是允许的\nuser.userid &#x3D; &#39;xxx&#39;\n&#x2F;&#x2F; 方式2: \nuser.$patch(&#123;userid: &#39;xxx&#39;&#125;)\n&#x2F;&#x2F; 方式3: \nuser.$patch((state) &#x3D;&gt; &#123; state.userid &#x3D; &#39;xxx&#39; &#125;)\n&#x2F;&#x2F; 方式4:\nuser.$state &#x3D; &#123; userid:&#39;xxx&#39; &#125;\n&#x2F;&#x2F; 方式5: 使用actions\nuser.setUserId(&#39;xxx&#39;)\n\nActions\n像getters ，actions行动可以访问到整个存储实例 通过this与全类型（和自动完成✨）的支持。\n与它们不同，actions可以是异步的，您可以await在它们内部进行任何 API 调用甚至其他操作！\n\n访问其他store中的acttionimport &#123; useAuthStore &#125; from &#39;.&#x2F;auth-store&#39;\n\nexport const useSettingsStore &#x3D; defineStore(&#39;settings&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    &#x2F;&#x2F; ...\n  &#125;),\n  actions: &#123;\n    async fetchUserPreferences(preferences) &#123;\n      const auth &#x3D; useAuthStore()\n      if (auth.isAuthenticated) &#123;\n        this.preferences &#x3D; await fetchPreferences()\n      &#125; else &#123;\n        throw new Error(&#39;User must be authenticated&#39;)\n      &#125;\n    &#125;,\n  &#125;,\n&#125;)\n\nGetter\n接收 “state” 作为第一个参数 state: () &#x3D;&gt; (&#123;\n  userid: localStorage.getItem(&#39;userid&#39;) || &#39;&#39;,\n  counter: 0\n&#125;),\ngetters: &#123;\n  doubleCount: (state) &#x3D;&gt; state.counter * 2,\n&#125;,\n\n常规函数使用this的注意事项\n\n\n\n\n\n\n\n\n定义常规函数时可以通过 this 访问到 整个 store 的实例, 但是需要定义返回类型（在 TypeScript 中）。 这是由于 TypeScript 中的一个已知限制，并且不会影响使用箭头函数定义的 getter，也不会影响不使用 this 的 getter： \nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0,\n  &#125;),\n  getters: &#123;\n    &#x2F;&#x2F; 自动将返回类型推断为数字\n    doubleCount(state) &#123;\n      return state.counter * 2\n    &#125;,\n    &#x2F;&#x2F; 返回类型必须明确设置\n    doublePlusOne() &#123;\n      &#x2F;&#x2F; 调用其他getter: \n      return this.doubleCount + 1\n      &#x2F;&#x2F; 等同于:\n      return this.counter * 2 + 1\n    &#125;,\n  &#125;,\n&#125;)\n\n接收参数传递(不常用)\nGetters 只是幕后的 computed 属性，因此无法向它们传递任何参数。 但是，您可以从 getter 返回一个函数以接受任何参数： \n这种操作getter不再缓存，只相当于在调用函数(从store 的解构中可以看出):::details Exampleexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  getters: &#123;\n    getUserById: (state) &#x3D;&gt; &#123;\n      return (userId) &#x3D;&gt; state.users.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId)\n    &#125;,\n  &#125;,\n&#125;)\n\n组件中&#x2F;&#x2F; store\ngetters: &#123;\n  doubleCount: (state) &#x3D;&gt; state.counter * 2,\n  doublePlusOne(): number &#123;\n    &#x2F;&#x2F; 等同于调用其他getter: return this.doubleCount + 1\n    return this.counter * 2 + 1\n  &#125;,\n  payloadCount() &#123;\n    return (payload) &#x3D;&gt; this.doublePlusOne + payload\n  &#125;\n&#125;,\n\n&#x2F;&#x2F; 组件\nconst &#123; userid, payloadCount &#125; &#x3D; storeToRefs(user)\n:::\nStore中的其他API$reset 重置状态store.$reset()\n&#x2F;&#x2F; PS: Setup 方式的 Store 不支持 $reset\n\n$state 访问 store 状态conosle.log(store.$state)\n\nstore.$state &#x3D; &#123; counter: 666, name: &#39;Paimon&#39; &#125;\n$onAction 监听 action 触发\nExample\nconst unsubscribe &#x3D; someStore.$onAction(\n  (&#123;\n    name, &#x2F;&#x2F; action 名称\n    store, &#x2F;&#x2F; store 实例，类似 &#96;someStore&#96;\n    args, &#x2F;&#x2F; 传递给 action 的参数数组\n    after, &#x2F;&#x2F; 在 action 返回或解决后的钩子\n    onError, &#x2F;&#x2F; action 抛出或拒绝的钩子\n  &#125;) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 为这个特定的 action 调用提供一个共享变量\n    const startTime &#x3D; Date.now()\n    &#x2F;&#x2F; 这将在执行 &quot;store &quot;的 action 之前触发。\n    console.log(&#96;Start &quot;$&#123;name&#125;&quot; with params [$&#123;args.join(&#39;, &#39;)&#125;].&#96;)\n\n    &#x2F;&#x2F; 这将在 action 成功并完全运行后触发。\n    &#x2F;&#x2F; 它等待着任何返回的 promise\n    after((result) &#x3D;&gt; &#123;\n      console.log(\n        &#96;Finished &quot;$&#123;name&#125;&quot; after $&#123;\n          Date.now() - startTime\n        &#125;ms.\\nResult: $&#123;result&#125;.&#96;\n      )\n    &#125;)\n\n    &#x2F;&#x2F; 如果 action 抛出或返回一个拒绝的 promise，这将触发\n    onError((error) &#x3D;&gt; &#123;\n      console.warn(\n        &#96;Failed &quot;$&#123;name&#125;&quot; after $&#123;Date.now() - startTime&#125;ms.\\nError: $&#123;error&#125;.&#96;\n      )\n    &#125;)\n  &#125;\n)\n\n&#x2F;&#x2F; 手动删除监听器\nunsubscribe()\n\n\n插件由于有了底层 API 的支持，Pinia store 现在完全支持扩展。以下是你可以扩展的内容：\n\n为 store 添加新的属性\n定义 store 时增加新的选项\n为 store 增加新的方法\n包装现有的方法\n改变甚至取消 action\n实现副作用，如本地存储\n仅应用插件于特定 store\n\n插件是通过 pinia.use() 添加到 pinia 实例的。最简单的例子是通过返回一个对象将一个静态属性添加到所有 store。\nimport &#123; createPinia &#125; from &#39;pinia&#39;\n\n&#x2F;&#x2F; 在安装此插件后创建的每个 store 中都会添加一个名为 &#96;secret&#96; 的属性。\n&#x2F;&#x2F; 插件可以保存在不同的文件中\nfunction SecretPiniaPlugin() &#123;\n  return &#123; secret: &#39;the cake is a lie&#39; &#125;\n&#125;\n\nconst pinia &#x3D; createPinia()\n&#x2F;&#x2F; 将该插件交给 Pinia\npinia.use(SecretPiniaPlugin)\n\n&#x2F;&#x2F; 在另一个文件中\nconst store &#x3D; useStore()\nstore.secret &#x2F;&#x2F; &#39;the cake is a lie&#39;\n\n\n简介Pinia 插件是一个函数，可以选择性地返回要添加到 store 的属性。它接收一个可选参数，即 context。\nexport function myPiniaPlugin(context) &#123;\n  context.pinia &#x2F;&#x2F; 用 &#96;createPinia()&#96; 创建的 pinia。 \n  context.app &#x2F;&#x2F; 用 &#96;createApp()&#96; 创建的当前应用(仅 Vue 3)。\n  context.store &#x2F;&#x2F; 该插件想扩展的 store\n  context.options &#x2F;&#x2F; 定义传给 &#96;defineStore()&#96; 的 store 的可选对象。\n  &#x2F;&#x2F; ...\n&#125;\n\n然后用 pinia.use() 将这个函数传给 pinia：\npinia.use(myPiniaPlugin)\n\n\n持久化存储function persistenceStatePlugin(context) &#123;\n  const &#123; store &#125; &#x3D; context;\n  const storage &#x3D; localStorage.getItem(&quot;pinia&quot;)\n    ? JSON.parse(localStorage.getItem(&quot;pinia&quot;))\n    : null;\n  \n  if (storage) &#123;\n    store.$patch(storage[store.$id]);\n  &#125;\n\n  store.$subscribe((mutation, state) &#x3D;&gt; &#123;\n    const storage &#x3D; localStorage.getItem(&quot;pinia&quot;)\n      ? JSON.parse(localStorage.getItem(&quot;pinia&quot;))\n      : &#123;&#125;;\n    storage[store.$id] &#x3D; state;\n    localStorage.setItem(&quot;pinia&quot;, JSON.stringify(storage));\n  &#125;);\n&#125;\n\n","slug":"pinia","date":"2023-03-21T15:21:53.000Z","categories_index":"Tecnology,Gadgets","tags_index":"tecnology","author_index":"X-29"},{"id":"0aaa27c48e7b40c2bc96b31fb70803da","title":"TypeScript","content":"TS 简介\nTypeScript 是 JavaScript 的超集。\n它对 JS 进行了扩展，向 JS 中引入了类型的概念，并添加了许多新的特性。\nTS 代码需要通过编译器编译为 JS，然后再交由 JS 解析器执行。\nTS 完全兼容 JS，换言之，任何的 JS 代码都可以直接当成 JS 使用。\n相较于 JS 而言，TS 拥有了静态类型，更加严格的语法，更强大的功能；TS 可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS 代码可以编译为任意版本的 JS 代码，可有效解决不同 JS 运行环境的兼容问题；同样的功能，TS 的代码量要大于 JS，但由于 TS 的代码结构更加清晰，变量类型更加明确，在后期代码的维护中 TS 却远远胜于 JS。\n\n开发环境搭建单文件\n下载 Node.js○ 64 位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi○ 32 位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi\n\n安装 Node.js\n\n使用 npm 全局安装 typescript○ 进入命令行○ 输入：npm i -g typescript\n\n创建一个 ts 文件\n\n使用 tsc 对 ts 文件进行编译○ 进入命令行○ 进入 ts 文件所在目录○ 执行命令：tsc xxx.ts\n\n\n脚手架直接内置，无需多管\n基本类型类型声明类型声明给变量设置了类型，使得变量只能存储某种类型的值语法：\nlet 变量: 类型;\n\nlet 变量: 类型 &#x3D; 值;\n\nfunction fn(参数: 类型, 参数: 类型): 类型&#123;\n    ...\n&#125;\n\n\n\n\n类型\n例子\n描述\n\n\n\nnumber\n1, -33, 2.5\n任意数字\n\n\nstring\n‘hi’, “hi”, hi\n任意字符串\n\n\nboolean\ntrue、false\n布尔值 true 或 false\n\n\n字面量\n其本身\n限制变量的值就是该字面量的值\n\n\nany\n*\n任意类型\n\n\nunknown\n*\n类型安全的 any\n\n\nvoid\n空值（undefined）\n没有值（或 undefined）\n\n\nnever\n没有值\n不能是任何值\n\n\nobject\n{name:’孙悟空’}\n任意的 JS 对象\n\n\narray\n[1,2,3]\n任意 JS 数组\n\n\ntuple\n[4,5]\n元素，TS 新增类型，固定长度数组\n\n\nenum\nenum{A, B}\n枚举，TS 中新增类型\n\n\nNumber\n\nClick to see more\nlet decimal: number &#x3D; 6;\nlet hex: number &#x3D; 0xf00d;\nlet binary: number &#x3D; 0b1010;\nlet octal: number &#x3D; 0o744;\nlet big: bigint &#x3D; 100n;\n\n\n\nBoolean\n\nClick to see more\nlet isDone: boolean &#x3D; false;\n\n\n\nString\n\nClick to see more\nlet color: string &#x3D; &quot;blue&quot;;\ncolor &#x3D; &#39;red&#39;;\n\nlet fullName: string &#x3D; &#96;Bob Bobbington&#96;;\nlet age: number &#x3D; 37;\nlet sentence: string &#x3D; &#96;Hello, my name is $&#123;fullName&#125;.\n\nI&#39;ll be $&#123;age + 1&#125; years old next month.&#96;;\n\n\n\n字面量\n\nClick to see more\n\n言外之意取值只能从规定的几个里面取let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;\n\n\n\nAny\n\nClick to see more\n\n相当于变成JavaScriptlet color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;\n\n\n\nUnknown\n\nClick to see more\nlet notSure: unknown &#x3D; 4;\nnotSure &#x3D; &#39;hello&#39;;\n\n\n\nvoid\n\nClick to see more\nlet unusable: void &#x3D; undefined;\n\n\n\nNever\n\nClick to see more\nfunction error(message: string): never &#123;\n  throw new Error(message);\n&#125;\n\n\n\nObject\n\nClick to see more\nlet obj: object &#x3D; &#123;&#125;;\n\n\nArray\n\nClick to see more\nlet list: number[] &#x3D; [1, 2, 3];\nlet list: Array&lt;number&gt; &#x3D; [1, 2, 3];\n\n\nTuple\n\nClick to see more\nlet x: [string, number];\nx &#x3D; [&quot;hello&quot;, 10];\n\n\nEnum\n\n枚举（Enum）类型用于取值被限定在一定范围内的场景\n\n枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射\n\n如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉\n\n除了普通枚举，还有常量枚举、外部枚举等\n\n枚举成员只读，不可修改\n\n普通枚举：做了反向映射，可双向访问，会编译到JS代码中；使用场景：状态的判断、状态码\n\n字符串枚举：枚举的是字符串\n\n常量枚举：不会被编译到JS中。使用场景：如果某个变量你确定只有几种值，那么就可以使用常枚举去规定，超出规定就会提示报错；\n\n\n\nClick to see more\n\n相当于变成JavaScript&#x2F;&#x2F; 普通枚举 | 数字枚举\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; true\nconsole.log(Days[0] &#x3D;&#x3D;&#x3D; &quot;Sun&quot;); &#x2F;&#x2F; true\nenum Color &#123;\n  Red, &#x2F;&#x2F; 0\n  Green, &#x2F;&#x2F; 1\n  Blue, &#x2F;&#x2F; 2\n&#125;\nenum Color &#123;\n  Red &#x3D; 1, &#x2F;&#x2F; 1\n  Green &#x3D; 7, &#x2F;&#x2F; 7\n  Blue, &#x2F;&#x2F; 8\n&#125;\nenum Color &#123;\n  Red &#x3D; 1,\n  Green &#x3D; 2,\n  Blue &#x3D; 4,\n&#125;\nenum Demo &#123;\n    &#x2F;&#x2F; const\n    a,                  &#x2F;&#x2F; 没有初始值\n    b &#x3D; Demo.a,         &#x2F;&#x2F; 对已有枚举成员的引用\n    c &#x3D; 1 + 2,          &#x2F;&#x2F; 常量的表达式\n    &#x2F;&#x2F; computed\n    d &#x3D; Math.random(),  &#x2F;&#x2F; 需要被计算的枚举成员\n    e &#x3D; &#39;abc&#39;.length    &#x2F;&#x2F; 需要被计算的枚举成员\n&#125;\n&#x2F;&#x2F; 字符串枚举\nenum orderStatusDesc &#123;\n    UN_PAYED &#x3D; &#39;未支付&#39;,\n    PAYED &#x3D; &#39;已支付&#39;,\n    CANCELED &#x3D; &#39;已取消&#39;,\n    CLOSED &#x3D; &#39;已关闭&#39;\n&#125;\n&#x2F;&#x2F; 常量枚举\nconst enum Month &#123;\n    Jan,\n    Feb,\n    Mar\n&#125;\n&#x2F;&#x2F; 异构枚举：字符串与数字枚举混合，不推荐\nenum Status&#123;\n    UN_PAYED,\n    PAYED &#x3D; &#39;已支付&#39;\n&#125;\n:::\n\n类型断言有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型\n第一种\nlet someValue: unknown &#x3D; &quot;this is a string&quot;;\nlet strLength: number &#x3D; (someValue as string).length;\n\n第二种\nlet someValue: unknown &#x3D; &quot;this is a string&quot;;\nlet strLength: number &#x3D; (&lt;string&gt;someValue).length;\n\n\n编译选项\n自动监视文件并编译：tsc xxx.ts -w \n自动编译整个项目：tsc\n\n:::details tsconfig.json文件配置\n&#x2F;&#x2F; tsconfig.json\n&#123;\n  &quot;files&quot;: [&quot;src&#x2F;a.ts&quot;], &#x2F;&#x2F; 需要编译的单个文件列表\n  &quot;include&quot;: [&quot;src&#x2F;*&quot;], &#x2F;&#x2F; 编译某个文件夹下的一级所有文件\n  &quot;exclude&quot;: [&quot;src&#x2F;lib&quot;], &#x2F;&#x2F; 需要排除的文件、文件夹\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base&quot;, &#x2F;&#x2F; 需继承的配置文件tsconfig.base.json\n  &quot;compileOnSave&quot;: true, &#x2F;&#x2F;保存文件的时候自动编译，但当前vscode不支持\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; 增量编译，第一次编译生成一个文件，使得第二次编译速度会提高\n    &quot;tsBuildInfoFile&quot;: &quot;.tsbuildinfo&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n    &quot;module&quot;: &quot;commonjs&quot;, &#x2F;&#x2F; 生成代码的模块标准\n    &quot;target&quot;: &quot;ES3&quot;, &#x2F;&#x2F; 生成代码目标语言的版本\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可用在AMD模块中\n    &quot;lib&quot;: [], &#x2F;&#x2F; ts需要引用的库，即声明文件，target&#x3D;es5则默认引用dom, es5,scripthost\n    &quot;allowJs&quot;: true, &#x2F;&#x2F; 允许编译JS文件\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 与allowJs配合使用，对JS文件进行语法检查\n    &quot;outDir&quot;: &quot;.&#x2F;out&quot;, &#x2F;&#x2F; 指定输出目录\n    &quot;rootDir&quot;: &quot;.&#x2F;src&quot;, &#x2F;&#x2F; 指定输入文件目录\n    &quot;declaration&quot;: false, &#x2F;&#x2F; 生成声明文件\n    &quot;declarationDir&quot;: &quot;.&#x2F;d&quot;, &#x2F;&#x2F; 声明文件的路径\n    &quot;emitDeclarationOnly&quot;: false, &#x2F;&#x2F; 只生成声明文件\n    &quot;sourceMap&quot;: false, &#x2F;&#x2F; 生成目标文件的sourceMap\n    &quot;inlineSourceMap&quot;: false, &#x2F;&#x2F; 生成目标文件的inlineSourceMap\n    &quot;declarationMap&quot;: false, &#x2F;&#x2F; 生成目标文件的declarationMap\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认node_modules&#x2F;@types\n    &quot;types&quot;: [], &#x2F;&#x2F; 声明文件包\n    &quot;removeComments&quot;: false, &#x2F;&#x2F; 删除注释\n    &quot;noEmit&quot;: false, &#x2F;&#x2F; 不输出文件\n    &quot;noEmitOnError&quot;: false, &#x2F;&#x2F; 发生错误时不输出文件\n    &quot;noEmitHelpers&quot;: false, &#x2F;&#x2F; 不生成helper函数，需额外安装ts-helpers\n    &quot;importHelpers&quot;: false, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n    &quot;downlevelIteration&quot;: false, &#x2F;&#x2F; 降级遍历器的实现(es3&#x2F;5)\n    &quot;strict&quot;: false, &#x2F;&#x2F; 开启所有严格的类型检查\n    &quot;alwaysStrict&quot;: false, &#x2F;&#x2F; 在代码中注入&quot;use strict&quot;\n    &quot;noImplicitAny&quot;: false, &#x2F;&#x2F; 不允许隐式的any类型\n    &quot;strictNullChecks&quot;: false, &#x2F;&#x2F; 不允许把null、undefined赋值给其它类型变量\n    &quot;strictFunctionTypes&quot;: false, &#x2F;&#x2F; 不允许函数参数双向协变\n    &quot;strictPropertyInitialization&quot;: false, &#x2F;&#x2F; 类的实例属性必须初始化\n    &quot;strictBindCallApply&quot;: false, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n    &quot;noImplicitThis&quot;: false, &#x2F;&#x2F; 不允许this有隐式的any类型\n    &quot;noUnusedLocals&quot;: false, &#x2F;&#x2F; 检查只声明，未使用的局部变量\n    &quot;noUnusedParameters&quot;: false, &#x2F;&#x2F; 检查未使用的函数参数\n    &quot;noFallthroughCasesInSwitch&quot;: false, &#x2F;&#x2F; 防止Switch语句贯穿\n    &quot;noImplicitReturns&quot;: false, &#x2F;&#x2F; 每个分支都要有返回值\n    &quot;esModuleInterop&quot;: false, &#x2F;&#x2F; 允许export &#x3D; 导出，由import from导入\n    &quot;allowUmdGlobalAccess&quot;: false, &#x2F;&#x2F; 允许在模块中访问UMD全局变量\n    &quot;moduleResolution&quot;: &quot;classic&quot;, &#x2F;&#x2F; 模块解析策略\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址\n    &quot;paths&quot;: &#123;&#125;, &#x2F;&#x2F; 路径映射，相对于baseUrl\n    &quot;rootDirs&quot;: [], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时\n    &quot;listEmittedFiles&quot;: false, &#x2F;&#x2F; 打印输出的文件\n    &quot;listFiles&quot;: false &#x2F;&#x2F; 打印编译的文件（包括引用的声明文件）\n  &#125;\n&#125;\n\n\n\n如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。 \n但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json \ntsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc -\n\n","slug":"TypeScript","date":"2023-03-05T04:07:57.000Z","categories_index":"Tecnology,Gadgets","tags_index":"tecnology","author_index":"X-29"},{"id":"3a4eda1192ec992162144e15ab7e2ec5","title":"Vue3","content":"创建工程使用 vite\n\n\n\n\n\n\n\n\n创建工程npm init vite-app 进入工程目录cd 安装依赖npm install运行npm run dev\n常用的 Composition Apisetup()setup 函数的两种返回值：\n\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。\n若返回一个渲染函数：则可以自定义渲染内容。\n\nPay Attention!\n\n尽量不要与 Vue2.x 配置混用 Vue2.x 配置（data、methos、computed…）中可以访问到 setup 中的属性、方法。\n但在 setup 中不能访问到 Vue2.x 配置（data、methos、computed…）\n如果有重名, setup 优先。\nsetup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）\nsetup 执行的时机：在 beforeCreate 之前执行一次，this 是 undefined。\n\n\n\n\n\n\n\n\nWARNING\n  setup 的参数\n\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\ncontext：上下文对象\nattrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs。\nslots: 收到的插槽内容, 相当于 this.$slots。\nemit: 分发自定义事件的函数, 相当于 this.$emit。\n\n\n\nref()作用: 定义一个响应式的数据语法:\n\nconst xxx &#x3D; ref(initValue)\n创建一个包含响应式数据的引用对象（reference 对象，简称 ref 对象）。\nJS 中操作数据： xxx.value\n模板中读取数据: 不需要.value，直接：备注：\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠 Object.defineProperty()的 get 与 set 完成的。\n对象类型的数据：内部 “ 求助 ” 了 Vue3.0 中的一个新函数—— reactive 函数。\n\nreactive()作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用 ref 函数）语法：\n\nconst 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 proxy 对象）\nreactive 定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n不常用的 Composition ApitoRef()作用：\n\n创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。语法：\nconst name &#x3D; toRef(person,’name’)应用:\n要将响应式对象中的某个属性单独提供给外部使用时。扩展：\ntoRefs 与 toRef 功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n\nshallowReactive() 与 shallowRef()shallowReactive：\n\n只处理对象最外层属性的响应式（浅响应式）。\n\nshallowRef：\n\n只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n什么时候使用?\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。\nreadonly() 与 shallowReadonly()readonly:\n\n让一个响应式数据变为只读的（深只读）。shallowReadonly：\n让一个响应式数据变为只读的（浅只读）。应用场景: 不希望数据被修改时。\n\ntoRaw() 与 markRaw()toRaw：作用：\n\n将一个由 reactive 生成的响应式对象转为普通对象。使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。markRaw：作用：\n标记一个对象，使其永远不会再成为响应式对象。应用场景:有些值不应被设置为响应式的，例如复杂的第三方类库等。当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\ncustomRef()作用：\n\n创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。Example↓\n\n实现输入框的防抖&lt;template&gt;\n\t&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;keyword&quot;&gt;\n\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;&#x2F;h3&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n\timport &#123;ref,customRef&#125; from &#39;vue&#39;\n\texport default &#123;\n\t\tname:&#39;Demo&#39;,\n\t\tsetup()&#123;\n\t\t\t&#x2F;&#x2F; let keyword &#x3D; ref(&#39;hello&#39;) &#x2F;&#x2F;使用Vue准备好的内置ref\n\t\t\t&#x2F;&#x2F;自定义一个myRef\n\t\t\tfunction myRef(value,delay)&#123;\n\t\t\t\tlet timer\n\t\t\t\t&#x2F;&#x2F;通过customRef去实现自定义\n\t\t\t\treturn customRef((track,trigger)&#x3D;&gt;&#123;\n\t\t\t\t\treturn&#123;\n\t\t\t\t\t\tget()&#123;\n\t\t\t\t\t\t\ttrack() &#x2F;&#x2F;告诉Vue这个value值是需要被“追踪”的\n\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\tset(newValue)&#123;\n\t\t\t\t\t\t\tclearTimeout(timer)\n\t\t\t\t\t\t\ttimer &#x3D; setTimeout(()&#x3D;&gt;&#123;\n\t\t\t\t\t\t\t\tvalue &#x3D; newValue\n\t\t\t\t\t\t\t\ttrigger() &#x2F;&#x2F;告诉Vue去更新界面\n\t\t\t\t\t\t\t&#125;,delay)\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;)\n\t\t\t&#125;\n\t\t\tlet keyword &#x3D; myRef(&#39;hello&#39;,500) &#x2F;&#x2F;使用程序员自定义的ref\n\t\t\treturn &#123;\n\t\t\t\tkeyword\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&lt;&#x2F;script&gt;\n\n检测型 ApiisRef:\n\n检查一个值是否为一个 ref 对象isReactive:\n检查一个对象是否是由 reactive 创建的响应式代理isReadonly:\n检查一个对象是否是由 readonly 创建的只读代理isProxy:\n检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\nComputed &amp; Watch &amp; WatchEffectComputed写法如下：\nimport &#123;computed&#125; from &#39;vue&#39;\n\nsetup()&#123;\n    ...\n\t&#x2F;&#x2F;计算属性——简写\n    let fullName &#x3D; computed(()&#x3D;&gt;&#123;\n        return person.firstName + &#39;-&#39; + person.lastName\n    &#125;)\n    &#x2F;&#x2F;计算属性——完整\n    let fullName &#x3D; computed(&#123;\n        get()&#123;\n            return person.firstName + &#39;-&#39; + person.lastName\n        &#125;,\n        set(value)&#123;\n            const nameArr &#x3D; value.split(&#39;-&#39;)\n            person.firstName &#x3D; nameArr[0]\n            person.lastName &#x3D; nameArr[1]\n        &#125;\n    &#125;)\n&#125;\n\nWatch\n\n\n\n\n\n\nWARNING\n监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。\n\n&#x2F;&#x2F;情况一：监视ref定义的响应式数据\nwatch(\n  sum,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;sum变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true &#125;\n);\n\n&#x2F;&#x2F;情况二：监视多个ref定义的响应式数据\nwatch([sum, msg], (newValue, oldValue) &#x3D;&gt; &#123;\n  console.log(&quot;sum或msg变化了&quot;, newValue, oldValue);\n&#125;);\n\n&#x2F;* 情况三：监视reactive定义的响应式数据\n\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\n\t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 \n*&#x2F;\nwatch(\n  person,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: false &#125;\n); &#x2F;&#x2F;此处的deep配置不再奏效\n\n&#x2F;&#x2F;情况四：监视reactive定义的响应式数据中的某个属性\nwatch(\n  () &#x3D;&gt; person.job,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: true &#125;\n);\n\n&#x2F;&#x2F;情况五：监视reactive定义的响应式数据中的某些属性\nwatch(\n  [() &#x3D;&gt; person.job, () &#x3D;&gt; person.name],\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: true &#125;\n);\n\n&#x2F;&#x2F;特殊情况\nwatch(\n  () &#x3D;&gt; person.job,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; deep: true &#125;\n); &#x2F;&#x2F;此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\nWatchEffectwatch 的套路是：\n\n既要指明监视的属性，也要指明监视的回调。\n\nwatchEffect 的套路是：\n\n不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\nwatchEffect 有点像 computed：\n\n但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n&#x2F;&#x2F;watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\nwatchEffect(() &#x3D;&gt; &#123;\n  const x1 &#x3D; sum.value;\n  const x2 &#x3D; person.age;\n  console.log(&quot;watchEffect配置的回调执行了&quot;);\n&#125;);\n\n生命周期mounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMountedbeforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdateupdated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdatedbeforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmountunmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmountedbeforeCreate&#x3D;&#x3D;&#x3D;&gt;setup()created&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup()\n自定义 Hook 函数\n什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。\n类似于 vue2.x 中的 mixin。\n自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。\n\n好用的传值provide 与 inject作用：\n\n实现祖与后代组件间通信套路：\n父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据,其实子组件可以用，但是 prop 更简单，别给自己找麻烦\n\n具体写法——祖组件setup()&#123;\n    ......\n    let car &#x3D; reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)\n    provide(&#39;car&#39;,car)\n    ......\n&#125;\n\n具体写法——后代组件setup(props,context)&#123;\n    ......\n    const car &#x3D; inject(&#39;car&#39;)\n    return &#123;car&#125;\n    ......\n&#125;\n\n新的组件&#x2F;标签Fragment\n\n在 Vue2 中: 组件必须有一个根标签\n在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\nTeleport一种能够将我们的组件 html 结构移动到指定位置的技术。无视所在盒子的 position，指哪打哪，其中“to”属性就是告诉代码依托于谁定位\nExample&lt;teleport to&#x3D;&quot;body&quot;&gt;\n\t&lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;dialog&quot;&gt;\n\t\t\t&lt;h3&gt;我是一个弹窗&lt;&#x2F;h3&gt;\n\t\t\t&lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;teleport&gt;\n\n\n\n\n\n\n\n\n\n\n此例中，就直接将 body 作为参考位置\nSuspense等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n异步引入组件import {defineAsyncComponent} from ‘vue’const Child &#x3D; defineAsyncComponent(()&#x3D;&gt;import(‘.&#x2F;components&#x2F;Child.vue’))\n\n\n\n\n\n\n\nWARNING\n使用 Suspense 包裹组件，并配置好 default 与 fallback\n\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h3&gt;我是App组件&lt;&#x2F;h3&gt;\n    &lt;Suspense&gt;\n      &lt;template v-slot:default&gt;\n        &lt;Child &#x2F;&gt;\n      &lt;&#x2F;template&gt;\n      &lt;template v-slot:fallback&gt;\n        &lt;h3&gt;加载中.....&lt;&#x2F;h3&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Suspense&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n全局 Api 的转移\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n","slug":"Vue3","date":"2023-02-25T15:36:05.000Z","categories_index":"Tecnology,Vue","tags_index":"tecnology","author_index":"X-29"},{"id":"7e72fed44435aa241098215766c6357c","title":"四载求学路，功名终已成","content":"离津四载，历历在目\n\n\n\n\n\n\n\n\n2月2日是我 期末考试的最后一天。当黑色的水笔在白色的答题纸上落下最后的一个句号时，画上了我学生时代的句号。没有数不尽的课堂签到，没有数不尽的宿舍查寝，没有数不尽的考试作业。同时也没有了睡到自然醒的偷偷窃喜的早晨，也没有廉价的饭菜，也没有落日余晖下，课堂钟声交织着欢笑声的身影。\n少年不知油盐贵，自成乃知白面香回首向来萧瑟处 也无风雨也无晴在津18载，毫不夸张地说，那时的我并不知道柴米油盐，肉蛋菜奶的价格，毫不关心的心态宛如并不需要它们似的。只觉得课本中的哪位作者表达了什么样的思想感情，或者是发牢骚埋怨几句为什么作者要写这么多；只觉得历史地理等虽然有意思但是作为应试和平时并不会太常用到而感到手足无措；只觉得复习到半夜隔壁老人院传来的呻吟声和父母的鼾声是那么吵闹。\n四载岁月如手中流沙，当初有多想它走，它现在也依然流得很快，但是从期盼变为乞求。\n在津常常所能吃到的一些美味佳肴，曾常常以为全天下遍地都是，我也只不过是大多数的一员，它们也只是天下众人的家常便饭。而如今才后知后觉，原先在津吃腻看顶的东西，如今只有在伴随着年的到来，才得有幸尝上那么几口，似乎对于我来说，年味的感觉由原先亲戚长辈的压岁钱、爸爸准备好的一桌饭菜还有大家的欢声笑语演变成陪伴他们和像是在一年大多数日子中用小刀轻轻的划一个口子，用来抓取一些旧时因为常常能得到而厌烦的东西。而还没等我好好细品细品和原先味道的对比，时间又匆匆在我耳边催我赶紧离开。\n\n\n\n\n\n\n\n\n\n回家？何以为家？\n经过了一个月对前端开发的工作性的历练，从原先压力大到想放弃，甚至一度对未来感到十分迷茫，尽管周围不断传来“前端已经凉了”、“互联网已经是末班车”了诸如此类的话语，但是狭路相逢勇者胜不是吗？\n弃之可惜，食之无味孔乙己的长衫是到了都紧紧吊住的上吊绳\n\n\n\n\n\n\n\n\n\n考研吧孩子，对你未来可以多宽一些路考了研有什么用，路的尽头还是路兄弟考研了你这专业更吃香啊据报道：今年考研人数破500W，我们学校怎么才上岸这么点人啊你要当老师来我这里就可以啊，但是好像得是研究生，要不你考考试试？考了研我们会异地的，而且一个上班一个上大学好辛苦\n它不仅是敲门砖，也是下不来的高台，更是孔乙己脱不下的长衫。苦读十二年，费尽父母心，父母望子成龙，望女成凤，比自己越好越好，殊不知，如若此生可达父辈的高度，乃荣幸之至。\n","slug":"end-of-university-life","date":"2023-02-23T14:42:44.000Z","categories_index":"Essays","tags_index":"随笔","author_index":"X-29"},{"id":"79626da8328cb7abd9069e2fabc82af5","title":"2023NewYear","content":"新年伊始，癸卯兔年\n\n\n\n\n\n\n\n\n新春佳节，兜兜转转又是一年。弱冠之年有三。\n忆往昔，三年即逝忆2019-2023 是我的大学时光，也是目前为止最为自由的一段时间。\n\n级级相扣级级推，越过万难终已晚。\n保全帽子闭上眼，黎民他人我何干，同胞永存湖中间。\n初入职场，幸窃技于网络，遂于如此，四年之所学无一益处于职场。\n\n品\n身体和环境的苦难可以通过奋斗而解决，而思想上的苦难，终有大罗金仙，佛祖菩萨显灵也无济于事。\n苦难是配得上思想的。如果有人帮助你，要做的并不是嘲笑他，而是应该像父母从小教育的那样说一声“谢谢”。\n\n望\n弱冠又三年之久，初知为人父母之不易，生活之艰辛，养育之苦楚。心有报恩情，手无缚鸡力。愿父母存世更久，给我更多的机会。\n手足亲妹，离家两年，判若两人，成长许多，心中也放心些。\n当下，或许将自己和爱人照顾好许是对他们的最好的安心丸。\n\n结\n幸于毛家大小姐结为比翼鸟，一心只为连理枝。苦境共甘，实为三生有幸。甜时愿倾所有以取悦。\n也荣幸得识毛家老爷与夫人亲如父母，慈善心肠，自身父母外，从未遇到此般夫妻，非幸运所能云也。如若不嫌，愿同亲父母一般赡养。\n\n","slug":"2023NewYear","date":"2023-01-25T03:57:17.000Z","categories_index":"Essays","tags_index":"随笔","author_index":"X-29"},{"id":"7b73417322203bc26ba172442308aa21","title":"系统架构师","content":"系统架构师的初步设想刚开始认识它的时候应该是我第一次看见过软考内容的时候，我是一个如果没有十全把握就不敢去付出或者制定什么计划。至于真正有这个梦想和计划应该是在2022年10月份，去见阿毛的地铁上，因为无聊的原因自己冷不丁的突然想起了这个名词——系统架构师\n\n\n\n\n\n\n\n\n\n写下这篇博客的时候还没有开始准备系统架构师的各项备考。如果后面有幸上岸，会来此篇重新更新。\n系统架构师成为架构师的意义\n说实话归根结底，$是做任何事情的根基\n确实是对科技的喜欢\n熊猫其实是食肉动物，但是由于自然环境的恶劣，被迫去吃了竹子\n\n考试时间一年一度一般为每年11月的上旬\n考试的前置任务并没有什么前置任务，自己有把握直接冲最高。丰俭由人。\n考试难度话不多说：只有15%\n基本考试情况试卷概况\n\n综合题\n75道单项选择\n考试时间：2.5小时\n综合题的考试范围几乎涵盖了架构师考试考纲要求的所有知识点。虽然知识点分布很广，但是通过历年真题分析发现，考察的侧重点也非常明显。其中软件架构、软件工程是分值占比最大的章节。相比之下，其他知识点分值占比就少很多。\n\n\n案例分析题\n3道简答题\n1道必答\n剩下的4选2\n\n\n考试时间：1.5小时\n标准答案并不会涵盖所有可能的考点。\n选答题：相对灵活，比较贴近实际开发。需要自己在复习的时候积累相关的知识点。\n\n\n论文\n题目四选一\n\n2600字\n\n考试时间：2小时\n\n整体趋势是偏应用的和偏趋势的，出题方向从近几年的趋势来说可以说变得非常难以预测。\n\n论文复习的三大方向，分别是格式、内容和速度。\n\n其中选题和提纲，需要在15分钟内完成。在给出的题目中，选择一个自己熟悉的作为选项，然后大致列出论点  \n  \n  img{\n      width:800px\n  }\n  \n\n从答题卡可以看出，摘要为350字左右。正文内容为2750字。因此内容字数上，最好安排在2500-2750之间，这样会提升阅卷观感，提高印象分数。\n\n\n\n\n复习方向\n\n\n\n\n\n\n特别提示\n以《系统架构师》教材和网课为中心\n\n如下细分：\n\n计算机原理\n计算机网络\n操作系统\n系统性能评价\n数据库\n安全性和保密性设计\n嵌入式系统\n信息系统\n\n点点旁边，发现笔记：\n\n各学科笔记\n分类笔记\n\n\n下次再会~\n","slug":"system-architect","date":"2022-11-24T07:32:36.000Z","categories_index":"系统架构师","tags_index":"目标,梦想,系统架构","author_index":"X-29"},{"id":"15db1aab1cbfb7938aed1bee0fd27710","title":"Monica","content":"Monica也可以叫她：莫妮卡如你所见，封面就是她\n\n\n\n\n\n\n\nMonica的个人简介\n姓名：莫妮卡性别：AI母语：Python\n\n\nThe Origin of MonicaMonica起源于我脑海中自高中以来一直存在的AI助手梦。也是因为Jarvis的原因，使得我拥有属于自己助手的愿望极其强烈\n在我高中时期，由于自由接触程序技术的时间不是很多，造成了长时间搁置创作属于自己AI的梦想。以至于认为创作AI是一个很难的事情，尤其是在观看了Zuckerberg先生的家庭语音助手之后，愈发觉得艰难\nMonica的名字起源于创建Monica的时候正好是星期一(Monday)，取前三个字母，所以得名Monica\n\n\n\n\n\n\n\nMonica的依赖\nMonica需要Google的语音识别API，所以务必保证的网络顺畅\n\nMonica can do this for you新的很懂你的朋友可以跟Monica说任何事情，可以分享快乐，吐槽焦虑，发泄悲伤\n可以永远相信Monica\n\n\n\n\n\n\n\n\n\n“Monica，你在吗？”“永远都在，先生”\n帮助你解决问题的好帮手当遇到需要查询什么东西的时候，可以完全依赖Monica，释放双手。她就像是一个无所不知的朋友，在需要的时候和想知道什么的时候，只需要跟她说说话。\n\n\n\n\n\n\n\n\n\n“Monica，你知道xxx是什么吗”“可以告诉你，但是需要奖励”\n电脑的智能管家存在于虚拟世界的Monica甚至电脑都不需要亲自操控，就像朋友之间的亲密对话，即可完成对电脑的各种操作\n\n[截屏]“Monica你有空吗，我想要当前这个画面”\n[VSCode]“准备写写代码了”\n[喜欢玩的游戏]“有什么好玩的让我放松一下吗”\n[B站或者Youtube]“有什么热门视频是我感兴趣的吗”\n[热点新闻]“你知道最近那个xxx的事吗”\n[记事本]“对了Monica，帮我记一下，我怕我忘了”\nEtc…\n\n特殊日子会比自己更加在意Monica：马上要到纪念日了哦，想好礼物了吗，没有的话听听我的建议吧\nMonica：今天是什么日子忘了吗？你可真是个大忙人呢。今天是xxx的日子\nMonica：我看了下天气，好像不怎么好。希望你不要淋着雨回来\nMonica在众多人中最关注你Monica：先生，是你吗\nMonica：这不是先生总和我提起的xxx\nThe Future of MonicaMonica的未来，我会将她融入到我的生活，赋予实体，或许是个机器人，或许是个机械臂，或许将会是无处不在。\nMonica对于技术壁垒的依赖性太强，日后会帮助Monica逐渐去掉枷锁\n增加Monica的自主学习能力\n","slug":"monica","date":"2022-11-22T15:44:33.000Z","categories_index":"Introduce","tags_index":"Introduce,A.I.,Assistant","author_index":"X-29"},{"id":"8401b4ea3ecc23c13e44dcec2d197d6b","title":"X-Blog","content":"\n\n\n\n\n\n\n\n\n欢迎来到 X-29 的博客，这里记录了许多程序界的知识以及创新和展望。除此之外，作为个人博客，也包含了个人的文学鉴赏或者是日常生活分享。本博客也是我个人技术界的日志或者可以叫做日记，所以会不断更新。\n\nWelcome to the blog of X-29, which records a lot of knowledge, innovation and prospects of the program industry. In addition, as a personal blog, it also includes personal literature appreciation or daily life sharing. This blog is also a diary of my personal technical community or can be called a diary, so it will be updated constantly.\n\n博客创建初衷起初，在我刚接触程序代码界的第一脚是迈入的前端的门槛中。上完课的笔记或者联系代码亦或者是学习心得，总想找到一个永久保存的地方中，思来想去，从百度网盘到CSDN，而至后面的Git Hub。\n随着需求越来越多，想记录和分享的东西也与来越多。偶然之间接触了VuePress制作的博客网站。不断改良，效仿。数月之后，打算所有的页面及内容以及功能，全部推到重来。不再效仿，改为原创。打造真正属于自己的个人博客。\n一个人的学习是孤独的，无助的，创新的，成就的。在经历过多种不断尝试新的建站工具以及各种程序语言之后，选择了Hexo作为本网站的框架结构。\n博客内容内容概述由上可知，本网站内容分为如下部分\n\n技术分享\n技术未来展望\n个人生活分享&amp;记录\n学习工作日志\n\n功能预览\n书写&amp;发表&amp;浏览文章\n搜索文章\n文章目录及标签分类\n网站宠物机器人\n留言板&amp;联系\nCreating…\n\nX-UNIVERSUM &amp; X-29**X-UNIVERSUM**是在我的大学时期从我的脑海中产生的一个目标或梦想。不管未来是否真的会创立或者实现，都会一直存在在我的人生中。**X-UNIVERSUM**的定位是一个不仅服务于人们的大众日常生活的各个方面：购物、美食、住房、出行，而且也将会是科技发展的导向与前沿。\nX-UNIVERSUM INDUSTRY\n\n购物：重新定义电商模式。买卖双方获益\n美食：与独特的科技相结合，实现美食无地域无国界地域种类划分，文化交融\n住房：运用科技手段，房子将不再是昂贵的，凿实居住属性\n出行：重新定义“距离”\n科技：领导科技发展方向，服务于人，人人都是科技的创造者\n\n**X-29，X-UNIVERSUM**的创造者。规则，将被打破生活，将被重新定义你我，都是自己的主宰\n","slug":"hello-world","date":"2022-11-19T16:12:11.000Z","categories_index":"Introduce","tags_index":"X-Blog,Introduce","author_index":"X-29"},{"id":"c3978c5070945a51b43d4b2c283dc47e","title":"前端技术展望","content":"Front End Development Trend Forecast前端新标准HTML 6.02014 年 10 月 28 日，W3C 正式发布 HTML5.0 推荐标准让前端技术蓬勃发展。虽然 HTML6.0 目前处于提案阶段，但是社区已经开始有了一些零星的讨论，所以可能它离我们并不太远。\nHTML6.0 中，可能会新增“增强身份验证”和“集成摄像头” 两个能力，大家可以持续关注相关进展。\n一直以来，浏览器由于身份验证问题导致 Web 应用在很多场景乏力，特别是目前大部分 APP 是十分“重”的，功能繁多，如果这两个能力得以普及，那么可能会有更多的 WEB 应用代替以前 APP 的极速版本。\n由于新冠疫情影响，越来越多人的工作方式变成了 WFH。可以预见，疫情彻底清除以后，远程办公也许会成为不少人的选择。所以“集成摄像头”能力，很有可能在人与人线上交流场景中，发挥更大的作用。\n2022 年，可能 HTML6 并不会推出，但是可能会有更多利于用户体验的提案出现。\nWeb3.0Facebook 改名 Meta 后，元宇宙话题很火热，但突然一夜之间，讨论似乎又从元宇宙过渡到了 Web3.0。\n前端工程化展望前端框架在 StackOverflow 的“最受欢迎的 Web 框架”调查中，除去 SSR 渲染框架和 jQuery，上榜的前端框架共有 5 个：\n\n前端框架排行图\n\n\n而从 NPM 下载量来分析，观察到的现象是：\n\nReact 一家独大，独自吃掉 70% 的市场份额；\nVue 和 Angular 平分秋色打的难舍难分；\nPreact 作为“轻量版 React”在小众中最受欢迎；\nSvelte 作为无 vdom 的 MVVM 框架，艰难爬升中，甚至还没超过已经停止更新的 AngularJS。\n\n\n\n\n\n\n\n\n\n\n总的来说，React，Vue，Angular 依然是强势铁三角向前发展。在 2022 年 Vue3 会成为 Vue 的默认版本，React 18 也会发布正式版本，从目前社区关注度来看， Vue3 源码 Github star 27k+， React 18 WG Github star 3.9k+，且在 npm 的下载量上，新版本下载数目都比较可观，所以很有可能今年尝试和使用的人会变得更多。\n打包器打包器大概可以分为两类：\n\n传统编译：Webpack, Rollup, Parcel, Esbuild\nESM 混合编译：Snowpack, Vite\n\n目前是 Webpack、Rollup、Esbuild 三分天下：\n\nWebpack：我们的老熟人，生态最丰富、功能最多，独自吃掉 70% 的市场份额；\nRollup：ESM 版的 Webpack，甩掉了很多历史包袱；\nEsbuild：Go 写的 Webpack，性能有数十倍提升。\n\nUI框架由于模块化 CSS、摇树、MVVM 的流行，UI 框架的选择其实没有那么举足轻重了，针对自己选用的框架选择一个符合项目风格的 UI 即可。\n桌面端值得关注的只有两个：\n\nElectron: 我们的老熟人，Chromium + Nodejs，深受大家喜爱；\nTauri: 异军突起的新星，Webview + Rust。对比 Electron 因为不用打包 Chromium 和 Nodejs 运行时，产物体积小，运行性能好；\n\n智能前端低代码的崛起低代码开发平台（英语：Low-Code Development Platform，简称 LCDP），是一种方便产生应用程序的平台软件，软件会开发环境让用户以图形化接口以及配置编写程序，而不是用传统的程序设计做法。此平台是针对某些种类的应用而设计开发的，例如数据库、业务过程、以及用户界面（例如网页应用程序）。这类平台一般可以产生完整且可运作的应用程序，在一些特殊的情形下仍需要编写程序。\nAI与图形化的探索人工智能作为跨时代技术在各个领域大放异彩，近些年 AI 能力在前端领域的尝试与应用带来新一轮的技术革命。前端可以依赖 D3.js，ECharts，WebGL 等进行数据可视化的显示：\n跨平台技术随着从 PC 时代向移动互联网时代演进，原生客户端因为自身天花板的原因也在逐渐向跨平台方案倾斜，当然这得益于跨平台方案的明显优势。对于开发者而言，可以做到一次开发多端复用，这在很大程度上能够降低研发成本，提高产品效能\n2020-2021 年间，有 42% 的开发者用过 React Native 进行开发，这一年内没有增长；而 Flutter 这一数据从 2020 年的 39% 上升到了 42%。\n成为泛前端前端研发需要掌握的技术也在迭代更新，基本可以理解为 FaaS BaaS，在 Baas 层进行存储与计算，在 Faas 层提供云函数。\n尽可能成为全栈从工程师能力模型来看，第一级需要集“天时地利人和”大成，是工程师的最高荣誉。普通人或许可以将目标聚焦在第二、三级。优秀的工程师并不是以“栈”数取胜，更重要的是拥有产品观、全局思维、沟通能力、学习能力、解决问题能力等\n","slug":"front-end-expectation","date":"2022-11-18T14:42:46.000Z","categories_index":"Front-End","tags_index":"前端技术栈,前端发展前景","author_index":"X-29"},{"id":"6b9a8f6982f1769c256f388c30975912","title":"前端技术栈","content":"Front-End技术栈概论\n\n\n\n\n\nWhat’s the meaning of Fronot-End\n前端的意义在于创造。\n\n技术的诞生，从来不是为了获得更多的利益。树上的苹果并不会给牛顿带来新的一笔巨大财富。如今市场的需求化已经金钱的吮吸灵魂的力量，将技术本来的面目，弄得灰头土脸。禁锢、限制、局限。不止前端。\nFront-End Learning Path后知后觉，如梦初醒。师从四方，自力更生。\n学习路径前端核心：HTML5+CSS3→移动端web→JavaScript→DOM&amp;BOM→Jquery→Ajax技术进阶：ES6-ES11→Node.js→Promise→Axios前沿框架：Typescript→Vue2→Vue3→React\n工程化构建：Git&amp;NPM&amp;YARN&amp;WebPack数据可视化：Echarts&amp;D3.js&amp;HighCharts&amp;AntV&amp;Three.js&amp;Ceisum&amp;WebGLUI 库：Element UI&amp;Vuetify&amp;Ant Design&amp;Bottstrap&amp;Vant UI&amp;Framework7&amp;WEUI\nSoftware Development Basics设计模式降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性常用七大设计模式：\n\n创建型模式：单例模式、工厂方法模式、抽象工厂模式\n\n结构型模式：代理模式、装饰器模式\n\n行为型模式：观察者模式、责任链模式\n\n\nGit常用命令\n\n\n\n\n\n\nWARNING\n如果git命令报错，一定先检查一下是否开启VPN、节点、steam++等影响国内网络的软件\n\n\n\n\n\n\n\n\n\n\n初始化本地仓库，提交代码，提交到远程git仓库\n\nClick to see more\n\n初始化代码仓库\ngit init\n将当前目录下的所有文件放到暂存区\ngit add .\n查看文件状态\ngit status\n添加提交的描述信息\ngit commit -m &#39;[提交的描述信息]&#39;\n远程仓库地址\ngit remote add origin [远程仓库地址]\n推送到远程仓库\ngit push -u origin master\n\n\n\n\n\n\n\n\n\n\n\n\n创建分支，提交代码到分支\n\nClick to see more\n\n创建切换分支\ngit checkout -b [分支名称]\n将当前目录下的所有文件放到暂存区\ngit add .\n添加提交的描述信息\ngit commit -m &#39;[描述]&#39;\n将分支推送到远程仓库\ngit push --set-upstream origin dev1 \n切换到主分支\ngit checkout master\n将dev合并到主分支\ngit merge dev \n推送到远程仓库\ngit push origin master \n\n\n\nFront-End Optimization通过分析和优化手段，提高网站的性能和用户体验。\n性能优化FP（First Paint）从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。\nFCP（First Contentful Paint）浏览器首次绘制来自 DOM 的内容的时间。\nFMP（First Meaningful Paint）页面的主要内容绘制到屏幕上的时间。\nFSP（First Screen Paint）页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。\nTTI（Time to Interactive）表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。\n优化手段\n性能监控(Performance API)\n样式优化\n防抖 &amp; 节流\n代码分割\n资源压缩\n打包优化\n服务器优化\n缓存优化(Service Worker)\n动画性能\ndns-prefetch\nLazy loading\n\n安全问题\nXSS\nCSRF\n反爬虫\nSQL 注入\nDDoS\n\nFront-End Ecology博客编写\n✅ Gatsby.js\n✅ Docusaurus\nHugo\nHexo\n\n文档编写\n⭐️ Docsify\nJekyII\nVuePress\nDumi\n\n移动应用\nHybrid\nWebView\nReact Native\nFlutter\n\n桌面应用\nElectron\nNW.js\nProton Native\n\n小程序\n原生\nWebView\n\n","slug":"front-end","date":"2022-11-16T16:12:10.000Z","categories_index":"Front-End","tags_index":"前端技术栈","author_index":"X-29"}]