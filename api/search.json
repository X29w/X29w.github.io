[{"id":"1b063f23855641c095e348bf57d4f4f2","title":"React-Router-Dom","content":"React-Router-Dom 5查看印记中文网站关于 React-Router-Dom 的介绍\n路由的基本使用index.js&#x2F;index.ts 入口文件中\nReactDOM.render(\n  &lt;React.StrictMode&gt;\n    &#123;&#x2F;* &lt;App&gt; 外侧包裹一个 &lt;BrowserRouter&gt; 或 &lt;HashRouter&gt; *&#x2F;&#125;\n    &lt;BrowserRouter&gt;\n      &lt;App &#x2F;&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  &lt;&#x2F;React.StrictMode&gt;,\n  document.getElementById(&quot;root&quot;)\n);\n\nApp.jsx 中\n&lt;div className&#x3D;&quot;container-wrap&quot;&gt;\n  &lt;div className&#x3D;&quot;left&quot;&gt;\n    &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;Link&gt;\n    &lt;hr &#x2F;&gt;\n    &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;home&lt;&#x2F;Link&gt;\n  &lt;&#x2F;div&gt;\n  &lt;div className&#x3D;&quot;main&quot;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&gt;&lt;&#x2F;Route&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n路由组件与一般组件\n写法不同：\n一般组件：\n路由组件：\n\n\n存放位置不同：\n一般组件：components\n路由组件：pages\n\n\n接收到的 props 不同：\n一般组件：写组件时传递什么就收到什么\n路由组件：\nhistory:\ngo、goBack、goForward、push、replace\n\n\nlocation：\npathname、search、state\n\n\nmatch：\nparams、path、url\n\n\n\n\n\n\n\n 的使用及其封装导航链接如果使用 ，那么跳转到当前页面时，会自动给当前  添加一个 class：active也可以通过 activeClassName 属性指定 class\n使用\n&lt;NavLink to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;NavLink&gt;\n\n&lt;NavLink activeClassName&#x3D;&quot;current&quot; to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;NavLink&gt;\n\n封装标签体内容是一个特殊的标签属性，可以通过 this.props.children 拿到，设置 children 属性相当于设置了标签体内容\nimport React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; NavLink &#125; from &quot;react-router-dom&quot;;\n\nexport default class MyNavLink extends Component &#123;\n  render() &#123;\n    return &lt;NavLink className&#x3D;&quot;link&quot; &#123;...this.props&#125; &#x2F;&gt;;\n  &#125;\n&#125;\n\n封装后使用\n&lt;MyNavLink to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;MyNavLink&gt;\n\n的使用&#x2F;&#x2F; 2个组件都会展示\n&lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Test&#125;&gt;&lt;&#x2F;Route&gt;\n\n&#x2F;&#x2F; 用 &lt;Switch&gt; 包裹一下，匹配到了就不继续匹配了\n&lt;Switch&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;&#x2F;Switch&gt;\n\n路由的模糊匹配与严格匹配默认模糊匹配，尽量不开启严格匹配/home/a/b 可以匹配 /home/a/home/b 不能匹配 /home 中的 to 属性，必须以  中指定的 path 开头，才能匹配成功\n&#x2F;&#x2F; 开启严格匹配，必须完全相等\n&lt;Route exact path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n\nRedirect 的使用&lt;Switch&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n\t&#x2F;&#x2F; 重定向 写在最下面  如果前面的都没匹配到，就重定向到 &lt;Redirect&gt; 指定的路径，兜底作用\n  &lt;Redirect to&#x3D;&quot;&#x2F;about&quot;&#x2F;&gt;\n&lt;&#x2F;Switch&gt;\n\n嵌套路由注册子路由时要在前面加上父路由路由的匹配顺序是按注册顺序进行的\n&lt;&gt;\n  &lt;div&gt;\n    &lt;h3&gt;home&lt;&#x2F;h3&gt;\n    &lt;MyNavLink to&#x3D;&quot;&#x2F;home&#x2F;message&quot;&gt;message&lt;&#x2F;MyNavLink&gt;\n    &lt;MyNavLink to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;news&lt;&#x2F;MyNavLink&gt;\n  &lt;&#x2F;div&gt;\n  &lt;Switch&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;message&quot; component&#x3D;&#123;Message&#125;&gt;&lt;&#x2F;Route&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;news&quot; component&#x3D;&#123;News&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;&#x2F;Switch&gt;\n&lt;&#x2F;&gt;\n\n向路由组件传递参数\nparams 参数 路由中包含参数， /xx/val1/val2\nsearch 参数 /xx?key1=val1&amp;key2=val2\nstate 参数 路由中不显示参数 HashRouter 时，刷新页面会丢失参数\n\n\n三种参数的举例\n&lt;div&gt;\n  &#123;messageArr.map((msg) &#x3D;&gt; &#123;\n    return (\n      &lt;div key&#x3D;&#123;msg.id&#125;&gt;\n        &#123;&#x2F;* 传递 params 参数 *&#x2F;&#125;\n        &#123;&#x2F;* &lt;Link to&#x3D;&#123;&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;msg.id&#125;&#x2F;$&#123;msg.title&#125;&#96;&#125;&gt;&#123;msg.title&#125;&lt;&#x2F;Link&gt; *&#x2F;&#125;\n\n        &#123;&#x2F;* 传递 search 参数 *&#x2F;&#125;\n        &#123;&#x2F;* &lt;Link to&#x3D;&#123;&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;$&#123;msg.id&#125;&amp;title&#x3D;$&#123;msg.title&#125;&#96;&#125;&gt;&#123;msg.title&#125;&lt;&#x2F;Link&gt; *&#x2F;&#125;\n\n        &#123;&#x2F;* 传递 state 参数 *&#x2F;&#125;\n        &lt;Link\n          to&#x3D;&#123;&#123;\n            pathname: &quot;&#x2F;home&#x2F;message&#x2F;detail&quot;,\n            state: &#123; id: msg.id, title: msg.title &#125;,\n          &#125;&#125;\n        &gt;\n          &#123;msg.title&#125;\n        &lt;&#x2F;Link&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;)&#125;\n  &lt;hr &#x2F;&gt;\n  &#123;&#x2F;* 声明接收 params 参数 *&#x2F;&#125;\n  &#123;&#x2F;* &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;:id&#x2F;:title&quot; component&#x3D;&#123;Detail&#125;&#x2F;&gt; *&#x2F;&#125;\n\n  &#123;&#x2F;* search 参数无需声明接收 *&#x2F;&#125;\n  &#123;&#x2F;* &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&quot; component&#x3D;&#123;Detail&#125;&#x2F;&gt; *&#x2F;&#125;\n\n  &#123;&#x2F;* state 参数无需声明接收 *&#x2F;&#125;\n  &lt;Route path&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&quot; component&#x3D;&#123;Detail&#125; &#x2F;&gt;\n&lt;&#x2F;div&gt;;\n\n&#x2F;&#x2F; 接收 params 参数\n&#x2F;&#x2F; const &#123;id, title&#125; &#x3D; this.props.match.params\n\n&#x2F;&#x2F; 接收 search 参数\n&#x2F;&#x2F; const &#123;search&#125; &#x3D; this.props.location\n&#x2F;&#x2F; const &#123;id, title&#125; &#x3D; qs.parse(search.slice(1))\n\n&#x2F;&#x2F; 接收 search 参数\nconst &#123; id, title &#125; &#x3D; this.props.location.state || &#123;&#125;;\n\n\n\nkey=value&amp;key2=value2 形式叫 urlencode 编码\nimport qs from &quot;querystring&quot;;\n\nlet obj &#x3D; &#123; a: 1, b: 2 &#125;;\n\nlet str &#x3D; qs.string(obj);\n\nobj &#x3D; qs.parse(str);\n\nPush&amp;Replace\n&lt;Link to&#x3D;&#123;&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;msg.id&#125;&#x2F;$&#123;msg.title&#125;&#96;&#125;&gt;&#123;msg.title&#125;&lt;&#x2F;Link&gt;\n\n&lt;Link replace&#x3D;&#123;true&#125; to&#x3D;&#123;&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;msg.id&#125;&#x2F;$&#123;msg.title&#125;&#96;&#125;&gt;&#123;msg.title&#125;&lt;&#x2F;Link&gt;\n\n编程式路由导航\n编程式路由导航举例\npushShow &#x3D; (id, title) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; push 跳转 + 携带 params 参数\n    &#x2F;&#x2F; this.props.history.push(&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;id&#125;&#x2F;$&#123;title&#125;&#96;)\n\n    &#x2F;&#x2F; push 跳转 + 携带 search 参数\n    &#x2F;&#x2F; this.props.history.push(&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;$&#123;id&#125;&amp;title&#x3D;$&#123;title&#125;&#96;)\n\n    &#x2F;&#x2F; push 跳转 + 携带 state 参数\n    this.props.history.push(&#96;&#x2F;home&#x2F;message&#x2F;detail&#96;, &#123;id, title&#125;)\n&#125;\n\nreplaceShow &#x3D; (id, title) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; replace 跳转 + 携带 params 参数\n    &#x2F;&#x2F; this.props.history.replace(&#96;&#x2F;home&#x2F;message&#x2F;detail&#x2F;$&#123;id&#125;&#x2F;$&#123;title&#125;&#96;)\n\n    &#x2F;&#x2F; replace 跳转 + 携带 search 参数\n    &#x2F;&#x2F; this.props.history.replace(&#96;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;$&#123;id&#125;&amp;title&#x3D;$&#123;title&#125;&#96;)\n\n    &#x2F;&#x2F; replace 跳转 + 携带 state 参数\n    this.props.history.replace(&#96;&#x2F;home&#x2F;message&#x2F;detail&#96;, &#123;id, title&#125;)\n&#125;\n\n&lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.pushShow(msg.id, msg.title)&#125;&gt;push 查看&lt;&#x2F;button&gt;\n&lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.replaceShow(msg.id, msg.title)&#125;&gt;replace 查看&lt;&#x2F;button&gt;\n\n&#x2F;&#x2F; 前进一步\nthis.props.history.goForward()\n&#x2F;&#x2F; 后退一步\nthis.props.history.goBack()\n&#x2F;&#x2F; 前进一步\nthis.props.history.go(1)\n\n\n\nWitshRouter 的使用withRouter 可以加工一般组件，让一般组件具有路由组件特有的 API，history 等withRouter 返回值是一个新组件\n\nWitshRouter 的使用\nimport React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; withRouter &#125; from &quot;react-router-dom&quot;;\n\nclass Header extends Component &#123;\n  go &#x3D; () &#x3D;&gt; &#123;\n    this.props.history.goForward();\n  &#125;;\n\n  back &#x3D; () &#x3D;&gt; &#123;\n    this.props.history.goBack();\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;react-router-dom&lt;&#x2F;h2&gt;\n        &lt;button onClick&#x3D;&#123;this.go&#125;&gt;前进&lt;&#x2F;button&gt;\n        &lt;button onClick&#x3D;&#123;this.back&#125;&gt;后退&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default withRouter(Header);\n\n\n\nBrowserRouter 与 HashRouter\n底层原理不一样：\nBrowserRouter 使用的是 H5 的 history API，不兼容 IE9 及以下版本\nHashRouter 使用的是 URL 的哈希值\n\n\npath 表现形式不一样：\nBrowserRouter 的路径中没有 #\nHashRouter 的路径中包含 #\n\n\n刷新后对 state 参数的影响：\nBrowserRouter 没有任何影响，因为 state 保存在 history 对象中\nHashRouter 刷新后会导致路由 state 参数的丢失\n\n\nHashRouter 可以解决一些路径错误相关的问题，比如多级路径刷新页面后样式丢失\n\nReact-Router-Dom 6与 v5 版本区别\n内置组件的变化：移除 ,新增\n语法的变化：注册组件时，component&#x3D;{Demo} 变为 element&#x3D;{}\n新增多个 hook:useParams,useNavigate,useMatch 等\n官方推荐使用函数式组件了\n\n&lt;Routes&gt;\n  &#123;&#x2F;* caseSensitive 设置path是否大小写敏感 *&#x2F;&#125;\n  &lt;Route path&#x3D;&quot;&#x2F;EXTENSION&quot; caseSensitive&#x3D;&#123;true&#125; element&#x3D;&#123;&lt;LazyDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;extension&quot; element&#x3D;&#123;&lt;ExtensionDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;lazy-demo&quot; element&#x3D;&#123;&lt;LazyDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;Route path&#x3D;&quot;&#x2F;react-router-v6&quot; element&#x3D;&#123;&lt;ReactRouterDomV6 &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &#123;&#x2F;* 这里不会继续往下匹配 *&#x2F;&#125;\n  &lt;Route path&#x3D;&quot;&#x2F;react-router-v6&quot; element&#x3D;&#123;&lt;ExtensionDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;&#x2F;Routes&gt;\n\n路由懒加载import Loading from &quot;.&#x2F;components&#x2F;Loading&quot;;\nimport &#123;lazy()&#125; from &#39;react&#39;\n&#x2F;&#x2F; 路由懒加载 1. 调用lazy\nconst LazyDemo &#x3D; lazy(() &#x3D;&gt; import(&quot;.&#x2F;pages&#x2F;ExtensionDemo&#x2F;02_lazy&quot;));\n&#123;\n  &#x2F;* 路由懒加载 2.使用Suspense *&#x2F;\n&#125;\n&lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n  &#123;&#x2F;* v5:使用的是 Switch *&#x2F;&#125;\n  &lt;Routes&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;lazy-demo&quot; element&#x3D;&#123;&lt;LazyDemo &#x2F;&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n  &lt;&#x2F;Routes&gt;\n&lt;&#x2F;Suspense&gt;;\n\n重定向v6 使用替代 v5 的\n&lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Navigate to&#x3D;&quot;react-router-v6&quot;&gt;&lt;&#x2F;Navigate&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n\n使用 useRoutes 配置路由链路表&#x2F;&#x2F; 根据配置生成链路表\nconst allElement &#x3D; useRoutes(routes);\n&lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n  &#123;&#x2F;* 路由链路表 *&#x2F;&#125;\n  &#123;allElement&#125;\n&lt;&#x2F;Suspense&gt;;\n\n嵌套路由路由链路表父路由添加 children 字段（和 vue-router 类似）\n&#123;\n  path: &#39;&#x2F;react-router-v6&#39;,\n    element: &lt;ReactRouterDomV6 &#x2F;&gt;,\n    &#x2F;&#x2F; 嵌套路由，父组件需要一个位置&lt;Outlet &#x2F;&gt;来展示\n    children: [\n      &#123;\n        path: &#39;child&#39;,\n        element: &lt;Child &#x2F;&gt;,\n      &#125;,\n    ],\n  &#125;,\n\n路由传参 params定义路由参数\n&#123;\n   path: &#39;use-params&#x2F;:id&#x2F;:name&#39;,\n   element: &lt;UseParamsDemo &#x2F;&gt;,\n &#125;\n\n获取路由参数第一种：useParams()\n&#x2F;&#x2F; 返回值：\n&#123;\n  &quot;id&quot;: &quot;id1&quot;,\n  &quot;name&quot;: &quot;name2&quot;\n&#125;\n\n第二种：useMatch()\n&#x2F;&#x2F; 返回值\n&#123;\n  &quot;params&quot;: &#123;\n    &quot;id&quot;: &quot;id1&quot;,\n    &quot;name&quot;: &quot;name2&quot;\n  &#125;,\n  &quot;pathname&quot;: &quot;&#x2F;react-router-v6&#x2F;use-params&#x2F;id1&#x2F;name2&quot;,\n  &quot;pathnameBase&quot;: &quot;&#x2F;react-router-v6&#x2F;use-params&#x2F;id1&#x2F;name2&quot;,\n  &quot;pattern&quot;: &#123;\n    &quot;path&quot;: &quot;&#x2F;react-router-v6&#x2F;use-params&#x2F;:id&#x2F;:name&quot;,\n    &quot;caseSensitive&quot;: false,\n    &quot;end&quot;: true\n  &#125;\n&#125;\n\n路由参数 search传参\n&lt;NavLink className&#x3D;&#123;linkClass&#125; to&#x3D;&quot;.&#x2F;use-search-params?id&#x3D;1&amp;name&#x3D;abc&amp;title&#x3D;xxx&quot;&gt;\n  useSearchParams\n&lt;&#x2F;NavLink&gt;\n\n取值\n\n取值示例\nimport React from &quot;react&quot;;\nimport &#123; useLocation, useSearchParams &#125; from &quot;react-router-dom&quot;;\n\nexport default function useSearchParamsDemo() &#123;\n  const [search, setSearch] &#x3D; useSearchParams();\n  const id &#x3D; search.get(&quot;id&quot;);\n  const name &#x3D; search.get(&quot;name&quot;);\n  const title &#x3D; search.get(&quot;title&quot;);\n  console.log(id, name, title);\n  &#x2F;&#x2F; 也可从location获取\n  const location &#x3D; useLocation();\n  console.log(location);\n  const handleClick &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 会替换url?后面所有参数\n    setSearch(&quot;id&#x3D;1&amp;name&#x3D;abc&amp;title&#x3D;xxx&quot;);\n  &#125;;\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;useSearchParams&lt;&#x2F;h3&gt;\n      &lt;div&gt;\n        &#123;id&#125;,&#123;name&#125;,&#123;title&#125;\n      &lt;&#x2F;div&gt;\n      &lt;div&gt;\n        &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;设置search&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n\n\n路由参数 state传参\n&lt;NavLink\n  className&#x3D;&#123;linkClass&#125;\n  to&#x3D;&#123;&#123; pathname: &quot;.&#x2F;state-params&quot;, state: &#123; name: &quot;curry&quot; &#125; &#125;&#125;\n&gt;\n  传入state路由参数\n&lt;&#x2F;NavLink&gt;\n\n取值通过 useLocation().state获取\n编程式导航v6 版本中，不区分普通组件还是路由组件，都使用 const navigete = useNavigete(),普通组件不再使用withRouter()\n额外的 Hooks\nuseInRouterContext()：判断是否在路由环境下，一般用于第三方组件库封装\nuseNavigeteType(): 返回跳转模式 PUSH | REPLACE | POP (刷新时)\nuseOutlet():用来呈现当前组件中渲染的嵌套路由（路由对象）\nuseResolvedPath(‘&#x2F;react-router-v6&#x2F;use-params&#x2F;id1&#x2F;name2?title&#x3D;解析 url#hashcode123’),用来解析任何路径\n\n&#123;\n  &quot;pathname&quot;: &quot;&#x2F;react-router-v6&#x2F;use-params&#x2F;id1&#x2F;name2&quot;,\n  &quot;search&quot;: &quot;?title&#x3D;解析url&quot;,\n  &quot;hash&quot;: &quot;#hashcode123&quot;\n&#125;\n\n","slug":"react-router-dom","date":"2023-03-22T14:10:34.000Z","categories_index":"Tecnology,React","tags_index":"tecnology","author_index":"X-29"},{"id":"d9e53d39e48f5c5aa42bf2e7c031bcd1","title":"React","content":"React 入门点我去官网\nReact 的基本使用需要的相关依赖文件\nreact.js：React 核心库。\nreact-dom.js：提供操作 DOM 的 react 扩展库。\nbabel.min.js：解析 JSX 语法代码转为 JS 代码的库\n\n\n\n\n\n\n\n\n\n\n引入顺序为：1.react.js2.react-dom.js3.babel.min.js\n创建虚拟 DOM 的两种方式\n纯 JS 方式(一般不用)\nJSX 方式\n\n虚拟 DOM 与真实 DOM\nReact 提供了一些 API 来创建一种 “特别” 的一般 js 对象\nconst VDOM = React.createElement(&#39;xx&#39;,&#123;id:&#39;xx&#39;&#125;,&#39;xx&#39;)\n上面创建的就是一个简单的虚拟 DOM 对象\n\n\n虚拟 DOM 对象最终都会被 React 转换为真实的 DOM\n我们编码时基本只需要操作 react 的虚拟 DOM 相关数据, react 会转换为真实 DOM 变化而更新界。\n\nJSXJSX\n全称: JavaScript XML\n\nreact 定义的一种类似于 XML 的 JS 扩展语法: JS + XML 本质是 React.createElement(component, props, …children)方法的语法糖\n\n作用: 用来简化创建虚拟 DOM\n\n写法：var ele = &lt;h1&gt;Hello JSX!&lt;/h1&gt;\n注意 1：它不是字符串, 也不是 HTML&#x2F;XML 标签\n注意 2：它最终产生的就是一个 JS 对象\n\n\n标签名任意: HTML 标签或其它标签\n\n标签属性任意: HTML 标签属性或其它\n\n基本语法规则\n\n遇到 &lt;开头的代码, 以标签的语法解析: html 同名标签转换为 html 同名元素, 其它标签需要特别解析\n遇到以&#123; 开头的代码，以 JS 语法解析: 标签中的 js 表达式必须用&#123; &#125;包含\n\n\nbabel.js 的作用\n\n浏览器不能直接解析 JSX 代码, 需要 babel 转译为纯 JS 的代码才能运行\n只要用了 JSX，都要加上type&#x3D;”text&#x2F;babel”, 声明需要 babel 来处理\n\n渲染虚拟 DOM（元素）\n语法: ReactDOM.render(virtualDOM, containerDOM)\n\n作用: 将虚拟 DOM 元素渲染到页面中的真实容器 DOM 中显示\n\n参数说明\n\n参数一: 纯 js 或 jsx 创建的虚拟 dom 对象\n参数二: 用来包含虚拟 DOM 元素的真实 dom 元素对象（一般是个&lt;div&gt;&lt;/div&gt;）\n\n\nExample: ReactDOM.render(&lt;Test /&gt;,document.getElementById(&#39;root&#39;))\n\n\nJSX 语法\n定义虚拟 DOM，不能使用“”\n标签中混入 JS 表达式的时候使用&#123;&#125;\nid = &#123;myId.toUpperCase()&#125;\n样式的类名指定不能使用class，使用className\n内敛样式要使用&#123;&#123;&#125;&#125;包裹\nstyle=&#123;&#123;color:'skyblue',fontSize:'24px'&#125;&#125;\n不能有多个根标签，只能有一个根标签\n标签必须闭合，自闭合也行\n如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错；如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错\n\n注释写法写在大括号里ReactDOM.render(\n  &lt;div&gt;\n    &lt;h1&gt;小丞&lt;&#x2F;h1&gt;\n    &#123;&#x2F;*注释...*&#x2F;&#125;\n  &lt;&#x2F;div&gt;,\n  document.getElementById(&quot;example&quot;)\n);\n\n数组插入并遍历\nJSX 允许在模板中插入数组，数组自动展开全部成员\n\nvar arr &#x3D; [&lt;h1&gt;小丞&lt;&#x2F;h1&gt;, &lt;h2&gt;同学&lt;&#x2F;h2&gt;];\nReactDOM.render(&lt;div&gt;&#123;arr&#125;&lt;&#x2F;div&gt;, document.getElementById(&quot;example&quot;));\n\n\n根据动态数据生成 \n\nconst data &#x3D; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];\nconst VDOM &#x3D; (\n  &lt;div&gt;\n    &lt;ul&gt;\n      &#123;data.map((item, index) &#x3D;&gt; &#123;\n        return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;;\n      &#125;)&#125;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;div&gt;\n);\nReactDOM.render(VDOM, document.querySelector(&quot;.test&quot;));\n\nReact 面向组件编程Tips\n组件名必须首字母大写\n虚拟 DOM 元素只能有一个根元素\n虚拟 DOM 元素必须有结束标签\n\n渲染类组件标签的基本流程\nReact 内部会创建组件实例对象\n调用 render()得到虚拟 DOM, 并解析为真实 DOM\n插入到指定的页面元素内部\n\n函数式组件&#x2F;&#x2F;1.先创建函数，函数可以有参数，也可以没有，但是必须要有返回值 返回一个虚拟DOM\nfunction Welcome(props) &#123;\n  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;\n&#125;\n&#x2F;&#x2F;2.进行渲染\nReactDOM.Render(&lt;Welcom name&#x3D;&quot;ljc&quot; &#x2F;&gt;, document.getElementById(&quot;div&quot;));\n\n类式组件class MyComponent extends React.Component &#123;\n  state &#x3D; &#123; isHot: false &#125;;\n  render() &#123;\n    const &#123; isHot &#125; &#x3D; this.state;\n    return (\n      &lt;h1 onClick&#x3D;&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;&lt;&#x2F;h1&gt;\n    );\n  &#125;\n  changeWeather &#x3D; () &#x3D;&gt; &#123;\n    const isHot &#x3D; this.state.isHot;\n    this.setState(&#123; isHot: !isHot &#125;);\n  &#125;;\n&#125;\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.querySelector(&quot;.test&quot;));\n\n\n组件中的 render 方法中的 this 为组件实例对象\n组件自定义方法中由于开启了严格模式，this 指向 undefined 如何解决\n通过 bind 改变 this 指向\n推荐采用箭头函数，箭头函数的 this 指向\n\n\nstate 数据不能直接修改或者更新\n\n组件实例三大属性StateReact 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）\nclass Weather extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n  &#125;\n  state &#x3D; &#123;\n    weather: &quot;炎热&quot;,\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;当前季节为：&#123;this.state.weather&#125;&lt;&#x2F;h2&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n\n使用的时候通过this.state调用 state 里面的值\n修改 state 里面的值通过调用this.setState(partialState, [callback])\npartialState: 需要更新的状态的部分对象\ncallback: 更新完状态后的回调函数&#x2F;直接要修改的值\nsetState 是一种合并操作，不是替换操作\n在执行 setState 操作后，React 会自动调用一次 render()\nrender() 的执行次数是 1+n (1 为初始化时的自动调用，n 为状态更新的次数)\n\n\n\nProps与state不同，state是组件自身的状态，而props则是外部传入的数据\nclass Person extends React.Component &#123;\n  render() &#123;\n    return (\n      &lt;ul&gt;\n        &lt;li&gt;&#123;this.props.name&#125;&lt;&#x2F;li&gt;\n        &lt;li&gt;&#123;this.props.age&#125;&lt;&#x2F;li&gt;\n        &lt;li&gt;&#123;this.props.sex&#125;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n    );\n  &#125;\n  &#x2F;&#x2F; 对 props传过来的数据进行数据类型的限制\n  static propTypes &#x3D; &#123;\n    name: propTypes.string.isRequired,\n    sex: PropTypes.string,\n    speak: PropTypes.func,\n  &#125;;\n  &#x2F;&#x2F; 对没有传的数据进行一个默认的填充\n  static defaultProps &#x3D; &#123;\n    sex: &quot;male&quot;,\n    age: 18,\n  &#125;;\n&#125;\n    const p &#x3D;&#123;\n        name:&quot;Lisa&quot;,\n        age:&#123;19&#125; ,\n        sex:&quot;female&quot;\n    &#125;\n\nReactDOM.render(\n  &lt;Person &#123;...p&#125;&#x2F;&gt;,document.getElementById(&quot;root&quot;)\n);\n\n\n在使用的时候可以通过 this.props 来获取值 类式组件的 props:\n通过在组件标签上传递值，在组件中就可以获取到所传递的值\n在构造器里的 props 参数里可以获取到 props\n可以分别设置 propTypes 和 defaultProps 两个属性来分别操作 props 的规范和默认值，两者都是直接添加在类式组件的原型对象上的（所以需要添加 static）\n同时可以通过…运算符来简化\n\n\n\nRefsRefs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。\n\n有三种操作 refs 的方法，分别为：\n字符串形式\n回调形式\ncreateRef 形式\n\n\n\n字符串形式 refs\n()&#x3D;&gt;&#123;\n    alert(this.refs.inp1)\n&#125;\nrender()&#123;return(&lt;input ref&#x3D;&quot;inp1&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;)&#125;\n\n回调形式的 refs组件实例的 ref 属性传递一个回调函数 c &#x3D;&gt; this.input1 &#x3D; c （箭头函数简写），这样会在实例的属性中存储对 DOM 节点的引用，使用时可通过 this.input1 来使用\n&lt;input\n  ref&#x3D;&#123;(c) &#x3D;&gt; (this.input1 &#x3D; c)&#125;\n  type&#x3D;&quot;text&quot;\n  placeholder&#x3D;&quot;点击按钮提示数据&quot;\n&#x2F;&gt;\n\ncreateRef 形式React 给我们提供了一个相应的 API，它会自动的将该 DOM 元素放入实例对象中\nDOM&lt;input ref&#x3D;&#123;this.MyRef&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;\n&lt;input ref&#x3D;&#123;this.MyRef1&#125; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;点击弹出&quot; &#x2F;&gt;\n\nMyRef &#x3D; React.createRef();\nMyRef1 &#x3D; React.createRef();\n\n使用&#x2F;&#x2F;调用\nbtnOnClick &#x3D; () &#x3D;&gt; &#123;\n  &#x2F;&#x2F;创建之后，将自身节点，传入current中\n  console.log(this.MyRef.current.value);\n&#125;;\n\n高阶函数及函数的柯里化以下例子即可知道，只可意会不可言传\n\n函数柯里化\nclass MyComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    username: &quot;&quot;,\n    password: &quot;&quot;,\n  &#125;;\n  saveFormInformation &#x3D; (dataType) &#x3D;&gt; &#123;\n    return (event) &#x3D;&gt; &#123;\n      console.log(dataType, event.target.value);\n      this.setState(&#123; [dataType]: event.target.value &#125;);\n    &#125;;\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;函数柯里化Example&lt;&#x2F;h1&gt;\n        &lt;form&gt;\n          &lt;div&gt;\n            &lt;input\n              onChange&#x3D;&#123;this.saveFormInformation(&quot;username&quot;)&#125;\n              type&#x3D;&quot;text&quot;\n              placeholder&#x3D;&quot;请输入用户名&quot;\n            &#x2F;&gt;\n            &lt;br &#x2F;&gt;\n            &lt;br &#x2F;&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div&gt;\n            &lt;input\n              onChange&#x3D;&#123;this.saveFormInformation(&quot;password&quot;)&#125;\n              type&#x3D;&quot;password&quot;\n              placeholder&#x3D;&quot;请输入密码&quot;\n            &#x2F;&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;form&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.getElementById(&quot;test&quot;));\n\n\n\n\n避免函数柯里化\nclass MyComponent extends React.Component &#123;\n  state &#x3D; &#123;\n    username: &quot;&quot;,\n    password: &quot;&quot;,\n  &#125;;\n  saveInfomation &#x3D; (name, value) &#x3D;&gt; &#123;\n    this.setState(&#123; [name]: value &#125;);\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;div&gt;\n          &lt;input\n            onChange&#x3D;&#123;(event) &#x3D;&gt; &#123;\n              this.saveInfomation(&quot;username&quot;, event.target.value);\n            &#125;&#125;\n            type&#x3D;&quot;text&quot;\n            placeholder&#x3D;&quot;请输入用户名&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n        &lt;br &#x2F;&gt;\n        &lt;br &#x2F;&gt;\n        &lt;div&gt;\n          &lt;input\n            onChange&#x3D;&#123;(event) &#x3D;&gt; &#123;\n              this.saveInfomation(&quot;password&quot;, event.target.value);\n            &#125;&#125;\n            type&#x3D;&quot;password&quot;\n            placeholder&#x3D;&quot;请输入密码&quot;\n          &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nReactDOM.render(&lt;MyComponent &#x2F;&gt;, document.getElementById(&quot;test&quot;));\n\n\n\n生命周期React 生命周期主要包括三个阶段：初始化阶段，更新阶段，销毁阶段\n旧的生命周期流程\n\n\n初始化阶段: 由 ReactDOM.render()触发—初次渲染\nconstructor()\ncomponentWillMount()\nrender()\ncomponentDidMount()\n\n\n更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发\nshouldComponentUpdate()\ncomponentWillUpdate()\nrender()\ncomponentDidUpdate()\n\n\n卸载组件: 由ReactDOM.unmountComponentAtNode()触发\ncomponentWillUnmount\n\n\n\n新的生命周期流程\n\n\n初始化阶段: 由 ReactDOM.render()触发—初次渲染\nconstructor()\ngetDerivedStateFromProps\nrender()\ncomponentDidMount()\n\n\n更新阶段: 由组件内部 this.setSate()或父组件重新 render 触发\ngetDerivedStateFromProps\nshouldComponentUpdate()\nrender()\ngetSnapshotBeforeUpdate\ncomponentDidUpdate()\n\n\n卸载组件: 由 ReactDOM.unmountComponentAtNode()触发\ncomponentWillUnmount()\n\n\n\n重要的钩子\nrender：初始化渲染或更新渲染调用\ncomponentDidMount：开启监听, 发送 ajax 请求\ncomponentWillUnmount：做一些收尾工作, 如: 清理定时器\n\n废弃的钩子\ncomponentWillMount\ncomponentWillReceiveProps\ncomponentWillUpdate\n\nReact 脚手架安装脚手架WebPack\n\n第一步：全局安装create-react-app npm install create-react-app -g\n第二步：创建项目create-react-app hello-react\n\nVite\n\nnpm init vite照着提示一步一步来就行\n\n脚手架项目结构WebPack\n\nhello-react\n.gitignore 自动创建本地仓库\npackage.json 相关配置文件\npublic 公共资源\nfavicon.ico 浏览器顶部的 icon 图标\nindex.html 应用的 index.html 入口\nlogo192.png 在 manifest 中使用的 logo 图\nlogo512.png 同上\nmanifest.json 应用加壳的配置文件\nrobots.txt 爬虫的协议文件\n\n\nsrc 源码文件夹\nApp.css &#x2F;&#x2F; pp 组件的样式\nApp.js App 组件\nApp.test.js 用于给 APP 做测试\nindex.css 样式\nindex.js 入口文件\nlogo.svg logo 图\nreportWebVitals.js 页面性能分析文件\nsetupTests.js 组件单元测试文件\n\n\nyarn.lock\n\n\n\n消息订阅与发布解决兄弟组件之间需要&lt;App/&gt;帮助的问题\n\n首先安装 pubsub-js\nyarn add pubsub-js\nnpm install pubsub-js\n\n\n引入\nimport PubSub from &#39;pubsub-js&#39;\n\n\n\n订阅消息我们通过 subscribe 来订阅消息，它接收两个参数，第一个参数是消息的名称，第二个是消息成功的回调，回调中也接受两个参数，一个是消息名称，一个是返回的数据\nPubSub.subscribe(&quot;search&quot;, (msg, data) &#x3D;&gt; &#123;\n  console.log(msg, data);\n&#125;);\n\n发布消息我们采用 publish 来发布消息\n&#x2F;&#x2F; 之前的写法\nthis.props.updateAppState(&#123; isFirst: false, isLoading: true &#125;);\n&#x2F;&#x2F; 改为发布订阅方式\nPubSub.publish(&quot;search&quot;, &#123; isFirst: false, isLoading: true &#125;);\n\n这样我们就能成功的在请求之前发送消息，我们只需要在 List 组件中订阅一下这个消息即可，并将返回的数据用于更新状态即可\nPubSub.subscribe(&quot;search&quot;, (msg, stateObj) &#x3D;&gt; &#123;\n  this.setState(stateObj);\n&#125;);\n\n同时上面的代码会返回一个 token ，这个就类似于定时器的编号的存在，我们可以通过这个 token 值，来取消对应的订阅\n通过 unsubscribe 来取消指定的订阅\nPubSub.unsubscribe(this.token);\n\n\n","slug":"react","date":"2023-03-22T14:07:08.000Z","categories_index":"Tecnology,React","tags_index":"tecnology","author_index":"X-29"},{"id":"d5f81ad13155fc328e81b1032965290d","title":"Vuex","content":"Vuex介绍What’s the Vuex?\n\n\n\n\n\n\n\n\n概念：专门在Vue中实现集中式状态（数据）管理的一个Vue插，对Vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信\n\n\n\n核心流程\nstore： 每一个Vuex应用的核心就是store(仓库),store基本上就是一个容器，它包含着应用中大部分的状态 (state)。\nstate ： 共同维护的一个状态，state里面可以是很多个全局状态\ngetters：获取数据并渲染\nactions：数据的异步操作\nmutations：处理数据的唯一途径，state的改变或赋值只能在这里\n\n实际体验配置vuex\n下载安装vuex  npm install vuex\n创建src/store/index.js该文件用于创建Vuex最为核心的store\n\nsrc/store/index.jsimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39; &#x2F;&#x2F;引入Vuex\n\nVue.use(Vuex) &#x2F;&#x2F;应用Vuex插件\n\nconst actions &#x3D; &#123;&#125;      &#x2F;&#x2F; 准备actions用于响应组件中的动作\nconst mutations &#x3D; &#123;&#125;    &#x2F;&#x2F; 准备mutations用于操作数据state\nconst state &#x3D; &#123;&#125;        &#x2F;&#x2F; 准备state用于存储数据\n\n&#x2F;&#x2F;创建并暴露store\nexport default new Vuex.Store(&#123;\n    actions,\n    mutations,\n    getters,\n    state\n&#125;)\n\n\n在src&#x2F;main.js中创建vm时传入store配置项src/store/index.jsimport Vue from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport store from &#39;.&#x2F;store&#39;\n\nVue.config.productionTip &#x3D; false\n\nnew Vue(&#123;\n    el:&#39;#app&#39;,\n    render:h &#x3D;&gt; h(App),\n    store,\n\n&#125;)\n\n使用Vuex\n初始化数据state、配置actions、mutations、操作文件store.js\n组件中读取Vuex中的数据：$store.state.数据\n组件中修改Vuex中的数据：this.$store.dispatch(&#39;action中的方法名&#39;,数据)或者this.$store.commit(&#39;mutations中的方法名&#39;,数据)\n\n\n\n\n\n\n\n\n如果没有网络请求或其他业务逻辑，组件中也可以 越过actions，即不写dispatch,直接写commmit\n\n\nGetters 配置项\n\n\n\n\n\n\n\n\n当state中的数据需要经过加工后再使用是，可以使用getters加工,，相当于全局计算属性\n\n组件中想读取getters中的数据则$store.getters.函数名\n\nMapState 辅助函数当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。可以使用mapstate()辅助函数帮助生成计算属性Example\nexport default &#123;\n    comuted:&#123;\n        ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;)&#x2F;&#x2F;写法一 对象\n        ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;])&#x2F;&#x2F;写法二 数组\n    &#125;\n&#125;\n\nMapGettersExample\nexport default &#123;\n    comuted:&#123;\n        ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;)&#x2F;&#x2F;写法一 对象\n\n        ...mapGetters([&#39;bigSum&#39;])&#x2F;&#x2F;写法二 数组\n    &#125;\n&#125;\n\nMapActions用于帮助生成与actions对话的方法，即包含了$store.dispatch(xx)的函数\nexport default &#123;\n    methods:&#123;\n        &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（对象形式）\n        ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;&#125;,incrementWait:&#39;jiaWait&#39;)\n\n        &#x2F;&#x2F;靠mapActions生成：incrementOdd、incrementWait（数组形式）\n         ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])\n    &#125;\n&#125;\n\nMapMutations用于帮助生成与mutations对话的方法，即包含$store.commit(xx)的函数\nexport default &#123;\n    methods:&#123;\n        &#x2F;&#x2F;靠mapMutations生成：increment、decreament（对象形式）\n        ...mapMutations(&#123;increment:&#39;JIA&#39;&#125;,decreament:&#39;JIAN&#39;)\n\n        &#x2F;&#x2F;靠mapMutations生成：increment、decreament（数组形式）\n         ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;])\n    &#125;\n&#125;\n\n模块化&amp;命名空间\n目的：让代码更好维护，让多种数据分类更加明确\n修改store.js：为了解决不同模块命名冲突的问题，设置不同模块的namespaced:true,之后在不同页面引入geeter、actions、mutations时，需要加上所属模块名\n\nExample\n\nDetails\nconst countAbout &#x3D; &#123;\n    naspaced:true,\n    state:&#123;&#125;,\n    mutaitons:&#123;&#125;,\n    actions:&#123;&#125;,\n    getters:&#123;&#125;\n&#125;\nconst personAbout &#x3D; &#123;\n    naspaced:true,\n    state:&#123;&#125;,\n    mutaitons:&#123;&#125;,\n    actions:&#123;&#125;,\n    getters:&#123;&#125;\n&#125;\nconst store &#x3D; new Vuex.Store(&#123;\n    modules:&#123;\n        countAbout,\n        personAbout\n    &#125;\n&#125;)\n\n\n开启命名空间后组件中读取state数据&#x2F;&#x2F; 方式一：直接读取\nthis.$store.state.personAbout.list\n&#x2F;&#x2F; 方式二：mapState\n...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;])\n\n开启命名空间后组件中读取getters数据&#x2F;&#x2F; 方式一：直接读取\nthis.$store.getters[&#39;perAbout&#x2F;firstPersonName&#39;]\n&#x2F;&#x2F; mapGetters\n...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])\n\n开启命名空间后组件中调用dispatch&#x2F;&#x2F; 方式一：直接读取\nthis.$store.getters[&#39;perAbout&#x2F;addPersonWang&#39;,person]\n&#x2F;&#x2F; mapActions\n...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiawait&#39;&#125;)\n\n开启命名空间后组件中调用commit&#x2F;&#x2F; 方式一：直接读取\nthis.$store.commit[&#39;perAbout&#x2F;ADD_PERSON&#39;,person]\n&#x2F;&#x2F; mapActions\n...mapActions(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;)\n","slug":"vuex","date":"2023-03-21T15:29:07.000Z","categories_index":"Tecnology,Vue,Gadgets","tags_index":"tecnology","author_index":"X-29"},{"id":"21b9d275999a54f82cbd29d23f792608","title":"Vue-Router","content":"介绍\n理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。\n前端路由：key 是路径，value 是组件。\n\n基本使用\n安装 vue-router，命令：npm i vue-router\n应用插件：Vue.use(VueRouter)\n编写 router 配置项:\n\n&#x2F;&#x2F;引入VueRouter\nimport VueRouter from &quot;vue-router&quot;;\n&#x2F;&#x2F;引入Luyou 组件\nimport About from &quot;..&#x2F;components&#x2F;About&quot;;\nimport Home from &quot;..&#x2F;components&#x2F;Home&quot;;\n\n&#x2F;&#x2F;创建router实例对象，去管理一组一组的路由规则\nconst router &#x3D; new VueRouter(&#123;\n  routes: [\n    &#123;\n      path: &quot;&#x2F;about&quot;,\n      component: About,\n    &#125;,\n    &#123;\n      path: &quot;&#x2F;home&quot;,\n      component: Home,\n    &#125;,\n  ],\n&#125;);\n\n&#x2F;&#x2F;暴露router\nexport default router;\n\n\n实现跳转\n\n&lt;router-link active-class&#x3D;&quot;active&quot; to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt;\n\n\n用于展示的容器这个超级容易忘，没有它写半天东西出不来\n\n&lt;router-view&gt;&lt;&#x2F;router-view&gt;\n\nTips\n路由组件通常存放在 pages 文件夹，一般组件通常存放在 components 文件夹。\n通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。\n每个组件都有自己的$route 属性，里面存储着自己的路由信息。\n整个应用只有一个 router，可以通过组件的$router 属性获取到。\n\n多级路由\n配置路由规则，使用 children 配置项：\n\nroutes: [\n  &#123;\n    path: &quot;&#x2F;about&quot;,\n    component: About,\n  &#125;,\n  &#123;\n    path: &quot;&#x2F;home&quot;,\n    component: Home,\n    children: [\n      &#x2F;&#x2F;通过children配置子级路由\n      &#123;\n        path: &quot;news&quot;, &#x2F;&#x2F;此处一定不要写：&#x2F;news\n        component: News,\n      &#125;,\n      &#123;\n        path: &quot;message&quot;, &#x2F;&#x2F;此处一定不要写：&#x2F;message\n        component: Message,\n      &#125;,\n    ],\n  &#125;,\n];\n\n\n跳转（要写完整路径）：\n\n&lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;News&lt;&#x2F;router-link&gt;\n\n路由的参数传递参数&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail?id&#x3D;666&amp;title&#x3D;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;\n&lt;router-link\n  :to&#x3D;&quot;&#123;\n    path: &#39;&#x2F;home&#x2F;message&#x2F;detail&#39;,\n    query: &#123;\n      id: 666,\n      title: &#39;你好&#39;,\n    &#125;,\n  &#125;&quot;\n&gt;跳转&lt;&#x2F;router-link&gt;\n\n接收参数$route.query.id;\n$route.query.title;\n\n命名路由\n可以简化路由的跳转。\n\n给路由命名&#123;\n\tpath:&#39;&#x2F;demo&#39;,\n\tcomponent:Demo,\n\tchildren:[\n\t\t&#123;\n\t\t\tpath:&#39;test&#39;,\n\t\t\tcomponent:Test,\n\t\t\tchildren:[\n\t\t\t\t&#123;\n                      name:&#39;hello&#39; &#x2F;&#x2F;给路由命名\n\t\t\t\t\tpath:&#39;welcome&#39;,\n\t\t\t\t\tcomponent:Hello,\n\t\t\t\t&#125;\n\t\t\t]\n\t\t&#125;\n\t]\n&#125;\n\n简化跳转&lt;!--简化前，需要写完整的路径 --&gt;\n&lt;router-link to&#x3D;&quot;&#x2F;demo&#x2F;test&#x2F;welcome&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n&lt;!--简化后，直接通过名字跳转 --&gt;\n&lt;router-link :to&#x3D;&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n&lt;!--简化写法配合传递参数 --&gt;\n&lt;router-link\n  :to&#x3D;&quot;&#123;\n\t\tname:&#39;hello&#39;,\n\t\tquery:&#123;\n\t\t   id:666,\n            title:&#39;你好&#39;\n\t\t&#125;\n\t&#125;&quot;\n  &gt;跳转&lt;&#x2F;router-link\n&gt;\n\n路由的 params 参数配置路由，声明接收 params 参数&#123;\n\tpath:&#39;&#x2F;home&#39;,\n\tcomponent:Home,\n\tchildren:[\n\t\t&#123;\n\t\t\tpath:&#39;news&#39;,\n\t\t\tcomponent:News\n\t\t&#125;,\n\t\t&#123;\n\t\t\tcomponent:Message,\n\t\t\tchildren:[\n\t\t\t\t&#123;\n\t\t\t\t\tname:&#39;xiangqing&#39;,\n\t\t\t\t\tpath:&#39;detail&#x2F;:id&#x2F;:title&#39;, &#x2F;&#x2F;使用占位符声明接收params参数\n\t\t\t\t\tcomponent:Detail\n\t\t\t\t&#125;\n\t\t\t]\n\t\t&#125;\n\t]\n&#125;\n\n传递参数&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;\n&lt;router-link :to&#x3D;&quot;&#x2F;home&#x2F;message&#x2F;detail&#x2F;666&#x2F;你好&quot;&gt;跳转&lt;&#x2F;router-link&gt;\n\n&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;\n&lt;router-link\n  :to&#x3D;&quot;&#123;\n\t\tname:&#39;xiangqing&#39;,\n\t\tparams:&#123;\n\t\t   id:666,\n            title:&#39;你好&#39;\n\t\t&#125;\n\t&#125;&quot;\n  &gt;跳转&lt;&#x2F;router-link\n&gt;\n\n接收参数$route.params.id;\n$route.params.title;\n\n路由的 props 配置\n作用：让路由组件更方便的收到参数\n\n&#123;\n\tname:&#39;xiangqing&#39;,\n\tpath:&#39;detail&#x2F;:id&#39;,\n\tcomponent:Detail,\n\n\t&#x2F;&#x2F;第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\n\t&#x2F;&#x2F; props:&#123;a:900&#125;\n\n\t&#x2F;&#x2F;第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\n\t&#x2F;&#x2F; props:true\n\n\t&#x2F;&#x2F;第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\n\tprops(route)&#123;\n\t\treturn &#123;\n\t\t\tid:route.query.id,\n\t\t\ttitle:route.query.title\n\t\t&#125;\n\t&#125;\n&#125;\n\n的 replace 属性\n作用：控制路由跳转时操作浏览器历史记录的模式\n浏览器的历史记录有两种写入方式：分别为 push 和 replace，push 是追加历史记录，replace 是替换当前记录。路由跳转时候默认为 push\n如何开启 replace 模式：&lt;router-link replace …….&gt;News\n\n编程式路由导航&#x2F;&#x2F;$router的两个API\nthis.$router.push(&#123;\n  name: &quot;xiangqing&quot;,\n  params: &#123;\n    id: xxx,\n    title: xxx,\n  &#125;,\n&#125;);\n\nthis.$router.replace(&#123;\n  name: &quot;xiangqing&quot;,\n  params: &#123;\n    id: xxx,\n    title: xxx,\n  &#125;,\n&#125;);\nthis.$router.forward(); &#x2F;&#x2F;前进\nthis.$router.back(); &#x2F;&#x2F;后退\nthis.$router.go(); &#x2F;&#x2F;可前进也可后退\n\n缓存路由组件\n作用：让不展示的路由组件保持挂载，不被销毁。\n\n&lt;keep-alive include&#x3D;&quot;News&quot;&gt;\n  &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;keep-alive&gt;\n\n两个新的生命周期钩子\n作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\n具体名字：\nactivated路由组件被激活时触发。\ndeactivated路由组件失活时触发。\n\n\n\n路由守卫\n作用：对路由进行权限控制\n分类：全局守卫、独享守卫、组件内守卫\n\n全局守卫&#x2F;&#x2F;全局前置守卫：初始化时执行、每次路由切换前执行\nrouter.beforeEach((to, from, next) &#x3D;&gt; &#123;\n  console.log(&quot;beforeEach&quot;, to, from);\n  if (to.meta.isAuth) &#123;\n    &#x2F;&#x2F;判断当前路由是否需要进行权限控制\n    if (localStorage.getItem(&quot;school&quot;) &#x3D;&#x3D;&#x3D; &quot;atguigu&quot;) &#123;\n      &#x2F;&#x2F;权限控制的具体规则\n      next(); &#x2F;&#x2F;放行\n    &#125; else &#123;\n      alert(&quot;暂无权限查看&quot;);\n      &#x2F;&#x2F; next(&#123;name:&#39;guanyu&#39;&#125;)\n    &#125;\n  &#125; else &#123;\n    next(); &#x2F;&#x2F;放行\n  &#125;\n&#125;);\n\n&#x2F;&#x2F;全局后置守卫：初始化时执行、每次路由切换后执行\nrouter.afterEach((to, from) &#x3D;&gt; &#123;\n  console.log(&quot;afterEach&quot;, to, from);\n  if (to.meta.title) &#123;\n    document.title &#x3D; to.meta.title; &#x2F;&#x2F;修改网页的title\n  &#125; else &#123;\n    document.title &#x3D; &quot;vue_test&quot;;\n  &#125;\n&#125;);\n\n独享守卫beforeEnter(to,from,next)&#123;\n\tconsole.log(&#39;beforeEnter&#39;,to,from)\n\tif(to.meta.isAuth)&#123; &#x2F;&#x2F;判断当前路由是否需要进行权限控制\n\t\tif(localStorage.getItem(&#39;school&#39;) &#x3D;&#x3D;&#x3D; &#39;atguigu&#39;)&#123;\n\t\t\tnext()\n\t\t&#125;else&#123;\n\t\t\talert(&#39;暂无权限查看&#39;)\n\t\t\t&#x2F;&#x2F; next(&#123;name:&#39;guanyu&#39;&#125;)\n\t\t&#125;\n\t&#125;else&#123;\n\t\tnext()\n\t&#125;\n&#125;\n\n组件内守卫&#x2F;&#x2F;进入守卫：通过路由规则，进入该组件时被调用\nbeforeRouteEnter (to, from, next) &#123;\n&#125;,\n&#x2F;&#x2F;离开守卫：通过路由规则，离开该组件时被调用\nbeforeRouteLeave (to, from, next) &#123;\n&#125;\n\n路由的两种工作模式\n对于一个 url 来说，什么是 hash 值？—— #及其后面的内容就是 hash 值。\nhash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。\nhash 模式：\n地址中永远带着#号，不美观 。\n若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。\n兼容性较好。\n\n\nhistory 模式：\n地址干净，美观 。\n兼容性和 hash 模式相比略差。\n应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题\n\n\n\n","slug":"vue-router","date":"2023-03-21T15:26:07.000Z","categories_index":"Tecnology,Vue","tags_index":"tecnology","author_index":"X-29"},{"id":"6a13b89bc1d9db16e3bd75ad19728f7b","title":"Pinia","content":"介绍但 Pinia 适用于 Vue 2 和 Vue 3 ，并且不需要您使用组合 API。\nBenefit\n开发工具支持\n跟踪操作、突变的时间表\n商店出现在使用它们的组件中\n时间旅行和更容易的调试\n\n\n热模块更换\n无需重新加载页面即可修改您的商店\n在开发时保持任何现有状态\n\n\n为 JS 用户提供适当的 TypeScript 支持或自动补全\n服务器端渲染支持\n\n与 VueX ≤ 4 对比\nMutation不再存在。他们经常被认为非常冗长。他们最初带来了 devtools 集成，但这不再是问题。\n无需创建自定义的复杂包装器来支持TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能地利用 TS 类型推断。\n不再需要注入、导入函数、调用它们，享受自动补全！\n无需动态添加store，默认情况下它们都是动态的\n不再有模块的嵌套结构。您仍然可以通过在另一个store中导入和使用store来隐式嵌套store\n\n安装yarn add pinia\n&#x2F;&#x2F; or with npm\nnpm install pinia\n\n\n\n\n\n\n\n\n\n\n如果使用的是Vue2，但还是想用 pinia，就要npm install @vue/composition-api\n项目引入Vue2import &#123; createPinia, PiniaVuePlugin &#125; from &#39;pinia&#39;\n\nVue.use(PiniaVuePlugin)\nconst pinia &#x3D; createPinia()\n\nnew Vue(&#123;\n  el: &#39;#app&#39;,\n  &#x2F;&#x2F; other options...\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F; note the same &#96;pinia&#96; instance can be used across multiple Vue apps on\n  &#x2F;&#x2F; the same page\n  pinia,\n&#125;)\n\nVue3import &#123; createPinia &#125; from &#39;pinia&#39;\n\napp.use(createPinia())\n\n核心概念Pinia 中的 Store 是一个保存状态和业务逻辑的实体，它不绑定到你的组件树。换句话说，它承载全局 state。它有点像一个始终存在的组件，每个人都可以读取和写入。它有三个概念，state, getters and actions可以看作为Vue2中的data()&#123;return&#123;&#125;&#125;、Computed()、Methods相对应\n具体实例运用在 Store&#x2F;index.js 中\n\n具体写法代码\nimport &#123; defineStore &#125; from &#39;pinia&#39;\n\n&#x2F;*  useStore could be anything like useUser, useCart\n [以use开头命名接收【defineStore】的返回值的变量] *&#x2F;\n&#x2F;* the first argument is a unique id of the store across your application\n[【defineStore】函数中需要放入的第一个参数必须是唯一的名字在当前的所有项目中，起到了一个ID的作用] *&#x2F;\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n&#x2F;* 第一种：以options的方式使用 *&#x2F;\n    &#x2F;&#x2F;推荐箭头函数的形式，有利于TypeScript推断变量类型\n      state:() &#x3D;&gt;&#123;\n        return&#123;\n            age:30\n        &#125;\n    &#125;,\n    getters:&#123;\n        ageComputed(state)&#123;\n            return state.age + 5\n        &#125;\n    &#125;,\n    actions:&#123;\n        ageMethod()&#123;\n            this.age +&#x3D; 5\n        &#125;\n    &#125;\n&#125;)\n&#x2F;* 第一种：以options的方式使用 *&#x2F;\n\n&#x2F;* 第二种：以setup()&#123;&#125;的方式使用 *&#x2F;\nexport const useConterStore &#x3D; defineStore(&#39;countStore&#39;,()&#x3D;&gt;&#123;\n    const counter &#x3D; ref(30)\n    const getterCounter &#x3D; computed(()&#x3D;&gt;&#123;\n        return counter.value + 5\n    &#125;)\n    const addCounter &#x3D; () &#x3D;&gt;&#123;\n        counter.value +&#x3D; 5\n    &#125;\n    return&#123;\n        counter,\n        getterCounter,\n        addCounter\n    &#125;\n&#125;)\n&#x2F;* 第二种：以setup()&#123;&#125;的方式使用 *&#x2F;\n\n\n\n可以根据需要定义任意数量的商店，并且您应该在不同的文件中定义每个商店以充分利用 pinia\n一旦商店被实例化，你可以访问定义的任何财产state，getters以及actions直接在店里。\n直接解构赋值是不被允许的需要借助storeToRefs()\n\n\n\n\n\n\n\n\n\n\n为了保证结构之后仍具有响应式数据的特点需要用到storeToRefs()\n&lt;script setup&gt;\n  import &#123; storeToRefs &#125; from &#39;pinia&#39;;\n  import &#123; useStore &#125; from &#39;&#x2F;Stroes&#x2F;index.js&#39;\n\n  const store &#x3D; useStore();\n  const &#123; name, doubleCount &#125; &#x3D; storeToRefs(store);\n&lt;&#x2F;script&gt;\n\nState定义state是store的核心部分在 Pinia 中，state被定义为返回初始状态的函数。这样Pinia 在服务器端和客户端都工作。使用箭头函数返回状态 更好的有利于TypeScript进行 类型推断\nimport &#123; defineStore &#125; from &#39;pinia&#39;\n\nconst useStore &#x3D; defineStore(&#39;storeId&#39;, &#123;\n  &#x2F;&#x2F; arrow function recommended for full type inference\n  state: () &#x3D;&gt; &#123;\n    return &#123;\n      &#x2F;&#x2F; all these properties will have their type inferred automatically\n      counter: 0,\n      name: &#39;Eduardo&#39;,\n      isAdmin: true,\n    &#125;\n  &#125;,\n&#125;)\n\n访问State[setup]import &#123; useUserStore &#125; from &#39;@&#x2F;stores&#x2F;user&#39;\nimport &#123; computed &#125; from &#39;vue&#39;\nimport &#123; storeToRefs &#125; from &#39;pinia&#39;\n&#x2F;&#x2F; 方式1,计算属性方式\nconst userid &#x3D; computed(() &#x3D;&gt; useUserStore().userid)\n&#x2F;&#x2F; 方式2, 通过user.userid的方式使用\nconst user &#x3D; useUserStore()\n&#x2F;&#x2F; 方式3, 使用toRef获取userid\nconst userid &#x3D; toRef(useUserStore(), &#39;userid&#39;)\n&#x2F;&#x2F; 方式4, 借助pinia提供的api: storeToRefs 实现\nconst &#123; userid &#125; &#x3D; storeToRefs(useUserStore())\n\n\n重置状态通过调用store 上的方法将状态重置为其初始值$reset()：\nconst store &#x3D; useStore()\n\nstore.$reset()\n\n修改状态[setup]import &#123; useUserStore &#125; from &#39;@&#x2F;stores&#x2F;user&#39;\n\nconst user &#x3D; useUserStore()\n&#x2F;&#x2F; 方式1: 直接修改,vuex不允许这种方式(需要提交mutation),但pinia是允许的\nuser.userid &#x3D; &#39;xxx&#39;\n&#x2F;&#x2F; 方式2: \nuser.$patch(&#123;userid: &#39;xxx&#39;&#125;)\n&#x2F;&#x2F; 方式3: \nuser.$patch((state) &#x3D;&gt; &#123; state.userid &#x3D; &#39;xxx&#39; &#125;)\n&#x2F;&#x2F; 方式4:\nuser.$state &#x3D; &#123; userid:&#39;xxx&#39; &#125;\n&#x2F;&#x2F; 方式5: 使用actions\nuser.setUserId(&#39;xxx&#39;)\n\nActions\n像getters ，actions行动可以访问到整个存储实例 通过this与全类型（和自动完成✨）的支持。\n与它们不同，actions可以是异步的，您可以await在它们内部进行任何 API 调用甚至其他操作！\n\n访问其他store中的acttionimport &#123; useAuthStore &#125; from &#39;.&#x2F;auth-store&#39;\n\nexport const useSettingsStore &#x3D; defineStore(&#39;settings&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    &#x2F;&#x2F; ...\n  &#125;),\n  actions: &#123;\n    async fetchUserPreferences(preferences) &#123;\n      const auth &#x3D; useAuthStore()\n      if (auth.isAuthenticated) &#123;\n        this.preferences &#x3D; await fetchPreferences()\n      &#125; else &#123;\n        throw new Error(&#39;User must be authenticated&#39;)\n      &#125;\n    &#125;,\n  &#125;,\n&#125;)\n\nGetter\n接收 “state” 作为第一个参数 state: () &#x3D;&gt; (&#123;\n  userid: localStorage.getItem(&#39;userid&#39;) || &#39;&#39;,\n  counter: 0\n&#125;),\ngetters: &#123;\n  doubleCount: (state) &#x3D;&gt; state.counter * 2,\n&#125;,\n\n常规函数使用this的注意事项\n\n\n\n\n\n\n\n\n定义常规函数时可以通过 this 访问到 整个 store 的实例, 但是需要定义返回类型（在 TypeScript 中）。 这是由于 TypeScript 中的一个已知限制，并且不会影响使用箭头函数定义的 getter，也不会影响不使用 this 的 getter： \nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    counter: 0,\n  &#125;),\n  getters: &#123;\n    &#x2F;&#x2F; 自动将返回类型推断为数字\n    doubleCount(state) &#123;\n      return state.counter * 2\n    &#125;,\n    &#x2F;&#x2F; 返回类型必须明确设置\n    doublePlusOne() &#123;\n      &#x2F;&#x2F; 调用其他getter: \n      return this.doubleCount + 1\n      &#x2F;&#x2F; 等同于:\n      return this.counter * 2 + 1\n    &#125;,\n  &#125;,\n&#125;)\n\n接收参数传递(不常用)\nGetters 只是幕后的 computed 属性，因此无法向它们传递任何参数。 但是，您可以从 getter 返回一个函数以接受任何参数： \n这种操作getter不再缓存，只相当于在调用函数(从store 的解构中可以看出):::details Exampleexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  getters: &#123;\n    getUserById: (state) &#x3D;&gt; &#123;\n      return (userId) &#x3D;&gt; state.users.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId)\n    &#125;,\n  &#125;,\n&#125;)\n\n组件中&#x2F;&#x2F; store\ngetters: &#123;\n  doubleCount: (state) &#x3D;&gt; state.counter * 2,\n  doublePlusOne(): number &#123;\n    &#x2F;&#x2F; 等同于调用其他getter: return this.doubleCount + 1\n    return this.counter * 2 + 1\n  &#125;,\n  payloadCount() &#123;\n    return (payload) &#x3D;&gt; this.doublePlusOne + payload\n  &#125;\n&#125;,\n\n&#x2F;&#x2F; 组件\nconst &#123; userid, payloadCount &#125; &#x3D; storeToRefs(user)\n:::\nStore中的其他API$reset 重置状态store.$reset()\n&#x2F;&#x2F; PS: Setup 方式的 Store 不支持 $reset\n\n$state 访问 store 状态conosle.log(store.$state)\n\nstore.$state &#x3D; &#123; counter: 666, name: &#39;Paimon&#39; &#125;\n$onAction 监听 action 触发\nExample\nconst unsubscribe &#x3D; someStore.$onAction(\n  (&#123;\n    name, &#x2F;&#x2F; action 名称\n    store, &#x2F;&#x2F; store 实例，类似 &#96;someStore&#96;\n    args, &#x2F;&#x2F; 传递给 action 的参数数组\n    after, &#x2F;&#x2F; 在 action 返回或解决后的钩子\n    onError, &#x2F;&#x2F; action 抛出或拒绝的钩子\n  &#125;) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 为这个特定的 action 调用提供一个共享变量\n    const startTime &#x3D; Date.now()\n    &#x2F;&#x2F; 这将在执行 &quot;store &quot;的 action 之前触发。\n    console.log(&#96;Start &quot;$&#123;name&#125;&quot; with params [$&#123;args.join(&#39;, &#39;)&#125;].&#96;)\n\n    &#x2F;&#x2F; 这将在 action 成功并完全运行后触发。\n    &#x2F;&#x2F; 它等待着任何返回的 promise\n    after((result) &#x3D;&gt; &#123;\n      console.log(\n        &#96;Finished &quot;$&#123;name&#125;&quot; after $&#123;\n          Date.now() - startTime\n        &#125;ms.\\nResult: $&#123;result&#125;.&#96;\n      )\n    &#125;)\n\n    &#x2F;&#x2F; 如果 action 抛出或返回一个拒绝的 promise，这将触发\n    onError((error) &#x3D;&gt; &#123;\n      console.warn(\n        &#96;Failed &quot;$&#123;name&#125;&quot; after $&#123;Date.now() - startTime&#125;ms.\\nError: $&#123;error&#125;.&#96;\n      )\n    &#125;)\n  &#125;\n)\n\n&#x2F;&#x2F; 手动删除监听器\nunsubscribe()\n\n\n插件由于有了底层 API 的支持，Pinia store 现在完全支持扩展。以下是你可以扩展的内容：\n\n为 store 添加新的属性\n定义 store 时增加新的选项\n为 store 增加新的方法\n包装现有的方法\n改变甚至取消 action\n实现副作用，如本地存储\n仅应用插件于特定 store\n\n插件是通过 pinia.use() 添加到 pinia 实例的。最简单的例子是通过返回一个对象将一个静态属性添加到所有 store。\nimport &#123; createPinia &#125; from &#39;pinia&#39;\n\n&#x2F;&#x2F; 在安装此插件后创建的每个 store 中都会添加一个名为 &#96;secret&#96; 的属性。\n&#x2F;&#x2F; 插件可以保存在不同的文件中\nfunction SecretPiniaPlugin() &#123;\n  return &#123; secret: &#39;the cake is a lie&#39; &#125;\n&#125;\n\nconst pinia &#x3D; createPinia()\n&#x2F;&#x2F; 将该插件交给 Pinia\npinia.use(SecretPiniaPlugin)\n\n&#x2F;&#x2F; 在另一个文件中\nconst store &#x3D; useStore()\nstore.secret &#x2F;&#x2F; &#39;the cake is a lie&#39;\n\n\n简介Pinia 插件是一个函数，可以选择性地返回要添加到 store 的属性。它接收一个可选参数，即 context。\nexport function myPiniaPlugin(context) &#123;\n  context.pinia &#x2F;&#x2F; 用 &#96;createPinia()&#96; 创建的 pinia。 \n  context.app &#x2F;&#x2F; 用 &#96;createApp()&#96; 创建的当前应用(仅 Vue 3)。\n  context.store &#x2F;&#x2F; 该插件想扩展的 store\n  context.options &#x2F;&#x2F; 定义传给 &#96;defineStore()&#96; 的 store 的可选对象。\n  &#x2F;&#x2F; ...\n&#125;\n\n然后用 pinia.use() 将这个函数传给 pinia：\npinia.use(myPiniaPlugin)\n\n\n持久化存储function persistenceStatePlugin(context) &#123;\n  const &#123; store &#125; &#x3D; context;\n  const storage &#x3D; localStorage.getItem(&quot;pinia&quot;)\n    ? JSON.parse(localStorage.getItem(&quot;pinia&quot;))\n    : null;\n  \n  if (storage) &#123;\n    store.$patch(storage[store.$id]);\n  &#125;\n\n  store.$subscribe((mutation, state) &#x3D;&gt; &#123;\n    const storage &#x3D; localStorage.getItem(&quot;pinia&quot;)\n      ? JSON.parse(localStorage.getItem(&quot;pinia&quot;))\n      : &#123;&#125;;\n    storage[store.$id] &#x3D; state;\n    localStorage.setItem(&quot;pinia&quot;, JSON.stringify(storage));\n  &#125;);\n&#125;\n\n","slug":"pinia","date":"2023-03-21T15:21:53.000Z","categories_index":"Tecnology,Gadgets","tags_index":"tecnology","author_index":"X-29"},{"id":"0aaa27c48e7b40c2bc96b31fb70803da","title":"TypeScript","content":"TS 简介\nTypeScript 是 JavaScript 的超集。\n它对 JS 进行了扩展，向 JS 中引入了类型的概念，并添加了许多新的特性。\nTS 代码需要通过编译器编译为 JS，然后再交由 JS 解析器执行。\nTS 完全兼容 JS，换言之，任何的 JS 代码都可以直接当成 JS 使用。\n相较于 JS 而言，TS 拥有了静态类型，更加严格的语法，更强大的功能；TS 可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS 代码可以编译为任意版本的 JS 代码，可有效解决不同 JS 运行环境的兼容问题；同样的功能，TS 的代码量要大于 JS，但由于 TS 的代码结构更加清晰，变量类型更加明确，在后期代码的维护中 TS 却远远胜于 JS。\n\n开发环境搭建单文件\n下载 Node.js○ 64 位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi○ 32 位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi\n\n安装 Node.js\n\n使用 npm 全局安装 typescript○ 进入命令行○ 输入：npm i -g typescript\n\n创建一个 ts 文件\n\n使用 tsc 对 ts 文件进行编译○ 进入命令行○ 进入 ts 文件所在目录○ 执行命令：tsc xxx.ts\n\n\n脚手架直接内置，无需多管\n基本类型类型声明类型声明给变量设置了类型，使得变量只能存储某种类型的值语法：\nlet 变量: 类型;\n\nlet 变量: 类型 &#x3D; 值;\n\nfunction fn(参数: 类型, 参数: 类型): 类型&#123;\n    ...\n&#125;\n\n\n\n\n类型\n例子\n描述\n\n\n\nnumber\n1, -33, 2.5\n任意数字\n\n\nstring\n‘hi’, “hi”, hi\n任意字符串\n\n\nboolean\ntrue、false\n布尔值 true 或 false\n\n\n字面量\n其本身\n限制变量的值就是该字面量的值\n\n\nany\n*\n任意类型\n\n\nunknown\n*\n类型安全的 any\n\n\nvoid\n空值（undefined）\n没有值（或 undefined）\n\n\nnever\n没有值\n不能是任何值\n\n\nobject\n{name:’孙悟空’}\n任意的 JS 对象\n\n\narray\n[1,2,3]\n任意 JS 数组\n\n\ntuple\n[4,5]\n元素，TS 新增类型，固定长度数组\n\n\nenum\nenum{A, B}\n枚举，TS 中新增类型\n\n\nNumber\n\nClick to see more\nlet decimal: number &#x3D; 6;\nlet hex: number &#x3D; 0xf00d;\nlet binary: number &#x3D; 0b1010;\nlet octal: number &#x3D; 0o744;\nlet big: bigint &#x3D; 100n;\n\n\n\nBoolean\n\nClick to see more\nlet isDone: boolean &#x3D; false;\n\n\n\nString\n\nClick to see more\nlet color: string &#x3D; &quot;blue&quot;;\ncolor &#x3D; &#39;red&#39;;\n\nlet fullName: string &#x3D; &#96;Bob Bobbington&#96;;\nlet age: number &#x3D; 37;\nlet sentence: string &#x3D; &#96;Hello, my name is $&#123;fullName&#125;.\n\nI&#39;ll be $&#123;age + 1&#125; years old next month.&#96;;\n\n\n\n字面量\n\nClick to see more\n\n言外之意取值只能从规定的几个里面取let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;\n\n\n\nAny\n\nClick to see more\n\n相当于变成JavaScriptlet color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;\nlet num: 1 | 2 | 3 | 4 | 5;\n\n\n\nUnknown\n\nClick to see more\nlet notSure: unknown &#x3D; 4;\nnotSure &#x3D; &#39;hello&#39;;\n\n\n\nvoid\n\nClick to see more\nlet unusable: void &#x3D; undefined;\n\n\n\nNever\n\nClick to see more\nfunction error(message: string): never &#123;\n  throw new Error(message);\n&#125;\n\n\n\nObject\n\nClick to see more\nlet obj: object &#x3D; &#123;&#125;;\n\n\nArray\n\nClick to see more\nlet list: number[] &#x3D; [1, 2, 3];\nlet list: Array&lt;number&gt; &#x3D; [1, 2, 3];\n\n\nTuple\n\nClick to see more\nlet x: [string, number];\nx &#x3D; [&quot;hello&quot;, 10];\n\n\nEnum\n\n枚举（Enum）类型用于取值被限定在一定范围内的场景\n\n枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射\n\n如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉\n\n除了普通枚举，还有常量枚举、外部枚举等\n\n枚举成员只读，不可修改\n\n普通枚举：做了反向映射，可双向访问，会编译到JS代码中；使用场景：状态的判断、状态码\n\n字符串枚举：枚举的是字符串\n\n常量枚举：不会被编译到JS中。使用场景：如果某个变量你确定只有几种值，那么就可以使用常枚举去规定，超出规定就会提示报错；\n\n\n\nClick to see more\n\n相当于变成JavaScript&#x2F;&#x2F; 普通枚举 | 数字枚举\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; true\nconsole.log(Days[0] &#x3D;&#x3D;&#x3D; &quot;Sun&quot;); &#x2F;&#x2F; true\nenum Color &#123;\n  Red, &#x2F;&#x2F; 0\n  Green, &#x2F;&#x2F; 1\n  Blue, &#x2F;&#x2F; 2\n&#125;\nenum Color &#123;\n  Red &#x3D; 1, &#x2F;&#x2F; 1\n  Green &#x3D; 7, &#x2F;&#x2F; 7\n  Blue, &#x2F;&#x2F; 8\n&#125;\nenum Color &#123;\n  Red &#x3D; 1,\n  Green &#x3D; 2,\n  Blue &#x3D; 4,\n&#125;\nenum Demo &#123;\n    &#x2F;&#x2F; const\n    a,                  &#x2F;&#x2F; 没有初始值\n    b &#x3D; Demo.a,         &#x2F;&#x2F; 对已有枚举成员的引用\n    c &#x3D; 1 + 2,          &#x2F;&#x2F; 常量的表达式\n    &#x2F;&#x2F; computed\n    d &#x3D; Math.random(),  &#x2F;&#x2F; 需要被计算的枚举成员\n    e &#x3D; &#39;abc&#39;.length    &#x2F;&#x2F; 需要被计算的枚举成员\n&#125;\n&#x2F;&#x2F; 字符串枚举\nenum orderStatusDesc &#123;\n    UN_PAYED &#x3D; &#39;未支付&#39;,\n    PAYED &#x3D; &#39;已支付&#39;,\n    CANCELED &#x3D; &#39;已取消&#39;,\n    CLOSED &#x3D; &#39;已关闭&#39;\n&#125;\n&#x2F;&#x2F; 常量枚举\nconst enum Month &#123;\n    Jan,\n    Feb,\n    Mar\n&#125;\n&#x2F;&#x2F; 异构枚举：字符串与数字枚举混合，不推荐\nenum Status&#123;\n    UN_PAYED,\n    PAYED &#x3D; &#39;已支付&#39;\n&#125;\n:::\n\n类型断言有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型\n第一种\nlet someValue: unknown &#x3D; &quot;this is a string&quot;;\nlet strLength: number &#x3D; (someValue as string).length;\n\n第二种\nlet someValue: unknown &#x3D; &quot;this is a string&quot;;\nlet strLength: number &#x3D; (&lt;string&gt;someValue).length;\n\n\n编译选项\n自动监视文件并编译：tsc xxx.ts -w \n自动编译整个项目：tsc\n\n:::details tsconfig.json文件配置\n&#x2F;&#x2F; tsconfig.json\n&#123;\n  &quot;files&quot;: [&quot;src&#x2F;a.ts&quot;], &#x2F;&#x2F; 需要编译的单个文件列表\n  &quot;include&quot;: [&quot;src&#x2F;*&quot;], &#x2F;&#x2F; 编译某个文件夹下的一级所有文件\n  &quot;exclude&quot;: [&quot;src&#x2F;lib&quot;], &#x2F;&#x2F; 需要排除的文件、文件夹\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base&quot;, &#x2F;&#x2F; 需继承的配置文件tsconfig.base.json\n  &quot;compileOnSave&quot;: true, &#x2F;&#x2F;保存文件的时候自动编译，但当前vscode不支持\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; 增量编译，第一次编译生成一个文件，使得第二次编译速度会提高\n    &quot;tsBuildInfoFile&quot;: &quot;.tsbuildinfo&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n    &quot;module&quot;: &quot;commonjs&quot;, &#x2F;&#x2F; 生成代码的模块标准\n    &quot;target&quot;: &quot;ES3&quot;, &#x2F;&#x2F; 生成代码目标语言的版本\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可用在AMD模块中\n    &quot;lib&quot;: [], &#x2F;&#x2F; ts需要引用的库，即声明文件，target&#x3D;es5则默认引用dom, es5,scripthost\n    &quot;allowJs&quot;: true, &#x2F;&#x2F; 允许编译JS文件\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 与allowJs配合使用，对JS文件进行语法检查\n    &quot;outDir&quot;: &quot;.&#x2F;out&quot;, &#x2F;&#x2F; 指定输出目录\n    &quot;rootDir&quot;: &quot;.&#x2F;src&quot;, &#x2F;&#x2F; 指定输入文件目录\n    &quot;declaration&quot;: false, &#x2F;&#x2F; 生成声明文件\n    &quot;declarationDir&quot;: &quot;.&#x2F;d&quot;, &#x2F;&#x2F; 声明文件的路径\n    &quot;emitDeclarationOnly&quot;: false, &#x2F;&#x2F; 只生成声明文件\n    &quot;sourceMap&quot;: false, &#x2F;&#x2F; 生成目标文件的sourceMap\n    &quot;inlineSourceMap&quot;: false, &#x2F;&#x2F; 生成目标文件的inlineSourceMap\n    &quot;declarationMap&quot;: false, &#x2F;&#x2F; 生成目标文件的declarationMap\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认node_modules&#x2F;@types\n    &quot;types&quot;: [], &#x2F;&#x2F; 声明文件包\n    &quot;removeComments&quot;: false, &#x2F;&#x2F; 删除注释\n    &quot;noEmit&quot;: false, &#x2F;&#x2F; 不输出文件\n    &quot;noEmitOnError&quot;: false, &#x2F;&#x2F; 发生错误时不输出文件\n    &quot;noEmitHelpers&quot;: false, &#x2F;&#x2F; 不生成helper函数，需额外安装ts-helpers\n    &quot;importHelpers&quot;: false, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n    &quot;downlevelIteration&quot;: false, &#x2F;&#x2F; 降级遍历器的实现(es3&#x2F;5)\n    &quot;strict&quot;: false, &#x2F;&#x2F; 开启所有严格的类型检查\n    &quot;alwaysStrict&quot;: false, &#x2F;&#x2F; 在代码中注入&quot;use strict&quot;\n    &quot;noImplicitAny&quot;: false, &#x2F;&#x2F; 不允许隐式的any类型\n    &quot;strictNullChecks&quot;: false, &#x2F;&#x2F; 不允许把null、undefined赋值给其它类型变量\n    &quot;strictFunctionTypes&quot;: false, &#x2F;&#x2F; 不允许函数参数双向协变\n    &quot;strictPropertyInitialization&quot;: false, &#x2F;&#x2F; 类的实例属性必须初始化\n    &quot;strictBindCallApply&quot;: false, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n    &quot;noImplicitThis&quot;: false, &#x2F;&#x2F; 不允许this有隐式的any类型\n    &quot;noUnusedLocals&quot;: false, &#x2F;&#x2F; 检查只声明，未使用的局部变量\n    &quot;noUnusedParameters&quot;: false, &#x2F;&#x2F; 检查未使用的函数参数\n    &quot;noFallthroughCasesInSwitch&quot;: false, &#x2F;&#x2F; 防止Switch语句贯穿\n    &quot;noImplicitReturns&quot;: false, &#x2F;&#x2F; 每个分支都要有返回值\n    &quot;esModuleInterop&quot;: false, &#x2F;&#x2F; 允许export &#x3D; 导出，由import from导入\n    &quot;allowUmdGlobalAccess&quot;: false, &#x2F;&#x2F; 允许在模块中访问UMD全局变量\n    &quot;moduleResolution&quot;: &quot;classic&quot;, &#x2F;&#x2F; 模块解析策略\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址\n    &quot;paths&quot;: &#123;&#125;, &#x2F;&#x2F; 路径映射，相对于baseUrl\n    &quot;rootDirs&quot;: [], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时\n    &quot;listEmittedFiles&quot;: false, &#x2F;&#x2F; 打印输出的文件\n    &quot;listFiles&quot;: false &#x2F;&#x2F; 打印编译的文件（包括引用的声明文件）\n  &#125;\n&#125;\n\n\n\n如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。 \n但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json \ntsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc -\n\n","slug":"TypeScript","date":"2023-03-05T04:07:57.000Z","categories_index":"Tecnology,Gadgets","tags_index":"tecnology","author_index":"X-29"},{"id":"3a4eda1192ec992162144e15ab7e2ec5","title":"Vue3","content":"创建工程使用 vite\n\n\n\n\n\n\n\n\n创建工程npm init vite-app 进入工程目录cd 安装依赖npm install运行npm run dev\n常用的 Composition Apisetup()setup 函数的两种返回值：\n\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。\n若返回一个渲染函数：则可以自定义渲染内容。\n\nPay Attention!\n\n尽量不要与 Vue2.x 配置混用 Vue2.x 配置（data、methos、computed…）中可以访问到 setup 中的属性、方法。\n但在 setup 中不能访问到 Vue2.x 配置（data、methos、computed…）\n如果有重名, setup 优先。\nsetup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）\nsetup 执行的时机：在 beforeCreate 之前执行一次，this 是 undefined。\n\n\n\n\n\n\n\n\nWARNING\n  setup 的参数\n\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\ncontext：上下文对象\nattrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs。\nslots: 收到的插槽内容, 相当于 this.$slots。\nemit: 分发自定义事件的函数, 相当于 this.$emit。\n\n\n\nref()作用: 定义一个响应式的数据语法:\n\nconst xxx &#x3D; ref(initValue)\n创建一个包含响应式数据的引用对象（reference 对象，简称 ref 对象）。\nJS 中操作数据： xxx.value\n模板中读取数据: 不需要.value，直接：备注：\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠 Object.defineProperty()的 get 与 set 完成的。\n对象类型的数据：内部 “ 求助 ” 了 Vue3.0 中的一个新函数—— reactive 函数。\n\nreactive()作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用 ref 函数）语法：\n\nconst 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 proxy 对象）\nreactive 定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n不常用的 Composition ApitoRef()作用：\n\n创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。语法：\nconst name &#x3D; toRef(person,’name’)应用:\n要将响应式对象中的某个属性单独提供给外部使用时。扩展：\ntoRefs 与 toRef 功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n\nshallowReactive() 与 shallowRef()shallowReactive：\n\n只处理对象最外层属性的响应式（浅响应式）。\n\nshallowRef：\n\n只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n什么时候使用?\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。\nreadonly() 与 shallowReadonly()readonly:\n\n让一个响应式数据变为只读的（深只读）。shallowReadonly：\n让一个响应式数据变为只读的（浅只读）。应用场景: 不希望数据被修改时。\n\ntoRaw() 与 markRaw()toRaw：作用：\n\n将一个由 reactive 生成的响应式对象转为普通对象。使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。markRaw：作用：\n标记一个对象，使其永远不会再成为响应式对象。应用场景:有些值不应被设置为响应式的，例如复杂的第三方类库等。当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\ncustomRef()作用：\n\n创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。Example↓\n\n实现输入框的防抖&lt;template&gt;\n\t&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;keyword&quot;&gt;\n\t&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;&#x2F;h3&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n\timport &#123;ref,customRef&#125; from &#39;vue&#39;\n\texport default &#123;\n\t\tname:&#39;Demo&#39;,\n\t\tsetup()&#123;\n\t\t\t&#x2F;&#x2F; let keyword &#x3D; ref(&#39;hello&#39;) &#x2F;&#x2F;使用Vue准备好的内置ref\n\t\t\t&#x2F;&#x2F;自定义一个myRef\n\t\t\tfunction myRef(value,delay)&#123;\n\t\t\t\tlet timer\n\t\t\t\t&#x2F;&#x2F;通过customRef去实现自定义\n\t\t\t\treturn customRef((track,trigger)&#x3D;&gt;&#123;\n\t\t\t\t\treturn&#123;\n\t\t\t\t\t\tget()&#123;\n\t\t\t\t\t\t\ttrack() &#x2F;&#x2F;告诉Vue这个value值是需要被“追踪”的\n\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\tset(newValue)&#123;\n\t\t\t\t\t\t\tclearTimeout(timer)\n\t\t\t\t\t\t\ttimer &#x3D; setTimeout(()&#x3D;&gt;&#123;\n\t\t\t\t\t\t\t\tvalue &#x3D; newValue\n\t\t\t\t\t\t\t\ttrigger() &#x2F;&#x2F;告诉Vue去更新界面\n\t\t\t\t\t\t\t&#125;,delay)\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;)\n\t\t\t&#125;\n\t\t\tlet keyword &#x3D; myRef(&#39;hello&#39;,500) &#x2F;&#x2F;使用程序员自定义的ref\n\t\t\treturn &#123;\n\t\t\t\tkeyword\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&lt;&#x2F;script&gt;\n\n检测型 ApiisRef:\n\n检查一个值是否为一个 ref 对象isReactive:\n检查一个对象是否是由 reactive 创建的响应式代理isReadonly:\n检查一个对象是否是由 readonly 创建的只读代理isProxy:\n检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\nComputed &amp; Watch &amp; WatchEffectComputed写法如下：\nimport &#123;computed&#125; from &#39;vue&#39;\n\nsetup()&#123;\n    ...\n\t&#x2F;&#x2F;计算属性——简写\n    let fullName &#x3D; computed(()&#x3D;&gt;&#123;\n        return person.firstName + &#39;-&#39; + person.lastName\n    &#125;)\n    &#x2F;&#x2F;计算属性——完整\n    let fullName &#x3D; computed(&#123;\n        get()&#123;\n            return person.firstName + &#39;-&#39; + person.lastName\n        &#125;,\n        set(value)&#123;\n            const nameArr &#x3D; value.split(&#39;-&#39;)\n            person.firstName &#x3D; nameArr[0]\n            person.lastName &#x3D; nameArr[1]\n        &#125;\n    &#125;)\n&#125;\n\nWatch\n\n\n\n\n\n\nWARNING\n监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。\n\n&#x2F;&#x2F;情况一：监视ref定义的响应式数据\nwatch(\n  sum,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;sum变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true &#125;\n);\n\n&#x2F;&#x2F;情况二：监视多个ref定义的响应式数据\nwatch([sum, msg], (newValue, oldValue) &#x3D;&gt; &#123;\n  console.log(&quot;sum或msg变化了&quot;, newValue, oldValue);\n&#125;);\n\n&#x2F;* 情况三：监视reactive定义的响应式数据\n\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\n\t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 \n*&#x2F;\nwatch(\n  person,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: false &#125;\n); &#x2F;&#x2F;此处的deep配置不再奏效\n\n&#x2F;&#x2F;情况四：监视reactive定义的响应式数据中的某个属性\nwatch(\n  () &#x3D;&gt; person.job,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: true &#125;\n);\n\n&#x2F;&#x2F;情况五：监视reactive定义的响应式数据中的某些属性\nwatch(\n  [() &#x3D;&gt; person.job, () &#x3D;&gt; person.name],\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: true &#125;\n);\n\n&#x2F;&#x2F;特殊情况\nwatch(\n  () &#x3D;&gt; person.job,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&quot;person的job变化了&quot;, newValue, oldValue);\n  &#125;,\n  &#123; deep: true &#125;\n); &#x2F;&#x2F;此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\nWatchEffectwatch 的套路是：\n\n既要指明监视的属性，也要指明监视的回调。\n\nwatchEffect 的套路是：\n\n不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\nwatchEffect 有点像 computed：\n\n但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n&#x2F;&#x2F;watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\nwatchEffect(() &#x3D;&gt; &#123;\n  const x1 &#x3D; sum.value;\n  const x2 &#x3D; person.age;\n  console.log(&quot;watchEffect配置的回调执行了&quot;);\n&#125;);\n\n生命周期mounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMountedbeforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdateupdated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdatedbeforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmountunmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmountedbeforeCreate&#x3D;&#x3D;&#x3D;&gt;setup()created&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup()\n自定义 Hook 函数\n什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。\n类似于 vue2.x 中的 mixin。\n自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。\n\n好用的传值provide 与 inject作用：\n\n实现祖与后代组件间通信套路：\n父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据,其实子组件可以用，但是 prop 更简单，别给自己找麻烦\n\n具体写法——祖组件setup()&#123;\n    ......\n    let car &#x3D; reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)\n    provide(&#39;car&#39;,car)\n    ......\n&#125;\n\n具体写法——后代组件setup(props,context)&#123;\n    ......\n    const car &#x3D; inject(&#39;car&#39;)\n    return &#123;car&#125;\n    ......\n&#125;\n\n新的组件&#x2F;标签Fragment\n\n在 Vue2 中: 组件必须有一个根标签\n在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\nTeleport一种能够将我们的组件 html 结构移动到指定位置的技术。无视所在盒子的 position，指哪打哪，其中“to”属性就是告诉代码依托于谁定位\nExample&lt;teleport to&#x3D;&quot;body&quot;&gt;\n\t&lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;dialog&quot;&gt;\n\t\t\t&lt;h3&gt;我是一个弹窗&lt;&#x2F;h3&gt;\n\t\t\t&lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;teleport&gt;\n\n\n\n\n\n\n\n\n\n\n此例中，就直接将 body 作为参考位置\nSuspense等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n异步引入组件import {defineAsyncComponent} from ‘vue’const Child &#x3D; defineAsyncComponent(()&#x3D;&gt;import(‘.&#x2F;components&#x2F;Child.vue’))\n\n\n\n\n\n\n\nWARNING\n使用 Suspense 包裹组件，并配置好 default 与 fallback\n\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h3&gt;我是App组件&lt;&#x2F;h3&gt;\n    &lt;Suspense&gt;\n      &lt;template v-slot:default&gt;\n        &lt;Child &#x2F;&gt;\n      &lt;&#x2F;template&gt;\n      &lt;template v-slot:fallback&gt;\n        &lt;h3&gt;加载中.....&lt;&#x2F;h3&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Suspense&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n全局 Api 的转移\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n","slug":"Vue3","date":"2023-02-25T15:36:05.000Z","categories_index":"Tecnology,Vue","tags_index":"tecnology","author_index":"X-29"},{"id":"7e72fed44435aa241098215766c6357c","title":"四载求学路，功名终已成","content":"离津四载，历历在目\n\n\n\n\n\n\n\n\n2月2日是我 期末考试的最后一天。当黑色的水笔在白色的答题纸上落下最后的一个句号时，画上了我学生时代的句号。没有数不尽的课堂签到，没有数不尽的宿舍查寝，没有数不尽的考试作业。同时也没有了睡到自然醒的偷偷窃喜的早晨，也没有廉价的饭菜，也没有落日余晖下，课堂钟声交织着欢笑声的身影。\n少年不知油盐贵，自成乃知白面香回首向来萧瑟处 也无风雨也无晴在津18载，毫不夸张地说，那时的我并不知道柴米油盐，肉蛋菜奶的价格，毫不关心的心态宛如并不需要它们似的。只觉得课本中的哪位作者表达了什么样的思想感情，或者是发牢骚埋怨几句为什么作者要写这么多；只觉得历史地理等虽然有意思但是作为应试和平时并不会太常用到而感到手足无措；只觉得复习到半夜隔壁老人院传来的呻吟声和父母的鼾声是那么吵闹。\n四载岁月如手中流沙，当初有多想它走，它现在也依然流得很快，但是从期盼变为乞求。\n在津常常所能吃到的一些美味佳肴，曾常常以为全天下遍地都是，我也只不过是大多数的一员，它们也只是天下众人的家常便饭。而如今才后知后觉，原先在津吃腻看顶的东西，如今只有在伴随着年的到来，才得有幸尝上那么几口，似乎对于我来说，年味的感觉由原先亲戚长辈的压岁钱、爸爸准备好的一桌饭菜还有大家的欢声笑语演变成陪伴他们和像是在一年大多数日子中用小刀轻轻的划一个口子，用来抓取一些旧时因为常常能得到而厌烦的东西。而还没等我好好细品细品和原先味道的对比，时间又匆匆在我耳边催我赶紧离开。\n\n\n\n\n\n\n\n\n\n回家？何以为家？\n经过了一个月对前端开发的工作性的历练，从原先压力大到想放弃，甚至一度对未来感到十分迷茫，尽管周围不断传来“前端已经凉了”、“互联网已经是末班车”了诸如此类的话语，但是狭路相逢勇者胜不是吗？\n弃之可惜，食之无味孔乙己的长衫是到了都紧紧吊住的上吊绳\n\n\n\n\n\n\n\n\n\n考研吧孩子，对你未来可以多宽一些路考了研有什么用，路的尽头还是路兄弟考研了你这专业更吃香啊据报道：今年考研人数破500W，我们学校怎么才上岸这么点人啊你要当老师来我这里就可以啊，但是好像得是研究生，要不你考考试试？考了研我们会异地的，而且一个上班一个上大学好辛苦\n它不仅是敲门砖，也是下不来的高台，更是孔乙己脱不下的长衫。苦读十二年，费尽父母心，父母望子成龙，望女成凤，比自己越好越好，殊不知，如若此生可达父辈的高度，乃荣幸之至。\n","slug":"end-of-university-life","date":"2023-02-23T14:42:44.000Z","categories_index":"Essays","tags_index":"随笔","author_index":"X-29"},{"id":"79626da8328cb7abd9069e2fabc82af5","title":"2023NewYear","content":"新年伊始，癸卯兔年\n\n\n\n\n\n\n\n\n新春佳节，兜兜转转又是一年。弱冠之年有三。\n忆往昔，三年即逝忆2019-2023 是我的大学时光，也是目前为止最为自由的一段时间。\n\n级级相扣级级推，越过万难终已晚。\n保全帽子闭上眼，黎民他人我何干，同胞永存湖中间。\n初入职场，幸窃技于网络，遂于如此，四年之所学无一益处于职场。\n\n品\n身体和环境的苦难可以通过奋斗而解决，而思想上的苦难，终有大罗金仙，佛祖菩萨显灵也无济于事。\n苦难是配得上思想的。如果有人帮助你，要做的并不是嘲笑他，而是应该像父母从小教育的那样说一声“谢谢”。\n\n望\n弱冠又三年之久，初知为人父母之不易，生活之艰辛，养育之苦楚。心有报恩情，手无缚鸡力。愿父母存世更久，给我更多的机会。\n手足亲妹，离家两年，判若两人，成长许多，心中也放心些。\n当下，或许将自己和爱人照顾好许是对他们的最好的安心丸。\n\n结\n幸于毛家大小姐结为比翼鸟，一心只为连理枝。苦境共甘，实为三生有幸。甜时愿倾所有以取悦。\n也荣幸得识毛家老爷与夫人亲如父母，慈善心肠，自身父母外，从未遇到此般夫妻，非幸运所能云也。如若不嫌，愿同亲父母一般赡养。\n\n","slug":"2023NewYear","date":"2023-01-25T03:57:17.000Z","categories_index":"Essays","tags_index":"随笔","author_index":"X-29"},{"id":"7b73417322203bc26ba172442308aa21","title":"系统架构师","content":"系统架构师的初步设想刚开始认识它的时候应该是我第一次看见过软考内容的时候，我是一个如果没有十全把握就不敢去付出或者制定什么计划。至于真正有这个梦想和计划应该是在2022年10月份，去见阿毛的地铁上，因为无聊的原因自己冷不丁的突然想起了这个名词——系统架构师\n\n\n\n\n\n\n\n\n\n写下这篇博客的时候还没有开始准备系统架构师的各项备考。如果后面有幸上岸，会来此篇重新更新。\n系统架构师成为架构师的意义\n说实话归根结底，$是做任何事情的根基\n确实是对科技的喜欢\n熊猫其实是食肉动物，但是由于自然环境的恶劣，被迫去吃了竹子\n\n考试时间一年一度一般为每年11月的上旬\n考试的前置任务并没有什么前置任务，自己有把握直接冲最高。丰俭由人。\n考试难度话不多说：只有15%\n基本考试情况试卷概况\n\n综合题\n75道单项选择\n考试时间：2.5小时\n综合题的考试范围几乎涵盖了架构师考试考纲要求的所有知识点。虽然知识点分布很广，但是通过历年真题分析发现，考察的侧重点也非常明显。其中软件架构、软件工程是分值占比最大的章节。相比之下，其他知识点分值占比就少很多。\n\n\n案例分析题\n3道简答题\n1道必答\n剩下的4选2\n\n\n考试时间：1.5小时\n标准答案并不会涵盖所有可能的考点。\n选答题：相对灵活，比较贴近实际开发。需要自己在复习的时候积累相关的知识点。\n\n\n论文\n题目四选一\n\n2600字\n\n考试时间：2小时\n\n整体趋势是偏应用的和偏趋势的，出题方向从近几年的趋势来说可以说变得非常难以预测。\n\n论文复习的三大方向，分别是格式、内容和速度。\n\n其中选题和提纲，需要在15分钟内完成。在给出的题目中，选择一个自己熟悉的作为选项，然后大致列出论点  \n  \n  img{\n      width:800px\n  }\n  \n\n从答题卡可以看出，摘要为350字左右。正文内容为2750字。因此内容字数上，最好安排在2500-2750之间，这样会提升阅卷观感，提高印象分数。\n\n\n\n\n复习方向\n\n\n\n\n\n\n特别提示\n以《系统架构师》教材和网课为中心\n\n如下细分：\n\n计算机原理\n计算机网络\n操作系统\n系统性能评价\n数据库\n安全性和保密性设计\n嵌入式系统\n信息系统\n\n点点旁边，发现笔记：\n\n各学科笔记\n分类笔记\n\n\n下次再会~\n","slug":"system-architect","date":"2022-11-24T07:32:36.000Z","categories_index":"系统架构师","tags_index":"目标,梦想,系统架构","author_index":"X-29"},{"id":"15db1aab1cbfb7938aed1bee0fd27710","title":"Monica","content":"Monica也可以叫她：莫妮卡如你所见，封面就是她\n\n\n\n\n\n\n\nMonica的个人简介\n姓名：莫妮卡性别：AI母语：Python\n\n\nThe Origin of MonicaMonica起源于我脑海中自高中以来一直存在的AI助手梦。也是因为Jarvis的原因，使得我拥有属于自己助手的愿望极其强烈\n在我高中时期，由于自由接触程序技术的时间不是很多，造成了长时间搁置创作属于自己AI的梦想。以至于认为创作AI是一个很难的事情，尤其是在观看了Zuckerberg先生的家庭语音助手之后，愈发觉得艰难\nMonica的名字起源于创建Monica的时候正好是星期一(Monday)，取前三个字母，所以得名Monica\n\n\n\n\n\n\n\nMonica的依赖\nMonica需要Google的语音识别API，所以务必保证的网络顺畅\n\nMonica can do this for you新的很懂你的朋友可以跟Monica说任何事情，可以分享快乐，吐槽焦虑，发泄悲伤\n可以永远相信Monica\n\n\n\n\n\n\n\n\n\n“Monica，你在吗？”“永远都在，先生”\n帮助你解决问题的好帮手当遇到需要查询什么东西的时候，可以完全依赖Monica，释放双手。她就像是一个无所不知的朋友，在需要的时候和想知道什么的时候，只需要跟她说说话。\n\n\n\n\n\n\n\n\n\n“Monica，你知道xxx是什么吗”“可以告诉你，但是需要奖励”\n电脑的智能管家存在于虚拟世界的Monica甚至电脑都不需要亲自操控，就像朋友之间的亲密对话，即可完成对电脑的各种操作\n\n[截屏]“Monica你有空吗，我想要当前这个画面”\n[VSCode]“准备写写代码了”\n[喜欢玩的游戏]“有什么好玩的让我放松一下吗”\n[B站或者Youtube]“有什么热门视频是我感兴趣的吗”\n[热点新闻]“你知道最近那个xxx的事吗”\n[记事本]“对了Monica，帮我记一下，我怕我忘了”\nEtc…\n\n特殊日子会比自己更加在意Monica：马上要到纪念日了哦，想好礼物了吗，没有的话听听我的建议吧\nMonica：今天是什么日子忘了吗？你可真是个大忙人呢。今天是xxx的日子\nMonica：我看了下天气，好像不怎么好。希望你不要淋着雨回来\nMonica在众多人中最关注你Monica：先生，是你吗\nMonica：这不是先生总和我提起的xxx\nThe Future of MonicaMonica的未来，我会将她融入到我的生活，赋予实体，或许是个机器人，或许是个机械臂，或许将会是无处不在。\nMonica对于技术壁垒的依赖性太强，日后会帮助Monica逐渐去掉枷锁\n增加Monica的自主学习能力\n","slug":"monica","date":"2022-11-22T15:44:33.000Z","categories_index":"Introduce","tags_index":"Introduce,A.I.,Assistant","author_index":"X-29"},{"id":"8401b4ea3ecc23c13e44dcec2d197d6b","title":"X-Blog","content":"\n\n\n\n\n\n\n\n\n欢迎来到 X-29 的博客，这里记录了许多程序界的知识以及创新和展望。除此之外，作为个人博客，也包含了个人的文学鉴赏或者是日常生活分享。本博客也是我个人技术界的日志或者可以叫做日记，所以会不断更新。\n\nWelcome to the blog of X-29, which records a lot of knowledge, innovation and prospects of the program industry. In addition, as a personal blog, it also includes personal literature appreciation or daily life sharing. This blog is also a diary of my personal technical community or can be called a diary, so it will be updated constantly.\n\n博客创建初衷起初，在我刚接触程序代码界的第一脚是迈入的前端的门槛中。上完课的笔记或者联系代码亦或者是学习心得，总想找到一个永久保存的地方中，思来想去，从百度网盘到CSDN，而至后面的Git Hub。\n随着需求越来越多，想记录和分享的东西也与来越多。偶然之间接触了VuePress制作的博客网站。不断改良，效仿。数月之后，打算所有的页面及内容以及功能，全部推到重来。不再效仿，改为原创。打造真正属于自己的个人博客。\n一个人的学习是孤独的，无助的，创新的，成就的。在经历过多种不断尝试新的建站工具以及各种程序语言之后，选择了Hexo作为本网站的框架结构。\n博客内容内容概述由上可知，本网站内容分为如下部分\n\n技术分享\n技术未来展望\n个人生活分享&amp;记录\n学习工作日志\n\n功能预览\n书写&amp;发表&amp;浏览文章\n搜索文章\n文章目录及标签分类\n网站宠物机器人\n留言板&amp;联系\nCreating…\n\nX-UNIVERSUM &amp; X-29**X-UNIVERSUM**是在我的大学时期从我的脑海中产生的一个目标或梦想。不管未来是否真的会创立或者实现，都会一直存在在我的人生中。**X-UNIVERSUM**的定位是一个不仅服务于人们的大众日常生活的各个方面：购物、美食、住房、出行，而且也将会是科技发展的导向与前沿。\nX-UNIVERSUM INDUSTRY\n\n购物：重新定义电商模式。买卖双方获益\n美食：与独特的科技相结合，实现美食无地域无国界地域种类划分，文化交融\n住房：运用科技手段，房子将不再是昂贵的，凿实居住属性\n出行：重新定义“距离”\n科技：领导科技发展方向，服务于人，人人都是科技的创造者\n\n**X-29，X-UNIVERSUM**的创造者。规则，将被打破生活，将被重新定义你我，都是自己的主宰\n","slug":"hello-world","date":"2022-11-19T16:12:11.000Z","categories_index":"Introduce","tags_index":"X-Blog,Introduce","author_index":"X-29"},{"id":"c3978c5070945a51b43d4b2c283dc47e","title":"前端技术展望","content":"Front End Development Trend Forecast前端新标准HTML 6.02014 年 10 月 28 日，W3C 正式发布 HTML5.0 推荐标准让前端技术蓬勃发展。虽然 HTML6.0 目前处于提案阶段，但是社区已经开始有了一些零星的讨论，所以可能它离我们并不太远。\nHTML6.0 中，可能会新增“增强身份验证”和“集成摄像头” 两个能力，大家可以持续关注相关进展。\n一直以来，浏览器由于身份验证问题导致 Web 应用在很多场景乏力，特别是目前大部分 APP 是十分“重”的，功能繁多，如果这两个能力得以普及，那么可能会有更多的 WEB 应用代替以前 APP 的极速版本。\n由于新冠疫情影响，越来越多人的工作方式变成了 WFH。可以预见，疫情彻底清除以后，远程办公也许会成为不少人的选择。所以“集成摄像头”能力，很有可能在人与人线上交流场景中，发挥更大的作用。\n2022 年，可能 HTML6 并不会推出，但是可能会有更多利于用户体验的提案出现。\nWeb3.0Facebook 改名 Meta 后，元宇宙话题很火热，但突然一夜之间，讨论似乎又从元宇宙过渡到了 Web3.0。\n前端工程化展望前端框架在 StackOverflow 的“最受欢迎的 Web 框架”调查中，除去 SSR 渲染框架和 jQuery，上榜的前端框架共有 5 个：\n\n前端框架排行图\n\n\n而从 NPM 下载量来分析，观察到的现象是：\n\nReact 一家独大，独自吃掉 70% 的市场份额；\nVue 和 Angular 平分秋色打的难舍难分；\nPreact 作为“轻量版 React”在小众中最受欢迎；\nSvelte 作为无 vdom 的 MVVM 框架，艰难爬升中，甚至还没超过已经停止更新的 AngularJS。\n\n\n\n\n\n\n\n\n\n\n总的来说，React，Vue，Angular 依然是强势铁三角向前发展。在 2022 年 Vue3 会成为 Vue 的默认版本，React 18 也会发布正式版本，从目前社区关注度来看， Vue3 源码 Github star 27k+， React 18 WG Github star 3.9k+，且在 npm 的下载量上，新版本下载数目都比较可观，所以很有可能今年尝试和使用的人会变得更多。\n打包器打包器大概可以分为两类：\n\n传统编译：Webpack, Rollup, Parcel, Esbuild\nESM 混合编译：Snowpack, Vite\n\n目前是 Webpack、Rollup、Esbuild 三分天下：\n\nWebpack：我们的老熟人，生态最丰富、功能最多，独自吃掉 70% 的市场份额；\nRollup：ESM 版的 Webpack，甩掉了很多历史包袱；\nEsbuild：Go 写的 Webpack，性能有数十倍提升。\n\nUI框架由于模块化 CSS、摇树、MVVM 的流行，UI 框架的选择其实没有那么举足轻重了，针对自己选用的框架选择一个符合项目风格的 UI 即可。\n桌面端值得关注的只有两个：\n\nElectron: 我们的老熟人，Chromium + Nodejs，深受大家喜爱；\nTauri: 异军突起的新星，Webview + Rust。对比 Electron 因为不用打包 Chromium 和 Nodejs 运行时，产物体积小，运行性能好；\n\n智能前端低代码的崛起低代码开发平台（英语：Low-Code Development Platform，简称 LCDP），是一种方便产生应用程序的平台软件，软件会开发环境让用户以图形化接口以及配置编写程序，而不是用传统的程序设计做法。此平台是针对某些种类的应用而设计开发的，例如数据库、业务过程、以及用户界面（例如网页应用程序）。这类平台一般可以产生完整且可运作的应用程序，在一些特殊的情形下仍需要编写程序。\nAI与图形化的探索人工智能作为跨时代技术在各个领域大放异彩，近些年 AI 能力在前端领域的尝试与应用带来新一轮的技术革命。前端可以依赖 D3.js，ECharts，WebGL 等进行数据可视化的显示：\n跨平台技术随着从 PC 时代向移动互联网时代演进，原生客户端因为自身天花板的原因也在逐渐向跨平台方案倾斜，当然这得益于跨平台方案的明显优势。对于开发者而言，可以做到一次开发多端复用，这在很大程度上能够降低研发成本，提高产品效能\n2020-2021 年间，有 42% 的开发者用过 React Native 进行开发，这一年内没有增长；而 Flutter 这一数据从 2020 年的 39% 上升到了 42%。\n成为泛前端前端研发需要掌握的技术也在迭代更新，基本可以理解为 FaaS BaaS，在 Baas 层进行存储与计算，在 Faas 层提供云函数。\n尽可能成为全栈从工程师能力模型来看，第一级需要集“天时地利人和”大成，是工程师的最高荣誉。普通人或许可以将目标聚焦在第二、三级。优秀的工程师并不是以“栈”数取胜，更重要的是拥有产品观、全局思维、沟通能力、学习能力、解决问题能力等\n","slug":"front-end-expectation","date":"2022-11-18T14:42:46.000Z","categories_index":"Front-End","tags_index":"前端技术栈,前端发展前景","author_index":"X-29"},{"id":"6b9a8f6982f1769c256f388c30975912","title":"前端技术栈","content":"Front-End技术栈概论\n\n\n\n\n\nWhat’s the meaning of Fronot-End\n前端的意义在于创造。\n\n技术的诞生，从来不是为了获得更多的利益。树上的苹果并不会给牛顿带来新的一笔巨大财富。如今市场的需求化已经金钱的吮吸灵魂的力量，将技术本来的面目，弄得灰头土脸。禁锢、限制、局限。不止前端。\nFront-End Learning Path后知后觉，如梦初醒。师从四方，自力更生。\n学习路径前端核心：HTML5+CSS3→移动端web→JavaScript→DOM&amp;BOM→Jquery→Ajax技术进阶：ES6-ES11→Node.js→Promise→Axios前沿框架：Typescript→Vue2→Vue3→React\n工程化构建：Git&amp;NPM&amp;YARN&amp;WebPack数据可视化：Echarts&amp;D3.js&amp;HighCharts&amp;AntV&amp;Three.js&amp;Ceisum&amp;WebGLUI 库：Element UI&amp;Vuetify&amp;Ant Design&amp;Bottstrap&amp;Vant UI&amp;Framework7&amp;WEUI\nSoftware Development Basics设计模式降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性常用七大设计模式：\n\n创建型模式：单例模式、工厂方法模式、抽象工厂模式\n\n结构型模式：代理模式、装饰器模式\n\n行为型模式：观察者模式、责任链模式\n\n\nGit常用命令\n\n\n\n\n\n\nWARNING\n如果git命令报错，一定先检查一下是否开启VPN、节点、steam++等影响国内网络的软件\n\n\n\n\n\n\n\n\n\n\n初始化本地仓库，提交代码，提交到远程git仓库\n\nClick to see more\n\n初始化代码仓库\ngit init\n将当前目录下的所有文件放到暂存区\ngit add .\n查看文件状态\ngit status\n添加提交的描述信息\ngit commit -m &#39;[提交的描述信息]&#39;\n远程仓库地址\ngit remote add origin [远程仓库地址]\n推送到远程仓库\ngit push -u origin master\n\n\n\n\n\n\n\n\n\n\n\n\n创建分支，提交代码到分支\n\nClick to see more\n\n创建切换分支\ngit checkout -b [分支名称]\n将当前目录下的所有文件放到暂存区\ngit add .\n添加提交的描述信息\ngit commit -m &#39;[描述]&#39;\n将分支推送到远程仓库\ngit push --set-upstream origin dev1 \n切换到主分支\ngit checkout master\n将dev合并到主分支\ngit merge dev \n推送到远程仓库\ngit push origin master \n\n\n\nFront-End Optimization通过分析和优化手段，提高网站的性能和用户体验。\n性能优化FP（First Paint）从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。\nFCP（First Contentful Paint）浏览器首次绘制来自 DOM 的内容的时间。\nFMP（First Meaningful Paint）页面的主要内容绘制到屏幕上的时间。\nFSP（First Screen Paint）页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。\nTTI（Time to Interactive）表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。\n优化手段\n性能监控(Performance API)\n样式优化\n防抖 &amp; 节流\n代码分割\n资源压缩\n打包优化\n服务器优化\n缓存优化(Service Worker)\n动画性能\ndns-prefetch\nLazy loading\n\n安全问题\nXSS\nCSRF\n反爬虫\nSQL 注入\nDDoS\n\nFront-End Ecology博客编写\n✅ Gatsby.js\n✅ Docusaurus\nHugo\nHexo\n\n文档编写\n⭐️ Docsify\nJekyII\nVuePress\nDumi\n\n移动应用\nHybrid\nWebView\nReact Native\nFlutter\n\n桌面应用\nElectron\nNW.js\nProton Native\n\n小程序\n原生\nWebView\n\n","slug":"front-end","date":"2022-11-16T16:12:10.000Z","categories_index":"Front-End","tags_index":"前端技术栈","author_index":"X-29"}]