[{"id":"cf0441f16ce9f9e8f078668d5a3bf9e5","title":"interview-javascript","content":"数据类型JavaScript 有哪些数据类型，它们的区别？在 JavaScript 中，数据类型主要分为两大类：基本数据类型（Primitive Types）和 引用数据类型（Reference Types）。以下是详细的分类和它们的区别：\n1. 基本数据类型（Primitive Types）基本数据类型是不可变的，存储在栈中。JavaScript 中的基本数据类型包括：\n\nNumber：表示数字，包括整数和浮点数。例如：42、3.14。\nString：表示字符串，是一系列字符的集合，用单引号、双引号或反引号包围。例如：&#39;Hello&#39;、&quot;World&quot;、`Template`。\nBoolean：表示布尔值，只有两个值：true 和 false。\nUndefined：表示未定义的值，变量声明但未赋值时，默认值为 undefined。\nNull：表示空值或无值，表示一个空对象引用。\nSymbol（ES6 引入）：表示唯一且不可变的值，常用于对象属性的唯一标识符。\nBigInt（ES11 引入）：表示大于 2^53 - 1 的整数，使用 n 后缀表示。例如：1234567890123456789012345678901234567890n。\n\n2. 引用数据类型（Reference Types）引用数据类型是可变的，存储在堆中。JavaScript 中的引用数据类型包括：\n\nObject：对象是键值对的集合，可以存储多个值和复杂数据结构。例如：\nconst obj &#x3D; &#123;\n  name: &quot;Alice&quot;,\n  age: 25,\n&#125;;\n\nArray：数组是特殊类型的对象，用于存储有序的值集合。例如：\nconst arr &#x3D; [1, 2, 3, 4, 5];\n\nFunction：函数也是对象，可以被调用并执行。例如：\nfunction greet() &#123;\n  console.log(&quot;Hello, World!&quot;);\n&#125;\n\n3. 区别\n\n\n特性\n基本数据类型\n引用数据类型\n\n\n\n存储位置\n存储在栈中\n存储在堆中\n\n\n值的特性\n不可变\n可变\n\n\n比较方式\n通过值比较\n通过引用比较\n\n\n类型\n包括 Number, String, Boolean, Undefined, Null, Symbol, BigInt\n包括 Object, Array, Function\n\n\n内存管理\n由 JavaScript 引擎自动管理\n需要手动管理（如避免内存泄漏）\n\n\n总结JavaScript 中的数据类型分为基本数据类型和引用数据类型。基本数据类型是不可变的，存储在栈中，而引用数据类型是可变的，存储在堆中。理解这些数据类型及其区别对于有效地使用 JavaScript 编程至关重要。\n数据类型检测的方式有哪些在 JavaScript 中，检测数据类型的方法有多种。以下是一些常用的数据类型检测方式及其示例：\n1. typeof 操作符typeof 是最常用的检测数据类型的方法。它返回一个表示数据类型的字符串。\n示例console.log(typeof 42); &#x2F;&#x2F; &quot;number&quot;\nconsole.log(typeof &quot;Hello&quot;); &#x2F;&#x2F; &quot;string&quot;\nconsole.log(typeof true); &#x2F;&#x2F; &quot;boolean&quot;\nconsole.log(typeof undefined); &#x2F;&#x2F; &quot;undefined&quot;\nconsole.log(typeof null); &#x2F;&#x2F; &quot;object&quot; (这是一个历史遗留问题)\nconsole.log(typeof Symbol(&quot;sym&quot;)); &#x2F;&#x2F; &quot;symbol&quot;\nconsole.log(typeof BigInt(123)); &#x2F;&#x2F; &quot;bigint&quot;\nconsole.log(typeof &#123;&#125;); &#x2F;&#x2F; &quot;object&quot;\nconsole.log(typeof []); &#x2F;&#x2F; &quot;object&quot; (数组也是对象)\nconsole.log(typeof function () &#123;&#125;); &#x2F;&#x2F; &quot;function&quot;\n\n2. instanceof 操作符instanceof 用于检测对象是否是某个构造函数的实例。它可以用于检测引用数据类型。\n示例const arr &#x3D; [1, 2, 3];\nconsole.log(arr instanceof Array); &#x2F;&#x2F; true\nconsole.log(arr instanceof Object); &#x2F;&#x2F; true\n\nconst obj &#x3D; &#123;&#125;;\nconsole.log(obj instanceof Object); &#x2F;&#x2F; true\nconsole.log(obj instanceof Array); &#x2F;&#x2F; false\n\nfunction MyClass() &#123;&#125;\nconst myInstance &#x3D; new MyClass();\nconsole.log(myInstance instanceof MyClass); &#x2F;&#x2F; true\n\n3. Object.prototype.toString.call()这种方法可以更准确地检测数据类型，尤其是对于数组和其他对象类型。它返回一个字符串，表示对象的类型。\n示例console.log(Object.prototype.toString.call(42)); &#x2F;&#x2F; &quot;[object Number]&quot;\nconsole.log(Object.prototype.toString.call(&quot;Hello&quot;)); &#x2F;&#x2F; &quot;[object String]&quot;\nconsole.log(Object.prototype.toString.call(true)); &#x2F;&#x2F; &quot;[object Boolean]&quot;\nconsole.log(Object.prototype.toString.call(undefined)); &#x2F;&#x2F; &quot;[object Undefined]&quot;\nconsole.log(Object.prototype.toString.call(null)); &#x2F;&#x2F; &quot;[object Null]&quot;\nconsole.log(Object.prototype.toString.call([])); &#x2F;&#x2F; &quot;[object Array]&quot;\nconsole.log(Object.prototype.toString.call(&#123;&#125;)); &#x2F;&#x2F; &quot;[object Object]&quot;\nconsole.log(Object.prototype.toString.call(function () &#123;&#125;)); &#x2F;&#x2F; &quot;[object Function]&quot;\nconsole.log(Object.prototype.toString.call(new Date())); &#x2F;&#x2F; &quot;[object Date]&quot;\n\n4. Array.isArray()这是一个专门用于检测数组的方法，返回一个布尔值，指示给定的值是否为数组。\n示例console.log(Array.isArray([1, 2, 3])); &#x2F;&#x2F; true\nconsole.log(Array.isArray(&#123;&#125;)); &#x2F;&#x2F; false\nconsole.log(Array.isArray(&quot;Hello&quot;)); &#x2F;&#x2F; false\n\n5. constructor 属性可以通过对象的 constructor 属性来检测对象的类型。\n示例const arr &#x3D; [1, 2, 3];\nconsole.log(arr.constructor &#x3D;&#x3D;&#x3D; Array); &#x2F;&#x2F; true\n\nconst obj &#x3D; &#123;&#125;;\nconsole.log(obj.constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F; true\n\nconst date &#x3D; new Date();\nconsole.log(date.constructor &#x3D;&#x3D;&#x3D; Date); &#x2F;&#x2F; true\n\n6. 自定义类型检测函数可以根据需要编写自定义函数来检测特定类型。\n示例function isNumber(value) &#123;\n  return typeof value &#x3D;&#x3D;&#x3D; &quot;number&quot; &amp;&amp; !isNaN(value);\n&#125;\n\nconsole.log(isNumber(42)); &#x2F;&#x2F; true\nconsole.log(isNumber(&quot;Hello&quot;)); &#x2F;&#x2F; false\nconsole.log(isNumber(NaN)); &#x2F;&#x2F; false\n\n总结在 JavaScript 中，检测数据类型的方法有多种，包括 typeof、instanceof、Object.prototype.toString.call()、Array.isArray()、constructor 属性以及自定义检测函数。选择合适的方法可以帮助您更准确地判断数据类型。\n判断数组的方式有哪些在 JavaScript 中，判断一个值是否为数组的方法有多种。以下是一些常用的判断数组的方式及其示例：\n1. Array.isArray()这是最推荐的方法，专门用于检测一个值是否为数组。它返回一个布尔值。\n示例console.log(Array.isArray([1, 2, 3])); &#x2F;&#x2F; true\nconsole.log(Array.isArray(&#123;&#125;)); &#x2F;&#x2F; false\nconsole.log(Array.isArray(&quot;Hello&quot;)); &#x2F;&#x2F; false\nconsole.log(Array.isArray(null)); &#x2F;&#x2F; false\n\n2. instanceof 操作符instanceof 可以用来检测一个对象是否是某个构造函数的实例。对于数组，可以使用 Array 构造函数。\n示例const arr &#x3D; [1, 2, 3];\nconsole.log(arr instanceof Array); &#x2F;&#x2F; true\nconsole.log(arr instanceof Object); &#x2F;&#x2F; true\n\nconst obj &#x3D; &#123;&#125;;\nconsole.log(obj instanceof Array); &#x2F;&#x2F; false\n\n3. Object.prototype.toString.call()这种方法可以更准确地检测数据类型，包括数组。它返回一个字符串，表示对象的类型。\n示例console.log(Object.prototype.toString.call([1, 2, 3])); &#x2F;&#x2F; &quot;[object Array]&quot;\nconsole.log(Object.prototype.toString.call(&#123;&#125;)); &#x2F;&#x2F; &quot;[object Object]&quot;\nconsole.log(Object.prototype.toString.call(&quot;Hello&quot;)); &#x2F;&#x2F; &quot;[object String]&quot;\n\n4. constructor 属性可以通过对象的 constructor 属性来判断对象的类型。对于数组，constructor 属性应该是 Array。\n示例const arr &#x3D; [1, 2, 3];\nconsole.log(arr.constructor &#x3D;&#x3D;&#x3D; Array); &#x2F;&#x2F; true\n\nconst obj &#x3D; &#123;&#125;;\nconsole.log(obj.constructor &#x3D;&#x3D;&#x3D; Array); &#x2F;&#x2F; false\n\n5. 自定义类型检测函数可以根据需要编写自定义函数来检测特定类型。\n示例function isArray(value) &#123;\n  return Array.isArray(value);\n&#125;\n\nconsole.log(isArray([1, 2, 3])); &#x2F;&#x2F; true\nconsole.log(isArray(&quot;Hello&quot;)); &#x2F;&#x2F; false\n\n总结在 JavaScript 中，判断数组的方式主要有以下几种：\n\n**Array.isArray()**：最推荐的方法，专门用于检测数组。\n**instanceof**：可以检测对象是否为数组，但在跨框架或跨窗口时可能不可靠。\n**Object.prototype.toString.call()**：可以准确判断数据类型，包括数组。\nconstructor 属性：通过构造函数判断，但不如 Array.isArray() 可靠。\n自定义函数：可以根据需要编写自定义检测函数。\n\n选择合适的方法可以帮助您更准确地判断一个值是否为数组。\nnull 和 undefined 区别在 JavaScript 中，null 和 undefined 都表示“无值”或“缺失值”，但它们之间有一些重要的区别：\n1. 定义\n**null**：表示一个空值或无值的对象引用。它是一个赋值类型，通常用于表示“没有对象”或“空对象”。开发者可以显式地将变量设置为 null，以表示该变量没有值。\n\n**undefined**：表示一个变量已声明但尚未赋值。它是一个原始数据类型，表示“未定义”或“缺失的值”。当一个变量被声明但没有被赋值时，JavaScript 会自动将其初始化为 undefined。\n\n\n2. 类型\n使用 typeof 操作符检查类型：console.log(typeof null); &#x2F;&#x2F; &quot;object&quot; (这是一个历史遗留问题)\nconsole.log(typeof undefined); &#x2F;&#x2F; &quot;undefined&quot;\n\n3. 使用场景\n**null**：\n\n通常用于表示一个变量应该有一个对象，但目前没有。\n可以用于初始化变量，以便后续可以赋值。\n\nlet obj &#x3D; null; &#x2F;&#x2F; 表示 obj 目前没有对象\n\n**undefined**：\n\n当一个变量被声明但没有赋值时，默认值为 undefined。\n函数没有返回值时，默认返回 undefined。\n\nlet x; &#x2F;&#x2F; x 被声明但未赋值，值为 undefined\nfunction test() &#123;&#125; &#x2F;&#x2F; test() 没有返回值，返回 undefined\n\n4. 相等性比较\n在使用相等运算符（==）进行比较时，null 和 undefined 被认为是相等的：\nconsole.log(null &#x3D;&#x3D; undefined); &#x2F;&#x2F; true\n\n但在使用严格相等运算符（===）时，它们被认为是不相等的：\nconsole.log(null &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; false\n\n5. 总结\nnull 是一个表示“空值”的对象引用，可以被显式赋值。\nundefined 表示“未定义”，通常是变量声明后未赋值的状态。\n它们在类型、使用场景和相等性比较上有明显的区别。\n\ntypeof null 的结果是什么，为什么？在 JavaScript 中，使用 typeof 操作符检查 null 的结果是 &quot;object&quot;。这是一个历史遗留问题，具体原因如下：\n1. typeof null 的结果console.log(typeof null); &#x2F;&#x2F; &quot;object&quot;\n\n2. 原因\n历史遗留问题：在 JavaScript 的早期版本中，null 被实现为一个指向空对象的引用。在当时，所有对象的类型都被标记为 &quot;object&quot;。因此，当使用 typeof 操作符检查 null 时，它返回了 &quot;object&quot;。\n\n设计缺陷：这个行为被认为是 JavaScript 语言设计中的一个缺陷，因为 null 实际上并不是一个对象，而是一个表示“无值”的原始类型。尽管这个问题在后来的版本中被发现，但为了保持向后兼容性，JavaScript 仍然保留了这个行为。\n\n\n3. 总结因此，typeof null 返回 &quot;object&quot; 是由于 JavaScript 的早期实现和设计缺陷所致。尽管这可能会引起混淆，但在实际编程中，开发者通常会记住这一点，并使用其他方法来检查 null 的值。\ninstanceof 操作符的实现原理及实现instanceof 操作符用于检测一个对象是否是某个构造函数的实例。它的基本语法是：\nobject instanceof constructor;\n\n1. 实现原理instanceof 的工作原理是通过检查对象的原型链来确定对象是否是构造函数的实例。具体步骤如下：\n\n获取构造函数的 prototype 属性：instanceof 操作符首先获取构造函数的 prototype 属性。\n查找原型链：然后，它会检查对象的原型链，查看对象的原型是否等于构造函数的 prototype 属性。\n循环查找：如果对象的原型不等于构造函数的 prototype，则继续查找对象的原型的原型，直到找到 null 为止。\n\n2. 示例以下是一个简单的示例，展示 instanceof 的用法：\nfunction Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\n\nconsole.log(alice instanceof Person); &#x2F;&#x2F; true\nconsole.log(alice instanceof Object); &#x2F;&#x2F; true\nconsole.log(alice instanceof Array); &#x2F;&#x2F; false\n\n在这个例子中，alice 是 Person 的实例，因此 alice instanceof Person 返回 true。同时，所有对象都是 Object 的实例，因此 alice instanceof Object 也返回 true。\n3. 自定义 instanceof 实现可以通过自定义函数来模拟 instanceof 的行为。以下是一个简单的实现：\nfunction myInstanceof(obj, constructor) &#123;\n  &#x2F;&#x2F; 获取构造函数的 prototype\n  const prototype &#x3D; constructor.prototype;\n\n  &#x2F;&#x2F; 获取对象的原型\n  let currentObj &#x3D; obj.__proto__;\n\n  &#x2F;&#x2F; 循环查找原型链\n  while (currentObj) &#123;\n    if (currentObj &#x3D;&#x3D;&#x3D; prototype) &#123;\n      return true; &#x2F;&#x2F; 找到匹配\n    &#125;\n    currentObj &#x3D; currentObj.__proto__; &#x2F;&#x2F; 移动到上一级原型\n  &#125;\n\n  return false; &#x2F;&#x2F; 未找到匹配\n&#125;\n\n&#x2F;&#x2F; 测试\nconsole.log(myInstanceof(alice, Person)); &#x2F;&#x2F; true\nconsole.log(myInstanceof(alice, Object)); &#x2F;&#x2F; true\nconsole.log(myInstanceof(alice, Array)); &#x2F;&#x2F; false\n\n4. 注意事项\n原型链：instanceof 依赖于原型链，因此如果对象的原型链被修改，可能会影响 instanceof 的结果。\n跨框架或跨窗口：在不同的 JavaScript 执行环境（如 iframe 或不同的窗口）中，instanceof 可能会出现问题，因为每个执行环境都有自己的 Object 和 Function 构造函数。\n\n5. 总结instanceof 操作符通过检查对象的原型链来确定对象是否是某个构造函数的实例。理解其实现原理有助于更好地使用和调试 JavaScript 中的对象和继承关系。\n为什么 0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等在 JavaScript 中，0.1 + 0.2 的结果并不等于 0.3，这是由于浮点数的精度问题。JavaScript 使用 IEEE 754 标准来表示数字，这种表示方式在处理某些小数时会导致精度损失。\n1. 浮点数精度问题当你执行 0.1 + 0.2 时，实际上计算的结果是一个近似值，而不是精确的 0.3。具体来说：\nconsole.log(0.1 + 0.2); &#x2F;&#x2F; 0.30000000000000004\nconsole.log(0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3); &#x2F;&#x2F; false\n\n在这个例子中，0.1 + 0.2 的结果是 0.30000000000000004，而不是 0.3，因此它们不相等。\n2. 如何让它相等为了比较浮点数时避免精度问题，通常的做法是使用一个容忍度（epsilon）来判断两个数是否“足够接近”。以下是一个简单的实现：\nfunction areEqual(num1, num2, epsilon &#x3D; 0.00001) &#123;\n  return Math.abs(num1 - num2) &lt; epsilon;\n&#125;\n\nconsole.log(areEqual(0.1 + 0.2, 0.3)); &#x2F;&#x2F; true\n\n在这个例子中，areEqual 函数通过检查两个数之间的差值是否小于一个小的容忍度（epsilon）来判断它们是否相等。\n3. 其他解决方案\n使用整数运算：可以将浮点数转换为整数进行计算，避免浮点数精度问题。例如，将 0.1 和 0.2 乘以 10，然后进行整数运算：\n\nconst result &#x3D; (0.1 * 10 + 0.2 * 10) &#x2F; 10; &#x2F;&#x2F; 0.3\nconsole.log(result &#x3D;&#x3D;&#x3D; 0.3); &#x2F;&#x2F; true\n\n\n使用库：可以使用专门处理精度问题的库，如 decimal.js 或 big.js，这些库提供了更高精度的数值计算。\n\n4. 总结0.1 + 0.2 不等于 0.3 是由于浮点数的精度问题。通过使用容忍度进行比较、整数运算或使用专门的库，可以有效地解决这个问题。\n如何获取安全的 undefined 值？在 JavaScript 中，undefined 是一个原始数据类型，表示一个变量已声明但尚未赋值。获取“安全的” undefined 值通常是指确保在使用 undefined 时不会引发错误或产生意外行为。以下是一些方法和最佳实践，以确保安全地使用 undefined：\n1. 使用 void 操作符void 操作符可以用于获取 undefined 值。它的语法是 void 0，这将始终返回 undefined。\nconst safeUndefined &#x3D; void 0;\nconsole.log(safeUndefined); &#x2F;&#x2F; undefined\n\n2. 直接使用 undefined在 JavaScript 中，您可以直接使用 undefined 关键字来表示未定义的值。尽管在某些情况下，undefined 的值可能会被重新赋值，但在现代 JavaScript 中，通常不建议这样做。\nlet myVar;\nconsole.log(myVar); &#x2F;&#x2F; undefined\n\n3. 检查变量是否为 undefined在使用变量之前，您可以检查它是否为 undefined，以确保安全性。\nlet myVar;\n\nif (myVar &#x3D;&#x3D;&#x3D; undefined) &#123;\n  console.log(&quot;myVar is undefined&quot;);\n&#125;\n\n4. 使用默认参数在函数中，您可以使用默认参数来确保参数的安全性。如果参数未传递，默认值将被使用。\nfunction myFunction(param &#x3D; undefined) &#123;\n  console.log(param); &#x2F;&#x2F; 如果未传递参数，将输出 undefined\n&#125;\n\nmyFunction(); &#x2F;&#x2F; undefined\nmyFunction(5); &#x2F;&#x2F; 5\n\n5. 使用 typeof 检查在某些情况下，您可能希望检查一个变量是否未定义，而不引发错误。使用 typeof 可以安全地检查变量的类型。\nlet myVar;\n\nif (typeof myVar &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;\n  console.log(&quot;myVar is undefined&quot;);\n&#125;\n\n6. 使用 try...catch 语句在某些情况下，您可能会尝试访问一个未定义的变量。使用 try...catch 可以捕获错误并安全地处理它。\nlet myVar;\n\ntry &#123;\n  console.log(myVar);\n&#125; catch (error) &#123;\n  console.log(&quot;Caught an error:&quot;, error);\n&#125;\n\n7. 总结获取“安全的” undefined 值主要是确保在使用 undefined 时不会引发错误或产生意外行为。可以使用 void 操作符、直接使用 undefined、检查变量、使用默认参数、typeof 检查和 try...catch 语句等方法来实现这一点。通过这些方法，您可以更安全地处理未定义的值。\ntypeof NaN 的结果是什么？在 JavaScript 中，使用 typeof 操作符检查 NaN 的结果是 &quot;number&quot;。\n示例console.log(typeof NaN); &#x2F;&#x2F; &quot;number&quot;\n\n解释\nNaN 的含义：NaN 代表“不是一个数字”（Not-a-Number），它是一个特殊的数值，表示无法表示为有效数字的结果。通常在数学运算中出现，例如将一个非数字值转换为数字时，或者进行无效的数学运算时。\n\nNaN 的类型：尽管 NaN 表示一个无效的数字，但在 JavaScript 中，它的类型仍然被视为 number。这是因为 NaN 是 Number 类型的一部分。\n\n\n额外信息\nNaN 的特性：NaN 是唯一一个不等于自身的值。也就是说，NaN === NaN 的结果是 false。\n\nconsole.log(NaN &#x3D;&#x3D;&#x3D; NaN); &#x2F;&#x2F; false\n\n\n**检查 NaN**：要检查一个值是否为 NaN，可以使用 Number.isNaN() 方法或 isNaN() 函数。\n\nconsole.log(Number.isNaN(NaN)); &#x2F;&#x2F; true\nconsole.log(isNaN(NaN)); &#x2F;&#x2F; true\nconsole.log(isNaN(&quot;Hello&quot;)); &#x2F;&#x2F; true (因为 &#39;Hello&#39; 转换为数字时是 NaN)\n\n总结typeof NaN 的结果是 &quot;number&quot;，尽管 NaN 表示一个无效的数字。理解 NaN 的特性和行为对于处理数字和进行数学运算时非常重要。\nisNaN 和 Number.isNaN 函数的区别？isNaN 和 Number.isNaN 是 JavaScript 中用于检测是否为 NaN 的两个函数，但它们的行为和用途有所不同。以下是它们之间的主要区别：\n1. isNaN 函数\n功能：isNaN 函数用于判断一个值是否为 NaN。但它会在判断之前将参数转换为数字。\n类型转换：如果传入的值不是数字，isNaN 会尝试将其转换为数字，然后再进行判断。\n返回值：如果转换后的值是 NaN，则返回 true；否则返回 false。\n\n示例console.log(isNaN(NaN)); &#x2F;&#x2F; true\nconsole.log(isNaN(&quot;Hello&quot;)); &#x2F;&#x2F; true (因为 &#39;Hello&#39; 转换为 NaN)\nconsole.log(isNaN(undefined)); &#x2F;&#x2F; true (因为 undefined 转换为 NaN)\nconsole.log(isNaN(123)); &#x2F;&#x2F; false\nconsole.log(isNaN(&quot;123&quot;)); &#x2F;&#x2F; false (因为 &#39;123&#39; 转换为 123)\n\n2. Number.isNaN 函数\n功能：Number.isNaN 函数用于判断一个值是否严格等于 NaN，并且不会进行类型转换。\n无类型转换：只有当传入的值是 NaN 时，Number.isNaN 才会返回 true；如果传入的值是其他类型（如字符串、对象等），则返回 false。\n更严格的判断：因此，Number.isNaN 更加精确，适合用于判断一个值是否为 NaN。\n\n示例console.log(Number.isNaN(NaN)); &#x2F;&#x2F; true\nconsole.log(Number.isNaN(&quot;Hello&quot;)); &#x2F;&#x2F; false (没有类型转换)\nconsole.log(Number.isNaN(undefined)); &#x2F;&#x2F; false\nconsole.log(Number.isNaN(123)); &#x2F;&#x2F; false\nconsole.log(Number.isNaN(&quot;123&quot;)); &#x2F;&#x2F; false\n\n3. 总结\n\n\n特性\nisNaN\nNumber.isNaN\n\n\n\n类型转换\n会进行类型转换\n不会进行类型转换\n\n\n判断条件\n判断转换后的值是否为 NaN\n仅判断值是否严格等于 NaN\n\n\n适用场景\n用于宽松的判断\n用于严格的判断\n\n\n因此，推荐在需要严格判断 NaN 时使用 Number.isNaN，而在需要宽松判断时使用 isNaN。\n其他值到字符串的转换规则？在 JavaScript 中，其他值转换为字符串的规则主要依赖于 String() 函数和 toString() 方法。以下是不同类型的值转换为字符串时的规则：\n1. 基本数据类型1.1. 数字（Number）\n使用 String() 函数或 toString() 方法将数字转换为字符串。\nNaN 和 Infinity 也会被转换为字符串。\n\nconsole.log(String(123)); &#x2F;&#x2F; &quot;123&quot;\nconsole.log((123).toString()); &#x2F;&#x2F; &quot;123&quot;\nconsole.log(String(NaN)); &#x2F;&#x2F; &quot;NaN&quot;\nconsole.log(String(Infinity)); &#x2F;&#x2F; &quot;Infinity&quot;\n\n1.2. 布尔值（Boolean）\ntrue 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。\n\nconsole.log(String(true)); &#x2F;&#x2F; &quot;true&quot;\nconsole.log(String(false)); &#x2F;&#x2F; &quot;false&quot;\n\n1.3. null\nnull 转换为字符串时，结果为 &quot;null&quot;。\n\nconsole.log(String(null)); &#x2F;&#x2F; &quot;null&quot;\n\n1.4. undefined\nundefined 转换为字符串时，结果为 &quot;undefined&quot;。\n\nconsole.log(String(undefined)); &#x2F;&#x2F; &quot;undefined&quot;\n\n1.5. Symbol\nSymbol 类型的值不能直接转换为字符串，尝试转换会抛出错误。\n\nconst sym &#x3D; Symbol(&quot;description&quot;);\nconsole.log(String(sym)); &#x2F;&#x2F; TypeError: Cannot convert a Symbol value to a string\n\n2. 对象（Object）\n对象在转换为字符串时，首先会调用其 toString() 方法。如果 toString() 方法未被重写，则返回 &quot;[object Object]&quot;。\n如果对象有 valueOf() 方法且返回一个原始值，则会使用该值进行转换。\n\nconst obj &#x3D; &#123; name: &quot;Alice&quot; &#125;;\nconsole.log(String(obj)); &#x2F;&#x2F; &quot;[object Object]&quot;\n\nconst customObj &#x3D; &#123;\n  toString: function () &#123;\n    return &quot;Custom Object&quot;;\n  &#125;,\n&#125;;\nconsole.log(String(customObj)); &#x2F;&#x2F; &quot;Custom Object&quot;\n\n3. 数组（Array）\n数组在转换为字符串时，会调用其 toString() 方法，返回数组元素的逗号分隔字符串。\n\nconst arr &#x3D; [1, 2, 3];\nconsole.log(String(arr)); &#x2F;&#x2F; &quot;1,2,3&quot;\n\n4. 函数（Function）\n函数在转换为字符串时，会返回函数的源代码。\n\nfunction myFunction() &#123;\n  return &quot;Hello&quot;;\n&#125;\nconsole.log(String(myFunction)); &#x2F;&#x2F; &quot;function myFunction() &#123; return &#39;Hello&#39;; &#125;&quot;\n\n5. 其他类型的转换\n使用 String() 函数：可以将任何值转换为字符串，遵循上述规则。\n\nconsole.log(String(123)); &#x2F;&#x2F; &quot;123&quot;\nconsole.log(String(true)); &#x2F;&#x2F; &quot;true&quot;\nconsole.log(String(null)); &#x2F;&#x2F; &quot;null&quot;\nconsole.log(String(undefined)); &#x2F;&#x2F; &quot;undefined&quot;\nconsole.log(String([1, 2, 3])); &#x2F;&#x2F; &quot;1,2,3&quot;\n\n总结在 JavaScript 中，其他值转换为字符串的规则主要依赖于其类型。基本数据类型（数字、布尔值、null、undefined）有明确的转换规则，而对象、数组和函数则通过调用其 toString() 方法或 valueOf() 方法来进行转换。理解这些规则有助于在编程中正确处理数据类型转换。\n|| 和 &amp;&amp; 操作符的返回值？在 JavaScript 中，||（逻辑或）和 &amp;&amp;（逻辑与）操作符不仅用于布尔值的逻辑运算，还可以用于返回操作数的值。以下是这两个操作符的详细说明及其返回值的规则：\n1. ||（逻辑或）操作符\n功能：|| 操作符用于返回第一个真值（truthy）操作数。如果所有操作数都是假值（falsy），则返回最后一个操作数。\n假值（falsy）：在 JavaScript 中，以下值被视为假值：\nfalse\n0\n&quot;&quot;（空字符串）\nnull\nundefined\nNaN\n\n\n\n示例console.log(true || false); &#x2F;&#x2F; true\nconsole.log(false || true); &#x2F;&#x2F; true\nconsole.log(0 || 42); &#x2F;&#x2F; 42\nconsole.log(null || &quot;Hello&quot;); &#x2F;&#x2F; &quot;Hello&quot;\nconsole.log(undefined || &quot;World&quot;); &#x2F;&#x2F; &quot;World&quot;\nconsole.log(false || 0 || null); &#x2F;&#x2F; null\nconsole.log(false || 0 || &quot;Hello&quot;); &#x2F;&#x2F; &quot;Hello&quot;\n\n2. &amp;&amp;（逻辑与）操作符\n功能：&amp;&amp; 操作符用于返回第一个假值（falsy）操作数。如果所有操作数都是真值（truthy），则返回最后一个操作数。\n真值（truthy）：在 JavaScript 中，除了假值以外的所有值都被视为真值。\n\n示例console.log(true &amp;&amp; true); &#x2F;&#x2F; true\nconsole.log(true &amp;&amp; false); &#x2F;&#x2F; false\nconsole.log(false &amp;&amp; true); &#x2F;&#x2F; false\nconsole.log(42 &amp;&amp; 0); &#x2F;&#x2F; 0\nconsole.log(&quot;Hello&quot; &amp;&amp; &quot;World&quot;); &#x2F;&#x2F; &quot;World&quot;\nconsole.log(null &amp;&amp; &quot;Hello&quot;); &#x2F;&#x2F; null\nconsole.log(0 &amp;&amp; &quot;World&quot;); &#x2F;&#x2F; 0\nconsole.log(&quot;Hello&quot; &amp;&amp; 42 &amp;&amp; &quot;World&quot;); &#x2F;&#x2F; &quot;World&quot;\n\n3. 返回值总结\n|| 操作符：\n返回第一个真值操作数，或最后一个操作数（如果所有操作数都是假值）。\n\n\n&amp;&amp; 操作符：\n返回第一个假值操作数，或最后一个操作数（如果所有操作数都是真值）。\n\n\n\n4. 结合使用这两个操作符可以结合使用，形成复杂的逻辑表达式。例如：\nconst a &#x3D; 0;\nconst b &#x3D; &quot;Hello&quot;;\nconst c &#x3D; null;\n\nconst result &#x3D; a || (b &amp;&amp; c); &#x2F;&#x2F; 结果为 &quot;Hello&quot;\nconsole.log(result); &#x2F;&#x2F; &quot;Hello&quot;\n\n在这个例子中，b &amp;&amp; c 的结果是 null，然后 a || null 的结果是 null，所以最终结果是 &quot;Hello&quot;。\n总结|| 和 &amp;&amp; 操作符在 JavaScript 中不仅用于逻辑运算，还可以返回操作数的值。理解它们的返回值规则对于编写有效的条件语句和逻辑表达式非常重要。\nObject.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？什么是 JavaScript 中的包装类型？Object.is()、严格相等操作符 === 和宽松相等操作符 == 都用于比较值，但它们的行为和比较规则有所不同。以下是它们之间的主要区别：\n1. Object.is()\n功能：Object.is() 用于判断两个值是否严格相等。它的行为与严格相等操作符 === 类似，但在某些特殊情况下有所不同。\n比较规则：\n对于 NaN，Object.is(NaN, NaN) 返回 true。\n对于 +0 和 -0，Object.is(+0, -0) 返回 false。\n对于其他值，Object.is() 的行为与 === 相同。\n\n\n\n示例console.log(Object.is(42, 42)); &#x2F;&#x2F; true\nconsole.log(Object.is(&quot;Hello&quot;, &quot;Hello&quot;)); &#x2F;&#x2F; true\nconsole.log(Object.is(NaN, NaN)); &#x2F;&#x2F; true\nconsole.log(Object.is(+0, -0)); &#x2F;&#x2F; false\nconsole.log(Object.is(null, null)); &#x2F;&#x2F; true\n\n2. 严格相等操作符 ===\n功能：=== 用于判断两个值是否严格相等。它在比较时不会进行类型转换。\n比较规则：\n如果两个值的类型不同，则返回 false。\n如果两个值的类型相同，则比较它们的值。\nNaN 与任何值（包括自身）都不相等。\n+0 和 -0 被视为相等。\n\n\n\n示例console.log(42 &#x3D;&#x3D;&#x3D; 42); &#x2F;&#x2F; true\nconsole.log(&quot;Hello&quot; &#x3D;&#x3D;&#x3D; &quot;Hello&quot;); &#x2F;&#x2F; true\nconsole.log(NaN &#x3D;&#x3D;&#x3D; NaN); &#x2F;&#x2F; false\nconsole.log(+0 &#x3D;&#x3D;&#x3D; -0); &#x2F;&#x2F; true\nconsole.log(null &#x3D;&#x3D;&#x3D; null); &#x2F;&#x2F; true\n\n3. 宽松相等操作符 ==\n功能：== 用于判断两个值是否相等，但在比较时会进行类型转换。\n比较规则：\n如果两个值的类型不同，JavaScript 会尝试进行类型转换，然后再进行比较。\nNaN 与任何值（包括自身）都不相等。\nnull 和 undefined 被视为相等。\n+0 和 -0 被视为相等。\n\n\n\n示例console.log(42 &#x3D;&#x3D; 42); &#x2F;&#x2F; true\nconsole.log(&quot;Hello&quot; &#x3D;&#x3D; &quot;Hello&quot;); &#x2F;&#x2F; true\nconsole.log(NaN &#x3D;&#x3D; NaN); &#x2F;&#x2F; false\nconsole.log(+0 &#x3D;&#x3D; -0); &#x2F;&#x2F; true\nconsole.log(null &#x3D;&#x3D; undefined); &#x2F;&#x2F; true\nconsole.log(1 &#x3D;&#x3D; &quot;1&quot;); &#x2F;&#x2F; true (类型转换)\n\n4. 总结\n\n\n特性\nObject.is()\n===\n==\n\n\n\n类型转换\n不进行类型转换\n不进行类型转换\n进行类型转换\n\n\nNaN\nObject.is(NaN, NaN) 返回 true\nNaN === NaN 返回 false\nNaN == NaN 返回 false\n\n\n+0 和 -0\nObject.is(+0, -0) 返回 false\n+0 === -0 返回 true\n+0 == -0 返回 true\n\n\nnull 和 undefined\nObject.is(null, undefined) 返回 false\nnull === undefined 返回 false\nnull == undefined 返回 true\n\n\n因此，Object.is() 提供了一种更严格的比较方式，适用于需要精确判断的场景，而 === 和 == 则适用于不同的比较需求。\nJavaScript 中如何进行隐式类型转换？在 JavaScript 中，隐式类型转换（也称为类型强制）是指在表达式中，JavaScript 自动将一种数据类型转换为另一种数据类型的过程。这种转换通常发生在需要不同类型的值进行比较或运算时。以下是一些常见的隐式类型转换的场景和规则：\n1. 数字与字符串的运算当数字和字符串一起进行运算时，JavaScript 会将数字转换为字符串进行连接。\n示例console.log(5 + &quot;5&quot;); &#x2F;&#x2F; &quot;55&quot; (数字 5 被转换为字符串)\nconsole.log(&quot;5&quot; - 2); &#x2F;&#x2F; 3 (字符串 &#39;5&#39; 被转换为数字)\nconsole.log(&quot;5&quot; * 2); &#x2F;&#x2F; 10 (字符串 &#39;5&#39; 被转换为数字)\n\n2. 布尔值的转换在进行运算时，布尔值会被转换为数字：true 转换为 1，false 转换为 0。\n示例console.log(true + 1); &#x2F;&#x2F; 2 (true 被转换为 1)\nconsole.log(false + 1); &#x2F;&#x2F; 1 (false 被转换为 0)\nconsole.log(true - 1); &#x2F;&#x2F; 0\nconsole.log(false - 1); &#x2F;&#x2F; -1\n\n3. 比较操作符在使用比较操作符（如 == 和 !=）时，JavaScript 会进行类型转换以比较值。\n示例console.log(5 &#x3D;&#x3D; &quot;5&quot;); &#x2F;&#x2F; true (字符串 &#39;5&#39; 被转换为数字)\nconsole.log(null &#x3D;&#x3D; undefined); &#x2F;&#x2F; true (null 和 undefined 被视为相等)\nconsole.log(0 &#x3D;&#x3D; false); &#x2F;&#x2F; true (false 被转换为 0)\nconsole.log(&quot;&quot; &#x3D;&#x3D; false); &#x2F;&#x2F; true (空字符串被转换为 0)\n\n4. 对象与原始值的转换当对象与原始值进行运算时，JavaScript 会调用对象的 valueOf() 或 toString() 方法进行转换。\n示例const obj &#x3D; &#123;\n  valueOf: function () &#123;\n    return 42;\n  &#125;,\n  toString: function () &#123;\n    return &quot;Hello&quot;;\n  &#125;,\n&#125;;\n\nconsole.log(obj + 1); &#x2F;&#x2F; 43 (obj.valueOf() 被调用)\nconsole.log(String(obj)); &#x2F;&#x2F; &quot;Hello&quot; (obj.toString() 被调用)\n\n5. 使用 + 操作符+ 操作符在处理字符串和数字时会进行隐式类型转换。如果其中一个操作数是字符串，另一个操作数会被转换为字符串。\n示例console.log(1 + &quot;2&quot;); &#x2F;&#x2F; &quot;12&quot; (数字 1 被转换为字符串)\nconsole.log(&quot;2&quot; + 3); &#x2F;&#x2F; &quot;23&quot; (数字 3 被转换为字符串)\n\n6. undefined 和 null在进行运算时，undefined 和 null 也会被转换为数字。undefined 转换为 NaN，而 null 转换为 0。\n示例console.log(null + 1); &#x2F;&#x2F; 1 (null 被转换为 0)\nconsole.log(undefined + 1); &#x2F;&#x2F; NaN (undefined 被转换为 NaN)\n\n7. 总结隐式类型转换在 JavaScript 中是一个重要的特性，理解其规则可以帮助开发者避免潜在的错误。以下是一些关键点：\n\n数字与字符串运算时，数字会被转换为字符串。\n布尔值在运算时会被转换为数字。\n比较操作符会进行类型转换。\n对象与原始值运算时，会调用 valueOf() 或 toString() 方法。\nundefined 和 null 在运算时会被转换为特定的值。\n\n了解这些规则可以帮助您更好地控制代码的行为，避免意外的结果。\n+操作符什么时候用于字符串的拼接？在 JavaScript 中，+ 操作符可以用于两种主要的操作：数字相加和字符串拼接。以下是关于 + 操作符用于字符串拼接的详细说明：\n1. 字符串拼接的基本规则\n当 + 操作符的任一操作数是字符串时，JavaScript 会将另一个操作数转换为字符串，并执行字符串拼接。\n如果两个操作数都是字符串，+ 操作符将它们连接在一起。\n\n2. 示例2.1. 字符串与字符串的拼接const str1 &#x3D; &quot;Hello&quot;;\nconst str2 &#x3D; &quot;World&quot;;\nconst result &#x3D; str1 + &quot; &quot; + str2; &#x2F;&#x2F; &quot;Hello World&quot;\nconsole.log(result);\n\n在这个例子中，两个字符串 &quot;Hello&quot; 和 &quot;World&quot; 被拼接在一起，中间加了一个空格。\n2.2. 字符串与数字的拼接const str &#x3D; &quot;The answer is &quot;;\nconst num &#x3D; 42;\nconst result &#x3D; str + num; &#x2F;&#x2F; &quot;The answer is 42&quot;\nconsole.log(result);\n\n在这个例子中，数字 42 被转换为字符串，并与字符串 &quot;The answer is &quot; 拼接在一起。\n2.3. 字符串与布尔值的拼接const str &#x3D; &quot;The value is &quot;;\nconst bool &#x3D; true;\nconst result &#x3D; str + bool; &#x2F;&#x2F; &quot;The value is true&quot;\nconsole.log(result);\n\n在这个例子中，布尔值 true 被转换为字符串，并与字符串 &quot;The value is &quot; 拼接在一起。\n3. 注意事项\n优先级：在表达式中，+ 操作符的优先级较高，因此在拼接字符串时，确保操作数的顺序和类型是正确的。\n隐式类型转换：当 + 操作符用于数字和字符串时，数字会被转换为字符串进行拼接，而不是进行数学运算。\n\nconsole.log(5 + &quot;5&quot;); &#x2F;&#x2F; &quot;55&quot; (数字 5 被转换为字符串)\nconsole.log(&quot;5&quot; - 2); &#x2F;&#x2F; 3 (字符串 &quot;5&quot; 被转换为数字)\n\n4. 总结+ 操作符用于字符串拼接的情况主要发生在以下几种情况下：\n\n当任一操作数是字符串时，另一个操作数会被转换为字符串并进行拼接。\n如果两个操作数都是字符串，+ 操作符将它们连接在一起。\n\n理解这些规则可以帮助您在 JavaScript 中有效地使用 + 操作符进行字符串拼接。\n为什么会有 BigInt 的提案？BigInt 是 JavaScript 中的一种新数据类型，旨在解决在处理大整数时的精度问题。以下是关于为什么会有 BigInt 提案的详细说明：\n1. 整数精度限制在 JavaScript 中，所有数字（包括整数和浮点数）都使用 IEEE 754 双精度浮点格式表示。这种格式的最大安全整数是 2^53 - 1（即 9007199254740991），超出这个范围的整数会导致精度丢失。\n示例console.log(9007199254740991); &#x2F;&#x2F; 9007199254740991\nconsole.log(9007199254740992); &#x2F;&#x2F; 9007199254740992 (精度丢失)\nconsole.log(9007199254740993); &#x2F;&#x2F; 9007199254740992 (精度丢失)\n\n在这个例子中，9007199254740992 和 9007199254740993 被错误地表示为 9007199254740992，这表明在处理大整数时存在精度问题。\n2. 需求增加随着现代应用程序（如金融、科学计算和大数据处理）的发展，开发者越来越需要处理超出安全整数范围的大整数。传统的数字类型无法满足这些需求，因此需要一种新的数据类型来处理大整数。\n3. 提案背景为了满足对大整数的需求，JavaScript 提出了 BigInt 的提案。BigInt 允许开发者表示任意大小的整数，而不受 Number 类型的限制。它的引入使得开发者可以安全地进行大整数的计算，而不会遇到精度丢失的问题。\n4. BigInt 的特性\n任意大小：BigInt 可以表示任意大小的整数，超出 Number 类型的范围。\n\n语法：可以通过在数字后面加上 n 后缀来创建 BigInt，或者使用 BigInt() 函数。\nconst bigInt1 &#x3D; 123456789012345678901234567890n; &#x2F;&#x2F; 使用 n 后缀\nconst bigInt2 &#x3D; BigInt(&quot;123456789012345678901234567890&quot;); &#x2F;&#x2F; 使用 BigInt() 函数\n\n与 Number 的兼容性：BigInt 和 Number 之间的运算需要显式转换，因为它们是不同的数据类型。\n\n\n5. 总结BigInt 的提案是为了满足开发者在处理大整数时的需求，解决了 JavaScript 中 Number 类型在表示大整数时的精度限制。通过引入 BigInt，JavaScript 提供了一种安全且灵活的方式来处理任意大小的整数，适应了现代应用程序的需求。\nobject.assign 和扩展运算法是深拷贝还是浅拷贝，两者区别在 JavaScript 中，Object.assign() 和扩展运算符（...）都用于对象的合并和复制，但它们都是浅拷贝，而不是深拷贝。以下是对这两者的详细说明及其区别：\n1. Object.assign()\n功能：Object.assign() 方法用于将一个或多个源对象的可枚举属性复制到目标对象。它返回目标对象。\n浅拷贝：Object.assign() 只会复制对象的第一层属性。如果属性是对象（如数组或其他对象），则复制的是引用，而不是对象本身。\n\n示例const target &#x3D; &#123; a: 1 &#125;;\nconst source &#x3D; &#123; b: 2, c: &#123; d: 3 &#125; &#125;;\n\nconst result &#x3D; Object.assign(target, source);\n\nconsole.log(result); &#x2F;&#x2F; &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;\nconsole.log(target); &#x2F;&#x2F; &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;\n\n&#x2F;&#x2F; 修改 source.c 的属性\nsource.c.d &#x3D; 4;\n\nconsole.log(target.c.d); &#x2F;&#x2F; 4 (target.c 也被修改了，因为是引用)\n\n2. 扩展运算符（...）\n功能：扩展运算符用于将一个对象的可枚举属性复制到另一个对象中，语法上更简洁。\n浅拷贝：与 Object.assign() 类似，扩展运算符也只会复制对象的第一层属性。\n\n示例const obj1 &#x3D; &#123; a: 1 &#125;;\nconst obj2 &#x3D; &#123; b: 2, c: &#123; d: 3 &#125; &#125;;\n\nconst result &#x3D; &#123; ...obj1, ...obj2 &#125;;\n\nconsole.log(result); &#x2F;&#x2F; &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125;\nconsole.log(obj1); &#x2F;&#x2F; &#123; a: 1 &#125;\n\n&#x2F;&#x2F; 修改 obj2.c 的属性\nobj2.c.d &#x3D; 4;\n\nconsole.log(result.c.d); &#x2F;&#x2F; 3 (result.c 没有被修改，因为是新的对象)\n\n3. 深拷贝与浅拷贝的区别\n浅拷贝：只复制对象的第一层属性。如果属性是对象，则复制的是引用。修改嵌套对象的属性会影响到原对象。\n深拷贝：复制对象及其所有嵌套对象的属性，创建一个完全独立的副本。修改副本的属性不会影响原对象。\n\n4. 深拷贝的实现要实现深拷贝，可以使用以下方法：\n\nJSON 方法：使用 JSON.stringify() 和 JSON.parse() 进行深拷贝，但此方法不适用于包含函数、undefined、Symbol、循环引用等的对象。\n\nconst original &#x3D; &#123; a: 1, b: &#123; c: 2 &#125; &#125;;\nconst deepCopy &#x3D; JSON.parse(JSON.stringify(original));\n\noriginal.b.c &#x3D; 3;\nconsole.log(deepCopy.b.c); &#x2F;&#x2F; 2 (深拷贝，原对象的修改不影响副本)\n\n\n递归函数：编写自定义的深拷贝函数，手动处理对象的每一层。\n\n5. 总结\nObject.assign() 和扩展运算符（...）都是浅拷贝。\n修改嵌套对象的属性会影响原对象。\n深拷贝可以通过 JSON 方法或自定义递归函数实现。\n\nES6let、const、var 的区别在 JavaScript 中，let、const 和 var 是用于声明变量的关键字，它们之间有一些重要的区别。以下是对这三者的详细说明：\n1. 作用域\n**var**：\n\nvar 声明的变量具有函数作用域或全局作用域。如果在函数内部使用 var 声明变量，该变量在整个函数内可用；如果在函数外部声明，则在全局范围内可用。\n\nfunction example() &#123;\n  if (true) &#123;\n    var x &#x3D; 10; &#x2F;&#x2F; x 在整个函数内可用\n  &#125;\n  console.log(x); &#x2F;&#x2F; 10\n&#125;\nexample();\n\n**let 和 const**：\n\nlet 和 const 声明的变量具有块作用域。它们只在声明它们的代码块内可用。\n\nfunction example() &#123;\n  if (true) &#123;\n    let y &#x3D; 20; &#x2F;&#x2F; y 只在这个块内可用\n    const z &#x3D; 30; &#x2F;&#x2F; z 也只在这个块内可用\n  &#125;\n  console.log(y); &#x2F;&#x2F; ReferenceError: y is not defined\n  console.log(z); &#x2F;&#x2F; ReferenceError: z is not defined\n&#125;\nexample();\n\n2. 变量提升\n**var**：\n\nvar 声明的变量会被提升到函数或全局作用域的顶部，但赋值不会被提升。可以在声明之前访问变量，但值为 undefined。\n\nconsole.log(a); &#x2F;&#x2F; undefined\nvar a &#x3D; 5;\nconsole.log(a); &#x2F;&#x2F; 5\n\n**let 和 const**：\n\nlet 和 const 也会被提升，但在声明之前访问会导致 ReferenceError，因为它们处于“暂时性死区”（Temporal Dead Zone）。\n\nconsole.log(b); &#x2F;&#x2F; ReferenceError: Cannot access &#39;b&#39; before initialization\nlet b &#x3D; 10;\n\nconsole.log(c); &#x2F;&#x2F; ReferenceError: Cannot access &#39;c&#39; before initialization\nconst c &#x3D; 15;\n\n3. 重新赋值\n**var**：\n\n使用 var 声明的变量可以被重新赋值。\n\nvar d &#x3D; 1;\nd &#x3D; 2; &#x2F;&#x2F; 合法\n\n**let**：\n\n使用 let 声明的变量也可以被重新赋值。\n\nlet e &#x3D; 3;\ne &#x3D; 4; &#x2F;&#x2F; 合法\n\n**const**：\n\n使用 const 声明的变量不能被重新赋值。const 声明的变量必须在声明时初始化。\n\nconst f &#x3D; 5;\nf &#x3D; 6; &#x2F;&#x2F; TypeError: Assignment to constant variable.\n\n\n但是，如果 const 声明的是一个对象或数组，可以修改对象的属性或数组的元素，但不能重新赋值整个对象或数组。\n\nconst obj &#x3D; &#123; key: 1 &#125;;\nobj.key &#x3D; 2; &#x2F;&#x2F; 合法\nconsole.log(obj.key); &#x2F;&#x2F; 2\n\nconst arr &#x3D; [1, 2, 3];\narr.push(4); &#x2F;&#x2F; 合法\nconsole.log(arr); &#x2F;&#x2F; [1, 2, 3, 4]\n\n4. 总结\n\n\n特性\nvar\nlet\nconst\n\n\n\n作用域\n函数作用域或全局作用域\n块作用域\n块作用域\n\n\n变量提升\n提升，值为 undefined\n提升，暂时性死区\n提升，暂时性死区\n\n\n重新赋值\n可以重新赋值\n可以重新赋值\n不可重新赋值\n\n\n声明时初始化\n可选\n可选\n必须\n\n\n理解这些区别有助于在 JavaScript 中更好地管理变量的作用域和生命周期。\nconst 对象的属性可以修改吗在 JavaScript 中，使用 const 声明的变量表示该变量的引用是常量，意味着你不能重新赋值给这个变量。然而，如果 const 声明的是一个对象或数组，你仍然可以修改该对象或数组的属性或元素。\n示例1. 修改对象的属性const obj &#x3D; &#123; key: 1 &#125;;\n\n&#x2F;&#x2F; 修改对象的属性\nobj.key &#x3D; 2; &#x2F;&#x2F; 合法\nconsole.log(obj.key); &#x2F;&#x2F; 2\n\n&#x2F;&#x2F; 添加新的属性\nobj.newKey &#x3D; 3; &#x2F;&#x2F; 合法\nconsole.log(obj.newKey); &#x2F;&#x2F; 3\n\n&#x2F;&#x2F; 尝试重新赋值会导致错误\n&#x2F;&#x2F; obj &#x3D; &#123; newKey: 4 &#125;; &#x2F;&#x2F; TypeError: Assignment to constant variable.\n\n在这个例子中，虽然 obj 是一个 const 声明的变量，但我们可以修改其属性 key 和添加新的属性 newKey。\n2. 修改数组的元素const arr &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 修改数组的元素\narr[0] &#x3D; 4; &#x2F;&#x2F; 合法\nconsole.log(arr); &#x2F;&#x2F; [4, 2, 3]\n\n&#x2F;&#x2F; 添加新的元素\narr.push(5); &#x2F;&#x2F; 合法\nconsole.log(arr); &#x2F;&#x2F; [4, 2, 3, 5]\n\n&#x2F;&#x2F; 尝试重新赋值会导致错误\n&#x2F;&#x2F; arr &#x3D; [6, 7, 8]; &#x2F;&#x2F; TypeError: Assignment to constant variable.\n\n在这个例子中，虽然 arr 是一个 const 声明的变量，但我们可以修改其元素和添加新的元素。\n总结\n使用 const 声明的对象或数组的引用是常量，不能重新赋值。\n但是，可以修改对象的属性或数组的元素，因为这些操作并不改变变量的引用，而是改变了引用的内容。\n\n如果 new 一个箭头函数的会怎么样在 JavaScript 中，箭头函数（arrow function）与普通函数有一些重要的区别，其中之一是箭头函数不能被用作构造函数。因此，尝试使用 new 关键字来实例化一个箭头函数会导致错误。\n1. 尝试使用 new 关键字如果你尝试使用 new 关键字来创建一个箭头函数的实例，会抛出一个 TypeError。\n示例const ArrowFunction &#x3D; () &#x3D;&gt; &#123;\n  this.value &#x3D; 42;\n&#125;;\n\n&#x2F;&#x2F; 尝试使用 new 关键字\nconst instance &#x3D; new ArrowFunction(); &#x2F;&#x2F; TypeError: ArrowFunction is not a constructor\n\n在这个例子中，ArrowFunction 是一个箭头函数，使用 new 关键字尝试实例化它会导致 TypeError，因为箭头函数不能作为构造函数。\n2. 箭头函数的特性\n没有 this 绑定：箭头函数不绑定自己的 this，它会从外部上下文中继承 this 的值。这意味着在箭头函数内部，this 的值是定义时的上下文，而不是调用时的上下文。\n\n不能用作构造函数：正如前面所述，箭头函数不能用作构造函数，因此不能使用 new 关键字。\n\n没有 arguments 对象：箭头函数没有自己的 arguments 对象。如果需要访问参数，可以使用剩余参数语法。\n\n\n3. 总结\n尝试使用 new 关键字来实例化一个箭头函数会导致 TypeError，因为箭头函数不能作为构造函数。\n箭头函数的设计目的是为了简化函数的书写和处理 this 的上下文，而不是用于创建对象的构造函数。\n\n箭头函数与普通函数的区别箭头函数（arrow function）和普通函数（function declaration 或 function expression）在 JavaScript 中有一些重要的区别。以下是它们之间的主要区别：\n1. 语法\n箭头函数：\n更简洁的语法，使用 =&gt; 符号。\n如果只有一个参数，可以省略圆括号；如果函数体只有一行，可以省略大括号和 return 关键字。\n\n\n\nconst add &#x3D; (a, b) &#x3D;&gt; a + b; &#x2F;&#x2F; 简写\nconst square &#x3D; (x) &#x3D;&gt; x * x; &#x2F;&#x2F; 单个参数\n\n\n普通函数：\n使用 function 关键字定义，语法相对冗长。\n\n\n\nfunction add(a, b) &#123;\n  return a + b;\n&#125;\n\nconst square &#x3D; function (x) &#123;\n  return x * x;\n&#125;;\n\n2. this 绑定\n箭头函数：\n不绑定自己的 this，而是从外部上下文中继承 this 的值。这使得箭头函数在处理回调时非常方便，尤其是在类方法中。\n\n\n\nclass Counter &#123;\n  constructor() &#123;\n    this.count &#x3D; 0;\n  &#125;\n  increment() &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      this.count++; &#x2F;&#x2F; 这里的 this 指向 Counter 实例\n      console.log(this.count);\n    &#125;, 1000);\n  &#125;\n&#125;\n\nconst counter &#x3D; new Counter();\ncounter.increment(); &#x2F;&#x2F; 1\n\n\n普通函数：\n绑定自己的 this，在调用时决定 this 的值。通常在回调中使用时，this 的值可能会丢失。\n\n\n\nclass Counter &#123;\n  constructor() &#123;\n    this.count &#x3D; 0;\n  &#125;\n  increment() &#123;\n    setTimeout(function () &#123;\n      this.count++; &#x2F;&#x2F; 这里的 this 不再指向 Counter 实例\n      console.log(this.count); &#x2F;&#x2F; NaN 或者抛出错误\n    &#125;, 1000);\n  &#125;\n&#125;\n\nconst counter &#x3D; new Counter();\ncounter.increment();\n\n3. arguments 对象\n箭头函数：\n没有自己的 arguments 对象。如果需要访问参数，可以使用剩余参数语法。\n\n\n\nconst arrowFunc &#x3D; (...args) &#x3D;&gt; &#123;\n  console.log(args); &#x2F;&#x2F; 可以访问所有参数\n&#125;;\n\narrowFunc(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]\n\n\n普通函数：\n拥有自己的 arguments 对象，可以访问传入的所有参数。\n\n\n\nfunction normalFunc() &#123;\n  console.log(arguments); &#x2F;&#x2F; 可以访问所有参数\n&#125;\n\nnormalFunc(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]\n\n4. 作为构造函数\n箭头函数：\n不能用作构造函数，不能使用 new 关键字实例化。\n\n\n\nconst ArrowFunc &#x3D; () &#x3D;&gt; &#123;&#125;;\nconst instance &#x3D; new ArrowFunc(); &#x2F;&#x2F; TypeError: ArrowFunc is not a constructor\n\n\n普通函数：\n可以用作构造函数，使用 new 关键字实例化。\n\n\n\nfunction NormalFunc() &#123;\n  this.value &#x3D; 42;\n&#125;\nconst instance &#x3D; new NormalFunc();\nconsole.log(instance.value); &#x2F;&#x2F; 42\n\n5. 方法定义\n箭头函数：\n不适合用作对象的方法，因为它不绑定 this。\n\n\n\nconst obj &#x3D; &#123;\n  value: 42,\n  getValue: () &#x3D;&gt; this.value, &#x2F;&#x2F; this 不指向 obj\n&#125;;\nconsole.log(obj.getValue()); &#x2F;&#x2F; undefined\n\n\n普通函数：\n适合用作对象的方法，能够正确绑定 this。\n\n\n\nconst obj &#x3D; &#123;\n  value: 42,\n  getValue: function () &#123;\n    return this.value; &#x2F;&#x2F; this 指向 obj\n  &#125;,\n&#125;;\nconsole.log(obj.getValue()); &#x2F;&#x2F; 42\n\n6. 总结\n\n\n特性\n箭头函数\n普通函数\n\n\n\n语法\n更简洁\n使用 function 关键字\n\n\nthis 绑定\n不绑定，继承外部 this\n绑定自己的 this\n\n\narguments 对象\n没有，使用剩余参数\n有，访问所有参数\n\n\n构造函数\n不能用作构造函数\n可以用作构造函数\n\n\n方法定义\n不适合用作对象的方法\n适合用作对象的方法\n\n\n理解这些区别有助于在 JavaScript 中选择合适的函数类型，以满足特定的编程需求。\n箭头函数的 this 指向哪⾥？在 JavaScript 中，箭头函数的 this 指向是一个重要的特性，它与普通函数的 this 绑定方式有所不同。以下是关于箭头函数 this 指向的详细说明：\n1. 继承外部上下文的 this\n**箭头函数不绑定自己的 this**：箭头函数不会创建自己的 this 上下文，而是从其外部上下文（即定义时的上下文）中继承 this 的值。这意味着在箭头函数内部，this 的值与外部函数或上下文中的 this 相同。\n\n2. 示例2.1. 在普通函数中的 thisfunction Person() &#123;\n  this.age &#x3D; 0;\n\n  setInterval(function () &#123;\n    this.age++; &#x2F;&#x2F; 这里的 this 指向全局对象（在浏览器中是 window）\n    console.log(this.age);\n  &#125;, 1000);\n&#125;\n\nconst p &#x3D; new Person(); &#x2F;&#x2F; 这里会导致 age 为 NaN，因为 this 不指向 Person 实例\n\n在这个例子中，setInterval 中的普通函数的 this 指向全局对象，而不是 Person 实例，因此 this.age 会导致错误。\n2.2. 在箭头函数中的 thisfunction Person() &#123;\n  this.age &#x3D; 0;\n\n  setInterval(() &#x3D;&gt; &#123;\n    this.age++; &#x2F;&#x2F; 这里的 this 指向 Person 实例\n    console.log(this.age);\n  &#125;, 1000);\n&#125;\n\nconst p &#x3D; new Person(); &#x2F;&#x2F; 正确输出年龄\n\n在这个例子中，使用箭头函数后，this 继承自 Person 的上下文，因此 this.age 正确地指向 Person 实例的 age 属性。\n3. 总结\n箭头函数的 this 指向：箭头函数的 this 指向定义时的外部上下文，而不是调用时的上下文。\n适用场景：这种特性使得箭头函数在处理回调函数时非常方便，尤其是在类方法中，可以避免 this 的指向问题。\n\n理解箭头函数的 this 指向特性可以帮助开发者更好地管理上下文，避免常见的 this 绑定错误。\n扩展运算符的作用及使用场景扩展运算符（Spread Operator）在 JavaScript 中使用三个点（...）表示，它可以用于数组和对象的操作。扩展运算符的主要作用是将可迭代对象（如数组、字符串）或对象的属性展开到另一个数组或对象中。以下是扩展运算符的作用及其常见使用场景：\n1. 作用\n展开数组：将一个数组的元素展开为单独的元素。\n合并数组：将多个数组合并为一个数组。\n克隆数组：创建一个数组的浅拷贝。\n展开对象：将一个对象的属性展开到另一个对象中。\n合并对象：将多个对象合并为一个对象。\n克隆对象：创建一个对象的浅拷贝。\n\n2. 使用场景2.1. 展开数组将数组的元素展开为单独的元素。\nconst arr1 &#x3D; [1, 2, 3];\nconst arr2 &#x3D; [4, 5, 6];\nconst combined &#x3D; [...arr1, ...arr2]; &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]\nconsole.log(combined);\n\n2.2. 合并数组将多个数组合并为一个数组。\nconst arr1 &#x3D; [1, 2];\nconst arr2 &#x3D; [3, 4];\nconst arr3 &#x3D; [5, 6];\nconst merged &#x3D; [...arr1, ...arr2, ...arr3]; &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]\nconsole.log(merged);\n\n2.3. 克隆数组创建一个数组的浅拷贝。\nconst original &#x3D; [1, 2, 3];\nconst clone &#x3D; [...original]; &#x2F;&#x2F; [1, 2, 3]\nconsole.log(clone);\n\n2.4. 展开对象将对象的属性展开到另一个对象中。\nconst obj1 &#x3D; &#123; a: 1, b: 2 &#125;;\nconst obj2 &#x3D; &#123; c: 3, d: 4 &#125;;\nconst mergedObj &#x3D; &#123; ...obj1, ...obj2 &#125;; &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3, d: 4 &#125;\nconsole.log(mergedObj);\n\n2.5. 合并对象将多个对象合并为一个对象。\nconst obj1 &#x3D; &#123; a: 1 &#125;;\nconst obj2 &#x3D; &#123; b: 2 &#125;;\nconst obj3 &#x3D; &#123; c: 3 &#125;;\nconst merged &#x3D; &#123; ...obj1, ...obj2, ...obj3 &#125;; &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125;\nconsole.log(merged);\n\n2.6. 克隆对象创建一个对象的浅拷贝。\nconst original &#x3D; &#123; a: 1, b: 2 &#125;;\nconst clone &#x3D; &#123; ...original &#125;; &#x2F;&#x2F; &#123; a: 1, b: 2 &#125;\nconsole.log(clone);\n\n3. 其他使用场景3.1. 在函数调用中展开数组可以将数组作为参数传递给函数。\nconst numbers &#x3D; [1, 2, 3];\nconst max &#x3D; Math.max(...numbers); &#x2F;&#x2F; 3\nconsole.log(max);\n\n3.2. 在函数参数中使用可以使用扩展运算符来处理不定数量的参数。\nfunction sum(...args) &#123;\n  return args.reduce((acc, curr) &#x3D;&gt; acc + curr, 0);\n&#125;\n\nconst result &#x3D; sum(1, 2, 3, 4); &#x2F;&#x2F; 10\nconsole.log(result);\n\n4. 总结扩展运算符（...）在 JavaScript 中是一个非常强大的工具，能够简化数组和对象的操作。它的主要作用包括展开、合并和克隆数组或对象，适用于多种场景，如函数调用、参数处理等。理解和灵活使用扩展运算符可以提高代码的可读性和简洁性。\n对对象与数组的解构的理解解构赋值（Destructuring Assignment）是 JavaScript 中的一种语法，允许从数组或对象中提取值并将其赋值给变量。解构赋值使得代码更加简洁和易读。以下是对对象和数组解构的详细理解。\n1. 数组解构数组解构允许从数组中提取值并将其赋值给变量。\n1.1. 基本语法使用方括号 [] 来进行数组解构。\nconst arr &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 解构赋值\nconst [a, b, c] &#x3D; arr;\n\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(b); &#x2F;&#x2F; 2\nconsole.log(c); &#x2F;&#x2F; 3\n\n1.2. 跳过元素可以在解构时跳过某些元素。\nconst arr &#x3D; [1, 2, 3, 4];\n\n&#x2F;&#x2F; 跳过第一个元素\nconst [, b, , d] &#x3D; arr;\n\nconsole.log(b); &#x2F;&#x2F; 2\nconsole.log(d); &#x2F;&#x2F; 4\n\n1.3. 默认值可以为解构的变量设置默认值。\nconst arr &#x3D; [1];\n\n&#x2F;&#x2F; b 将会是 2，因为 arr[1] 是 undefined\nconst [a, b &#x3D; 2] &#x3D; arr;\n\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(b); &#x2F;&#x2F; 2\n\n2. 对象解构对象解构允许从对象中提取属性并将其赋值给变量。\n2.1. 基本语法使用花括号 &#123;&#125; 来进行对象解构。\nconst obj &#x3D; &#123; x: 1, y: 2 &#125;;\n\n&#x2F;&#x2F; 解构赋值\nconst &#123; x, y &#125; &#x3D; obj;\n\nconsole.log(x); &#x2F;&#x2F; 1\nconsole.log(y); &#x2F;&#x2F; 2\n\n2.2. 重命名变量可以在解构时重命名变量。\nconst obj &#x3D; &#123; x: 1, y: 2 &#125;;\n\n&#x2F;&#x2F; 重命名\nconst &#123; x: a, y: b &#125; &#x3D; obj;\n\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(b); &#x2F;&#x2F; 2\n\n2.3. 默认值可以为解构的变量设置默认值。\nconst obj &#x3D; &#123; x: 1 &#125;;\n\n&#x2F;&#x2F; y 将会是 2，因为 obj.y 是 undefined\nconst &#123; x, y &#x3D; 2 &#125; &#x3D; obj;\n\nconsole.log(x); &#x2F;&#x2F; 1\nconsole.log(y); &#x2F;&#x2F; 2\n\n3. 嵌套解构可以对嵌套的数组和对象进行解构。\n3.1. 数组嵌套解构const arr &#x3D; [1, [2, 3]];\n\n&#x2F;&#x2F; 嵌套解构\nconst [a, [b, c]] &#x3D; arr;\n\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(b); &#x2F;&#x2F; 2\nconsole.log(c); &#x2F;&#x2F; 3\n\n3.2. 对象嵌套解构const obj &#x3D; &#123; a: 1, b: &#123; c: 2 &#125; &#125;;\n\n&#x2F;&#x2F; 嵌套解构\nconst &#123;\n  a,\n  b: &#123; c &#125;,\n&#125; &#x3D; obj;\n\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(c); &#x2F;&#x2F; 2\n\n4. 使用场景\n函数参数：解构赋值常用于函数参数中，可以直接提取对象或数组的属性。\n\nfunction printCoordinates(&#123; x, y &#125;) &#123;\n  console.log(&#96;X: $&#123;x&#125;, Y: $&#123;y&#125;&#96;);\n&#125;\n\nconst point &#x3D; &#123; x: 10, y: 20 &#125;;\nprintCoordinates(point); &#x2F;&#x2F; X: 10, Y: 20\n\n\n状态管理：在 React 等框架中，解构赋值常用于提取状态和属性。\n\nconst &#123; name, age &#125; &#x3D; this.props; &#x2F;&#x2F; 在 React 组件中\n\n5. 总结解构赋值是 JavaScript 中一种强大的语法，允许从数组和对象中提取值并赋值给变量。它使得代码更加简洁和易读，尤其在处理复杂数据结构时。理解数组和对象的解构赋值可以帮助开发者更高效地编写代码。\n如何提取高度嵌套的对象里的指定属性？在 JavaScript 中，提取高度嵌套对象中的指定属性可以使用解构赋值（Destructuring Assignment）来实现。解构赋值允许你从对象中提取值并将其赋值给变量，适用于嵌套对象的情况。以下是一些示例和方法来提取高度嵌套对象中的指定属性。\n1. 使用解构赋值假设我们有一个高度嵌套的对象，结构如下：\nconst data &#x3D; &#123;\n  user: &#123;\n    id: 1,\n    name: &quot;Alice&quot;,\n    address: &#123;\n      city: &quot;Wonderland&quot;,\n      zip: &quot;12345&quot;,\n      coordinates: &#123;\n        lat: 37.7749,\n        long: -122.4194,\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;;\n\n1.1. 提取嵌套属性你可以使用解构赋值直接提取嵌套属性：\nconst &#123;\n  user: &#123;\n    name,\n    address: &#123;\n      city,\n      coordinates: &#123; lat, long &#125;,\n    &#125;,\n  &#125;,\n&#125; &#x3D; data;\n\nconsole.log(name); &#x2F;&#x2F; &quot;Alice&quot;\nconsole.log(city); &#x2F;&#x2F; &quot;Wonderland&quot;\nconsole.log(lat); &#x2F;&#x2F; 37.7749\nconsole.log(long); &#x2F;&#x2F; -122.4194\n\n2. 提取部分属性如果你只想提取某些特定的嵌套属性，可以选择性地解构：\nconst &#123;\n  user: &#123;\n    address: &#123; zip &#125;,\n  &#125;,\n&#125; &#x3D; data;\n\nconsole.log(zip); &#x2F;&#x2F; &quot;12345&quot;\n\n3. 使用默认值在解构时，你还可以为嵌套属性设置默认值，以防某些属性不存在：\nconst &#123;\n  user: &#123;\n    address: &#123;\n      country &#x3D; &quot;Unknown&quot;, &#x2F;&#x2F; 设置默认值\n    &#125;,\n  &#125;,\n&#125; &#x3D; data;\n\nconsole.log(country); &#x2F;&#x2F; &quot;Unknown&quot;\n\n4. 提取动态属性如果你需要提取动态属性，可以结合变量使用解构：\nconst key &#x3D; &quot;name&quot;;\nconst &#123;\n  user: &#123; [key]: userName &#125;,\n&#125; &#x3D; data;\n\nconsole.log(userName); &#x2F;&#x2F; &quot;Alice&quot;\n\n5. 总结\n使用解构赋值可以方便地提取高度嵌套对象中的指定属性。\n你可以选择性地提取属性、设置默认值，并且可以结合变量提取动态属性。\n解构赋值使得代码更加简洁和易读，特别是在处理复杂数据结构时。\n\n对 rest 参数的理解在 JavaScript 中，rest 参数（剩余参数）是一种用于函数定义的语法，允许将不定数量的参数收集到一个数组中。它使用三个点（...）表示，通常放在函数参数列表的最后一个位置。以下是对 rest 参数的详细理解和使用示例。\n1. 基本语法rest 参数的语法如下：\nfunction myFunction(...rest) &#123;\n  &#x2F;&#x2F; rest 是一个数组，包含所有传入的额外参数\n&#125;\n\n2. 使用场景2.1. 收集不定数量的参数rest 参数可以用于收集函数调用时传入的所有额外参数，并将它们放入一个数组中。\nfunction sum(...numbers) &#123;\n  return numbers.reduce((acc, curr) &#x3D;&gt; acc + curr, 0);\n&#125;\n\nconsole.log(sum(1, 2, 3)); &#x2F;&#x2F; 6\nconsole.log(sum(10, 20, 30, 40)); &#x2F;&#x2F; 100\n\n在这个例子中，sum 函数可以接受任意数量的参数，并将它们相加。\n2.2. 与其他参数结合使用rest 参数可以与其他参数一起使用，但必须放在参数列表的最后。\nfunction multiply(factor, ...numbers) &#123;\n  return numbers.map((num) &#x3D;&gt; num * factor);\n&#125;\n\nconsole.log(multiply(2, 1, 2, 3)); &#x2F;&#x2F; [2, 4, 6]\n\n在这个例子中，factor 是一个普通参数，而 ...numbers 是一个 rest 参数，收集所有额外的数字。\n3. 与 arguments 对象的区别\nrest 参数：是一个真正的数组，可以使用数组的方法（如 map、reduce 等）。\narguments 对象：是一个类数组对象，包含所有传入的参数，但不是数组，不能直接使用数组方法。\n\nfunction example() &#123;\n  console.log(arguments); &#x2F;&#x2F; 类数组对象\n  console.log(Array.isArray(arguments)); &#x2F;&#x2F; false\n\n  const argsArray &#x3D; [...arguments]; &#x2F;&#x2F; 将 arguments 转换为数组\n  console.log(argsArray); &#x2F;&#x2F; 现在是数组\n&#125;\n\nexample(1, 2, 3); &#x2F;&#x2F; 输出: [1, 2, 3]\n\n4. 其他注意事项\n只能有一个 rest 参数：在函数参数中只能有一个 rest 参数，且必须放在最后。\n\nfunction invalidFunction(...rest, a) &#123; &#x2F;&#x2F; 语法错误\n    &#x2F;&#x2F; ...\n&#125;\n\n\n与解构赋值结合使用：可以在解构赋值中使用 rest 参数来收集剩余的属性。\n\nconst obj &#x3D; &#123; a: 1, b: 2, c: 3, d: 4 &#125;;\nconst &#123; a, ...rest &#125; &#x3D; obj;\n\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(rest); &#x2F;&#x2F; &#123; b: 2, c: 3, d: 4 &#125;\n\n5. 总结\nrest 参数 是一种强大的功能，允许函数接收不定数量的参数并将其收集到一个数组中。\n它使得函数更加灵活，能够处理多种输入情况。\n与 arguments 对象相比，rest 参数提供了更好的可读性和可操作性。理解和使用 rest 参数可以帮助开发者编写更简洁和灵活的函数。\n\nES6 中模板语法与字符串处理在 ES6（ECMAScript 2015）中，引入了模板字面量（Template Literals），这是一种新的字符串处理语法，提供了更强大和灵活的字符串操作方式。以下是对模板字面量及其在字符串处理中的应用的详细说明。\n1. 模板字面量的基本语法模板字面量使用反引号（`）来定义，可以包含多行文本和嵌入表达式。\n示例const name &#x3D; &quot;Alice&quot;;\nconst greeting &#x3D; &#96;Hello, $&#123;name&#125;!&#96;; &#x2F;&#x2F; 使用 $&#123;&#125; 嵌入表达式\nconsole.log(greeting); &#x2F;&#x2F; &quot;Hello, Alice!&quot;\n\n2. 多行字符串模板字面量允许创建多行字符串，而不需要使用换行符或字符串连接。\n示例const multiLineString &#x3D; &#96;This is a string\nthat spans multiple\nlines.&#96;;\nconsole.log(multiLineString);\n\n输出：\nThis is a string\nthat spans multiple\nlines.\n\n3. 嵌入表达式模板字面量可以嵌入任意 JavaScript 表达式，包括变量、函数调用和运算。\n示例const a &#x3D; 5;\nconst b &#x3D; 10;\nconst sum &#x3D; &#96;The sum of $&#123;a&#125; and $&#123;b&#125; is $&#123;a + b&#125;.&#96;;\nconsole.log(sum); &#x2F;&#x2F; &quot;The sum of 5 and 10 is 15.&quot;\n\n4. 标签模板标签模板（Tagged Templates）允许你定义一个函数来处理模板字面量的内容。这使得你可以自定义字符串的处理方式。\n示例function tag(strings, ...values) &#123;\n  return strings.reduce((result, str, i) &#x3D;&gt; &#123;\n    return result + str + (values[i] ? &#96;&lt;strong&gt;$&#123;values[i]&#125;&lt;&#x2F;strong&gt;&#96; : &quot;&quot;);\n  &#125;, &quot;&quot;);\n&#125;\n\nconst name &#x3D; &quot;Alice&quot;;\nconst age &#x3D; 30;\nconst message &#x3D; tag&#96;My name is $&#123;name&#125; and I am $&#123;age&#125; years old.&#96;;\nconsole.log(message); &#x2F;&#x2F; &quot;My name is &lt;strong&gt;Alice&lt;&#x2F;strong&gt; and I am &lt;strong&gt;30&lt;&#x2F;strong&gt; years old.&quot;\n\n5. 字符串处理的优势\n可读性：模板字面量使得字符串的拼接和格式化更加直观和易读。\n灵活性：可以轻松嵌入表达式，支持多行字符串，减少了使用传统字符串拼接时的复杂性。\n自定义处理：通过标签模板，可以实现自定义的字符串处理逻辑。\n\n6. 总结ES6 中的模板字面量提供了一种更强大和灵活的字符串处理方式。它允许多行字符串、嵌入表达式和自定义处理，使得字符串的创建和操作更加简洁和易于维护。理解和使用模板字面量可以帮助开发者编写更清晰和高效的代码。\nJavaScript 基础new 操作符的实现原理在 JavaScript 中，new 操作符用于创建一个对象实例，并调用构造函数。它的实现原理涉及几个步骤，以下是对 new 操作符的详细解释和实现原理。\n1. new 操作符的基本功能当使用 new 操作符调用一个构造函数时，它会执行以下操作：\n\n创建一个新对象：创建一个空对象 obj。\n设置原型：将新对象的 __proto__ 属性指向构造函数的 prototype 属性。\n**绑定 this**：将构造函数内部的 this 绑定到新创建的对象 obj。\n执行构造函数：调用构造函数，并传入参数（如果有）。\n返回对象：如果构造函数返回一个对象，则返回该对象；否则返回新创建的对象 obj。\n\n2. 实现步骤以下是 new 操作符的实现步骤的详细说明：\n2.1. 创建新对象当 new 被调用时，首先会创建一个新的空对象。\nlet obj &#x3D; &#123;&#125;; &#x2F;&#x2F; 创建一个新对象\n\n2.2. 设置原型新对象的 __proto__ 属性被设置为构造函数的 prototype 属性，以便新对象可以访问构造函数原型上的方法和属性。\nobj.__proto__ &#x3D; Constructor.prototype; &#x2F;&#x2F; 设置原型\n\n2.3. 绑定 this在构造函数内部，this 被绑定到新创建的对象 obj。\nConstructor.call(obj, ...args); &#x2F;&#x2F; 绑定 this 并调用构造函数\n\n2.4. 返回对象最后，new 操作符会返回新创建的对象。如果构造函数返回的是一个对象，则返回该对象；如果返回的是一个原始值（如数字、字符串等），则返回新创建的对象。\nreturn obj; &#x2F;&#x2F; 返回新对象\n\n3. 示例以下是一个简单的构造函数和使用 new 操作符的示例：\nfunction Person(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n&#125;\n\n&#x2F;&#x2F; 使用 new 操作符创建一个新对象\nconst alice &#x3D; new Person(&quot;Alice&quot;, 30);\n\nconsole.log(alice.name); &#x2F;&#x2F; &quot;Alice&quot;\nconsole.log(alice.age); &#x2F;&#x2F; 30\nconsole.log(alice.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true\n\n4. 自定义 new 实现你可以自定义一个 myNew 函数来模拟 new 操作符的行为：\nfunction myNew(Constructor, ...args) &#123;\n  &#x2F;&#x2F; 创建新对象\n  const obj &#x3D; &#123;&#125;;\n\n  &#x2F;&#x2F; 设置原型\n  obj.__proto__ &#x3D; Constructor.prototype;\n\n  &#x2F;&#x2F; 绑定 this 并调用构造函数\n  const result &#x3D; Constructor.apply(obj, args);\n\n  &#x2F;&#x2F; 返回对象\n  return typeof result &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof result &#x3D;&#x3D;&#x3D; &quot;function&quot;\n    ? result\n    : obj;\n&#125;\n\n&#x2F;&#x2F; 使用自定义的 myNew 函数\nconst bob &#x3D; myNew(Person, &quot;Bob&quot;, 25);\nconsole.log(bob.name); &#x2F;&#x2F; &quot;Bob&quot;\nconsole.log(bob.age); &#x2F;&#x2F; 25\n\n5. 总结new 操作符的实现原理涉及创建新对象、设置原型、绑定 this、执行构造函数和返回对象等步骤。理解 new 操作符的工作原理有助于更好地掌握 JavaScript 中的对象创建和构造函数的使用。\nmap 和 Object 的区别在 JavaScript 中，Map 和 Object 都是用于存储键值对的数据结构，但它们在设计、功能和使用场景上有一些重要的区别。以下是对 Map 和 Object 的详细比较：\n1. 基本定义\nObject：\nObject 是 JavaScript 中的基本数据结构，用于存储键值对。键通常是字符串或符号（Symbol），值可以是任何类型。\n\n\nMap：\nMap 是 ES6 引入的一种新的数据结构，专门用于存储键值对。键可以是任何类型，包括对象、函数和原始值。\n\n\n\n2. 键的类型\nObject：\n\n只能使用字符串或符号作为键。其他类型的键会被自动转换为字符串。\n\nconst obj &#x3D; &#123;&#125;;\nobj[1] &#x3D; &quot;one&quot;; &#x2F;&#x2F; 1 被转换为 &quot;1&quot;\nconsole.log(obj[&quot;1&quot;]); &#x2F;&#x2F; &quot;one&quot;\n\nMap：\n\n可以使用任何类型的值作为键，包括对象、数组、函数等。\n\nconst map &#x3D; new Map();\nmap.set(1, &quot;one&quot;);\nmap.set(&#123;&#125;, &quot;empty object&quot;);\nconsole.log(map.get(1)); &#x2F;&#x2F; &quot;one&quot;\n\n3. 键值对的顺序\nObject：\n\n在对象中，属性的顺序是根据属性的添加顺序来决定的，但对于整数键（如 1、2）会被排序。\n\nconst obj &#x3D; &#123; b: 2, a: 1, 1: &quot;one&quot; &#125;;\nconsole.log(Object.keys(obj)); &#x2F;&#x2F; [&quot;1&quot;, &quot;a&quot;, &quot;b&quot;]\n\nMap：\n\nMap 保持插入的顺序，遍历时会按照插入的顺序返回键值对。\n\nconst map &#x3D; new Map();\nmap.set(&quot;b&quot;, 2);\nmap.set(&quot;a&quot;, 1);\nmap.set(1, &quot;one&quot;);\nconsole.log([...map.keys()]); &#x2F;&#x2F; [&quot;b&quot;, &quot;a&quot;, 1]\n\n4. 性能\nObject：\n\n对于频繁的添加和删除操作，Object 的性能可能会受到影响，尤其是在属性数量较多时。\n\n\nMap：\n\nMap 在添加、删除和查找操作上通常比 Object 更高效，尤其是在处理大量数据时。\n\n\n\n5. 方法和属性\nObject：\n\nObject 提供了一些基本的方法，如 Object.keys()、Object.values() 和 Object.entries() 来获取对象的键、值和键值对。\n\n\nMap：\n\nMap 提供了丰富的方法，如 set()、get()、has()、delete() 和 clear()，以及可以直接使用 size 属性获取键值对的数量。\n\nconst map &#x3D; new Map();\nmap.set(&quot;a&quot;, 1);\nmap.set(&quot;b&quot;, 2);\nconsole.log(map.size); &#x2F;&#x2F; 2\nconsole.log(map.has(&quot;a&quot;)); &#x2F;&#x2F; true\n\n6. 迭代\nObject：\n\n对象的迭代通常使用 for...in 循环或 Object.keys()、Object.values()、Object.entries()。\n\n\nMap：\n\nMap 可以直接使用 for...of 循环进行迭代，支持迭代器，提供了 keys()、values() 和 entries() 方法。\n\nconst map &#x3D; new Map([\n  [&quot;a&quot;, 1],\n  [&quot;b&quot;, 2],\n]);\nfor (const [key, value] of map) &#123;\n  console.log(&#96;$&#123;key&#125;: $&#123;value&#125;&#96;);\n&#125;\n\n7. 总结\n\n\n特性\nObject\nMap\n\n\n\n键的类型\n只能是字符串或符号\n可以是任何类型\n\n\n键值对的顺序\n不保证顺序\n保持插入顺序\n\n\n性能\n对于频繁操作性能较差\n在添加、删除和查找上更高效\n\n\n方法和属性\n基本方法\n丰富的方法和 size 属性\n\n\n迭代\n使用 for...in 或 Object 方法\n使用 for...of 和迭代器\n\n\n理解 Map 和 Object 的区别可以帮助开发者在适当的场景中选择合适的数据结构，以提高代码的性能和可读性。\nmap 和 weakMap 的区别在 JavaScript 中，Map 和 WeakMap 都是用于存储键值对的数据结构，但它们在键的类型、内存管理和使用场景上有一些重要的区别。以下是对 Map 和 WeakMap 的详细比较：\n1. 基本定义\nMap：\n\nMap 是一个集合，允许存储任意类型的键值对。键可以是任何类型，包括对象、函数和原始值。\n\n\nWeakMap：\n\nWeakMap 是一个类似于 Map 的集合，但它的键必须是对象，并且是弱引用。这意味着如果没有其他引用指向键对象，键对象可以被垃圾回收。\n\n\n\n2. 键的类型\nMap：\n\n可以使用任何类型的值作为键，包括原始值（如字符串、数字、布尔值）和对象。\n\nconst map &#x3D; new Map();\nmap.set(&quot;stringKey&quot;, &quot;value1&quot;);\nmap.set(123, &quot;value2&quot;);\nmap.set(&#123;&#125;, &quot;value3&quot;);\n\nWeakMap：\n\n只能使用对象作为键，不能使用原始值（如字符串、数字、布尔值等）。\n\nconst weakMap &#x3D; new WeakMap();\nconst objKey &#x3D; &#123;&#125;;\nweakMap.set(objKey, &quot;value1&quot;);\n&#x2F;&#x2F; weakMap.set(&#39;stringKey&#39;, &#39;value2&#39;); &#x2F;&#x2F; TypeError: Invalid value used as weak map key\n\n3. 垃圾回收\nMap：\n\nMap 中的键是强引用，即使没有其他引用指向键对象，Map 仍然会保持对该对象的引用，导致内存不会被回收。\n\n\nWeakMap：\n\nWeakMap 中的键是弱引用。如果没有其他引用指向键对象，键对象会被垃圾回收。这使得 WeakMap 更加适合用于缓存和存储私有数据。\n\n\n\n4. 方法和属性\nMap：\n\n提供了丰富的方法，如 set()、get()、has()、delete() 和 clear()，以及可以直接使用 size 属性获取键值对的数量。\n\nconst map &#x3D; new Map();\nmap.set(&quot;a&quot;, 1);\nconsole.log(map.size); &#x2F;&#x2F; 1\nconsole.log(map.get(&quot;a&quot;)); &#x2F;&#x2F; 1\n\nWeakMap：\n\n只提供了 set()、get()、has() 和 delete() 方法，没有 size 属性，也不支持迭代器，因此无法直接获取 WeakMap 的大小或遍历其内容。\n\nconst weakMap &#x3D; new WeakMap();\nconst objKey &#x3D; &#123;&#125;;\nweakMap.set(objKey, &quot;value1&quot;);\nconsole.log(weakMap.get(objKey)); &#x2F;&#x2F; &quot;value1&quot;\n\n5. 迭代\nMap：\n\nMap 是可迭代的，可以使用 for...of 循环进行迭代，支持 keys()、values() 和 entries() 方法。\n\nconst map &#x3D; new Map([\n  [&quot;a&quot;, 1],\n  [&quot;b&quot;, 2],\n]);\nfor (const [key, value] of map) &#123;\n  console.log(&#96;$&#123;key&#125;: $&#123;value&#125;&#96;);\n&#125;\n\nWeakMap：\n\nWeakMap 不是可迭代的，不能使用 for...of 循环进行迭代，也没有提供迭代器方法。\n\n\n\n6. 使用场景\nMap：\n\n适用于需要存储任意类型的键值对，并且需要频繁访问、添加和删除的场景。\n\n\nWeakMap：\n\n适用于需要存储对象的私有数据或缓存，且希望在没有其他引用时自动清理的场景。\n\n\n\n7. 总结\n\n\n特性\nMap\nWeakMap\n\n\n\n键的类型\n可以是任何类型\n只能是对象\n\n\n垃圾回收\n强引用，内存不会被回收\n弱引用，键对象可以被垃圾回收\n\n\n方法和属性\n提供丰富的方法和 size 属性\n仅提供基本方法，没有 size\n\n\n迭代\n可迭代，支持迭代器\n不可迭代\n\n\n使用场景\n存储任意类型的键值对\n存储对象的私有数据或缓存\n\n\n理解 Map 和 WeakMap 的区别可以帮助开发者在适当的场景中选择合适的数据结构，以提高代码的性能和内存管理效率。\nJavaScript 有哪些内置对象在 JavaScript 中，内置对象是指在语言中预定义的对象，这些对象提供了各种功能和方法，帮助开发者进行常见的编程任务。以下是一些主要的 JavaScript 内置对象的分类及其简要说明：\n1. 基本对象\nObject：所有对象的基类，提供了对象的基本功能。\nFunction：用于创建函数的对象，提供了函数的相关方法。\nBoolean：用于处理布尔值（true 和 false）。\nNumber：用于处理数字，包括整数和浮点数。\nString：用于处理字符串，提供了字符串的相关方法。\n\n2. 数据结构对象\nArray：用于处理数组，提供了数组的相关方法，如 push、pop、map、filter 等。\nMap：用于存储键值对，键可以是任何类型，保持插入顺序。\nSet：用于存储唯一值的集合，提供了集合的相关方法。\nWeakMap：类似于 Map，但键是弱引用，适用于存储对象的私有数据。\nWeakSet：类似于 Set，但存储的值是弱引用。\n\n3. 错误对象\nError：用于表示运行时错误的基本对象。\nSyntaxError：表示语法错误。\nReferenceError：表示引用错误。\nTypeError：表示类型错误。\nRangeError：表示数值超出范围的错误。\n\n4. 日期和时间对象\nDate：用于处理日期和时间，提供了获取和设置日期时间的方法。\n\n5. 正则表达式对象\nRegExp：用于处理正则表达式，提供了匹配和搜索字符串的功能。\n\n6. JSON 对象\nJSON：用于处理 JSON 数据，提供了 parse 和 stringify 方法，用于将 JSON 字符串转换为对象和将对象转换为 JSON 字符串。\n\n7. 数学对象\nMath：提供了数学常数和函数，如 Math.PI、Math.sqrt()、Math.random() 等。\n\n8. 全局对象\nGlobal：在浏览器中，window 对象是全局对象，提供了全局作用域的变量和方法。在 Node.js 中，global 是全局对象。\n\n9. 其他内置对象\nPromise：用于处理异步操作的对象，提供了 then、catch 和 finally 方法。\nSymbol：用于创建唯一的标识符，常用于对象属性的键。\nReflect：提供了一组方法，用于操作对象的反射。\nProxy：用于创建代理对象，可以拦截和定义基本操作（如属性查找、赋值等）。\n\n10. 结论JavaScript 提供了丰富的内置对象，帮助开发者处理各种编程任务。理解这些内置对象及其功能可以提高开发效率，简化代码的编写。\n对 JSON 的理解JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人类阅读和编写，同时也易于机器解析和生成。JSON 是基于 JavaScript 的对象表示法，但它是语言无关的，广泛用于数据传输和存储。以下是对 JSON 的详细理解：\n1. JSON 的基本结构JSON 的基本结构由键值对组成，使用花括号 &#123;&#125; 表示对象，使用方括号 [] 表示数组。JSON 的数据类型包括：\n\n对象：由 &#123;&#125; 包围的键值对集合。\n数组：由 [] 包围的值的有序集合。\n字符串：用双引号 &quot; 包围的文本。\n数字：整数或浮点数。\n布尔值：true 或 false。\nnull：表示空值。\n\n示例&#123;\n  &quot;name&quot;: &quot;Alice&quot;,\n  &quot;age&quot;: 30,\n  &quot;isStudent&quot;: false,\n  &quot;courses&quot;: [&quot;Math&quot;, &quot;Science&quot;],\n  &quot;address&quot;: &#123;\n    &quot;city&quot;: &quot;Wonderland&quot;,\n    &quot;zip&quot;: &quot;12345&quot;\n  &#125;,\n  &quot;graduated&quot;: null\n&#125;\n\n2. JSON 的特点\n轻量级：JSON 格式简单，数据结构清晰，适合数据交换。\n易于阅读：JSON 的语法接近于 JavaScript 对象，易于人类理解。\n语言无关：虽然 JSON 源于 JavaScript，但它可以被多种编程语言解析和生成，如 Python、Java、C# 等。\n\n3. JSON 的使用场景\n数据交换：JSON 常用于客户端和服务器之间的数据交换，尤其是在 Web 应用程序中。\n配置文件：许多应用程序使用 JSON 格式的配置文件来存储设置和参数。\nAPI 响应：许多 RESTful API 使用 JSON 格式返回数据。\n\n4. JSON 的解析和生成在 JavaScript 中，可以使用 JSON 对象提供的方法来解析和生成 JSON 数据：\n\n解析 JSON：使用 JSON.parse() 方法将 JSON 字符串转换为 JavaScript 对象。\n\nconst jsonString &#x3D; &#39;&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30&#125;&#39;;\nconst jsonObject &#x3D; JSON.parse(jsonString);\nconsole.log(jsonObject.name); &#x2F;&#x2F; &quot;Alice&quot;\n\n\n生成 JSON：使用 JSON.stringify() 方法将 JavaScript 对象转换为 JSON 字符串。\n\nconst obj &#x3D; &#123; name: &quot;Alice&quot;, age: 30 &#125;;\nconst jsonString &#x3D; JSON.stringify(obj);\nconsole.log(jsonString); &#x2F;&#x2F; &#39;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30&#125;&#39;\n\n5. JSON 的限制\n键必须是字符串：在 JSON 对象中，所有的键都必须用双引号包围，不能使用单引号。\n不支持函数和日期：JSON 只支持基本数据类型，不能直接表示函数、日期对象等。\n不支持循环引用：JSON 不能表示包含循环引用的对象。\n\n6. 总结JSON 是一种广泛使用的数据交换格式，具有轻量级、易于阅读和语言无关的特点。它在 Web 开发、API 设计和配置管理中发挥着重要作用。理解 JSON 的结构和使用方法可以帮助开发者更有效地处理数据交换和存储。\nJavaScript 脚本延迟加载的方式有哪些？在 JavaScript 中，脚本延迟加载是指在页面加载时推迟加载 JavaScript 文件，以提高页面的加载速度和性能。以下是几种常见的 JavaScript 脚本延迟加载方式：\n1. 使用 defer 属性\ndefer 属性：在 &lt;script&gt; 标签中添加 defer 属性，表示脚本将在文档解析完成后执行，但在 DOMContentLoaded 事件之前。所有带有 defer 属性的脚本会按照它们在文档中出现的顺序执行。\n\n&lt;script src&#x3D;&quot;script.js&quot; defer&gt;&lt;&#x2F;script&gt;\n\n2. 使用 async 属性\nasync 属性：在 &lt;script&gt; 标签中添加 async 属性，表示脚本会异步加载并立即执行。与 defer 不同，async 脚本的执行顺序不一定与它们在文档中的顺序一致。\n\n&lt;script src&#x3D;&quot;script.js&quot; async&gt;&lt;&#x2F;script&gt;\n\n3. 将脚本放在页面底部\n在 &lt;body&gt; 标签的底部：将 &lt;script&gt; 标签放在 HTML 文档的底部，通常在 &lt;/body&gt; 标签之前。这可以确保在加载和解析 HTML 内容后再加载脚本，从而提高页面的加载速度。\n\n&lt;body&gt;\n  &lt;!-- 页面内容 --&gt;\n  &lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n4. 使用 JavaScript 动态加载\n动态创建 &lt;script&gt; 标签：使用 JavaScript 动态创建和插入 &lt;script&gt; 标签，以便在需要时加载脚本。这种方法可以在特定条件下延迟加载脚本。\n\nfunction loadScript(url) &#123;\n  const script &#x3D; document.createElement(&quot;script&quot;);\n  script.src &#x3D; url;\n  script.onload &#x3D; () &#x3D;&gt; &#123;\n    console.log(&quot;Script loaded successfully.&quot;);\n  &#125;;\n  document.body.appendChild(script);\n&#125;\n\n&#x2F;&#x2F; 在需要时调用\nloadScript(&quot;script.js&quot;);\n\n5. 使用模块化加载器\n使用模块化加载器：如 RequireJS、Webpack 等工具，可以实现按需加载和延迟加载 JavaScript 模块。这些工具通常提供了更复杂的依赖管理和异步加载功能。\n\n&#x2F;&#x2F; 使用 RequireJS\nrequire([&quot;script&quot;], function (script) &#123;\n  &#x2F;&#x2F; 脚本加载完成后执行\n&#125;);\n\n6. 使用 Intersection Observer API\n懒加载脚本：可以使用 Intersection Observer API 来监测某个元素是否进入视口，从而在用户滚动到该元素时加载脚本。\n\nconst scriptUrl &#x3D; &quot;script.js&quot;;\nconst observer &#x3D; new IntersectionObserver((entries) &#x3D;&gt; &#123;\n  entries.forEach((entry) &#x3D;&gt; &#123;\n    if (entry.isIntersecting) &#123;\n      const script &#x3D; document.createElement(&quot;script&quot;);\n      script.src &#x3D; scriptUrl;\n      document.body.appendChild(script);\n      observer.unobserve(entry.target); &#x2F;&#x2F; 停止观察\n    &#125;\n  &#125;);\n&#125;);\n\n&#x2F;&#x2F; 监测某个元素\nconst targetElement &#x3D; document.getElementById(&quot;lazy-load&quot;);\nobserver.observe(targetElement);\n\n7. 总结JavaScript 脚本延迟加载的方式有多种，包括使用 defer 和 async 属性、将脚本放在页面底部、动态加载脚本、使用模块化加载器以及利用 Intersection Observer API。选择合适的延迟加载方式可以提高页面的加载速度和用户体验。\nJavaScript 类数组对象的定义？在 JavaScript 中，类数组对象（Array-like Object）是指具有类似数组的特性，但并不是实际的数组对象的对象。类数组对象通常具有以下特征：\n\n具有 length 属性：类数组对象有一个 length 属性，表示对象中元素的数量。\n可以通过索引访问元素：类数组对象的元素可以通过数字索引访问，类似于数组。\n\n1. 类数组对象的示例以下是一些常见的类数组对象的示例：\n1.1. arguments 对象在函数内部，arguments 对象是一个类数组对象，包含传递给函数的所有参数。\nfunction example() &#123;\n  console.log(arguments); &#x2F;&#x2F; 类数组对象\n  console.log(arguments.length); &#x2F;&#x2F; 参数的数量\n  console.log(arguments[0]); &#x2F;&#x2F; 第一个参数\n&#125;\n\nexample(1, 2, 3); &#x2F;&#x2F; 输出: [1, 2, 3]\n\n1.2. DOM 方法返回的 NodeList许多 DOM 方法（如 document.querySelectorAll）返回的结果是类数组对象（NodeList），可以通过索引访问，但不具备数组的方法。\nconst elements &#x3D; document.querySelectorAll(&quot;div&quot;); &#x2F;&#x2F; 返回 NodeList\nconsole.log(elements.length); &#x2F;&#x2F; div 元素的数量\nconsole.log(elements[0]); &#x2F;&#x2F; 第一个 div 元素\n\n1.3. HTMLCollectiondocument.getElementsByTagName 和 document.getElementsByClassName 等方法返回的也是类数组对象（HTMLCollection）。\nconst divs &#x3D; document.getElementsByTagName(&quot;div&quot;); &#x2F;&#x2F; 返回 HTMLCollection\nconsole.log(divs.length); &#x2F;&#x2F; div 元素的数量\nconsole.log(divs[0]); &#x2F;&#x2F; 第一个 div 元素\n\n2. 类数组对象与数组的区别\n方法：类数组对象不具备数组的方法（如 push、pop、map、forEach 等），而数组具有这些方法。\n原型：类数组对象的原型不是 Array.prototype，而是 Object.prototype，因此不能直接使用数组的方法。\n\n3. 将类数组对象转换为数组可以使用 Array.from() 或扩展运算符（...）将类数组对象转换为真正的数组。\n3.1. 使用 Array.from()const argsArray &#x3D; Array.from(arguments); &#x2F;&#x2F; 将 arguments 转换为数组\n\n3.2. 使用扩展运算符const argsArray &#x3D; [...arguments]; &#x2F;&#x2F; 将 arguments 转换为数组\n\n4. 总结类数组对象是指具有类似数组特征的对象，通常具有 length 属性和索引访问的能力。常见的类数组对象包括 arguments 对象、NodeList 和 HTMLCollection。虽然类数组对象与数组有相似之处，但它们不具备数组的方法，因此在需要数组功能时，通常需要将类数组对象转换为真正的数组。\n数组有哪些原生方法？JavaScript 中的数组提供了许多原生方法，这些方法可以帮助开发者进行数组的操作和处理。以下是一些常用的数组原生方法的分类及其简要说明：\n1. 数组创建和初始化\n**Array.of()**：创建一个新数组实例，使用可变数量的参数。\nconst arr &#x3D; Array.of(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]\n\n**Array.from()**：从类数组对象或可迭代对象创建一个新数组实例。\nconst arr &#x3D; Array.from(&quot;hello&quot;); &#x2F;&#x2F; [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]\n\n2. 数组操作\n**push()**：向数组末尾添加一个或多个元素，并返回新数组的长度。\nconst arr &#x3D; [1, 2];\narr.push(3); &#x2F;&#x2F; [1, 2, 3]\n\n**pop()**：从数组末尾删除一个元素，并返回该元素。\nconst arr &#x3D; [1, 2, 3];\nconst last &#x3D; arr.pop(); &#x2F;&#x2F; last &#x3D; 3, arr &#x3D; [1, 2]\n\n**shift()**：从数组开头删除一个元素，并返回该元素。\nconst arr &#x3D; [1, 2, 3];\nconst first &#x3D; arr.shift(); &#x2F;&#x2F; first &#x3D; 1, arr &#x3D; [2, 3]\n\n**unshift()**：向数组开头添加一个或多个元素，并返回新数组的长度。\nconst arr &#x3D; [2, 3];\narr.unshift(1); &#x2F;&#x2F; [1, 2, 3]\n\n3. 数组遍历\n**forEach()**：对数组的每个元素执行一次提供的函数。\nconst arr &#x3D; [1, 2, 3];\narr.forEach((num) &#x3D;&gt; console.log(num)); &#x2F;&#x2F; 1, 2, 3\n\n**map()**：创建一个新数组，包含调用函数处理每个元素后的结果。\nconst arr &#x3D; [1, 2, 3];\nconst doubled &#x3D; arr.map((num) &#x3D;&gt; num * 2); &#x2F;&#x2F; [2, 4, 6]\n\n**filter()**：创建一个新数组，包含所有通过测试的元素。\nconst arr &#x3D; [1, 2, 3, 4];\nconst evens &#x3D; arr.filter((num) &#x3D;&gt; num % 2 &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; [2, 4]\n\n**reduce()**：对数组中的每个元素执行一个 reducer 函数，最终计算出一个值。\nconst arr &#x3D; [1, 2, 3];\nconst sum &#x3D; arr.reduce((acc, num) &#x3D;&gt; acc + num, 0); &#x2F;&#x2F; 6\n\n4. 数组查找\n**find()**：返回数组中满足提供的测试函数的第一个元素的值。\nconst arr &#x3D; [1, 2, 3, 4];\nconst found &#x3D; arr.find((num) &#x3D;&gt; num &gt; 2); &#x2F;&#x2F; 3\n\n**findIndex()**：返回满足提供的测试函数的第一个元素的索引。\nconst arr &#x3D; [1, 2, 3, 4];\nconst index &#x3D; arr.findIndex((num) &#x3D;&gt; num &gt; 2); &#x2F;&#x2F; 2\n\n**includes()**：判断数组是否包含某个值，返回布尔值。\nconst arr &#x3D; [1, 2, 3];\nconst hasTwo &#x3D; arr.includes(2); &#x2F;&#x2F; true\n\n5. 数组排序和反转\n**sort()**：对数组的元素进行排序，并返回该数组。\nconst arr &#x3D; [3, 1, 2];\narr.sort(); &#x2F;&#x2F; [1, 2, 3]\n\n**reverse()**：反转数组中的元素顺序。\nconst arr &#x3D; [1, 2, 3];\narr.reverse(); &#x2F;&#x2F; [3, 2, 1]\n\n6. 数组连接和切割\n**concat()**：连接两个或多个数组，并返回一个新数组。\nconst arr1 &#x3D; [1, 2];\nconst arr2 &#x3D; [3, 4];\nconst combined &#x3D; arr1.concat(arr2); &#x2F;&#x2F; [1, 2, 3, 4]\n\n**slice()**：返回数组的一个片段，创建一个新数组。\nconst arr &#x3D; [1, 2, 3, 4];\nconst sliced &#x3D; arr.slice(1, 3); &#x2F;&#x2F; [2, 3]\n\n**splice()**：改变数组的内容，通过添加、删除或替换现有元素。\nconst arr &#x3D; [1, 2, 3, 4];\narr.splice(1, 2, 5); &#x2F;&#x2F; arr &#x3D; [1, 5, 4]\n\n7. 数组其他方法\n**join()**：将数组的所有元素连接成一个字符串。\nconst arr &#x3D; [&quot;Hello&quot;, &quot;World&quot;];\nconst str &#x3D; arr.join(&quot; &quot;); &#x2F;&#x2F; &quot;Hello World&quot;\n\n**toString()**：将数组转换为字符串。\nconst arr &#x3D; [1, 2, 3];\nconst str &#x3D; arr.toString(); &#x2F;&#x2F; &quot;1,2,3&quot;\n\n**flat()**：将嵌套数组“扁平化”到指定的深度。\nconst arr &#x3D; [1, [2, [3, 4]]];\nconst flatArr &#x3D; arr.flat(2); &#x2F;&#x2F; [1, 2, 3, 4]\n\n**flatMap()**：先映射每个元素，然后将结果扁平化。\nconst arr &#x3D; [1, 2, 3];\nconst flatMapped &#x3D; arr.flatMap((x) &#x3D;&gt; [x, x * 2]); &#x2F;&#x2F; [1, 2, 2, 4, 3, 6]\n\n8. 总结JavaScript 数组提供了丰富的原生方法，帮助开发者进行数组的创建、操作、遍历、查找、排序、连接和切割等操作。理解这些方法可以提高开发效率，简化代码的编写。\n常见的位运算符有哪些？其计算规则是什么？在 JavaScript 中，位运算符用于对整数的二进制位进行操作。位运算符的操作数会被转换为 32 位有符号整数。以下是常见的位运算符及其计算规则：\n1. 位运算符列表1.1. 按位与（AND）&amp;\n操作：对两个数的每一位进行比较，只有当两个对应的位都是 1 时，结果位才为 1，否则为 0。\nconst a &#x3D; 5; &#x2F;&#x2F; 0101\nconst b &#x3D; 3; &#x2F;&#x2F; 0011\nconst result &#x3D; a &amp; b; &#x2F;&#x2F; 0001 (1)\n\n1.2. 按位或（OR）|\n操作：对两个数的每一位进行比较，只要有一个对应的位是 1，结果位就为 1，否则为 0。\nconst a &#x3D; 5; &#x2F;&#x2F; 0101\nconst b &#x3D; 3; &#x2F;&#x2F; 0011\nconst result &#x3D; a | b; &#x2F;&#x2F; 0111 (7)\n\n1.3. 按位异或（XOR）^\n操作：对两个数的每一位进行比较，当两个对应的位不同（一个是 1，一个是 0）时，结果位为 1，否则为 0。\nconst a &#x3D; 5; &#x2F;&#x2F; 0101\nconst b &#x3D; 3; &#x2F;&#x2F; 0011\nconst result &#x3D; a ^ b; &#x2F;&#x2F; 0110 (6)\n\n1.4. 按位非（NOT）~\n操作：对一个数的每一位进行取反操作，即 0 变为 1，1 变为 0。结果是 -(n + 1)，其中 n 是原数。\nconst a &#x3D; 5; &#x2F;&#x2F; 0101\nconst result &#x3D; ~a; &#x2F;&#x2F; 1010 (即 -6)\n\n1.5. 左移（Left Shift）&lt;&lt;\n操作：将一个数的二进制位向左移动指定的位数，右侧用 0 填充。相当于乘以 2 的指定次方。\nconst a &#x3D; 5; &#x2F;&#x2F; 0101\nconst result &#x3D; a &lt;&lt; 1; &#x2F;&#x2F; 1010 (10)\n\n1.6. 右移（Right Shift）&gt;&gt;\n操作：将一个数的二进制位向右移动指定的位数，左侧用符号位填充（如果是负数，左侧填充 1；如果是正数，左侧填充 0）。相当于除以 2 的指定次方。\nconst a &#x3D; 5; &#x2F;&#x2F; 0101\nconst result &#x3D; a &gt;&gt; 1; &#x2F;&#x2F; 0010 (2)\n\n1.7. 无符号右移（Unsigned Right Shift）&gt;&gt;&gt;\n操作：将一个数的二进制位向右移动指定的位数，左侧用 0 填充，不考虑符号位。适用于处理无符号整数。\nconst a &#x3D; -5; &#x2F;&#x2F; 11111111111111111111111111111011\nconst result &#x3D; a &gt;&gt;&gt; 1; &#x2F;&#x2F; 01111111111111111111111111111101 (2147483645)\n\n2. 计算规则\n二进制表示：位运算符操作的是整数的二进制表示，所有的操作都是在二进制位上进行的。\n32 位有符号整数：JavaScript 中的位运算符将操作数转换为 32 位有符号整数。\n结果类型：位运算的结果也是一个整数，通常以十进制形式表示。\n\n3. 总结JavaScript 中的位运算符包括按位与、按位或、按位异或、按位非、左移、右移和无符号右移。它们通过对整数的二进制位进行操作来实现各种计算，适用于需要低级别位操作的场景。理解这些运算符及其计算规则可以帮助开发者更有效地处理位级数据。\n为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?在 JavaScript 中，arguments 对象是一个类数组对象，它包含传递给函数的所有参数。arguments 不是一个真正的数组，而是一个类似数组的对象，主要有以下几个原因：\n1. arguments 是类数组而不是数组的原因\n历史遗留：arguments 对象是 JavaScript 早期版本的一部分，设计时并没有考虑到将其作为数组来处理。它的主要目的是提供对函数参数的访问，而不是作为一个完整的数组对象。\n\n性能考虑：在函数调用时，arguments 对象的实现方式可能更高效，因为它不需要分配额外的数组方法和属性。类数组对象只需要存储参数的引用和 length 属性。\n\n灵活性：arguments 对象允许函数接受不定数量的参数，这种灵活性在早期 JavaScript 中是非常重要的。将其设计为类数组对象可以更简单地实现这一点。\n\n\n2. arguments 对象的特点\n类数组特性：arguments 对象具有 length 属性，可以通过索引访问参数，但不具备数组的方法（如 push、pop、map 等）。\n动态性：arguments 对象的内容是动态的，随着函数调用的参数变化而变化。\n\n3. 遍历类数组对象虽然 arguments 对象不是数组，但可以使用多种方法遍历它：\n3.1. 使用 for 循环可以使用传统的 for 循环遍历 arguments 对象。\nfunction example() &#123;\n  for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123;\n    console.log(arguments[i]);\n  &#125;\n&#125;\n\nexample(1, 2, 3); &#x2F;&#x2F; 输出: 1, 2, 3\n\n3.2. 使用 for...of 循环在 ES6 中，可以使用 for...of 循环遍历 arguments 对象，但需要将其转换为数组。\nfunction example() &#123;\n  for (const arg of Array.from(arguments)) &#123;\n    console.log(arg);\n  &#125;\n&#125;\n\nexample(1, 2, 3); &#x2F;&#x2F; 输出: 1, 2, 3\n\n3.3. 使用 Array.from()可以使用 Array.from() 方法将 arguments 对象转换为数组，然后遍历。\nfunction example() &#123;\n  const argsArray &#x3D; Array.from(arguments);\n  argsArray.forEach((arg) &#x3D;&gt; &#123;\n    console.log(arg);\n  &#125;);\n&#125;\n\nexample(1, 2, 3); &#x2F;&#x2F; 输出: 1, 2, 3\n\n3.4. 使用扩展运算符在 ES6 中，可以使用扩展运算符将 arguments 对象转换为数组。\nfunction example() &#123;\n  const argsArray &#x3D; [...arguments];\n  argsArray.forEach((arg) &#x3D;&gt; &#123;\n    console.log(arg);\n  &#125;);\n&#125;\n\nexample(1, 2, 3); &#x2F;&#x2F; 输出: 1, 2, 3\n\n4. 总结arguments 对象是类数组而不是数组的原因主要与历史设计、性能和灵活性有关。虽然 arguments 对象不具备数组的方法，但可以通过多种方式遍历它，如使用 for 循环、for...of 循环、Array.from() 或扩展运算符等。理解 arguments 对象的特性和遍历方法可以帮助开发者更有效地处理函数参数。\n什么是 DOM 和 BOM？在 Web 开发中，DOM（文档对象模型）和 BOM（浏览器对象模型）是两个重要的概念，它们分别用于处理网页的结构和浏览器的功能。以下是对 DOM 和 BOM 的详细解释：\n1. DOM（文档对象模型）1.1. 定义DOM 是一种编程接口，用于表示和操作 HTML 和 XML 文档的结构。它将文档视为一个树形结构，其中每个节点代表文档中的一个部分（如元素、属性、文本等）。\n1.2. 特点\n树形结构：DOM 将文档表示为一个树形结构，根节点是 document 对象，子节点是 HTML 元素、文本节点等。\n\n动态性：通过 JavaScript，可以动态地修改 DOM，添加、删除或更改元素和属性，从而实现交互性和动态效果。\n\n语言无关：虽然 DOM 最初是为 JavaScript 设计的，但它是语言无关的，可以被多种编程语言访问。\n\n\n1.3. 常用 DOM 方法\n获取元素：\n\ndocument.getElementById(id)：通过 ID 获取元素。\ndocument.getElementsByClassName(className)：通过类名获取元素集合。\ndocument.querySelector(selector)：通过 CSS 选择器获取第一个匹配的元素。\n\n\n修改元素：\n\nelement.innerHTML：获取或设置元素的 HTML 内容。\nelement.style：获取或设置元素的样式。\n\n\n添加和删除元素：\n\ndocument.createElement(tagName)：创建新元素。\nparentElement.appendChild(childElement)：将子元素添加到父元素。\nparentElement.removeChild(childElement)：从父元素中删除子元素。\n\n\n\n2. BOM（浏览器对象模型）2.1. 定义BOM 是一组 JavaScript 对象，用于与浏览器进行交互。它提供了对浏览器窗口、历史记录、导航、定时器等功能的访问。\n2.2. 特点\n与浏览器相关：BOM 提供了与浏览器相关的功能，允许开发者控制浏览器的行为和与用户的交互。\n\n不依赖于文档：BOM 的功能不依赖于 DOM，开发者可以在没有文档的情况下使用 BOM。\n\n\n2.3. 常用 BOM 对象\nwindow：表示浏览器窗口，是 BOM 的根对象，提供了许多方法和属性，如 alert()、setTimeout()、location 等。\n\ndocument：虽然 document 是 DOM 的一部分，但它也是 BOM 的一部分，表示当前加载的文档。\n\nnavigator：提供有关浏览器的信息，如浏览器名称、版本、操作系统等。\n\nlocation：表示当前文档的 URL，提供了获取和修改 URL 的方法。\n\nhistory：提供对浏览器历史记录的访问，允许开发者控制用户的浏览历史。\n\n\n3. 总结\nDOM（文档对象模型）：用于表示和操作 HTML 和 XML 文档的结构，允许开发者动态修改网页内容和结构。\nBOM（浏览器对象模型）：用于与浏览器进行交互，提供对浏览器窗口、历史记录、导航等功能的访问。\n\n理解 DOM 和 BOM 的概念及其功能是 Web 开发的基础，有助于开发者创建动态和交互性强的网页应用。\n对类数组对象的理解，如何转化为数组在 JavaScript 中，类数组对象（Array-like Object）是指具有类似数组的特性，但并不是实际的数组对象的对象。类数组对象通常具有以下几个特征：\n1. 类数组对象的特征\n具有 length 属性：类数组对象有一个 length 属性，表示对象中元素的数量。\n可以通过索引访问元素：类数组对象的元素可以通过数字索引访问，类似于数组。\n\n2. 常见的类数组对象\narguments 对象：在函数内部，arguments 对象是一个类数组对象，包含传递给函数的所有参数。\nfunction example() &#123;\n  console.log(arguments); &#x2F;&#x2F; 类数组对象\n  console.log(arguments.length); &#x2F;&#x2F; 参数的数量\n  console.log(arguments[0]); &#x2F;&#x2F; 第一个参数\n&#125;\n\nexample(1, 2, 3); &#x2F;&#x2F; 输出: 1, 2, 3\n\nDOM 方法返回的 NodeList：许多 DOM 方法（如 document.querySelectorAll）返回的结果是类数组对象（NodeList），可以通过索引访问，但不具备数组的方法。\nconst elements &#x3D; document.querySelectorAll(&quot;div&quot;); &#x2F;&#x2F; 返回 NodeList\nconsole.log(elements.length); &#x2F;&#x2F; div 元素的数量\nconsole.log(elements[0]); &#x2F;&#x2F; 第一个 div 元素\n\nHTMLCollection：document.getElementsByTagName 和 document.getElementsByClassName 等方法返回的也是类数组对象（HTMLCollection）。\n\n\n3. 将类数组对象转换为数组虽然类数组对象不具备数组的方法，但可以使用多种方法将其转换为真正的数组：\n3.1. 使用 Array.from()Array.from() 方法可以将类数组对象或可迭代对象转换为数组。\nfunction example() &#123;\n  const argsArray &#x3D; Array.from(arguments); &#x2F;&#x2F; 将 arguments 转换为数组\n  console.log(argsArray); &#x2F;&#x2F; [1, 2, 3]\n&#125;\n\nexample(1, 2, 3);\n\n3.2. 使用扩展运算符（Spread Operator）在 ES6 中，可以使用扩展运算符将类数组对象转换为数组。\nfunction example() &#123;\n  const argsArray &#x3D; [...arguments]; &#x2F;&#x2F; 将 arguments 转换为数组\n  console.log(argsArray); &#x2F;&#x2F; [1, 2, 3]\n&#125;\n\nexample(1, 2, 3);\n\n3.3. 使用 Array.prototype.slice.call()可以使用 Array.prototype.slice 方法将类数组对象转换为数组。\nfunction example() &#123;\n  const argsArray &#x3D; Array.prototype.slice.call(arguments); &#x2F;&#x2F; 将 arguments 转换为数组\n  console.log(argsArray); &#x2F;&#x2F; [1, 2, 3]\n&#125;\n\nexample(1, 2, 3);\n\n3.4. 使用 Array.prototype.concat()可以使用 Array.prototype.concat() 方法将类数组对象转换为数组。\nfunction example() &#123;\n  const argsArray &#x3D; [].concat.apply([], arguments); &#x2F;&#x2F; 将 arguments 转换为数组\n  console.log(argsArray); &#x2F;&#x2F; [1, 2, 3]\n&#125;\n\nexample(1, 2, 3);\n\n4. 总结类数组对象是指具有类似数组特征的对象，通常具有 length 属性和索引访问的能力。常见的类数组对象包括 arguments 对象、NodeList 和 HTMLCollection。虽然类数组对象与数组有相似之处，但它们不具备数组的方法，因此在需要数组功能时，通常需要将类数组对象转换为真正的数组。可以使用 Array.from()、扩展运算符、Array.prototype.slice.call() 或 Array.prototype.concat() 等方法进行转换。\nescape、encodeURI、encodeURIComponent 的区别在 JavaScript 中，escape、encodeURI 和 encodeURIComponent 都是用于编码字符串的函数，但它们的用途和处理方式有所不同。以下是对这三者的详细比较：\n1. escape\n定义：escape 是一个较旧的函数，用于对字符串进行编码，以便在 URL 中使用。它会对非 ASCII 字符和某些特殊字符进行编码。\n\n编码方式：escape 会将所有非 ASCII 字符（Unicode 字符）和以下字符进行编码：*、+、-、.、/、@、&amp;、=、?、:、#、!、&#39;、(、)、~、%、$、^、&#123;、&#125;、[、]、|、&lt;、&gt;、&quot;。\n\n注意：escape 已被弃用，不推荐使用。它不能正确处理某些字符（如 + 和 @），并且不适用于现代 Web 开发。\n\n\n示例const str &#x3D; &quot;Hello, 世界!&quot;;\nconst encoded &#x3D; escape(str); &#x2F;&#x2F; &quot;Hello%2C%20%u4E16%u754C%21&quot;\nconsole.log(encoded);\n\n2. encodeURI\n定义：encodeURI 用于对整个 URI 进行编码。它会对 URI 中的特殊字符进行编码，但保留一些字符，以确保 URI 的结构不被破坏。\n\n编码方式：encodeURI 不会编码以下字符：#、?、&amp;、=、:、/、@、+、$、!、&#39;、(、)、*、~、-、.、_。\n\n用途：适用于编码完整的 URI，确保 URI 的结构和语义不被改变。\n\n\n示例const uri &#x3D; &quot;http:&#x2F;&#x2F;example.com&#x2F;?name&#x3D;张三&amp;age&#x3D;25&quot;;\nconst encodedURI &#x3D; encodeURI(uri); &#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;?name&#x3D;%E5%BC%A0%E4%B8%89&amp;age&#x3D;25&quot;\nconsole.log(encodedURI);\n\n3. encodeURIComponent\n定义：encodeURIComponent 用于对 URI 的组成部分进行编码。它会对所有字符进行编码，包括特殊字符。\n\n编码方式：encodeURIComponent 会编码所有非字母数字字符，包括 !、&#39;、(、)、*、~、-、.、_、/、:、@、&amp;、=、+、$、#、?。\n\n用途：适用于编码 URI 的单个组件（如查询参数、路径段等），确保这些组件在 URI 中的正确性。\n\n\n示例const param &#x3D; &quot;name&#x3D;张三&amp;age&#x3D;25&quot;;\nconst encodedParam &#x3D; encodeURIComponent(param); &#x2F;&#x2F; &quot;name%3D%E5%BC%A0%E4%B8%89%26age%3D25&quot;\nconsole.log(encodedParam);\n\n4. 总结\n\n\n函数\n用途\n编码的字符\n\n\n\nescape\n编码字符串（已弃用）\n非 ASCII 字符和某些特殊字符\n\n\nencodeURI\n编码整个 URI\n保留 URI 结构字符（如 ?、&amp;、=）\n\n\nencodeURIComponent\n编码 URI 的组成部分\n编码所有非字母数字字符\n\n\n在现代 Web 开发中，推荐使用 encodeURI 和 encodeURIComponent，而不使用 escape。通常，encodeURIComponent 更常用于处理 URL 的查询参数和路径段，以确保所有字符都被正确编码。\n对 AJAX 的理解，实现一个 AJAX 请求AJAX（Asynchronous JavaScript and XML）是一种用于在不重新加载整个网页的情况下与服务器交换数据的技术。它允许网页在后台与服务器进行异步通信，从而提高用户体验和页面响应速度。虽然 AJAX 的名称中包含 XML，但它实际上可以使用多种数据格式（如 JSON、XML、HTML 等）进行数据交换。\n1. AJAX 的工作原理AJAX 的工作原理通常包括以下几个步骤：\n\n创建 XMLHttpRequest 对象：使用 JavaScript 创建一个 XMLHttpRequest 对象。\n配置请求：使用 open() 方法配置请求的类型（GET、POST 等）、URL 和是否异步。\n发送请求：使用 send() 方法发送请求到服务器。\n处理响应：通过 onreadystatechange 事件或 onload 事件处理服务器的响应。\n\n2. 实现一个 AJAX 请求以下是一个使用原生 JavaScript 实现 AJAX 请求的示例，向一个 API 发送 GET 请求并处理响应。\n示例：获取 JSON 数据&#x2F;&#x2F; 创建 XMLHttpRequest 对象\nconst xhr &#x3D; new XMLHttpRequest();\n\n&#x2F;&#x2F; 配置请求\nxhr.open(&quot;GET&quot;, &quot;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&quot;, true);\n\n&#x2F;&#x2F; 设置响应类型\nxhr.responseType &#x3D; &quot;json&quot;;\n\n&#x2F;&#x2F; 处理响应\nxhr.onload &#x3D; function () &#123;\n  if (xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) &#123;\n    &#x2F;&#x2F; 请求成功，处理响应数据\n    const data &#x3D; xhr.response;\n    console.log(data); &#x2F;&#x2F; 输出获取到的数据\n  &#125; else &#123;\n    &#x2F;&#x2F; 请求失败，处理错误\n    console.error(&quot;Request failed with status:&quot;, xhr.status);\n  &#125;\n&#125;;\n\n&#x2F;&#x2F; 处理请求错误\nxhr.onerror &#x3D; function () &#123;\n  console.error(&quot;Request failed&quot;);\n&#125;;\n\n&#x2F;&#x2F; 发送请求\nxhr.send();\n\n3. 代码解释\n创建 XMLHttpRequest 对象：使用 new XMLHttpRequest() 创建一个新的 XMLHttpRequest 对象。\n配置请求：使用 xhr.open(method, url, async) 方法配置请求，其中 method 是请求类型（如 GET 或 POST），url 是请求的目标地址，async 表示是否异步。\n设置响应类型：使用 xhr.responseType 设置响应的数据类型，这里设置为 json，表示期望返回 JSON 格式的数据。\n处理响应：使用 xhr.onload 处理响应，当请求完成时会触发该事件。如果状态码在 200 到 299 之间，表示请求成功，可以处理响应数据；否则，处理错误。\n处理请求错误：使用 xhr.onerror 处理请求错误。\n发送请求：使用 xhr.send() 发送请求。\n\n4. 使用 Fetch API现代浏览器还支持 Fetch API，它提供了更简洁的方式来进行 AJAX 请求。以下是使用 Fetch API 的示例：\nfetch(&quot;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&quot;)\n  .then((response) &#x3D;&gt; &#123;\n    if (!response.ok) &#123;\n      throw new Error(&quot;Network response was not ok&quot;);\n    &#125;\n    return response.json(); &#x2F;&#x2F; 解析 JSON 数据\n  &#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(data); &#x2F;&#x2F; 输出获取到的数据\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;There was a problem with the fetch operation:&quot;, error);\n  &#125;);\n\n5. 总结AJAX 是一种强大的技术，允许网页在不重新加载的情况下与服务器进行异步通信。通过使用 XMLHttpRequest 对象或 Fetch API，开发者可以轻松实现 AJAX 请求，从而提高用户体验和页面响应速度。理解 AJAX 的工作原理和实现方式是现代 Web 开发的重要组成部分。\nJavaScript 为什么要进行变量提升，它导致了什么问题？在 JavaScript 中，变量提升（Hoisting）是一个重要的概念，它指的是在代码执行之前，变量和函数声明会被提升到其所在作用域的顶部。这意味着你可以在声明变量或函数之前使用它们。以下是对变量提升的详细解释及其可能导致的问题。\n1. 变量提升的机制在 JavaScript 中，变量提升的机制如下：\n\n变量声明提升：所有的变量声明（使用 var 声明的变量）会被提升到函数或全局作用域的顶部，但赋值不会被提升。\n函数声明提升：函数声明会被提升到其所在作用域的顶部，包括函数体内的所有代码。\n\n示例console.log(x); &#x2F;&#x2F; undefined\nvar x &#x3D; 5;\nconsole.log(x); &#x2F;&#x2F; 5\n\n在这个例子中，尽管 console.log(x) 在变量 x 被声明之前执行，但由于变量提升，JavaScript 引擎会将 var x 的声明提升到顶部，因此第一次输出 undefined。\n2. 变量提升的影响2.1. 可能导致的混淆\n未初始化的变量：由于变量提升，使用未初始化的变量会导致 undefined，这可能会让开发者感到困惑。\n\nconsole.log(y); &#x2F;&#x2F; undefined\nvar y &#x3D; 10;\n\n\n函数提升：函数声明会被提升，但如果使用函数表达式，提升的行为就不同了。\n\nconsole.log(myFunc()); &#x2F;&#x2F; &quot;Hello&quot;\nfunction myFunc() &#123;\n  return &quot;Hello&quot;;\n&#125;\n\nconsole.log(myFunc()); &#x2F;&#x2F; TypeError: myFunc is not a function\nvar myFunc &#x3D; function () &#123;\n  return &quot;Hello&quot;;\n&#125;;\n\n在第二个例子中，myFunc 的声明被提升，但赋值并没有，因此在调用时会导致错误。\n3. 解决变量提升问题的方法为了避免变量提升带来的问题，建议遵循以下最佳实践：\n\n**使用 let 和 const**：在 ES6 中引入的 let 和 const 不会发生提升，使用它们可以避免一些提升相关的问题。\n\nconsole.log(a); &#x2F;&#x2F; ReferenceError: Cannot access &#39;a&#39; before initialization\nlet a &#x3D; 5;\n\n\n在使用变量之前声明它们：始终在使用变量之前进行声明，以确保代码的可读性和可维护性。\n\nvar b &#x3D; 10;\nconsole.log(b); &#x2F;&#x2F; 10\n\n\n使用函数表达式而不是函数声明：如果不希望函数被提升，可以使用函数表达式。\n\nvar myFunc &#x3D; function () &#123;\n  return &quot;Hello&quot;;\n&#125;;\nconsole.log(myFunc()); &#x2F;&#x2F; &quot;Hello&quot;\n\n4. 总结变量提升是 JavaScript 中的一个特性，它允许变量和函数声明在代码执行之前被提升到作用域的顶部。虽然这可以带来一定的灵活性，但也可能导致混淆和错误。通过使用 let 和 const、在使用变量之前声明它们以及使用函数表达式，可以有效地避免与变量提升相关的问题。理解变量提升的机制有助于编写更清晰和可维护的代码。\n什么是尾调用，使用尾调用有什么好处？尾调用（Tail Call）是指在一个函数的最后一步调用另一个函数的情况。在这种情况下，调用的结果直接作为当前函数的返回值。尾调用的一个重要特性是，它可以优化内存使用，避免栈溢出。\n1. 尾调用的定义在 JavaScript 中，尾调用的定义如下：\n\n如果一个函数在其执行的最后一步调用另一个函数（或自身），并且没有其他操作（如计算、处理等），那么这个调用就是尾调用。\n\n示例function tailCallExample(n) &#123;\n  if (n &lt;&#x3D; 1) &#123;\n    return n;\n  &#125;\n  return tailCallExample(n - 1); &#x2F;&#x2F; 尾调用\n&#125;\n\n在这个例子中，tailCallExample 函数的最后一步是调用自身，因此这是一个尾调用。\n2. 尾调用优化（TCO）尾调用优化（Tail Call Optimization, TCO）是一种编程语言的优化技术，允许编译器或解释器在执行尾调用时重用当前函数的栈帧，而不是创建新的栈帧。这可以显著减少内存使用，避免栈溢出。\n尾调用优化的工作原理\n当一个函数执行尾调用时，当前函数的执行上下文可以被替换为被调用函数的执行上下文。\n这意味着不需要在调用栈中保留当前函数的状态，从而节省内存。\n\n3. 使用尾调用的好处3.1. 避免栈溢出在递归函数中，使用尾调用可以避免栈溢出的问题。传统的递归调用会在每次调用时增加栈帧，导致栈溢出，而尾调用优化可以重用栈帧。\nfunction factorial(n, acc &#x3D; 1) &#123;\n  if (n &lt;&#x3D; 1) &#123;\n    return acc;\n  &#125;\n  return factorial(n - 1, n * acc); &#x2F;&#x2F; 尾调用\n&#125;\n\nconsole.log(factorial(5)); &#x2F;&#x2F; 120\n\n在这个例子中，factorial 函数使用尾调用来计算阶乘，避免了栈溢出。\n3.2. 提高性能尾调用优化可以提高性能，因为它减少了函数调用的开销。通过重用栈帧，程序可以更高效地执行递归操作。\n3.3. 更清晰的代码使用尾调用可以使代码更简洁和易于理解，特别是在处理递归时。它可以将递归逻辑转化为迭代逻辑，使得代码更易于维护。\n4. 注意事项\n支持情况：并不是所有的 JavaScript 引擎都支持尾调用优化。虽然 ES6 规范中引入了尾调用优化的概念，但在实际的 JavaScript 环境中（如浏览器和 Node.js），并不一定会实现这一优化。\n使用场景：尾调用特别适合于需要大量递归的场景，如遍历树结构、计算斐波那契数列等。\n\n5. 总结尾调用是指在函数的最后一步调用另一个函数的情况。使用尾调用的好处包括避免栈溢出、提高性能和使代码更清晰。虽然尾调用优化在理论上是有益的，但在实际应用中，开发者需要注意其支持情况和使用场景。理解尾调用的概念可以帮助开发者编写更高效和可维护的代码。\nES6 模块与 CommonJS 模块有什么异同？在 JavaScript 中，ES6 模块（也称为 ES2015 模块）和 CommonJS 模块是两种不同的模块化系统。它们各自有不同的语法、特性和使用场景。以下是对这两种模块化系统的详细比较：\n1. 定义\nES6 模块：是 ECMAScript 2015（ES6）引入的模块系统，使用 import 和 export 语法来定义和使用模块。\nCommonJS 模块：是 Node.js 中使用的模块系统，使用 require() 函数来导入模块，使用 module.exports 或 exports 来导出模块。\n\n2. 语法2.1. ES6 模块\n导出：\n\n&#x2F;&#x2F; 导出单个变量\nexport const name &#x3D; &quot;Alice&quot;;\n\n&#x2F;&#x2F; 导出多个变量\nexport const age &#x3D; 30;\n\n&#x2F;&#x2F; 导出默认值\nexport default function () &#123;\n  console.log(&quot;Hello, World!&quot;);\n&#125;\n\n\n导入：\n\nimport &#123; name, age &#125; from &quot;.&#x2F;module.js&quot;; &#x2F;&#x2F; 导入命名导出\nimport myFunction from &quot;.&#x2F;module.js&quot;; &#x2F;&#x2F; 导入默认导出\n\n2.2. CommonJS 模块\n导出：\n\n&#x2F;&#x2F; 导出单个变量\nconst name &#x3D; &quot;Alice&quot;;\nmodule.exports &#x3D; name;\n\n&#x2F;&#x2F; 导出多个变量\nconst age &#x3D; 30;\nexports.age &#x3D; age;\n\n&#x2F;&#x2F; 导出函数\nmodule.exports &#x3D; function () &#123;\n  console.log(&quot;Hello, World!&quot;);\n&#125;;\n\n\n导入：\n\nconst name &#x3D; require(&quot;.&#x2F;module&quot;); &#x2F;&#x2F; 导入模块\nconst myFunction &#x3D; require(&quot;.&#x2F;module&quot;); &#x2F;&#x2F; 导入模块\n\n3. 加载方式\nES6 模块：采用静态加载，模块在编译时就确定了依赖关系，支持树摇（tree-shaking）优化。ES6 模块是异步加载的，支持 import() 动态导入。\n\nCommonJS 模块：采用动态加载，模块在运行时加载，依赖关系在运行时确定。CommonJS 模块是同步加载的，适合在服务器端使用。\n\n\n4. 作用域\nES6 模块：每个模块都有自己的作用域，模块内的变量不会污染全局作用域。\n\nCommonJS 模块：每个模块也是一个独立的作用域，但模块内的变量可以通过 exports 或 module.exports 导出。\n\n\n5. 兼容性\nES6 模块：在现代浏览器和 Node.js（从 v12 开始）中得到支持，但在某些旧版本的环境中可能不兼容。\n\nCommonJS 模块：广泛用于 Node.js 和许多构建工具（如 Webpack、Browserify）中，兼容性较好。\n\n\n6. 主要区别总结\n\n\n特性\nES6 模块\nCommonJS 模块\n\n\n\n导入导出语法\nimport 和 export\nrequire() 和 module.exports\n\n\n加载方式\n静态加载，异步\n动态加载，同步\n\n\n作用域\n每个模块有自己的作用域\n每个模块也是独立作用域\n\n\n兼容性\n现代浏览器和 Node.js（v12+）支持\nNode.js 和构建工具广泛支持\n\n\n树摇优化\n支持\n不支持\n\n\n7. 总结ES6 模块和 CommonJS 模块是 JavaScript 中两种主要的模块化系统。ES6 模块提供了更现代的语法和静态加载特性，适合前端开发和现代 JavaScript 应用；而 CommonJS 模块则在 Node.js 中广泛使用，适合服务器端开发。理解这两种模块化系统的异同可以帮助开发者在不同的环境中选择合适的模块化方案。\n常见的 DOM 操作有哪些在 JavaScript 中，DOM（文档对象模型）操作是与 HTML 文档进行交互和修改的关键。以下是一些常见的 DOM 操作，包括获取、修改、添加和删除元素等。\n1. 获取元素\n**document.getElementById(id)**：通过元素的 ID 获取单个元素。\nconst element &#x3D; document.getElementById(&quot;myId&quot;);\n\n**document.getElementsByClassName(className)**：通过类名获取元素集合（HTMLCollection）。\nconst elements &#x3D; document.getElementsByClassName(&quot;myClass&quot;);\n\n**document.getElementsByTagName(tagName)**：通过标签名获取元素集合（HTMLCollection）。\nconst elements &#x3D; document.getElementsByTagName(&quot;div&quot;);\n\n**document.querySelector(selector)**：通过 CSS 选择器获取第一个匹配的元素。\nconst element &#x3D; document.querySelector(&quot;.myClass&quot;);\n\n**document.querySelectorAll(selector)**：通过 CSS 选择器获取所有匹配的元素（NodeList）。\nconst elements &#x3D; document.querySelectorAll(&quot;div.myClass&quot;);\n\n2. 修改元素\n修改文本内容：使用 textContent 或 innerHTML 属性。\nconst element &#x3D; document.getElementById(&quot;myId&quot;);\nelement.textContent &#x3D; &quot;新文本内容&quot;; &#x2F;&#x2F; 设置文本内容\nelement.innerHTML &#x3D; &quot;&lt;strong&gt;新内容&lt;&#x2F;strong&gt;&quot;; &#x2F;&#x2F; 设置 HTML 内容\n\n修改属性：使用 setAttribute() 方法或直接访问属性。\nconst element &#x3D; document.getElementById(&quot;myId&quot;);\nelement.setAttribute(&quot;src&quot;, &quot;image.jpg&quot;); &#x2F;&#x2F; 设置属性\nelement.alt &#x3D; &quot;新图片&quot;; &#x2F;&#x2F; 直接设置属性\n\n修改样式：使用 style 属性。\nconst element &#x3D; document.getElementById(&quot;myId&quot;);\nelement.style.color &#x3D; &quot;red&quot;; &#x2F;&#x2F; 设置文本颜色\nelement.style.backgroundColor &#x3D; &quot;blue&quot;; &#x2F;&#x2F; 设置背景颜色\n\n3. 添加和删除元素\n创建新元素：使用 document.createElement() 方法。\nconst newElement &#x3D; document.createElement(&quot;div&quot;);\nnewElement.textContent &#x3D; &quot;这是一个新元素&quot;;\n\n添加元素：使用 appendChild() 或 insertBefore() 方法。\nconst parentElement &#x3D; document.getElementById(&quot;parent&quot;);\nparentElement.appendChild(newElement); &#x2F;&#x2F; 添加到父元素的末尾\n\n插入元素：使用 insertAdjacentElement() 方法。\nconst referenceElement &#x3D; document.getElementById(&quot;reference&quot;);\nreferenceElement.insertAdjacentElement(&quot;beforebegin&quot;, newElement); &#x2F;&#x2F; 在参考元素之前插入\n\n删除元素：使用 removeChild() 或 remove() 方法。\nconst parentElement &#x3D; document.getElementById(&quot;parent&quot;);\nparentElement.removeChild(newElement); &#x2F;&#x2F; 从父元素中删除\nnewElement.remove(); &#x2F;&#x2F; 直接删除元素\n\n4. 事件处理\n添加事件监听器：使用 addEventListener() 方法。\nconst button &#x3D; document.getElementById(&quot;myButton&quot;);\nbutton.addEventListener(&quot;click&quot;, function () &#123;\n  alert(&quot;按钮被点击了！&quot;);\n&#125;);\n\n移除事件监听器：使用 removeEventListener() 方法。\nfunction handleClick() &#123;\n  alert(&quot;按钮被点击了！&quot;);\n&#125;\nbutton.addEventListener(&quot;click&quot;, handleClick);\nbutton.removeEventListener(&quot;click&quot;, handleClick);\n\n5. 遍历和操作节点\n遍历子节点：使用 childNodes 或 children 属性。\nconst parentElement &#x3D; document.getElementById(&quot;parent&quot;);\nconst children &#x3D; parentElement.childNodes; &#x2F;&#x2F; 包含所有子节点（包括文本节点）\nconst childElements &#x3D; parentElement.children; &#x2F;&#x2F; 仅包含元素节点\n\n访问父节点：使用 parentNode 属性。\nconst childElement &#x3D; document.getElementById(&quot;child&quot;);\nconst parentElement &#x3D; childElement.parentNode; &#x2F;&#x2F; 获取父节点\n\n访问兄弟节点：使用 nextSibling 和 previousSibling 属性。\nconst sibling &#x3D; childElement.nextSibling; &#x2F;&#x2F; 获取下一个兄弟节点\n\n6. 其他常用操作\n克隆节点：使用 cloneNode() 方法。\nconst originalElement &#x3D; document.getElementById(&quot;myId&quot;);\nconst clonedElement &#x3D; originalElement.cloneNode(true); &#x2F;&#x2F; 深克隆\n\n替换节点：使用 replaceChild() 方法。\nconst newElement &#x3D; document.createElement(&quot;div&quot;);\nparentElement.replaceChild(newElement, originalElement); &#x2F;&#x2F; 替换原有节点\n\n7. 总结常见的 DOM 操作包括获取元素、修改元素、添加和删除元素、事件处理、遍历和操作节点等。这些操作使得开发者能够动态地与网页内容进行交互，从而实现丰富的用户体验。理解这些基本的 DOM 操作是前端开发的基础。\nuse strict 是什么意思 ? 使用它区别是什么？在 JavaScript 中，&quot;use strict&quot; 是一种指令，用于启用严格模式（Strict Mode）。严格模式是一种更严格的 JavaScript 解析和执行模式，它可以帮助开发者编写更安全和更高效的代码。以下是对 &quot;use strict&quot; 的详细解释及其使用的区别。\n1. 什么是严格模式严格模式是 ECMAScript 5（ES5）引入的一种特性，通过在 JavaScript 代码的开头添加 &quot;use strict&quot; 字符串，可以启用严格模式。严格模式会对 JavaScript 的某些行为进行限制，帮助开发者避免常见的错误。\n2. 启用严格模式严格模式可以在全局范围内或在函数内部启用：\n\n全局严格模式：\n\n&quot;use strict&quot;; &#x2F;&#x2F; 启用全局严格模式\n\nfunction myFunction() &#123;\n  &#x2F;&#x2F; 这里的代码在严格模式下执行\n&#125;\n\n\n函数内部严格模式：\n\nfunction myFunction() &#123;\n  &quot;use strict&quot;; &#x2F;&#x2F; 仅在该函数内启用严格模式\n  &#x2F;&#x2F; 这里的代码在严格模式下执行\n&#125;\n\n3. 严格模式的主要区别和限制使用严格模式会引入一些限制和不同的行为，主要包括：\n3.1. 禁止使用未声明的变量在严格模式下，使用未声明的变量会抛出错误。\n&quot;use strict&quot;;\nx &#x3D; 10; &#x2F;&#x2F; ReferenceError: x is not defined\n\n3.2. 禁止删除变量、对象属性和函数在严格模式下，尝试删除不可删除的变量、对象属性或函数会抛出错误。\n&quot;use strict&quot;;\nvar obj &#x3D; &#123;&#125;;\ndelete obj; &#x2F;&#x2F; SyntaxError: Delete of an unqualified identifier in strict mode.\n\n3.3. 禁止重名参数在严格模式下，函数的参数不能有相同的名称。\n&quot;use strict&quot;;\nfunction myFunction(a, a, b) &#123;\n  &#x2F;&#x2F; SyntaxError: Duplicate parameter name not allowed in this context\n  &#x2F;&#x2F; ...\n&#125;\n\n3.4. this 的行为在严格模式下，this 的值为 undefined，而不是全局对象（如 window）。\n&quot;use strict&quot;;\nfunction myFunction() &#123;\n  console.log(this); &#x2F;&#x2F; undefined\n&#125;\nmyFunction();\n\n3.5. 其他限制\n禁止使用 with 语句。\n禁止使用 eval 影响外部作用域。\n不能使用 octal 字面量（如 012）。\n不能使用 arguments.callee。\n\n4. 使用严格模式的好处\n提高代码安全性：通过限制某些不安全的行为，减少潜在的错误。\n提高性能：某些 JavaScript 引擎在严格模式下可以进行更好的优化。\n更清晰的错误信息：在严格模式下，许多常见的错误会抛出更明确的错误信息，帮助开发者更快地定位问题。\n\n5. 总结&quot;use strict&quot; 是一种指令，用于启用 JavaScript 的严格模式。严格模式通过引入一些限制和不同的行为，帮助开发者编写更安全和更高效的代码。使用严格模式可以提高代码的可维护性，减少潜在的错误，并提供更清晰的错误信息。理解严格模式的特性和使用场景是编写高质量 JavaScript 代码的重要组成部分。\n如何判断一个对象是否属于某个类？在 JavaScript 中，判断一个对象是否属于某个类（或构造函数）可以通过多种方法实现。以下是几种常用的方法：\n1. 使用 instanceof 操作符instanceof 操作符用于测试一个对象在其原型链中是否存在构造函数的 prototype 属性。它是判断对象类型的最常用方法。\n示例class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\n\nconsole.log(alice instanceof Person); &#x2F;&#x2F; true\nconsole.log(alice instanceof Object); &#x2F;&#x2F; true\n\n2. 使用 isPrototypeOf 方法isPrototypeOf 方法可以用来检查一个对象是否存在于另一个对象的原型链中。\n示例class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\n\nconsole.log(Person.prototype.isPrototypeOf(alice)); &#x2F;&#x2F; true\n\n3. 使用 Object.getPrototypeOf()Object.getPrototypeOf() 方法返回指定对象的原型（即内部 [[Prototype]] 属性的值）。可以通过比较原型来判断对象是否属于某个类。\n示例class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\n\nconsole.log(Object.getPrototypeOf(alice) &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true\n\n4. 使用 constructor 属性每个对象都有一个 constructor 属性，指向创建该对象的构造函数。可以通过检查 constructor 属性来判断对象的类型。\n示例class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\n\nconsole.log(alice.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true\n\n5. 注意事项\n原型链：使用 instanceof 和 isPrototypeOf 时，注意它们会检查原型链，因此可以判断子类的实例。\n构造函数：如果对象的构造函数被修改，使用 constructor 属性可能会导致误判。\n性能：在性能敏感的场景中，instanceof 是最常用且高效的方法。\n\n6. 总结判断一个对象是否属于某个类可以通过多种方法实现，包括使用 instanceof 操作符、isPrototypeOf 方法、Object.getPrototypeOf() 和 constructor 属性。选择合适的方法可以帮助开发者更准确地判断对象的类型，确保代码的正确性和可维护性。\n强类型语言和弱类型语言的区别强类型语言和弱类型语言是编程语言分类的一种方式，主要根据语言对数据类型的处理方式进行区分。以下是对这两种类型语言的详细比较：\n1. 强类型语言（Strongly Typed Language）定义强类型语言是指在编程过程中，变量的类型是严格定义的，类型检查在编译时或运行时都会进行。强类型语言不允许隐式类型转换，类型不匹配会导致错误。\n特点\n严格的类型检查：在强类型语言中，变量的类型在编译时或运行时必须明确，类型不匹配会导致错误。\n不允许隐式转换：强类型语言通常不允许自动将一种类型转换为另一种类型，必须显式进行转换。\n类型安全：强类型语言提供更高的类型安全性，减少了类型相关的错误。\n\n示例语言\nJava\nC#\nPython\nHaskell\n\n示例&#x2F;&#x2F; Java 示例\nint number &#x3D; 10;\nString text &#x3D; &quot;Hello&quot;;\n&#x2F;&#x2F; number &#x3D; text; &#x2F;&#x2F; 编译错误：不兼容的类型\n\n2. 弱类型语言（Weakly Typed Language）定义弱类型语言是指在编程过程中，变量的类型不严格，允许隐式类型转换。弱类型语言在运行时会自动进行类型转换，可能导致意想不到的结果。\n特点\n灵活的类型检查：在弱类型语言中，变量的类型可以在运行时改变，类型检查不严格。\n允许隐式转换：弱类型语言允许自动将一种类型转换为另一种类型，可能导致类型相关的错误。\n易于使用：弱类型语言通常更灵活，适合快速开发和原型设计。\n\n示例语言\nJavaScript\nPHP\nRuby\nPerl\n\n示例&#x2F;&#x2F; JavaScript 示例\nlet number &#x3D; 10;\nlet text &#x3D; &quot;5&quot;;\nlet result &#x3D; number + text; &#x2F;&#x2F; 结果是 &quot;105&quot;，隐式转换为字符串\n\n3. 主要区别总结\n\n\n特性\n强类型语言\n弱类型语言\n\n\n\n类型检查\n严格的类型检查\n灵活的类型检查\n\n\n隐式转换\n不允许隐式类型转换\n允许隐式类型转换\n\n\n类型安全\n提供更高的类型安全性\n类型安全性较低\n\n\n开发灵活性\n可能需要更多的类型声明和转换\n更加灵活，适合快速开发\n\n\n4. 总结强类型语言和弱类型语言在类型处理上有显著的区别。强类型语言提供更严格的类型检查和更高的类型安全性，而弱类型语言则提供更大的灵活性和便捷性。选择使用哪种类型的语言通常取决于项目的需求、开发团队的经验和开发的复杂性。理解这两种类型语言的特点可以帮助开发者更好地选择合适的编程语言和编写高质量的代码。\n解释性语言和编译型语言的区别解释性语言和编译型语言是两种不同的编程语言执行方式，它们在代码执行、性能、开发流程等方面存在显著差异。以下是对这两种语言的详细比较：\n1. 定义\n解释性语言：解释性语言是指在运行时逐行解释和执行代码的语言。代码在执行时由解释器逐行读取并执行，而不是事先编译成机器代码。\n\n编译型语言：编译型语言是指在执行之前，先将源代码编译成机器代码或中间代码，然后再执行。编译过程通常会生成一个可执行文件。\n\n\n2. 执行方式\n解释性语言：\n\n代码在运行时由解释器逐行解释执行。\n不需要事先编译，适合快速开发和调试。\n\n\n编译型语言：\n\n代码在执行之前由编译器编译成机器代码。\n编译后生成可执行文件，执行时不需要再次编译。\n\n\n\n3. 性能\n解释性语言：\n\n由于逐行解释执行，通常性能较低，执行速度较慢。\n适合开发和测试阶段，便于快速迭代。\n\n\n编译型语言：\n\n编译后生成的机器代码执行速度较快，性能通常较高。\n适合对性能要求较高的应用程序。\n\n\n\n4. 开发流程\n解释性语言：\n\n开发流程简单，修改代码后可以立即运行，无需重新编译。\n适合动态开发和快速原型设计。\n\n\n编译型语言：\n\n开发流程相对复杂，修改代码后需要重新编译才能运行。\n适合大型项目和需要优化的应用程序。\n\n\n\n5. 错误处理\n解释性语言：\n\n错误通常在运行时被捕获，可能导致程序在运行时崩溃。\n便于调试，因为可以逐行执行代码。\n\n\n编译型语言：\n\n编译时会检查语法错误，编译失败时不会生成可执行文件。\n需要在编译阶段解决所有错误，通常提供更严格的类型检查。\n\n\n\n6. 示例语言\n解释性语言：\n\nJavaScript\nPython\nRuby\nPHP\n\n\n编译型语言：\n\nC\nC++\nJava（编译成字节码后由 JVM 解释执行）\nGo\n\n\n\n7. 混合型语言一些语言结合了编译和解释的特性，例如 Java。Java 代码首先被编译成字节码，然后由 Java 虚拟机（JVM）解释执行。这种方式结合了编译型语言的性能和解释型语言的灵活性。\n8. 总结解释性语言和编译型语言在执行方式、性能、开发流程和错误处理等方面存在显著差异。解释性语言适合快速开发和动态应用，而编译型语言则适合对性能要求较高的应用程序。理解这两种语言的特点可以帮助开发者选择合适的编程语言和开发策略。\nfor…in 和 for…of 的区别在 JavaScript 中，for...in 和 for...of 是两种用于遍历集合的循环结构，但它们的用途和行为有显著的区别。以下是对这两种循环的详细比较：\n1. for...in 循环定义for...in 循环用于遍历对象的可枚举属性（包括继承的属性）。它主要用于对象和数组，但通常不推荐用于数组，因为它会遍历所有可枚举的属性，包括原型链上的属性。\n语法for (const key in object) &#123;\n  &#x2F;&#x2F; 处理每个属性\n&#125;\n\n示例const obj &#x3D; &#123; a: 1, b: 2, c: 3 &#125;;\n\nfor (const key in obj) &#123;\n  console.log(key, obj[key]); &#x2F;&#x2F; 输出属性名和对应的值\n&#125;\n\n&#x2F;&#x2F; 输出:\n&#x2F;&#x2F; a 1\n&#x2F;&#x2F; b 2\n&#x2F;&#x2F; c 3\n\n2. for...of 循环定义for...of 循环用于遍历可迭代对象（如数组、字符串、Map、Set 等）。它直接遍历对象的值，而不是属性名。\n语法for (const value of iterable) &#123;\n  &#x2F;&#x2F; 处理每个值\n&#125;\n\n示例const arr &#x3D; [1, 2, 3];\n\nfor (const value of arr) &#123;\n  console.log(value); &#x2F;&#x2F; 输出数组的每个值\n&#125;\n\n&#x2F;&#x2F; 输出:\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n\n3. 主要区别\n\n\n特性\nfor...in\nfor...of\n\n\n\n遍历对象\n遍历对象的可枚举属性（包括原型链）\n遍历可迭代对象的值\n\n\n适用对象\n适用于对象（不推荐用于数组）\n适用于数组、字符串、Map、Set 等\n\n\n返回值\n返回属性名（键）\n返回属性值\n\n\n性能\n性能较低，可能遍历原型链上的属性\n性能较高，直接遍历值\n\n\n4. 使用建议\n**使用 for...in**：适合用于遍历对象的属性，但要注意可能会遍历到原型链上的属性。可以使用 hasOwnProperty 方法来过滤掉继承的属性。\n\nconst obj &#x3D; &#123; a: 1, b: 2 &#125;;\nfor (const key in obj) &#123;\n  if (obj.hasOwnProperty(key)) &#123;\n    console.log(key, obj[key]);\n  &#125;\n&#125;\n\n\n**使用 for...of**：适合用于遍历数组和其他可迭代对象，推荐用于处理数组，因为它更简洁且性能更好。\n\n5. 总结for...in 和 for...of 是 JavaScript 中用于遍历集合的两种循环结构。for...in 用于遍历对象的可枚举属性，而 for...of 用于遍历可迭代对象的值。理解这两者的区别可以帮助开发者选择合适的循环结构，以提高代码的可读性和性能。\najax、axios、fetch 的区别在 JavaScript 中，AJAX、Axios 和 Fetch 是用于进行网络请求的三种不同方式。它们各自有不同的特性、用法和适用场景。以下是对这三者的详细比较：\n1. AJAX定义AJAX（Asynchronous JavaScript and XML）是一种用于在不重新加载整个网页的情况下与服务器交换数据的技术。它通常使用 XMLHttpRequest 对象来发送和接收数据。\n特点\n**使用 XMLHttpRequest**：AJAX 主要依赖于 XMLHttpRequest 对象进行网络请求。\n支持异步请求：可以在后台与服务器进行异步通信。\n兼容性：广泛支持于所有现代浏览器。\n\n示例const xhr &#x3D; new XMLHttpRequest();\nxhr.open(&quot;GET&quot;, &quot;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&quot;, true);\nxhr.onload &#x3D; function () &#123;\n  if (xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) &#123;\n    console.log(JSON.parse(xhr.responseText));\n  &#125; else &#123;\n    console.error(&quot;Request failed with status:&quot;, xhr.status);\n  &#125;\n&#125;;\nxhr.send();\n\n2. Axios定义Axios 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js。它封装了 XMLHttpRequest，提供了更简洁的 API 和更强大的功能。\n特点\n基于 Promise：Axios 使用 Promise 处理异步请求，支持 async/await 语法。\n自动转换 JSON：Axios 会自动将响应数据转换为 JSON 格式。\n请求和响应拦截器：支持请求和响应的拦截器，可以在请求发送前或响应到达后进行处理。\n支持取消请求：可以通过 CancelToken 取消请求。\n\n示例axios\n  .get(&quot;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&quot;)\n  .then((response) &#x3D;&gt; &#123;\n    console.log(response.data);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;Request failed:&quot;, error);\n  &#125;);\n\n3. Fetch定义Fetch 是一个现代的 API，用于进行网络请求，基于 Promise，提供了更强大的功能和更简洁的语法。Fetch API 是 ES6 引入的，旨在替代 XMLHttpRequest。\n特点\n基于 Promise：Fetch 使用 Promise 处理异步请求，支持 async/await 语法。\n更简洁的语法：Fetch API 提供了更简洁的语法，易于使用。\n不自动转换 JSON：Fetch 不会自动将响应数据转换为 JSON，需要手动调用 response.json()。\n不支持 IE：Fetch API 在 Internet Explorer 中不被支持。\n\n示例fetch(&quot;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&quot;)\n  .then((response) &#x3D;&gt; &#123;\n    if (!response.ok) &#123;\n      throw new Error(&quot;Network response was not ok&quot;);\n    &#125;\n    return response.json(); &#x2F;&#x2F; 手动转换为 JSON\n  &#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(data);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;Request failed:&quot;, error);\n  &#125;);\n\n4. 主要区别总结\n\n\n特性\nAJAX\nAxios\nFetch\n\n\n\n基础\nXMLHttpRequest\n基于 XMLHttpRequest\n基于 Promise\n\n\n语法\n较为复杂\n简洁，支持 Promise\n简洁，支持 Promise\n\n\n自动转换 JSON\n不支持\n支持\n不支持，需要手动转换\n\n\n请求拦截器\n不支持\n支持\n不支持\n\n\n取消请求\n不支持\n支持\n不支持\n\n\n兼容性\n广泛支持\n广泛支持\n不支持 IE\n\n\n5. 总结AJAX、Axios 和 Fetch 是用于进行网络请求的三种不同方式。AJAX 是传统的方式，使用 XMLHttpRequest；Axios 是一个基于 Promise 的 HTTP 客户端，提供了更强大的功能；Fetch 是现代的 API，提供了更简洁的语法和 Promise 支持。选择使用哪种方式通常取决于项目的需求、浏览器兼容性和开发者的偏好。\n数组的遍历方法有哪些在 JavaScript 中，数组提供了多种遍历方法，允许开发者以不同的方式访问和操作数组中的元素。以下是一些常见的数组遍历方法：\n1. for 循环最基本的遍历方法，使用传统的 for 循环可以访问数组的每个元素。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nfor (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n  console.log(arr[i]); &#x2F;&#x2F; 输出每个元素\n&#125;\n\n2. for...of 循环for...of 循环用于遍历可迭代对象（如数组），直接访问数组的值。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nfor (const value of arr) &#123;\n  console.log(value); &#x2F;&#x2F; 输出每个元素\n&#125;\n\n3. forEach() 方法forEach() 方法对数组的每个元素执行一次提供的函数，适合执行副作用操作。\nconst arr &#x3D; [1, 2, 3, 4, 5];\narr.forEach((value) &#x3D;&gt; &#123;\n  console.log(value); &#x2F;&#x2F; 输出每个元素\n&#125;);\n\n4. map() 方法map() 方法创建一个新数组，包含调用函数处理每个元素后的结果。适合用于转换数组。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nconst doubled &#x3D; arr.map((value) &#x3D;&gt; value * 2);\nconsole.log(doubled); &#x2F;&#x2F; 输出: [2, 4, 6, 8, 10]\n\n5. filter() 方法filter() 方法创建一个新数组，包含所有通过测试的元素。适合用于筛选数组。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nconst evens &#x3D; arr.filter((value) &#x3D;&gt; value % 2 &#x3D;&#x3D;&#x3D; 0);\nconsole.log(evens); &#x2F;&#x2F; 输出: [2, 4]\n\n6. reduce() 方法reduce() 方法对数组中的每个元素执行一个 reducer 函数，最终计算出一个值。适合用于累加或合并数组。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nconst sum &#x3D; arr.reduce((accumulator, value) &#x3D;&gt; accumulator + value, 0);\nconsole.log(sum); &#x2F;&#x2F; 输出: 15\n\n7. some() 方法some() 方法测试数组中是否至少有一个元素通过了提供的函数测试，返回布尔值。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nconst hasEven &#x3D; arr.some((value) &#x3D;&gt; value % 2 &#x3D;&#x3D;&#x3D; 0);\nconsole.log(hasEven); &#x2F;&#x2F; 输出: true\n\n8. every() 方法every() 方法测试数组中的所有元素是否都通过了提供的函数测试，返回布尔值。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nconst allPositive &#x3D; arr.every((value) &#x3D;&gt; value &gt; 0);\nconsole.log(allPositive); &#x2F;&#x2F; 输出: true\n\n9. find() 方法find() 方法返回数组中满足提供的测试函数的第一个元素的值。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nconst found &#x3D; arr.find((value) &#x3D;&gt; value &gt; 3);\nconsole.log(found); &#x2F;&#x2F; 输出: 4\n\n10. findIndex() 方法findIndex() 方法返回满足提供的测试函数的第一个元素的索引。\nconst arr &#x3D; [1, 2, 3, 4, 5];\nconst index &#x3D; arr.findIndex((value) &#x3D;&gt; value &gt; 3);\nconsole.log(index); &#x2F;&#x2F; 输出: 3\n\n11. keys()、values() 和 entries() 方法\n**keys()**：返回一个包含数组索引的迭代器。\n**values()**：返回一个包含数组值的迭代器。\n**entries()**：返回一个包含数组索引和对应值的迭代器。\n\nconst arr &#x3D; [1, 2, 3, 4, 5];\n\nfor (const index of arr.keys()) &#123;\n  console.log(index); &#x2F;&#x2F; 输出索引\n&#125;\n\nfor (const value of arr.values()) &#123;\n  console.log(value); &#x2F;&#x2F; 输出值\n&#125;\n\nfor (const [index, value] of arr.entries()) &#123;\n  console.log(index, value); &#x2F;&#x2F; 输出索引和值\n&#125;\n\n12. 总结JavaScript 提供了多种数组遍历方法，包括传统的 for 循环、for...of 循环、forEach()、map()、filter()、reduce() 等。每种方法都有其特定的用途和适用场景，开发者可以根据需求选择合适的遍历方式。理解这些方法可以帮助开发者更高效地处理数组数据。\nforEach 和 map 方法有什么区别forEach 和 map 是 JavaScript 中数组的两个常用方法，它们都用于遍历数组，但在功能和返回值上有显著的区别。以下是对这两者的详细比较：\n1. 定义\n**forEach**：用于对数组的每个元素执行一次提供的函数。它主要用于执行副作用操作（如打印、修改外部变量等），不返回任何值。\n\n**map**：用于创建一个新数组，包含调用提供的函数处理每个元素后的结果。它主要用于转换数组中的元素。\n\n\n2. 返回值\n**forEach**：\n\n返回 undefined。\n适合用于需要对每个元素执行操作但不需要返回新数组的场景。\n\n\n**map**：\n\n返回一个新数组，包含处理后的结果。\n适合用于需要对数组进行转换并返回新数组的场景。\n\n\n\n3. 用法示例forEach 示例const arr &#x3D; [1, 2, 3, 4, 5];\narr.forEach((value) &#x3D;&gt; &#123;\n  console.log(value * 2); &#x2F;&#x2F; 输出每个元素的两倍\n&#125;);\n&#x2F;&#x2F; 返回值是 undefined\n\nmap 示例const arr &#x3D; [1, 2, 3, 4, 5];\nconst doubled &#x3D; arr.map((value) &#x3D;&gt; value * 2); &#x2F;&#x2F; 返回一个新数组\nconsole.log(doubled); &#x2F;&#x2F; 输出: [2, 4, 6, 8, 10]\n\n4. 适用场景\n**使用 forEach**：\n\n当你只需要对数组的每个元素执行某个操作，而不需要返回新数组时，使用 forEach。\n例如，打印数组元素、更新外部变量等。\n\n\n**使用 map**：\n\n当你需要对数组的每个元素进行转换，并返回一个新数组时，使用 map。\n例如，将数组中的数字转换为字符串、将对象数组中的某个属性提取出来等。\n\n\n\n5. 性能\nforEach 和 map 的性能差异通常不大，但由于 map 会创建一个新数组，因此在处理大型数组时，map 可能会消耗更多的内存。\n\n6. 总结\n\n\n特性\nforEach\nmap\n\n\n\n返回值\nundefined\n新数组\n\n\n用途\n执行副作用操作\n转换数组元素\n\n\n适用场景\n不需要返回新数组的操作\n需要返回新数组的转换操作\n\n\n理解 forEach 和 map 的区别可以帮助开发者选择合适的方法来处理数组，确保代码的可读性和效率。\n原型与原型链对原型、原型链的理解在 JavaScript 中，原型（Prototype）和原型链（Prototype Chain）是实现对象继承和共享属性的重要机制。以下是对这两个概念的详细解释：\n1. 原型（Prototype）定义原型是 JavaScript 中对象的一个重要特性。每个 JavaScript 对象都有一个内部属性 [[Prototype]]，指向另一个对象，这个对象被称为原型。原型可以用来共享属性和方法。\n特点\n共享属性和方法：通过原型，多个对象可以共享同一个属性和方法，节省内存。\n构造函数的原型：当使用构造函数创建对象时，构造函数的 prototype 属性会被赋值给新创建对象的 [[Prototype]]。\n\n示例function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\n&#x2F;&#x2F; 在构造函数的原型上添加方法\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\nalice.sayHello(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n在这个例子中，sayHello 方法被添加到 Person 的原型上，因此所有通过 Person 构造函数创建的实例（如 alice）都可以访问这个方法。\n2. 原型链（Prototype Chain）定义原型链是 JavaScript 中实现对象继承的机制。当访问对象的属性或方法时，JavaScript 首先会查找对象自身的属性，如果没有找到，则会查找其原型对象的属性，依此类推，直到找到该属性或到达原型链的顶端（通常是 Object.prototype）。\n特点\n查找顺序：当访问一个对象的属性时，JavaScript 会按照以下顺序查找：\n\n对象自身的属性\n对象的原型（[[Prototype]]）\n原型的原型（即原型链上的下一个对象）\n直到 null（原型链的顶端）\n\n\n动态性：原型链是动态的，如果在原型上添加或修改属性，所有实例都可以立即访问这些更改。\n\n\n示例function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nfunction Student(name, grade) &#123;\n  Person.call(this, name); &#x2F;&#x2F; 继承 Person 的属性\n  this.grade &#x3D; grade;\n&#125;\n\n&#x2F;&#x2F; 设置 Student 的原型为 Person 的实例\nStudent.prototype &#x3D; Object.create(Person.prototype);\nStudent.prototype.constructor &#x3D; Student;\n\n&#x2F;&#x2F; 在 Student 的原型上添加方法\nStudent.prototype.study &#x3D; function () &#123;\n  console.log(&#96;$&#123;this.name&#125; is studying.&#96;);\n&#125;;\n\nconst bob &#x3D; new Student(&quot;Bob&quot;, &quot;A&quot;);\nbob.sayHello(); &#x2F;&#x2F; 输出: Hello, my name is Bob\nbob.study(); &#x2F;&#x2F; 输出: Bob is studying.\n\n在这个例子中，Student 通过 Object.create(Person.prototype) 继承了 Person 的原型，因此 bob 实例可以访问 sayHello 方法。\n3. 总结\n原型：是对象的一个重要特性，用于共享属性和方法。每个对象都有一个原型，可以通过构造函数的 prototype 属性进行设置。\n原型链：是实现对象继承的机制，通过查找对象自身及其原型的属性，形成一个链式结构。原型链允许对象共享属性和方法，并实现继承。\n\n理解原型和原型链是掌握 JavaScript 对象继承和共享机制的关键，有助于编写更高效和可维护的代码。\n原型修改、重写在 JavaScript 中，原型（Prototype）是实现对象继承和共享属性的重要机制。原型的修改和重写可以影响对象的行为和属性访问。以下是对原型修改和重写的详细解释。\n1. 原型修改原型修改是指对对象的原型进行更改，以添加、删除或修改属性和方法。这种修改会影响所有通过该原型创建的实例。\n示例：修改原型function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\n&#x2F;&#x2F; 在原型上添加方法\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\nalice.sayHello(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n&#x2F;&#x2F; 修改原型，添加新方法\nPerson.prototype.sayGoodbye &#x3D; function () &#123;\n  console.log(&#96;Goodbye, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nalice.sayGoodbye(); &#x2F;&#x2F; 输出: Goodbye, my name is Alice\n\n在这个例子中，sayGoodbye 方法被添加到 Person 的原型上，因此所有实例（如 alice）都可以访问这个新方法。\n2. 原型重写原型重写是指完全替换对象的原型。这通常通过将一个新的对象赋值给构造函数的 prototype 属性来实现。重写原型会影响所有通过该构造函数创建的实例。\n示例：重写原型function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\n&#x2F;&#x2F; 原型上添加方法\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\nalice.sayHello(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n&#x2F;&#x2F; 重写原型\nPerson.prototype &#x3D; &#123;\n  sayGoodbye: function () &#123;\n    console.log(&#96;Goodbye, my name is $&#123;this.name&#125;&#96;);\n  &#125;,\n&#125;;\n\nconst bob &#x3D; new Person(&quot;Bob&quot;);\nbob.sayHello(); &#x2F;&#x2F; TypeError: bob.sayHello is not a function\nbob.sayGoodbye(); &#x2F;&#x2F; 输出: Goodbye, my name is undefined\n\n在这个例子中，Person.prototype 被重写为一个新的对象。由于 sayHello 方法不再存在于新的原型中，bob 实例无法访问它。此外，name 属性在 sayGoodbye 方法中未定义，因为 bob 实例没有 name 属性。\n3. 注意事项\n影响实例：修改原型会影响所有通过该原型创建的实例，而重写原型会影响新创建的实例，但不会影响已经存在的实例。\n保留原型链：在重写原型时，如果希望保留原有的原型链，可以使用 Object.create() 方法。\n\n示例：保留原型链function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\n&#x2F;&#x2F; 重写原型，保留原有原型链\nPerson.prototype &#x3D; Object.create(Person.prototype);\nPerson.prototype.sayGoodbye &#x3D; function () &#123;\n  console.log(&#96;Goodbye, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\nalice.sayHello(); &#x2F;&#x2F; 输出: Hello, my name is Alice\nalice.sayGoodbye(); &#x2F;&#x2F; 输出: Goodbye, my name is Alice\n\n4. 总结\n原型修改：是对现有原型的添加、删除或修改操作，影响所有实例。\n原型重写：是完全替换原型，影响新创建的实例，但不会影响已经存在的实例。重写原型时要小心，以免丢失原有的方法和属性。\n\n理解原型的修改和重写是掌握 JavaScript 对象继承和共享机制的关键，有助于编写更高效和可维护的代码。\n原型链指向在 JavaScript 中，原型链（Prototype Chain）是实现对象继承和属性共享的机制。每个对象都有一个内部属性 [[Prototype]]，指向其原型对象。原型链的结构决定了对象属性和方法的查找顺序。以下是对原型链指向的详细解释。\n1. 原型链的基本概念\n原型：每个 JavaScript 对象都有一个原型，原型是另一个对象，包含可以被该对象共享的属性和方法。\n**[[Prototype]]**：每个对象都有一个内部属性 [[Prototype]]，指向其原型对象。可以通过 Object.getPrototypeOf(obj) 或 __proto__ 属性访问。\n\n2. 原型链的构建当一个对象访问某个属性或方法时，JavaScript 引擎会按照以下顺序查找：\n\n对象自身：首先检查对象自身是否有该属性或方法。\n原型：如果对象自身没有，查找其原型对象（[[Prototype]]）。\n原型的原型：继续查找原型的原型，直到找到该属性或方法或到达原型链的顶端（通常是 Object.prototype）。\n**null**：如果到达 null，表示原型链的末尾，属性或方法不存在。\n\n3. 示例创建一个对象和原型链function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\n\nconsole.log(alice.name); &#x2F;&#x2F; 输出: Alice\nalice.sayHello(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n&#x2F;&#x2F; 查看原型链\nconsole.log(Object.getPrototypeOf(alice) &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; 输出: true\nconsole.log(Object.getPrototypeOf(Person.prototype) &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; 输出: true\nconsole.log(Object.getPrototypeOf(Object.prototype)); &#x2F;&#x2F; 输出: null\n\n在这个例子中：\n\nalice 是 Person 的实例，具有 name 属性。\nsayHello 方法定义在 Person.prototype 上，alice 可以通过原型链访问它。\nObject.getPrototypeOf(alice) 返回 Person.prototype，而 Object.getPrototypeOf(Person.prototype) 返回 Object.prototype，最终到达 null。\n\n4. 原型链的作用\n属性共享：通过原型链，多个对象可以共享同一个方法，节省内存。\n继承：原型链是实现对象继承的基础，子类可以通过原型链访问父类的方法和属性。\n\n5. 注意事项\n性能：频繁访问原型链上的属性可能会影响性能，尤其是在深层嵌套的情况下。\n属性覆盖：如果对象自身定义了与原型链上同名的属性，访问时会优先使用对象自身的属性，原型链上的属性将被覆盖。\n\n6. 总结原型链是 JavaScript 中实现对象继承和属性共享的机制。每个对象都有一个原型，通过 [[Prototype]] 属性连接，形成一个链式结构。当访问对象的属性或方法时，JavaScript 引擎会沿着原型链查找，直到找到该属性或方法或到达原型链的顶端。理解原型链的指向和工作原理是掌握 JavaScript 对象继承和共享机制的关键。\n原型链的终点是什么？如何打印出原型链的终点？在 JavaScript 中，原型链的终点是 null。当访问一个对象的属性或方法时，如果在该对象及其原型链上都找不到该属性或方法，最终会到达 null，这表示原型链的末尾。\n1. 原型链的终点\n**Object.prototype**：所有对象的原型链最终都会指向 Object.prototype，这是 JavaScript 中所有对象的基类。\n**null**：Object.prototype 的 [[Prototype]] 是 null，这标志着原型链的终点。\n\n2. 打印原型链的终点可以通过 Object.getPrototypeOf() 方法逐步向上遍历原型链，直到到达 null。以下是一个示例，展示如何打印出一个对象的原型链及其终点。\n示例代码function Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nPerson.prototype.sayHello &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\n\n&#x2F;&#x2F; 打印原型链\nlet currentObject &#x3D; alice;\n\nwhile (currentObject !&#x3D;&#x3D; null) &#123;\n  console.log(currentObject);\n  currentObject &#x3D; Object.getPrototypeOf(currentObject);\n&#125;\n\n&#x2F;&#x2F; 最后会打印出 null\nconsole.log(currentObject); &#x2F;&#x2F; 输出: null\n\n3. 输出结果在这个示例中，代码会逐步打印出 alice 对象及其原型链上的每个对象，直到到达 null。输出结果可能类似于：\nPerson &#123; name: &#39;Alice&#39; &#125;\nPerson.prototype &#123; sayHello: [Function (anonymous)] &#125;\nObject.prototype &#123;&#125;\nnull\n\n4. 总结原型链的终点是 null，表示没有更多的原型可供查找。通过 Object.getPrototypeOf() 方法，可以逐步遍历原型链并打印出每个对象，直到到达终点 null。理解原型链的结构和终点是掌握 JavaScript 对象继承和属性访问的重要部分。\n执行上下文&#x2F;作用域链&#x2F;闭包对闭包的理解在 JavaScript 中，闭包（Closure）是一个重要的概念，它是指一个函数可以“记住”并访问其外部作用域的变量，即使在外部函数已经返回之后。闭包使得函数能够访问其外部作用域的变量，从而实现数据的封装和私有化。\n1. 闭包的基本概念\n函数与作用域：每当一个函数被创建时，都会创建一个新的作用域。函数可以访问其外部作用域中的变量。\n闭包的形成：当一个函数在其外部作用域中被定义并返回时，形成了闭包。这个返回的函数可以继续访问其外部作用域中的变量。\n\n2. 闭包的特点\n持久化的作用域：闭包可以让函数保持对其外部作用域的引用，即使外部函数已经执行完毕。\n数据封装：闭包可以用于创建私有变量，外部无法直接访问这些变量，只能通过闭包提供的函数进行访问和修改。\n\n3. 闭包的示例示例 1：基本闭包function outerFunction() &#123;\n  let outerVariable &#x3D; &quot;I am from outer scope&quot;;\n\n  function innerFunction() &#123;\n    console.log(outerVariable); &#x2F;&#x2F; 访问外部变量\n  &#125;\n\n  return innerFunction; &#x2F;&#x2F; 返回内部函数\n&#125;\n\nconst closureFunction &#x3D; outerFunction(); &#x2F;&#x2F; 执行外部函数，返回内部函数\nclosureFunction(); &#x2F;&#x2F; 输出: I am from outer scope\n\n在这个例子中，innerFunction 是一个闭包，它可以访问 outerFunction 的 outerVariable 变量，即使 outerFunction 已经执行完毕。\n示例 2：数据封装function createCounter() &#123;\n  let count &#x3D; 0; &#x2F;&#x2F; 私有变量\n\n  return &#123;\n    increment: function () &#123;\n      count++;\n      console.log(count);\n    &#125;,\n    decrement: function () &#123;\n      count--;\n      console.log(count);\n    &#125;,\n    getCount: function () &#123;\n      return count;\n    &#125;,\n  &#125;;\n&#125;\n\nconst counter &#x3D; createCounter();\ncounter.increment(); &#x2F;&#x2F; 输出: 1\ncounter.increment(); &#x2F;&#x2F; 输出: 2\ncounter.decrement(); &#x2F;&#x2F; 输出: 1\nconsole.log(counter.getCount()); &#x2F;&#x2F; 输出: 1\n\n在这个例子中，count 是一个私有变量，外部无法直接访问。通过返回的对象中的方法，外部可以对 count 进行操作，从而实现数据的封装。\n4. 闭包的应用场景\n数据私有化：使用闭包可以创建私有变量，防止外部直接访问。\n函数工厂：可以创建具有特定状态的函数，例如计数器、事件处理器等。\n延迟执行：闭包可以用于实现延迟执行的功能，保存状态。\n\n5. 注意事项\n内存消耗：闭包会保持对外部作用域的引用，可能导致内存泄漏，特别是在不再需要闭包时。\n调试困难：由于闭包的作用域链，调试时可能会增加复杂性。\n\n6. 总结闭包是 JavaScript 中一个强大而灵活的特性，它允许函数访问其外部作用域的变量，即使外部函数已经返回。通过闭包，可以实现数据的封装、私有变量和函数工厂等功能。理解闭包的概念和应用场景是掌握 JavaScript 编程的重要部分。\n对作用域、作用域链的理解在 JavaScript 中，作用域（Scope）和作用域链（Scope Chain）是理解变量访问和函数执行的重要概念。以下是对这两个概念的详细解释。\n1. 作用域（Scope）定义作用域是指在程序中定义变量的可访问范围。它决定了变量的生命周期和可见性。JavaScript 中的作用域主要分为以下几种类型：\n\n全局作用域：在代码的最外层定义的变量，任何地方都可以访问。\n函数作用域：在函数内部定义的变量，只能在该函数内部访问。\n块级作用域：在 &#123;&#125; 块内定义的变量（如 if、for 等语句中的变量），使用 let 和 const 声明的变量具有块级作用域。\n\n示例&#x2F;&#x2F; 全局作用域\nlet globalVar &#x3D; &quot;I am global&quot;;\n\nfunction myFunction() &#123;\n  &#x2F;&#x2F; 函数作用域\n  let functionVar &#x3D; &quot;I am local to the function&quot;;\n  console.log(globalVar); &#x2F;&#x2F; 可以访问全局变量\n  console.log(functionVar); &#x2F;&#x2F; 可以访问函数变量\n&#125;\n\nmyFunction();\nconsole.log(globalVar); &#x2F;&#x2F; 输出: I am global\n&#x2F;&#x2F; console.log(functionVar); &#x2F;&#x2F; ReferenceError: functionVar is not defined\n\n在这个例子中，globalVar 是全局变量，functionVar 是函数作用域内的变量，外部无法访问 functionVar。\n2. 作用域链（Scope Chain）定义作用域链是指在查找变量时，JavaScript 引擎会按照一定的顺序查找变量的过程。每当一个函数被创建时，都会形成一个作用域链。作用域链的顺序是从当前作用域到外部作用域，直到全局作用域。\n特点\n查找顺序：当访问一个变量时，JavaScript 首先会在当前作用域查找，如果没有找到，则会查找其外部作用域，依此类推，直到找到该变量或到达全局作用域。\n嵌套作用域：函数内部可以访问外部函数的变量，这种嵌套关系形成了作用域链。\n\n示例let globalVar &#x3D; &quot;I am global&quot;;\n\nfunction outerFunction() &#123;\n  let outerVar &#x3D; &quot;I am from outer function&quot;;\n\n  function innerFunction() &#123;\n    let innerVar &#x3D; &quot;I am from inner function&quot;;\n    console.log(globalVar); &#x2F;&#x2F; 访问全局变量\n    console.log(outerVar); &#x2F;&#x2F; 访问外部函数的变量\n    console.log(innerVar); &#x2F;&#x2F; 访问内部函数的变量\n  &#125;\n\n  innerFunction();\n&#125;\n\nouterFunction();\n\n在这个例子中，innerFunction 可以访问 outerFunction 的变量 outerVar 和全局变量 globalVar，形成了一个作用域链。\n3. 总结\n作用域：是变量的可访问范围，决定了变量的生命周期和可见性。JavaScript 中的作用域主要包括全局作用域、函数作用域和块级作用域。\n作用域链：是查找变量的过程，JavaScript 引擎会按照从当前作用域到外部作用域的顺序查找变量，直到找到该变量或到达全局作用域。\n\n理解作用域和作用域链是掌握 JavaScript 变量访问、函数执行和闭包等概念的基础，有助于编写更清晰和可维护的代码。\n对执行上下文的理解在 JavaScript 中，执行上下文（Execution Context）是一个非常重要的概念，它是代码执行时的环境。执行上下文包含了代码执行所需的所有信息，包括变量、函数、对象等。理解执行上下文有助于更好地掌握 JavaScript 的执行机制、作用域和闭包等概念。\n1. 执行上下文的类型JavaScript 中有三种主要的执行上下文：\n1.1. 全局执行上下文\n定义：当 JavaScript 代码首次运行时，创建的执行上下文称为全局执行上下文。它是代码的最外层环境。\n特点：\n在全局上下文中，所有的变量和函数都是全局可访问的。\n全局上下文的 this 指向全局对象（在浏览器中是 window 对象）。\n\n\n\n1.2. 函数执行上下文\n定义：每当一个函数被调用时，都会创建一个新的执行上下文，称为函数执行上下文。\n特点：\n每个函数都有自己的作用域，函数内部的变量和参数在该上下文中可用。\n函数执行上下文的 this 指向调用该函数的对象。\n\n\n\n1.3. Eval 执行上下文\n定义：当使用 eval 函数执行字符串代码时，会创建一个 eval 执行上下文。\n特点：通常不推荐使用 eval，因为它会影响性能和安全性。\n\n2. 执行上下文的组成每个执行上下文都有三个主要组成部分：\n2.1. 变量环境（Variable Environment）\n定义：变量环境是执行上下文中存储变量和函数声明的地方。\n特点：在函数执行上下文中，变量环境会包含函数的参数和内部变量。\n\n2.2. 词法环境（Lexical Environment）\n定义：词法环境是一个包含变量和函数的对象，记录了变量的绑定关系。\n特点：每个执行上下文都有一个指向外部词法环境的引用，形成了作用域链。\n\n2.3. this 绑定\n定义：this 是一个特殊的关键字，指向当前执行上下文中的对象。\n特点：this 的值在函数调用时确定，取决于函数的调用方式。\n\n3. 执行上下文的生命周期执行上下文的生命周期通常包括以下几个阶段：\n\n创建阶段：\n\n创建变量环境和词法环境。\n识别并存储函数声明和变量声明（但不赋值）。\n绑定 this。\n\n\n执行阶段：\n\n执行代码，赋值变量，调用函数。\n访问变量和函数，更新变量环境。\n\n\n销毁阶段：\n\n当执行上下文完成执行后，会被销毁，释放内存。\n\n\n\n4. 示例以下是一个简单的示例，展示了执行上下文的创建和使用：\nlet globalVar &#x3D; &quot;I am global&quot;;\n\nfunction outerFunction() &#123;\n  let outerVar &#x3D; &quot;I am from outer function&quot;;\n\n  function innerFunction() &#123;\n    let innerVar &#x3D; &quot;I am from inner function&quot;;\n    console.log(globalVar); &#x2F;&#x2F; 访问全局变量\n    console.log(outerVar); &#x2F;&#x2F; 访问外部函数的变量\n    console.log(innerVar); &#x2F;&#x2F; 访问内部函数的变量\n  &#125;\n\n  innerFunction();\n&#125;\n\nouterFunction();\n\n在这个例子中：\n\n当 outerFunction 被调用时，会创建一个新的函数执行上下文，包含 outerVar 和对全局变量的访问。\n当 innerFunction 被调用时，会创建另一个函数执行上下文，包含 innerVar 和对 outerVar 的访问。\n\n5. 总结执行上下文是 JavaScript 中代码执行的环境，包含了变量、函数、作用域等信息。理解执行上下文的类型、组成和生命周期有助于掌握 JavaScript 的执行机制、作用域、闭包等概念，从而编写更高效和可维护的代码。\nthis&#x2F;call&#x2F;apply&#x2F;bind对 this 对象的理解在 JavaScript 中，this 是一个特殊的关键字，指向当前执行上下文中的对象。this 的值在函数调用时确定，取决于函数的调用方式。理解 this 的行为对于掌握 JavaScript 的对象和函数非常重要。以下是对 this 对象的详细解释。\n1. this 的基本概念\n上下文：this 的值与函数的调用方式密切相关。它可以指向不同的对象，具体取决于函数是如何被调用的。\n动态绑定：this 是动态绑定的，意味着它的值在运行时确定，而不是在函数定义时。\n\n2. this 的不同情况2.1. 全局上下文中的 this在全局上下文中，this 指向全局对象。在浏览器中，全局对象是 window。\nconsole.log(this); &#x2F;&#x2F; 在浏览器中输出: Window &#123; ... &#125;\n\n2.2. 函数调用中的 this在普通函数调用中，this 指向全局对象（在严格模式下为 undefined）。\nfunction showThis() &#123;\n  console.log(this);\n&#125;\n\nshowThis(); &#x2F;&#x2F; 在浏览器中输出: Window &#123; ... &#125;\n\n2.3. 对象方法中的 this当函数作为对象的方法调用时，this 指向调用该方法的对象。\nconst obj &#x3D; &#123;\n  name: &quot;Alice&quot;,\n  greet: function () &#123;\n    console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n  &#125;,\n&#125;;\n\nobj.greet(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n2.4. 构造函数中的 this在构造函数中，this 指向新创建的实例对象。\nfunction Person(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;);\nconsole.log(alice.name); &#x2F;&#x2F; 输出: Alice\n\n2.5. call、apply 和 bind 方法\ncall 和 **apply**：这两个方法可以显式地设置 this 的值。\n\nfunction greet() &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;\n\nconst obj &#x3D; &#123; name: &quot;Alice&quot; &#125;;\ngreet.call(obj); &#x2F;&#x2F; 输出: Hello, my name is Alice\ngreet.apply(obj); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n\n**bind**：bind 方法创建一个新函数，永久绑定 this 的值。\n\nconst obj &#x3D; &#123; name: &quot;Alice&quot; &#125;;\nconst greet &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;.bind(obj);\n\ngreet(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n2.6. 箭头函数中的 this箭头函数不具有自己的 this，它会从外部作用域中继承 this 的值。\nconst obj &#x3D; &#123;\n  name: &quot;Alice&quot;,\n  greet: function () &#123;\n    const inner &#x3D; () &#x3D;&gt; &#123;\n      console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n    &#125;;\n    inner();\n  &#125;,\n&#125;;\n\nobj.greet(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n3. 总结\nthis 是动态的：this 的值在运行时确定，取决于函数的调用方式。\n全局上下文：在全局上下文中，this 指向全局对象。\n对象方法：在对象方法中，this 指向调用该方法的对象。\n构造函数：在构造函数中，this 指向新创建的实例对象。\n显式绑定：可以使用 call、apply 和 bind 方法显式设置 this 的值。\n箭头函数：箭头函数不具有自己的 this，而是从外部作用域中继承。\n\n理解 this 对象的行为对于掌握 JavaScript 的对象、函数和作用域等概念至关重要，有助于编写更高效和可维护的代码。\ncall() 和 apply() 的区别？在 JavaScript 中，call() 和 apply() 是两个用于改变函数执行上下文的函数，它们都可以用来显式地设置 this 的值。尽管它们的功能相似，但在参数传递的方式上有所不同。以下是对这两个方法的详细比较：\n1. call() 方法\n定义：call() 方法调用一个函数，并将 this 关键字设置为指定的值。它接受参数列表。\n\n语法：\nfunctionName.call(thisArg, arg1, arg2, ...);\n\n示例：\nfunction greet(greeting) &#123;\n  console.log(&#96;$&#123;greeting&#125;, my name is $&#123;this.name&#125;&#96;);\n&#125;\n\nconst person &#x3D; &#123; name: &quot;Alice&quot; &#125;;\ngreet.call(person, &quot;Hello&quot;); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n2. apply() 方法\n定义：apply() 方法也调用一个函数，并将 this 关键字设置为指定的值。与 call() 不同的是，apply() 接受一个数组或类数组对象作为参数。\n\n语法：\nfunctionName.apply(thisArg, [argsArray]);\n\n示例：\nfunction greet(greeting, punctuation) &#123;\n  console.log(&#96;$&#123;greeting&#125;, my name is $&#123;this.name&#125;$&#123;punctuation&#125;&#96;);\n&#125;\n\nconst person &#x3D; &#123; name: &quot;Alice&quot; &#125;;\ngreet.apply(person, [&quot;Hello&quot;, &quot;!&quot;]); &#x2F;&#x2F; 输出: Hello, my name is Alice!\n\n3. 主要区别\n\n\n特性\ncall()\napply()\n\n\n\n参数传递方式\n逐个参数传递\n以数组或类数组对象传递参数\n\n\n语法\nfunctionName.call(thisArg, arg1, arg2, ...)\nfunctionName.apply(thisArg, [argsArray])\n\n\n使用场景\n当参数数量已知且不多时使用\n当参数数量不确定或为数组时使用\n\n\n4. 何时使用\n**使用 call()**：当你知道要传递的参数数量，并且希望逐个传递时，使用 call() 方法。\n\n**使用 apply()**：当你有一个数组或类数组对象，并希望将其作为参数传递给函数时，使用 apply() 方法。\n\n\n5. 例子对比function sum(a, b) &#123;\n  return a + b;\n&#125;\n\nconst numbers &#x3D; [5, 10];\n\n&#x2F;&#x2F; 使用 call()\nconsole.log(sum.call(null, 5, 10)); &#x2F;&#x2F; 输出: 15\n\n&#x2F;&#x2F; 使用 apply()\nconsole.log(sum.apply(null, numbers)); &#x2F;&#x2F; 输出: 15\n\n6. 总结call() 和 apply() 都是用于改变函数的 this 上下文的方法。它们的主要区别在于参数的传递方式：call() 逐个传递参数，而 apply() 以数组的形式传递参数。理解这两个方法的区别和使用场景可以帮助开发者更灵活地控制函数的执行上下文。\n实现 call、apply 及 bind 函数在 JavaScript 中，call、apply 和 bind 是用于改变函数执行上下文的常用方法。下面是如何实现这三个方法的示例。\n1. 实现 call 方法call 方法调用一个函数，并将 this 关键字设置为指定的值。它接受参数列表。\nFunction.prototype.myCall &#x3D; function (context, ...args) &#123;\n  &#x2F;&#x2F; 如果 context 为 null 或 undefined，则指向全局对象\n  context &#x3D; context || globalThis; &#x2F;&#x2F; 在浏览器中是 window\n  &#x2F;&#x2F; 将函数绑定到 context 上\n  context.fn &#x3D; this; &#x2F;&#x2F; this 是调用 myCall 的函数\n  &#x2F;&#x2F; 调用函数并返回结果\n  const result &#x3D; context.fn(...args);\n  &#x2F;&#x2F; 删除临时函数\n  delete context.fn;\n  return result;\n&#125;;\n\n&#x2F;&#x2F; 示例\nfunction greet(greeting) &#123;\n  console.log(&#96;$&#123;greeting&#125;, my name is $&#123;this.name&#125;&#96;);\n&#125;\n\nconst person &#x3D; &#123; name: &quot;Alice&quot; &#125;;\ngreet.myCall(person, &quot;Hello&quot;); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n2. 实现 apply 方法apply 方法与 call 类似，但它接受一个数组作为参数。\nFunction.prototype.myApply &#x3D; function (context, args) &#123;\n  context &#x3D; context || globalThis; &#x2F;&#x2F; 如果 context 为 null 或 undefined，则指向全局对象\n  context.fn &#x3D; this; &#x2F;&#x2F; this 是调用 myApply 的函数\n  &#x2F;&#x2F; 调用函数并返回结果\n  const result &#x3D; context.fn(...(args || [])); &#x2F;&#x2F; 如果 args 为 undefined，则传递空数组\n  delete context.fn; &#x2F;&#x2F; 删除临时函数\n  return result;\n&#125;;\n\n&#x2F;&#x2F; 示例\nfunction greet(greeting, punctuation) &#123;\n  console.log(&#96;$&#123;greeting&#125;, my name is $&#123;this.name&#125;$&#123;punctuation&#125;&#96;);\n&#125;\n\nconst person &#x3D; &#123; name: &quot;Alice&quot; &#125;;\ngreet.myApply(person, [&quot;Hello&quot;, &quot;!&quot;]); &#x2F;&#x2F; 输出: Hello, my name is Alice!\n\n3. 实现 bind 方法bind 方法创建一个新函数，永久绑定 this 的值，并可以预设参数。\nFunction.prototype.myBind &#x3D; function (context, ...args) &#123;\n  const fn &#x3D; this; &#x2F;&#x2F; this 是调用 myBind 的函数\n  return function (...newArgs) &#123;\n    return fn.apply(context, [...args, ...newArgs]); &#x2F;&#x2F; 合并参数并调用\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; 示例\nfunction greet(greeting, punctuation) &#123;\n  console.log(&#96;$&#123;greeting&#125;, my name is $&#123;this.name&#125;$&#123;punctuation&#125;&#96;);\n&#125;\n\nconst person &#x3D; &#123; name: &quot;Alice&quot; &#125;;\nconst boundGreet &#x3D; greet.myBind(person, &quot;Hello&quot;);\nboundGreet(&quot;!&quot;); &#x2F;&#x2F; 输出: Hello, my name is Alice!\n\n4. 总结\n**myCall**：实现了 call 方法，允许你指定 this 的值并逐个传递参数。\n**myApply**：实现了 apply 方法，允许你指定 this 的值并以数组的形式传递参数。\n**myBind**：实现了 bind 方法，创建一个新函数，永久绑定 this 的值，并可以预设参数。\n\n通过这些实现，你可以更好地理解 call、apply 和 bind 的工作原理。\n异步编程异步编程的实现方式？在 JavaScript 中，异步编程是处理并发操作的重要方式，尤其是在处理网络请求、文件读取等耗时操作时。以下是几种常见的异步编程实现方式：\n1. 回调函数（Callback）回调函数是最基本的异步编程方式。通过将一个函数作为参数传递给另一个函数，在异步操作完成后调用这个回调函数。\n示例function fetchData(callback) &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    const data &#x3D; &#123; name: &quot;Alice&quot; &#125;;\n    callback(data); &#x2F;&#x2F; 异步操作完成后调用回调\n  &#125;, 1000);\n&#125;\n\nfetchData((data) &#x3D;&gt; &#123;\n  console.log(data); &#x2F;&#x2F; 输出: &#123; name: &#39;Alice&#39; &#125;\n&#125;);\n\n2. PromisePromise 是一种更现代的异步编程方式，表示一个可能在未来某个时间点完成的操作。Promise 有三种状态：pending（进行中）、fulfilled（已完成）和 rejected（已拒绝）。\n示例function fetchData() &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      const data &#x3D; &#123; name: &quot;Alice&quot; &#125;;\n      resolve(data); &#x2F;&#x2F; 操作成功，调用 resolve\n    &#125;, 1000);\n  &#125;);\n&#125;\n\nfetchData()\n  .then((data) &#x3D;&gt; &#123;\n    console.log(data); &#x2F;&#x2F; 输出: &#123; name: &#39;Alice&#39; &#125;\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(error);\n  &#125;);\n\n3. async&#x2F;awaitasync/await 是基于 Promise 的语法糖，使得异步代码看起来更像同步代码。async 函数返回一个 Promise，而 await 用于等待 Promise 的完成。\n示例function fetchData() &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      const data &#x3D; &#123; name: &quot;Alice&quot; &#125;;\n      resolve(data);\n    &#125;, 1000);\n  &#125;);\n&#125;\n\nasync function getData() &#123;\n  try &#123;\n    const data &#x3D; await fetchData(); &#x2F;&#x2F; 等待 Promise 完成\n    console.log(data); &#x2F;&#x2F; 输出: &#123; name: &#39;Alice&#39; &#125;\n  &#125; catch (error) &#123;\n    console.error(error);\n  &#125;\n&#125;\n\ngetData();\n\n4. 事件驱动（Event-driven）事件驱动编程是通过事件和事件处理程序来实现异步操作的方式。JavaScript 的许多 API（如 DOM 事件、网络请求等）都是基于事件驱动的。\n示例document.getElementById(&quot;myButton&quot;).addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;\n  console.log(&quot;Button clicked!&quot;); &#x2F;&#x2F; 处理点击事件\n&#125;);\n\n5. 生成器（Generators）生成器是 ES6 引入的一种异步编程方式，可以通过 yield 关键字暂停和恢复函数的执行。结合 Promise 使用时，可以实现异步控制流。\n示例function* fetchData() &#123;\n  const data &#x3D; yield new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(&#123; name: &quot;Alice&quot; &#125;);\n    &#125;, 1000);\n  &#125;);\n  console.log(data);\n&#125;\n\nconst generator &#x3D; fetchData();\nconst promise &#x3D; generator.next().value; &#x2F;&#x2F; 获取 Promise\npromise.then((data) &#x3D;&gt; generator.next(data)); &#x2F;&#x2F; 继续执行生成器\n\n6. 总结JavaScript 提供了多种异步编程实现方式，包括回调函数、Promise、async&#x2F;await、事件驱动和生成器等。每种方式都有其适用场景和优缺点：\n\n回调函数：简单，但可能导致回调地狱（callback hell）。\nPromise：更清晰的错误处理和链式调用。\nasync&#x2F;await：使异步代码更易读，像同步代码一样。\n事件驱动：适用于处理用户交互和事件。\n生成器：提供了更灵活的异步控制流。\n\n理解这些异步编程方式可以帮助开发者更有效地处理并发操作，提高代码的可读性和可维护性。\nsetTimeout、Promise、Async&#x2F;Await 的区别setTimeout、Promise 和 async/await 是 JavaScript 中处理异步操作的三种不同方式。它们各自有不同的用途和特性。以下是对这三者的详细比较：\n1. setTimeout定义setTimeout 是一个用于延迟执行代码的函数。它接受两个参数：要执行的函数和延迟的时间（以毫秒为单位）。\n特点\n延迟执行：setTimeout 用于在指定的时间后执行某个函数。\n不返回值：setTimeout 返回一个定时器 ID，而不是 Promise。\n不处理异步操作的结果：它主要用于延迟执行，而不是处理异步操作的结果。\n\n示例console.log(&quot;Start&quot;);\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&quot;Executed after 1 second&quot;);\n&#125;, 1000);\n\nconsole.log(&quot;End&quot;);\n\n&#x2F;&#x2F; 输出:\n&#x2F;&#x2F; Start\n&#x2F;&#x2F; End\n&#x2F;&#x2F; Executed after 1 second\n\n2. Promise定义Promise 是一种用于表示异步操作的结果的对象。它可以处于三种状态：pending（进行中）、fulfilled（已完成）和 rejected（已拒绝）。\n特点\n链式调用：Promise 支持链式调用，可以通过 .then() 和 .catch() 方法处理成功和失败的结果。\n处理异步操作的结果：Promise 主要用于处理异步操作的结果，提供更清晰的错误处理。\n可以与 setTimeout 结合使用：可以在 Promise 中使用 setTimeout 来模拟异步操作。\n\n示例const fetchData &#x3D; () &#x3D;&gt; &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(&quot;Data fetched&quot;);\n    &#125;, 1000);\n  &#125;);\n&#125;;\n\nconsole.log(&quot;Start&quot;);\n\nfetchData().then((data) &#x3D;&gt; &#123;\n  console.log(data); &#x2F;&#x2F; 输出: Data fetched\n&#125;);\n\nconsole.log(&quot;End&quot;);\n\n&#x2F;&#x2F; 输出:\n&#x2F;&#x2F; Start\n&#x2F;&#x2F; End\n&#x2F;&#x2F; (1 second later)\n&#x2F;&#x2F; Data fetched\n\n3. async/await定义async/await 是基于 Promise 的语法糖，使得异步代码看起来更像同步代码。async 函数返回一个 Promise，而 await 用于等待 Promise 的完成。\n特点\n更易读的语法：async/await 使得异步代码更易于理解和维护，像同步代码一样。\n错误处理：可以使用 try/catch 语句处理错误。\n依赖于 Promise：await 只能在 async 函数内部使用。\n\n示例const fetchData &#x3D; () &#x3D;&gt; &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(&quot;Data fetched&quot;);\n    &#125;, 1000);\n  &#125;);\n&#125;;\n\nconst getData &#x3D; async () &#x3D;&gt; &#123;\n  console.log(&quot;Start&quot;);\n  const data &#x3D; await fetchData(); &#x2F;&#x2F; 等待 Promise 完成\n  console.log(data); &#x2F;&#x2F; 输出: Data fetched\n  console.log(&quot;End&quot;);\n&#125;;\n\ngetData();\n\n&#x2F;&#x2F; 输出:\n&#x2F;&#x2F; Start\n&#x2F;&#x2F; (1 second later)\n&#x2F;&#x2F; Data fetched\n&#x2F;&#x2F; End\n\n4. 主要区别总结\n\n\n特性\nsetTimeout\nPromise\nasync/await\n\n\n\n用途\n延迟执行代码\n处理异步操作的结果\n使异步代码更易读\n\n\n返回值\n返回定时器 ID\n返回 Promise\n返回 Promise\n\n\n错误处理\n无法直接处理错误\n使用 .catch() 处理错误\n使用 try/catch 处理错误\n\n\n语法\n传统回调\n链式调用\n类似同步代码\n\n\n5. 总结\n**setTimeout**：用于延迟执行某个函数，主要用于定时操作。\n**Promise**：用于处理异步操作的结果，提供更清晰的错误处理和链式调用。\n**async/await**：基于 Promise 的语法糖，使得异步代码更易读，像同步代码一样。\n\n理解这三者的区别和适用场景可以帮助开发者更有效地处理异步操作，提高代码的可读性和可维护性。\n对 Promise 的理解在 JavaScript 中，Promise 是一种用于处理异步操作的对象，它代表一个可能在未来某个时间点完成的操作。Promise 提供了一种更清晰和结构化的方式来处理异步代码，避免了传统回调函数带来的“回调地狱”问题。以下是对 Promise 的详细理解。\n1. Promise 的基本概念\n状态：Promise 有三种状态：\n\nPending（进行中）：初始状态，表示异步操作尚未完成。\nFulfilled（已完成）：表示异步操作成功完成，并返回结果。\nRejected（已拒绝）：表示异步操作失败，并返回错误信息。\n\n\n不可变性：一旦 Promise 的状态从 pending 变为 fulfilled 或 rejected，就不能再改变。\n\n\n2. Promise 的创建可以通过 Promise 构造函数创建一个新的 Promise 对象。构造函数接受一个执行器函数（executor），该函数有两个参数：resolve 和 reject。\n示例const myPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 模拟异步操作\n  setTimeout(() &#x3D;&gt; &#123;\n    const success &#x3D; true; &#x2F;&#x2F; 模拟成功或失败\n    if (success) &#123;\n      resolve(&quot;Operation succeeded!&quot;); &#x2F;&#x2F; 调用 resolve\n    &#125; else &#123;\n      reject(&quot;Operation failed!&quot;); &#x2F;&#x2F; 调用 reject\n    &#125;\n  &#125;, 1000);\n&#125;);\n\n3. Promise 的使用3.1. then() 方法then() 方法用于处理 Promise 的成功结果。它接受两个参数：第一个是处理成功结果的回调函数，第二个是处理失败结果的回调函数（可选）。\n示例myPromise\n  .then((result) &#x3D;&gt; &#123;\n    console.log(result); &#x2F;&#x2F; 输出: Operation succeeded!\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(error); &#x2F;&#x2F; 处理错误\n  &#125;);\n\n3.2. catch() 方法catch() 方法用于处理 Promise 的拒绝结果，通常用于捕获错误。\nmyPromise\n  .then((result) &#x3D;&gt; &#123;\n    console.log(result);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(error); &#x2F;&#x2F; 输出: Operation failed!\n  &#125;);\n\n3.3. finally() 方法finally() 方法用于在 Promise 完成后执行某个操作，无论是成功还是失败。它不接受参数。\nmyPromise\n  .then((result) &#x3D;&gt; &#123;\n    console.log(result);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(error);\n  &#125;)\n  .finally(() &#x3D;&gt; &#123;\n    console.log(&quot;Promise has been settled.&quot;); &#x2F;&#x2F; 无论成功或失败都会执行\n  &#125;);\n\n4. Promise 的链式调用Promise 支持链式调用，可以通过返回新的 Promise 来实现多个异步操作的顺序执行。\n示例const fetchData &#x3D; () &#x3D;&gt; &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(&quot;Data fetched&quot;);\n    &#125;, 1000);\n  &#125;);\n&#125;;\n\nfetchData()\n  .then((data) &#x3D;&gt; &#123;\n    console.log(data); &#x2F;&#x2F; 输出: Data fetched\n    return &quot;Next step&quot;; &#x2F;&#x2F; 返回新的值\n  &#125;)\n  .then((nextData) &#x3D;&gt; &#123;\n    console.log(nextData); &#x2F;&#x2F; 输出: Next step\n  &#125;);\n\n5. Promise 的静态方法\n**Promise.all()**：接受一个 Promise 数组，返回一个新的 Promise，只有当所有 Promise 都成功时才会成功。\n\nconst promise1 &#x3D; Promise.resolve(3);\nconst promise2 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 1000, &quot;foo&quot;));\nconst promise3 &#x3D; 42;\n\nPromise.all([promise1, promise2, promise3]).then((values) &#x3D;&gt; &#123;\n  console.log(values); &#x2F;&#x2F; 输出: [3, &#39;foo&#39;, 42]\n&#125;);\n\n\n**Promise.race()**：接受一个 Promise 数组，返回一个新的 Promise，一旦其中一个 Promise 完成或拒绝，就返回该 Promise 的结果。\n\nconst promise1 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 1000, &quot;one&quot;));\nconst promise2 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 500, &quot;two&quot;));\n\nPromise.race([promise1, promise2]).then((value) &#x3D;&gt; &#123;\n  console.log(value); &#x2F;&#x2F; 输出: &#39;two&#39;\n&#125;);\n\n6. 总结\nPromise 是处理异步操作的强大工具，提供了更清晰的语法和结构，避免了回调地狱。\n状态：Promise 有三种状态：pending、fulfilled 和 rejected。\n方法：使用 then()、catch() 和 finally() 方法处理结果和错误。\n链式调用：支持链式调用，可以顺序执行多个异步操作。\n静态方法：提供了 Promise.all() 和 Promise.race() 等静态方法，方便处理多个 Promise。\n\n理解 Promise 的概念和用法是掌握 JavaScript 异步编程的重要基础，有助于编写更高效和可维护的代码。\nPromise 的基本用法Promise 是 JavaScript 中用于处理异步操作的对象。它提供了一种更清晰的方式来处理异步代码，避免了回调地狱的问题。以下是 Promise 的基本用法，包括创建、使用和处理 Promise 的结果。\n1. 创建 Promise使用 Promise 构造函数可以创建一个新的 Promise 对象。构造函数接受一个执行器函数（executor），该函数有两个参数：resolve 和 reject。\n示例const myPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 模拟异步操作\n  setTimeout(() &#x3D;&gt; &#123;\n    const success &#x3D; true; &#x2F;&#x2F; 模拟成功或失败\n    if (success) &#123;\n      resolve(&quot;Operation succeeded!&quot;); &#x2F;&#x2F; 调用 resolve\n    &#125; else &#123;\n      reject(&quot;Operation failed!&quot;); &#x2F;&#x2F; 调用 reject\n    &#125;\n  &#125;, 1000);\n&#125;);\n\n2. 使用 Promise2.1. then() 方法then() 方法用于处理 Promise 的成功结果。它接受两个参数：第一个是处理成功结果的回调函数，第二个是处理失败结果的回调函数（可选）。\n示例myPromise\n  .then((result) &#x3D;&gt; &#123;\n    console.log(result); &#x2F;&#x2F; 输出: Operation succeeded!\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(error); &#x2F;&#x2F; 处理错误\n  &#125;);\n\n2.2. catch() 方法catch() 方法用于处理 Promise 的拒绝结果，通常用于捕获错误。\nmyPromise\n  .then((result) &#x3D;&gt; &#123;\n    console.log(result);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(error); &#x2F;&#x2F; 输出: Operation failed!\n  &#125;);\n\n2.3. finally() 方法finally() 方法用于在 Promise 完成后执行某个操作，无论是成功还是失败。它不接受参数。\nmyPromise\n  .then((result) &#x3D;&gt; &#123;\n    console.log(result);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(error);\n  &#125;)\n  .finally(() &#x3D;&gt; &#123;\n    console.log(&quot;Promise has been settled.&quot;); &#x2F;&#x2F; 无论成功或失败都会执行\n  &#125;);\n\n3. Promise 的链式调用Promise 支持链式调用，可以通过返回新的 Promise 来实现多个异步操作的顺序执行。\n示例const fetchData &#x3D; () &#x3D;&gt; &#123;\n  return new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(&quot;Data fetched&quot;);\n    &#125;, 1000);\n  &#125;);\n&#125;;\n\nfetchData()\n  .then((data) &#x3D;&gt; &#123;\n    console.log(data); &#x2F;&#x2F; 输出: Data fetched\n    return &quot;Next step&quot;; &#x2F;&#x2F; 返回新的值\n  &#125;)\n  .then((nextData) &#x3D;&gt; &#123;\n    console.log(nextData); &#x2F;&#x2F; 输出: Next step\n  &#125;);\n\n4. Promise 的静态方法\n**Promise.all()**：接受一个 Promise 数组，返回一个新的 Promise，只有当所有 Promise 都成功时才会成功。\n\nconst promise1 &#x3D; Promise.resolve(3);\nconst promise2 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 1000, &quot;foo&quot;));\nconst promise3 &#x3D; 42;\n\nPromise.all([promise1, promise2, promise3]).then((values) &#x3D;&gt; &#123;\n  console.log(values); &#x2F;&#x2F; 输出: [3, &#39;foo&#39;, 42]\n&#125;);\n\n\n**Promise.race()**：接受一个 Promise 数组，返回一个新的 Promise，一旦其中一个 Promise 完成或拒绝，就返回该 Promise 的结果。\n\nconst promise1 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 1000, &quot;one&quot;));\nconst promise2 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 500, &quot;two&quot;));\n\nPromise.race([promise1, promise2]).then((value) &#x3D;&gt; &#123;\n  console.log(value); &#x2F;&#x2F; 输出: &#39;two&#39;\n&#125;);\n\n5. 总结\nPromise 是处理异步操作的强大工具，提供了更清晰的语法和结构，避免了回调地狱。\n状态：Promise 有三种状态：pending、fulfilled 和 rejected。\n方法：使用 then()、catch() 和 finally() 方法处理结果和错误。\n链式调用：支持链式调用，可以顺序执行多个异步操作。\n静态方法：提供了 Promise.all() 和 Promise.race() 等静态方法，方便处理多个 Promise。\n\n理解 Promise 的基本用法是掌握 JavaScript 异步编程的重要基础，有助于编写更高效和可维护的代码。\nPromise 解决了什么问题Promise 是 JavaScript 中用于处理异步操作的重要工具，它解决了许多传统异步编程方式（如回调函数）所面临的问题。以下是 Promise 解决的一些主要问题：\n1. 回调地狱（Callback Hell）在使用回调函数处理异步操作时，嵌套的回调会导致代码变得难以阅读和维护，形成所谓的“回调地狱”。这种情况通常发生在多个异步操作依赖于彼此的结果时。\n示例（回调地狱）getData(function (result) &#123;\n  processData(result, function (processed) &#123;\n    saveData(processed, function (saved) &#123;\n      console.log(&quot;Data saved:&quot;, saved);\n    &#125;);\n  &#125;);\n&#125;);\n\n使用 Promise 解决使用 Promise 可以将异步操作链式调用，从而避免嵌套。\ngetData()\n  .then(processData)\n  .then(saveData)\n  .then((saved) &#x3D;&gt; &#123;\n    console.log(&quot;Data saved:&quot;, saved);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;Error:&quot;, error);\n  &#125;);\n\n2. 更清晰的错误处理在传统的回调方式中，错误处理通常需要在每个回调中进行，导致代码重复且难以维护。Promise 提供了统一的错误处理机制，可以通过 .catch() 方法集中处理错误。\n示例（错误处理）getData()\n  .then(processData)\n  .then(saveData)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;Error:&quot;, error); &#x2F;&#x2F; 统一处理错误\n  &#125;);\n\n3. 状态管理Promise 具有三种状态：pending（进行中）、fulfilled（已完成）和 rejected（已拒绝）。这种状态管理使得开发者可以更清晰地了解异步操作的进展，并在适当的时候处理结果或错误。\n4. 组合异步操作Promise 提供了静态方法，如 Promise.all() 和 Promise.race()，使得处理多个异步操作变得更加简单和直观。\n\n**Promise.all()**：可以并行执行多个 Promise，只有当所有 Promise 都成功时才会成功。\n\nPromise.all([promise1, promise2])\n  .then((results) &#x3D;&gt; &#123;\n    console.log(&quot;All results:&quot;, results);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;One of the promises failed:&quot;, error);\n  &#125;);\n\n\n**Promise.race()**：可以在多个 Promise 中，返回第一个完成的 Promise 的结果。\n\nPromise.race([promise1, promise2]).then((result) &#x3D;&gt; &#123;\n  console.log(&quot;First completed:&quot;, result);\n&#125;);\n\n5. 更好的可读性和可维护性由于 Promise 允许链式调用和集中处理错误，代码的可读性和可维护性得到了显著提升。开发者可以更容易地理解异步操作的流程。\n6. 与 async/await 的结合Promise 与 async/await 语法结合使用，使得异步代码看起来更像同步代码，进一步提高了代码的可读性。\nasync function fetchData() &#123;\n  try &#123;\n    const data &#x3D; await getData();\n    const processed &#x3D; await processData(data);\n    await saveData(processed);\n    console.log(&quot;Data saved successfully&quot;);\n  &#125; catch (error) &#123;\n    console.error(&quot;Error:&quot;, error);\n  &#125;\n&#125;\n\n7. 总结Promise 解决了许多传统异步编程方式所面临的问题，包括回调地狱、错误处理的复杂性、状态管理、组合异步操作的便利性以及代码的可读性和可维护性。通过使用 Promise，开发者可以更高效地处理异步操作，编写出更清晰和易于维护的代码。\nPromise.all 和 Promise.race 的区别的使用场景Promise.all 和 Promise.race 是 JavaScript 中处理多个 Promise 的两个静态方法。它们的主要区别在于处理多个 Promise 的方式和返回结果的逻辑。以下是对这两个方法的详细比较以及它们的使用场景。\n1. Promise.all定义Promise.all 接受一个可迭代对象（通常是数组），并返回一个新的 Promise。这个新的 Promise 只有在所有输入的 Promise 都成功时才会成功，并返回一个包含所有成功结果的数组。如果其中任何一个 Promise 失败，则返回的 Promise 会立即被拒绝，并返回第一个失败的错误。\n使用场景\n并行执行多个异步操作：当你需要同时执行多个异步操作，并在所有操作完成后处理结果时，使用 Promise.all。\n需要所有结果：当你需要所有 Promise 的结果，并且只有在所有 Promise 都成功时才继续执行后续操作。\n\n示例const promise1 &#x3D; Promise.resolve(3);\nconst promise2 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 1000, &quot;foo&quot;));\nconst promise3 &#x3D; 42;\n\nPromise.all([promise1, promise2, promise3])\n  .then((values) &#x3D;&gt; &#123;\n    console.log(values); &#x2F;&#x2F; 输出: [3, &#39;foo&#39;, 42]\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;One of the promises failed:&quot;, error);\n  &#125;);\n\n2. Promise.race定义Promise.race 也接受一个可迭代对象（通常是数组），并返回一个新的 Promise。这个新的 Promise 一旦有任何一个输入的 Promise 完成（无论是成功还是失败），就会立即返回该 Promise 的结果。\n使用场景\n竞争条件：当你有多个异步操作，但只关心第一个完成的操作时，使用 Promise.race。\n超时处理：可以用来实现超时机制，例如，如果某个操作在一定时间内没有完成，则返回一个超时的 Promise。\n\n示例const promise1 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 1000, &quot;one&quot;));\nconst promise2 &#x3D; new Promise((resolve) &#x3D;&gt; setTimeout(resolve, 500, &quot;two&quot;));\n\nPromise.race([promise1, promise2])\n  .then((value) &#x3D;&gt; &#123;\n    console.log(value); &#x2F;&#x2F; 输出: &#39;two&#39; (因为 promise2 更快完成)\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;One of the promises failed:&quot;, error);\n  &#125;);\n\n3. 主要区别总结\n\n\n特性\nPromise.all\nPromise.race\n\n\n\n返回值\n只有在所有 Promise 都成功时才成功\n只要有一个 Promise 完成就返回结果\n\n\n失败处理\n只要有一个 Promise 失败就立即拒绝\n只要有一个 Promise 完成（成功或失败）就返回\n\n\n使用场景\n需要所有结果，且所有操作必须成功\n只关心第一个完成的操作\n\n\n4. 总结\n使用 Promise.all 当你需要并行执行多个异步操作，并在所有操作完成后处理结果时。\n使用 Promise.race 当你只关心第一个完成的操作，或者需要实现超时机制时。\n\n理解这两个方法的区别和适用场景可以帮助开发者更有效地处理多个异步操作，提高代码的可读性和可维护性。\n对 async&#x2F;await 的理解async/await 是 JavaScript 中用于处理异步操作的语法糖，基于 Promise 实现。它使得异步代码的编写和阅读更加直观，像同步代码一样。以下是对 async/await 的详细理解。\n1. 基本概念\nasync 关键字：用于定义一个异步函数。异步函数总是返回一个 Promise。如果函数内部返回一个值，该值会被自动包装成一个已解决的 Promise；如果抛出一个错误，则返回一个被拒绝的 Promise。\n\nawait 关键字：用于等待一个 Promise 的完成。await 只能在 async 函数内部使用。它会暂停函数的执行，直到 Promise 完成，并返回结果。\n\n\n2. 使用 async/await2.1. 定义异步函数使用 async 关键字定义一个异步函数。\nasync function fetchData() &#123;\n  &#x2F;&#x2F; 这里可以使用 await\n&#125;\n\n2.2. 使用 await在异步函数内部，可以使用 await 来等待 Promise 的结果。\nasync function fetchData() &#123;\n  const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n  const data &#x3D; await response.json();\n  return data; &#x2F;&#x2F; 返回一个 Promise\n&#125;\n\n2.3. 调用异步函数调用异步函数时，可以使用 then() 方法处理返回的 Promise，或者使用 await 来获取结果。\n&#x2F;&#x2F; 使用 then()\nfetchData().then((data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;);\n\n&#x2F;&#x2F; 使用 await\n(async () &#x3D;&gt; &#123;\n  const data &#x3D; await fetchData();\n  console.log(data);\n&#125;)();\n\n3. 错误处理使用 try/catch 语句可以捕获异步函数中的错误，提供了更清晰的错误处理方式。\nasync function fetchData() &#123;\n  try &#123;\n    const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n    if (!response.ok) &#123;\n      throw new Error(&quot;Network response was not ok&quot;);\n    &#125;\n    const data &#x3D; await response.json();\n    return data;\n  &#125; catch (error) &#123;\n    console.error(&quot;Fetch error:&quot;, error);\n  &#125;\n&#125;\n\n4. 优势\n可读性：async/await 使得异步代码看起来更像同步代码，易于理解和维护。\n简化错误处理：通过 try/catch 语句，可以更方便地处理错误。\n避免回调地狱：使用 async/await 可以避免嵌套的回调函数，使代码结构更清晰。\n\n5. 注意事项\n**只能在 async 函数中使用 await**：await 关键字只能在异步函数内部使用，不能在普通函数或全局作用域中使用。\nPromise 的返回值：async 函数总是返回一个 Promise，因此可以使用 .then() 和 .catch() 方法处理结果和错误。\n并行执行：如果需要并行执行多个异步操作，可以使用 Promise.all()。\n\n6. 示例以下是一个完整的示例，展示了如何使用 async/await 进行异步操作：\nasync function fetchData() &#123;\n  try &#123;\n    const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n    if (!response.ok) &#123;\n      throw new Error(&quot;Network response was not ok&quot;);\n    &#125;\n    const data &#x3D; await response.json();\n    return data;\n  &#125; catch (error) &#123;\n    console.error(&quot;Fetch error:&quot;, error);\n  &#125;\n&#125;\n\n(async () &#x3D;&gt; &#123;\n  const data &#x3D; await fetchData();\n  console.log(data);\n&#125;)();\n\n7. 总结async/await 是 JavaScript 中处理异步操作的强大工具，它使得异步代码的编写和阅读更加直观，提供了更清晰的错误处理方式。通过使用 async/await，开发者可以编写出更易于理解和维护的异步代码，提升代码的可读性和可维护性。\nawait 到底在等什么？在 JavaScript 中，await 是一个关键字，用于暂停异步函数的执行，直到一个 Promise 完成（即变为 fulfilled 或 rejected）。具体来说，await 会等待以下几种情况：\n1. 等待 Promiseawait 通常用于等待一个 Promise 对象的完成。它会暂停当前 async 函数的执行，直到 Promise 被解决（fulfilled）或拒绝（rejected）。\n示例async function fetchData() &#123;\n  const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;); &#x2F;&#x2F; 等待 fetch 返回的 Promise\n  const data &#x3D; await response.json(); &#x2F;&#x2F; 等待 response.json() 返回的 Promise\n  return data;\n&#125;\n\nfetchData().then((data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;);\n\n在这个例子中，await fetch(...) 会等待 fetch 函数返回的 Promise 完成，只有在 Promise 完成后，才会继续执行下一行代码。\n2. 等待 Promise 的结果当 await 等待的 Promise 被解决时，它会返回 Promise 的结果。如果 Promise 被拒绝，await 会抛出错误，可以通过 try/catch 语句捕获。\n示例async function fetchData() &#123;\n  try &#123;\n    const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n    if (!response.ok) &#123;\n      throw new Error(&quot;Network response was not ok&quot;);\n    &#125;\n    const data &#x3D; await response.json();\n    return data;\n  &#125; catch (error) &#123;\n    console.error(&quot;Fetch error:&quot;, error);\n  &#125;\n&#125;\n\n在这个例子中，如果 fetch 返回的 Promise 被拒绝，await 会抛出错误，进入 catch 块进行错误处理。\n3. 等待非 Promise 值如果 await 后面跟的是一个非 Promise 值，JavaScript 会将其包装成一个已解决的 Promise，并立即返回该值。这意味着 await 也可以用于同步值。\n示例async function example() &#123;\n  const result &#x3D; await 42; &#x2F;&#x2F; 42 会被包装成一个已解决的 Promise\n  console.log(result); &#x2F;&#x2F; 输出: 42\n&#125;\n\nexample();\n\n在这个例子中，await 42 会立即返回 42，因为它不是一个 Promise。\n4. 总结\nawait 等待的是一个 Promise：它会暂停 async 函数的执行，直到 Promise 完成。\n返回 Promise 的结果：如果 Promise 被解决，await 返回其结果；如果被拒绝，await 抛出错误。\n可以等待非 Promise 值：如果 await 后面是一个非 Promise 值，它会被包装成一个已解决的 Promise。\n\n理解 await 的工作原理有助于更好地使用 async/await 语法编写异步代码，使得代码更易于理解和维护。\nasync&#x2F;await 的优势async/await 是 JavaScript 中处理异步操作的一种语法糖，基于 Promise 实现。它提供了一种更直观和易于理解的方式来编写异步代码。以下是 async/await 的主要优势：\n1. 更好的可读性\n接近同步代码：async/await 使得异步代码的结构看起来更像同步代码，减少了回调函数的嵌套，使得代码更易于阅读和理解。\n\n示例async function fetchData() &#123;\n  const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n  const data &#x3D; await response.json();\n  return data;\n&#125;\n\n与传统的 Promise 链式调用相比，async/await 使得代码更简洁。\n2. 简化错误处理\n**使用 try/catch**：async/await 允许使用 try/catch 语句来捕获错误，这使得错误处理更加直观和集中。\n\n示例async function fetchData() &#123;\n  try &#123;\n    const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n    if (!response.ok) &#123;\n      throw new Error(&quot;Network response was not ok&quot;);\n    &#125;\n    const data &#x3D; await response.json();\n    return data;\n  &#125; catch (error) &#123;\n    console.error(&quot;Fetch error:&quot;, error);\n  &#125;\n&#125;\n\n这种方式比使用 .catch() 方法处理错误更清晰。\n3. 避免回调地狱\n减少嵌套：使用 async/await 可以避免回调地狱（callback hell），使得代码结构更加扁平化，易于维护。\n\n示例async function processData() &#123;\n  const data &#x3D; await fetchData();\n  const processed &#x3D; await process(data);\n  await save(processed);\n  console.log(&quot;Data saved successfully&quot;);\n&#125;\n\n与传统的回调方式相比，async/await 使得代码更易于跟踪和理解。\n4. 组合多个异步操作\n并行执行：虽然 async/await 本身是顺序执行的，但可以结合 Promise.all() 来并行执行多个异步操作。\n\n示例async function fetchAllData() &#123;\n  const [data1, data2] &#x3D; await Promise.all([fetchData1(), fetchData2()]);\n  console.log(data1, data2);\n&#125;\n\n这种方式使得多个异步操作可以同时进行，提高了效率。\n5. 更好的调试体验\n栈跟踪：使用 async/await 时，错误的栈跟踪信息通常更清晰，便于调试。因为错误会在 await 语句处抛出，而不是在 Promise 链的某个地方。\n\n6. 兼容性\n广泛支持：async/await 是 ES2017（ES8）引入的特性，现代浏览器和 Node.js 都广泛支持这一特性，使得开发者可以放心使用。\n\n7. 代码结构清晰\n逻辑顺序：async/await 使得异步操作的逻辑顺序更加清晰，开发者可以按照自然的顺序编写代码，而不必担心回调的嵌套。\n\n8. 总结async/await 提供了更好的可读性、简化的错误处理、避免回调地狱、并行执行多个异步操作的能力，以及更好的调试体验。这些优势使得 async/await 成为现代 JavaScript 开发中处理异步操作的首选方式。理解和掌握 async/await 的使用，可以帮助开发者编写出更清晰、可维护和高效的代码。\nasync&#x2F;await 对比 Promise 的优势async/await 是基于 Promise 的语法糖，旨在使异步编程更加直观和易于理解。虽然 Promise 本身已经提供了强大的异步处理能力，但 async/await 在多个方面相较于 Promise 具有明显的优势。以下是 async/await 对比 Promise 的主要优势：\n1. 更好的可读性\n接近同步代码：async/await 使得异步代码的结构看起来更像同步代码，减少了嵌套，使得代码更易于阅读和理解。\n\n示例使用 Promise\nfetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;)\n  .then((response) &#x3D;&gt; &#123;\n    return response.json();\n  &#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(data);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;Error:&quot;, error);\n  &#125;);\n\n使用 async&#x2F;await\nasync function fetchData() &#123;\n  try &#123;\n    const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n    const data &#x3D; await response.json();\n    console.log(data);\n  &#125; catch (error) &#123;\n    console.error(&quot;Error:&quot;, error);\n  &#125;\n&#125;\n\nfetchData();\n\n2. 简化错误处理\n**使用 try/catch**：async/await 允许使用 try/catch 语句来捕获错误，这使得错误处理更加直观和集中。\n\n示例使用 Promise\nfetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;)\n  .then((response) &#x3D;&gt; &#123;\n    if (!response.ok) &#123;\n      throw new Error(&quot;Network response was not ok&quot;);\n    &#125;\n    return response.json();\n  &#125;)\n  .then((data) &#x3D;&gt; &#123;\n    console.log(data);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;Error:&quot;, error);\n  &#125;);\n\n使用 async&#x2F;await\nasync function fetchData() &#123;\n  try &#123;\n    const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n    if (!response.ok) &#123;\n      throw new Error(&quot;Network response was not ok&quot;);\n    &#125;\n    const data &#x3D; await response.json();\n    console.log(data);\n  &#125; catch (error) &#123;\n    console.error(&quot;Error:&quot;, error);\n  &#125;\n&#125;\n\nfetchData();\n\n3. 避免回调地狱\n减少嵌套：使用 async/await 可以避免回调地狱（callback hell），使得代码结构更加扁平化，易于维护。\n\n示例使用 Promise\nfetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;)\n  .then((response) &#x3D;&gt; &#123;\n    return response.json();\n  &#125;)\n  .then((data) &#x3D;&gt; &#123;\n    return processData(data);\n  &#125;)\n  .then((processedData) &#x3D;&gt; &#123;\n    return saveData(processedData);\n  &#125;)\n  .then(() &#x3D;&gt; &#123;\n    console.log(&quot;Data saved successfully&quot;);\n  &#125;)\n  .catch((error) &#x3D;&gt; &#123;\n    console.error(&quot;Error:&quot;, error);\n  &#125;);\n\n使用 async&#x2F;await\nasync function processAndSaveData() &#123;\n  try &#123;\n    const response &#x3D; await fetch(&quot;https:&#x2F;&#x2F;api.example.com&#x2F;data&quot;);\n    const data &#x3D; await response.json();\n    const processedData &#x3D; await processData(data);\n    await saveData(processedData);\n    console.log(&quot;Data saved successfully&quot;);\n  &#125; catch (error) &#123;\n    console.error(&quot;Error:&quot;, error);\n  &#125;\n&#125;\n\nprocessAndSaveData();\n\n4. 更好的调试体验\n栈跟踪：使用 async/await 时，错误的栈跟踪信息通常更清晰，便于调试。因为错误会在 await 语句处抛出，而不是在 Promise 链的某个地方。\n\n5. 组合多个异步操作\n并行执行：虽然 async/await 本身是顺序执行的，但可以结合 Promise.all() 来并行执行多个异步操作。\n\n示例async function fetchAllData() &#123;\n  const [data1, data2] &#x3D; await Promise.all([fetchData1(), fetchData2()]);\n  console.log(data1, data2);\n&#125;\n\n6. 代码结构清晰\n逻辑顺序：async/await 使得异步操作的逻辑顺序更加清晰，开发者可以按照自然的顺序编写代码，而不必担心回调的嵌套。\n\n7. 总结\n可读性：async/await 使得异步代码更易于阅读，接近同步代码的风格。\n错误处理：通过 try/catch 语句，错误处理变得更加直观。\n避免回调地狱：减少了嵌套，使得代码结构更清晰。\n调试体验：提供了更好的栈跟踪信息，便于调试。\n组合异步操作：可以结合 Promise.all() 轻松处理多个异步操作。\n\n理解 async/await 的优势可以帮助开发者更有效地编写异步代码，提高代码的可读性和可维护性。\n面向对象对象创建的方式有哪些？在 JavaScript 中，有多种方式可以创建对象。每种方式都有其特定的用例和优缺点。以下是几种常见的对象创建方式：\n1. 对象字面量这是创建对象最简单和最常用的方式。通过对象字面量，可以直接定义对象的属性和方法。\n示例const person &#x3D; &#123;\n  name: &quot;Alice&quot;,\n  age: 30,\n  greet: function () &#123;\n    console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n  &#125;,\n&#125;;\n\nperson.greet(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n2. Object 构造函数使用 Object 构造函数可以创建一个空对象，然后可以动态地添加属性和方法。\n示例const person &#x3D; new Object();\nperson.name &#x3D; &quot;Bob&quot;;\nperson.age &#x3D; 25;\nperson.greet &#x3D; function () &#123;\n  console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n&#125;;\n\nperson.greet(); &#x2F;&#x2F; 输出: Hello, my name is Bob\n\n3. 构造函数通过定义构造函数，可以创建具有相同属性和方法的多个对象实例。构造函数通常与 new 关键字一起使用。\n示例function Person(name, age) &#123;\n  this.name &#x3D; name;\n  this.age &#x3D; age;\n  this.greet &#x3D; function () &#123;\n    console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n  &#125;;\n&#125;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;, 30);\nconst bob &#x3D; new Person(&quot;Bob&quot;, 25);\n\nalice.greet(); &#x2F;&#x2F; 输出: Hello, my name is Alice\nbob.greet(); &#x2F;&#x2F; 输出: Hello, my name is Bob\n\n4. Object.create() 方法Object.create() 方法可以创建一个新对象，并将其原型设置为指定的对象。这种方式适合用于实现对象的继承。\n示例const personPrototype &#x3D; &#123;\n  greet: function () &#123;\n    console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n  &#125;,\n&#125;;\n\nconst alice &#x3D; Object.create(personPrototype);\nalice.name &#x3D; &quot;Alice&quot;;\nalice.greet(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n5. ES6 类（Class）ES6 引入了类语法，使得定义对象的构造函数和方法更加直观。类实际上是构造函数的语法糖。\n示例class Person &#123;\n  constructor(name, age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n  &#125;\n\n  greet() &#123;\n    console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n  &#125;\n&#125;\n\nconst alice &#x3D; new Person(&quot;Alice&quot;, 30);\nalice.greet(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n6. 工厂函数工厂函数是一种返回对象的普通函数。它不使用 new 关键字，而是直接返回一个对象。\n示例function createPerson(name, age) &#123;\n  return &#123;\n    name: name,\n    age: age,\n    greet: function () &#123;\n      console.log(&#96;Hello, my name is $&#123;this.name&#125;&#96;);\n    &#125;,\n  &#125;;\n&#125;\n\nconst alice &#x3D; createPerson(&quot;Alice&quot;, 30);\nalice.greet(); &#x2F;&#x2F; 输出: Hello, my name is Alice\n\n7. 总结\n对象字面量：简单直接，适合创建单个对象。\nObject 构造函数：灵活但不常用。\n构造函数：适合创建多个具有相同属性和方法的对象实例。\n**Object.create()**：适合实现对象继承。\nES6 类：提供了更清晰的语法，适合面向对象编程。\n工厂函数：灵活且不依赖 new 关键字，适合创建对象实例。\n\n理解这些对象创建方式可以帮助开发者根据不同的需求选择合适的方法来创建和管理对象。\n对象继承的方式有哪些？在 JavaScript 中，对象继承是实现代码重用和组织的重要机制。JavaScript 提供了多种方式来实现对象继承。以下是几种常见的对象继承方式：\n1. 原型链继承这是 JavaScript 中最基本的继承方式。通过将一个对象的原型设置为另一个对象的实例，实现继承。\n示例function Animal(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nAnimal.prototype.speak &#x3D; function () &#123;\n  console.log(&#96;$&#123;this.name&#125; makes a noise.&#96;);\n&#125;;\n\nfunction Dog(name) &#123;\n  Animal.call(this, name); &#x2F;&#x2F; 调用父类构造函数\n&#125;\n\nDog.prototype &#x3D; Object.create(Animal.prototype); &#x2F;&#x2F; 设置原型链\nDog.prototype.constructor &#x3D; Dog; &#x2F;&#x2F; 修正构造函数指向\n\nconst dog &#x3D; new Dog(&quot;Rex&quot;);\ndog.speak(); &#x2F;&#x2F; 输出: Rex makes a noise.\n\n2. Object.create() 方法Object.create() 方法可以创建一个新对象，并将其原型设置为指定的对象。这种方式适合用于实现对象的继承。\n示例const animal &#x3D; &#123;\n  speak: function () &#123;\n    console.log(&#96;$&#123;this.name&#125; makes a noise.&#96;);\n  &#125;,\n&#125;;\n\nconst dog &#x3D; Object.create(animal);\ndog.name &#x3D; &quot;Rex&quot;;\ndog.speak(); &#x2F;&#x2F; 输出: Rex makes a noise.\n\n3. 构造函数继承通过在子类构造函数中调用父类构造函数，实现属性的继承。\n示例function Animal(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nfunction Dog(name) &#123;\n  Animal.call(this, name); &#x2F;&#x2F; 调用父类构造函数\n&#125;\n\nconst dog &#x3D; new Dog(&quot;Rex&quot;);\nconsole.log(dog.name); &#x2F;&#x2F; 输出: Rex\n\n4. 组合继承（伪经典继承）组合继承结合了原型链继承和构造函数继承的优点，是一种常用的继承方式。\n示例function Animal(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nAnimal.prototype.speak &#x3D; function () &#123;\n  console.log(&#96;$&#123;this.name&#125; makes a noise.&#96;);\n&#125;;\n\nfunction Dog(name) &#123;\n  Animal.call(this, name); &#x2F;&#x2F; 调用父类构造函数\n&#125;\n\nDog.prototype &#x3D; Object.create(Animal.prototype); &#x2F;&#x2F; 设置原型链\nDog.prototype.constructor &#x3D; Dog; &#x2F;&#x2F; 修正构造函数指向\n\nconst dog &#x3D; new Dog(&quot;Rex&quot;);\ndog.speak(); &#x2F;&#x2F; 输出: Rex makes a noise.\n\n5. 寄生组合继承寄生组合继承是对组合继承的一种优化，避免了调用两次父类构造函数。\n示例function Animal(name) &#123;\n  this.name &#x3D; name;\n&#125;\n\nAnimal.prototype.speak &#x3D; function () &#123;\n  console.log(&#96;$&#123;this.name&#125; makes a noise.&#96;);\n&#125;;\n\nfunction Dog(name) &#123;\n  Animal.call(this, name); &#x2F;&#x2F; 调用父类构造函数\n&#125;\n\nDog.prototype &#x3D; Object.create(Animal.prototype); &#x2F;&#x2F; 设置原型链\nDog.prototype.constructor &#x3D; Dog; &#x2F;&#x2F; 修正构造函数指向\n\nconst dog &#x3D; new Dog(&quot;Rex&quot;);\ndog.speak(); &#x2F;&#x2F; 输出: Rex makes a noise.\n\n6. ES6 类继承ES6 引入了类语法，使得继承更加直观和易于理解。class 和 extends 关键字用于实现继承。\n示例class Animal &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n\n  speak() &#123;\n    console.log(&#96;$&#123;this.name&#125; makes a noise.&#96;);\n  &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n  constructor(name) &#123;\n    super(name); &#x2F;&#x2F; 调用父类构造函数\n  &#125;\n&#125;\n\nconst dog &#x3D; new Dog(&quot;Rex&quot;);\ndog.speak(); &#x2F;&#x2F; 输出: Rex makes a noise.\n\n7. 总结\n原型链继承：通过设置原型链实现继承，适合方法的继承。\n**Object.create()**：创建一个新对象并设置其原型，适合简单的继承。\n构造函数继承：通过调用父类构造函数实现属性的继承。\n组合继承：结合原型链和构造函数继承的优点，常用的继承方式。\n寄生组合继承：对组合继承的优化，避免了不必要的父类构造函数调用。\nES6 类继承：使用 class 和 extends 关键字实现继承，语法更清晰。\n\n理解这些继承方式可以帮助开发者根据不同的需求选择合适的方法来实现对象继承，提高代码的可读性和可维护性。\n垃圾回收与内存泄漏浏览器的垃圾回收机制JavaScript 是一种具有自动垃圾回收（Garbage Collection, GC）机制的语言，这意味着开发者不需要手动管理内存分配和释放。浏览器中的 JavaScript 引擎（如 V8、SpiderMonkey 等）负责自动管理内存，回收不再使用的对象。以下是浏览器垃圾回收机制的基本概念和工作原理：\n1. 垃圾回收的基本概念\n内存管理：JavaScript 引擎会自动分配内存给新对象，并在对象不再需要时回收内存。\n垃圾：在程序中不再可访问的对象被视为垃圾，需要被回收以释放内存。\n\n2. 常见的垃圾回收算法2.1. 标记-清除（Mark-and-Sweep）这是最常用的垃圾回收算法。其基本思想是通过标记和清除两个阶段来回收内存。\n\n标记阶段：从根对象（如全局对象）开始，递归遍历所有可达对象，并标记它们。\n清除阶段：遍历内存中的所有对象，回收未被标记的对象。\n\n示例1. 标记阶段：标记所有从根对象可达的对象。\n2. 清除阶段：回收未标记的对象。\n\n2.2. 引用计数（Reference Counting）这种算法通过跟踪每个对象的引用次数来管理内存。当对象的引用计数为零时，表示该对象不再可访问，可以被回收。\n\n优点：简单直接。\n缺点：无法处理循环引用。\n\n示例let obj1 &#x3D; &#123;&#125;;\nlet obj2 &#x3D; &#123; ref: obj1 &#125;;\nobj1.ref &#x3D; obj2;\n\n&#x2F;&#x2F; obj1 和 obj2 互相引用，引用计数不会降为零，导致内存泄漏。\n\n3. 垃圾回收的触发条件\n内存分配：当分配新对象时，可能会触发垃圾回收。\n内存使用达到阈值：当内存使用达到某个阈值时，可能会触发垃圾回收。\n\n4. 垃圾回收的优化现代 JavaScript 引擎通常会使用分代垃圾回收（Generational Garbage Collection）来优化性能。分代垃圾回收将内存分为两代：新生代和老生代。\n\n新生代：存储生命周期较短的对象，垃圾回收频率较高。\n老生代：存储生命周期较长的对象，垃圾回收频率较低。\n\n5. 内存泄漏的常见原因尽管 JavaScript 有自动垃圾回收机制，但内存泄漏仍然可能发生。常见的内存泄漏原因包括：\n\n意外的全局变量：未使用 var、let 或 const 声明的变量会成为全局变量。\n闭包：不当使用闭包可能导致内存无法释放。\n未清理的 DOM 引用：删除 DOM 元素时未清理相关的 JavaScript 引用。\n循环引用：对象之间的循环引用可能导致内存无法释放。\n\n6. 总结\n自动内存管理：JavaScript 引擎自动管理内存分配和回收。\n标记-清除算法：最常用的垃圾回收算法，通过标记和清除来回收内存。\n分代垃圾回收：通过将内存分为新生代和老生代来优化性能。\n内存泄漏：尽管有垃圾回收机制，内存泄漏仍可能发生，需要注意代码中的潜在问题。\n\n理解浏览器的垃圾回收机制有助于编写更高效和内存友好的 JavaScript 代码。\n哪些情况会导致内存泄漏内存泄漏是指程序在运行过程中无法释放不再使用的内存，导致内存占用不断增加。尽管 JavaScript 有自动垃圾回收机制，但某些编程错误仍可能导致内存泄漏。以下是一些常见的导致内存泄漏的情况：\n1. 意外的全局变量未使用 var、let 或 const 声明的变量会成为全局变量，导致内存无法释放。\n示例function createLeak() &#123;\n  leakyVar &#x3D; &quot;This is a leak&quot;; &#x2F;&#x2F; 未声明的变量，成为全局变量\n&#125;\n\ncreateLeak();\n\n2. 闭包闭包可以捕获外部函数的变量，但不当使用可能导致内存无法释放，尤其是在循环中创建闭包时。\n示例function createClosure() &#123;\n  const largeArray &#x3D; new Array(1000).fill(&quot;leak&quot;);\n  return function () &#123;\n    console.log(largeArray.length);\n  &#125;;\n&#125;\n\nconst closure &#x3D; createClosure();\n&#x2F;&#x2F; 即使不再需要 largeArray，闭包仍然持有对它的引用\n\n3. 未清理的 DOM 引用删除 DOM 元素时，如果 JavaScript 中仍然保留对这些元素的引用，可能导致内存无法释放。\n示例const element &#x3D; document.getElementById(&quot;myElement&quot;);\ndocument.body.removeChild(element);\n&#x2F;&#x2F; 仍然保留对 element 的引用，导致内存泄漏\n\n4. 循环引用对象之间的循环引用可能导致内存无法释放，尤其是在使用旧版浏览器时。\n示例function createCircularReference() &#123;\n  const obj1 &#x3D; &#123;&#125;;\n  const obj2 &#x3D; &#123;&#125;;\n  obj1.ref &#x3D; obj2;\n  obj2.ref &#x3D; obj1;\n&#125;\n\ncreateCircularReference();\n&#x2F;&#x2F; obj1 和 obj2 互相引用，可能导致内存泄漏\n\n5. 事件监听器未移除为 DOM 元素添加事件监听器后，如果不再需要这些监听器但未移除，可能导致内存泄漏。\n示例const button &#x3D; document.getElementById(&quot;myButton&quot;);\nfunction handleClick() &#123;\n  console.log(&quot;Button clicked&quot;);\n&#125;\n\nbutton.addEventListener(&quot;click&quot;, handleClick);\n&#x2F;&#x2F; 如果不再需要 handleClick，应该移除监听器\nbutton.removeEventListener(&quot;click&quot;, handleClick);\n\n6. 定时器和回调未清理的定时器和回调函数可能导致内存泄漏。\n示例const intervalId &#x3D; setInterval(() &#x3D;&gt; &#123;\n  console.log(&quot;This runs every second&quot;);\n&#125;, 1000);\n\n&#x2F;&#x2F; 如果不再需要，应该清除定时器\nclearInterval(intervalId);\n\n7. 缓存过多数据在应用中缓存过多数据，尤其是大数据集，可能导致内存占用过高。\n示例const cache &#x3D; &#123;&#125;;\nfunction cacheData(key, data) &#123;\n  cache[key] &#x3D; data;\n&#125;\n\n&#x2F;&#x2F; 应该定期清理不再需要的数据\n\n8. 总结\n意外的全局变量：未声明的变量会成为全局变量。\n闭包：不当使用闭包可能导致内存无法释放。\n未清理的 DOM 引用：删除 DOM 元素时未清理相关的 JavaScript 引用。\n循环引用：对象之间的循环引用可能导致内存无法释放。\n事件监听器未移除：未移除不再需要的事件监听器。\n定时器和回调：未清理的定时器和回调函数。\n缓存过多数据：缓存过多数据可能导致内存占用过高。\n\n理解这些内存泄漏的原因可以帮助开发者编写更高效和内存友好的 JavaScript 代码。\n","slug":"interview-javascript","date":"2024-12-28T06:44:24.000Z","categories_index":"interview","tags_index":"javascript","author_index":"X-29"},{"id":"22d898182469a084004dd0b5135b46c1","title":"interview-css","content":"一、CSS 基础CSS 选择器及其优先级CSS 选择器用于选择 HTML 元素并应用样式。选择器的种类繁多，每种选择器都有其特定的用途和优先级。以下是常见的 CSS 选择器及其优先级的详细介绍。\n1. 常见的 CSS 选择器\n通用选择器 (*)：\n\n选择所有元素。\n\n* &#123;\n  margin: 0;\n  padding: 0;\n&#125;\n\n类型选择器（元素选择器）：\n\n选择特定类型的元素。\n\np &#123;\n  color: blue;\n&#125;\n\n类选择器 (.)：\n\n选择具有特定类的元素。\n\n.my-class &#123;\n  font-size: 16px;\n&#125;\n\nID 选择器 (#)：\n\n选择具有特定 ID 的元素。ID 在文档中应唯一。\n\n#my-id &#123;\n  background-color: yellow;\n&#125;\n\n属性选择器：\n\n选择具有特定属性的元素。\n\ninput[type&#x3D;&quot;text&quot;] &#123;\n  border: 1px solid black;\n&#125;\n\n伪类选择器：\n\n选择元素的特定状态。\n\na:hover &#123;\n  color: red;\n&#125;\n\n伪元素选择器：\n\n选择元素的特定部分。\n\np::first-line &#123;\n  font-weight: bold;\n&#125;\n\n组合选择器：\n\n组合多个选择器。div &gt; p &#123;\n  margin: 10px;\n&#125;\n\n\n\n2. CSS 选择器的优先级CSS 的优先级（或特指权重）决定了当多个选择器应用于同一元素时，哪个选择器的样式会生效。优先级的计算规则如下：\n\n内联样式：直接在元素的 style 属性中定义的样式，优先级最高。\n\n权重：1000\n\n&lt;p style&#x3D;&quot;color: red;&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;\n\nID 选择器：每个 ID 选择器的权重为 100。\n\n权重：100\n\n#my-id &#123;\n  color: blue;\n&#125;\n\n类选择器、伪类选择器和属性选择器：每个类、伪类或属性选择器的权重为 10。\n\n权重：10\n\n.my-class &#123;\n  color: green;\n&#125;\n\n类型选择器（元素选择器）和伪元素选择器：每个类型选择器的权重为 1。\n\n权重：1\n\np &#123;\n  color: black;\n&#125;\n\n通用选择器（*）和组合选择器的权重为 0。\n\n\n3. 优先级示例假设有以下 CSS 规则：\np &#123;\n    color: black; &#x2F;* 权重 1 *&#x2F;\n&#125;\n\n.my-class &#123;\n    color: green; &#x2F;* 权重 10 *&#x2F;\n&#125;\n\n#my-id &#123;\n    color: blue; &#x2F;* 权重 100 *&#x2F;\n&#125;\n\np#my-id &#123;\n    color: red; &#x2F;* 权重 101 *&#x2F;\n&#125;\n\n&lt;p id&#x3D;&quot;my-id&quot; class&#x3D;&quot;my-class&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;\n\n在这个例子中，段落的最终颜色将是 红色，因为 p#my-id 的权重（101）高于其他选择器。\n4. 总结\nCSS 选择器用于选择 HTML 元素并应用样式，种类繁多，包括通用选择器、类型选择器、类选择器、ID 选择器等。\nCSS 的优先级决定了当多个选择器应用于同一元素时，哪个选择器的样式会生效。优先级从高到低依次为内联样式、ID 选择器、类选择器、类型选择器和通用选择器。\n\nCSS 中可继承与不可继承属性有哪些在 CSS 中，某些属性是可继承的，而另一些属性则不可继承。理解这些属性的继承特性对于编写有效的样式表非常重要。以下是可继承和不可继承属性的详细分类。\n1. 可继承属性可继承属性是指当一个元素的样式被设置时，其子元素会自动继承这些样式。常见的可继承属性包括：\n\n文本相关属性：\n\ncolor：文本颜色\nfont-family：字体系列\nfont-size：字体大小\nfont-style：字体样式（如斜体）\nfont-variant：字体变体（如小型大写字母）\nfont-weight：字体粗细\nline-height：行高\ntext-align：文本对齐方式\ntext-indent：文本缩进\ntext-transform：文本转换（如大写）\nwhite-space：空白处理\nword-spacing：单词间距\n\n\n列表相关属性：\n\nlist-style：列表样式\nlist-style-type：列表项的样式类型\nlist-style-position：列表项的位置\n\n\n其他：\n\nvisibility：可见性\nquotes：引用样式\n\n\n\n2. 不可继承属性不可继承属性是指当一个元素的样式被设置时，其子元素不会自动继承这些样式。常见的不可继承属性包括：\n\n盒模型相关属性：\n\nmargin：外边距\npadding：内边距\nborder：边框\nwidth：宽度\nheight：高度\noverflow：溢出处理\n\n\n背景相关属性：\n\nbackground：背景样式\nbackground-color：背景颜色\nbackground-image：背景图像\nbackground-position：背景位置\nbackground-repeat：背景重复方式\n\n\n定位相关属性：\n\nposition：定位方式\ntop、right、bottom、left：定位偏移量\n\n\n显示相关属性：\n\ndisplay：显示类型\nvisibility：可见性（虽然可继承，但在某些情况下会被覆盖）\n\n\n其他：\n\nfloat：浮动\nclear：清除浮动\nz-index：堆叠顺序\n\n\n\n3. 继承的控制虽然某些属性是可继承的，但开发者可以通过使用 inherit、initial 和 unset 关键字来控制继承行为：\n\n**inherit**：强制子元素继承父元素的属性值。\n.child &#123;\n  color: inherit; &#x2F;* 继承父元素的颜色 *&#x2F;\n&#125;\n\n**initial**：将属性设置为其默认值。\n.child &#123;\n  color: initial; &#x2F;* 设置为默认颜色 *&#x2F;\n&#125;\n\n**unset**：将属性重置为其自然值（如果是可继承的则继承，如果是不可继承的则为初始值）。\n.child &#123;\n  color: unset; &#x2F;* 根据属性类型决定 *&#x2F;\n&#125;\n\n4. 总结\n可继承属性：如 color、font-family、line-height 等，子元素会自动继承父元素的样式。\n不可继承属性：如 margin、padding、border 等，子元素不会自动继承父元素的样式。\n通过使用 inherit、initial 和 unset 关键字，开发者可以控制属性的继承行为。\n\ndisplay 的属性值及其作用display 属性是 CSS 中一个非常重要的属性，用于控制元素的显示类型。它决定了元素在文档流中的表现方式，包括如何占据空间、如何与其他元素交互等。以下是 display 属性的常见值及其作用：\n1. 常见的 display 属性值1.1 block\n作用：将元素设置为块级元素。块级元素会在新行上开始，并占据整个行的宽度。\n示例：&lt;div&gt;、&lt;p&gt;、&lt;h1&gt; 到 &lt;h6&gt; 等默认都是块级元素。\n\ndiv &#123;\n  display: block;\n&#125;\n\n1.2 inline\n作用：将元素设置为行内元素。行内元素不会在新行上开始，只占据其内容的宽度。\n示例：&lt;span&gt;、&lt;a&gt;、&lt;strong&gt; 等默认都是行内元素。\n\nspan &#123;\n  display: inline;\n&#125;\n\n1.3 inline-block\n作用：将元素设置为行内块级元素。元素在同一行内显示，但可以设置宽度和高度。\n示例：适用于需要在同一行内排列的块级元素。\n\n.box &#123;\n  display: inline-block;\n  width: 100px;\n  height: 100px;\n&#125;\n\n1.4 none\n作用：完全隐藏元素，元素不会占据任何空间。\n示例：用于动态显示和隐藏元素。\n\n.hidden &#123;\n  display: none;\n&#125;\n\n1.5 flex\n作用：将元素设置为弹性盒子容器。允许使用 Flexbox 布局模型来控制子元素的排列和对齐。\n示例：适用于需要灵活布局的场景。\n\n.container &#123;\n  display: flex;\n&#125;\n\n1.6 grid\n作用：将元素设置为网格容器。允许使用 CSS Grid 布局模型来控制子元素的排列和对齐。\n示例：适用于需要网格布局的场景。\n\n.container &#123;\n  display: grid;\n&#125;\n\n1.7 table\n作用：将元素设置为表格元素，类似于 HTML 中的 &lt;table&gt; 元素。\n示例：用于创建表格布局。\n\n.table &#123;\n  display: table;\n&#125;\n\n1.8 table-row\n作用：将元素设置为表格行，类似于 HTML 中的 &lt;tr&gt; 元素。\n\n.row &#123;\n  display: table-row;\n&#125;\n\n1.9 table-cell\n作用：将元素设置为表格单元格，类似于 HTML 中的 &lt;td&gt; 元素。\n\n.cell &#123;\n  display: table-cell;\n&#125;\n\n2. 总结\ndisplay 属性用于控制元素的显示类型，影响元素在文档流中的表现。\n常见的值包括 block、inline、inline-block、none、flex、grid、table、table-row 和 table-cell。\n选择合适的 display 属性值可以帮助实现所需的布局和样式效果。\n\n隐藏元素的方法有哪些在 CSS 和 HTML 中，有多种方法可以隐藏元素。以下是一些常见的隐藏元素的方法及其适用场景：\n1. 使用 CSS display 属性\n**display: none;**：\n完全隐藏元素，元素不会占据任何空间。\n适用于需要动态显示和隐藏元素的场景。\n\n\n\n.hidden &#123;\n  display: none;\n&#125;\n\n2. 使用 CSS visibility 属性\n**visibility: hidden;**：\n隐藏元素，但仍然占据空间。元素在页面上不可见，但其位置仍然保留。\n适用于需要保留布局但不希望显示元素的场景。\n\n\n\n.hidden &#123;\n  visibility: hidden;\n&#125;\n\n3. 使用 CSS opacity 属性\n**opacity: 0;**：\n将元素的透明度设置为 0，使其不可见，但仍然占据空间并可以响应事件。\n适用于需要保留元素的布局和交互，但希望其不可见的场景。\n\n\n\n.hidden &#123;\n  opacity: 0;\n&#125;\n\n4. 使用 CSS position 属性\n**position: absolute; 和 left: -9999px;**：\n将元素移出视口，使其不可见，但仍然占据空间。\n适用于需要隐藏元素但仍希望其在 DOM 中存在的场景。\n\n\n\n.hidden &#123;\n  position: absolute;\n  left: -9999px;\n&#125;\n\n5. 使用 HTML 属性\nhidden 属性：\nHTML5 中的 hidden 属性可以直接在元素上使用，表示该元素是隐藏的。\n适用于需要在 HTML 中直接标记元素为隐藏的场景。\n\n\n\n&lt;div hidden&gt;这个元素是隐藏的&lt;&#x2F;div&gt;\n\n6. 使用 JavaScript\n通过 JavaScript 修改样式：\n可以使用 JavaScript 动态修改元素的样式来隐藏元素。\n\n\n\ndocument.getElementById(&quot;myElement&quot;).style.display &#x3D; &quot;none&quot;;\n\n\n通过 JavaScript 设置 hidden 属性：\n\ndocument.getElementById(&quot;myElement&quot;).hidden &#x3D; true;\n\n7. 使用媒体查询\n在响应式设计中使用媒体查询：\n根据视口大小隐藏元素，适用于响应式布局。\n\n\n\n@media (max-width: 600px) &#123;\n  .hidden &#123;\n    display: none;\n  &#125;\n&#125;\n\n8. 总结\n**display: none;**：完全隐藏元素，不占据空间。\n**visibility: hidden;**：隐藏元素，仍占据空间。\n**opacity: 0;**：元素透明，但仍占据空间。\n**position: absolute; left: -9999px;**：将元素移出视口。\nhidden 属性：HTML5 中的隐藏标记。\nJavaScript：动态修改样式或属性。\n媒体查询：根据视口大小隐藏元素。\n\nlink 和@import 的区别在 CSS 中，&lt;link&gt; 标签和 @import 语句都是用于引入外部样式表的方式，但它们之间有一些重要的区别。以下是对这两者的详细比较：\n1. &lt;link&gt; 标签\n用法：\n\n&lt;link&gt; 标签用于在 HTML 文档的 &lt;head&gt; 部分引入外部 CSS 文件。\n语法示例：&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;styles.css&quot; &#x2F;&gt;\n\n\n加载方式：\n\n&lt;link&gt; 标签在页面加载时并行加载样式表，这意味着它不会阻塞页面的渲染。\n浏览器会在解析 HTML 时立即请求和加载样式表。\n\n\n优先级：\n\n&lt;link&gt; 标签引入的样式表的优先级较高，尤其是在多个样式表存在时。\n\n\n适用场景：\n\n适用于在 HTML 文档中引入多个外部样式表，通常是推荐的方式。\n\n\n\n2. @import 语句\n用法：\n\n@import 语句用于在 CSS 文件中引入其他 CSS 文件。\n语法示例：@import url(&quot;styles.css&quot;);\n\n\n加载方式：\n\n@import 语句会在 CSS 文件被解析时加载样式表，这意味着它会阻塞页面的渲染，直到所有的样式表都被加载。\n这可能导致页面加载速度变慢，尤其是在有多个 @import 语句时。\n\n\n优先级：\n\n@import 引入的样式表的优先级较低，通常在同一 CSS 文件中定义的样式优先级更高。\n\n\n适用场景：\n\n适用于在 CSS 文件中组织和管理样式，尤其是在需要将样式分割成多个文件时。\n\n\n\n3. 主要区别总结\n\n\n特点\n&lt;link&gt; 标签\n@import 语句\n\n\n\n位置\n在 HTML 文档的 &lt;head&gt; 部分\n在 CSS 文件中\n\n\n加载方式\n并行加载，不阻塞渲染\n顺序加载，阻塞渲染\n\n\n优先级\n较高\n较低\n\n\n适用场景\n引入多个外部样式表\n在 CSS 文件中组织样式\n\n\n4. 总结\n使用 &lt;link&gt; 标签是引入外部样式表的推荐方式，因为它可以并行加载样式表，提升页面加载性能。\n@import 语句适合在 CSS 文件中组织样式，但由于其阻塞加载的特性，可能会影响页面的渲染速度。\n\ntransition 和 animation 的区别在 CSS 中，transition 和 animation 都用于创建元素的动态效果，但它们之间有一些重要的区别。以下是对这两者的详细比较：\n1. transition\n定义：transition 是一种用于在元素的状态变化时平滑过渡的效果。它允许你定义在特定属性变化时的过渡效果。\n\n用法：\n\n需要在元素的样式中定义 transition 属性，并指定要过渡的属性、持续时间、延迟等。\n\n语法示例：\n.box &#123;\n  width: 100px;\n  height: 100px;\n  background-color: blue;\n  transition: background-color 0.5s ease, width 0.5s ease;\n&#125;\n\n.box:hover &#123;\n  background-color: red;\n  width: 200px;\n&#125;\n\n\n触发方式：\n\ntransition 通常在元素的状态变化时触发，例如通过伪类（如 :hover、:focus）或 JavaScript 事件。\n\n\n控制：\n\n过渡效果是一次性的，通常只在状态变化时发生。\n\n\n\n2. animation\n定义：animation 是一种更复杂的效果，允许你创建多帧动画。它可以在元素的生命周期内持续运行，并且可以定义多个关键帧。\n\n用法：\n\n需要定义 @keyframes 规则来描述动画的关键帧，然后在元素的样式中使用 animation 属性来应用动画。\n\n语法示例：\n@keyframes example &#123;\n  0% &#123;\n    background-color: blue;\n    width: 100px;\n  &#125;\n  50% &#123;\n    background-color: red;\n    width: 200px;\n  &#125;\n  100% &#123;\n    background-color: blue;\n    width: 100px;\n  &#125;\n&#125;\n\n.box &#123;\n  animation: example 2s infinite;\n&#125;\n\n\n触发方式：\n\nanimation 可以在页面加载时自动开始，也可以通过 JavaScript 控制开始和停止。\n\n\n控制：\n\n动画可以循环、反向播放、延迟等，提供更丰富的控制选项。\n\n\n\n3. 主要区别总结\n\n\n特点\ntransition\nanimation\n\n\n\n定义\n用于状态变化的平滑过渡\n用于创建多帧动画\n\n\n用法\n通过 transition 属性定义\n通过 @keyframes 和 animation 属性定义\n\n\n触发方式\n状态变化时触发（如 :hover）\n可以自动开始或通过 JavaScript 控制\n\n\n控制\n一次性过渡\n可以循环、反向播放、延迟等\n\n\n4. 总结\ntransition 适合用于简单的状态变化效果，提供平滑的过渡。\nanimation 适合用于更复杂的动画效果，允许定义多个关键帧和丰富的控制选项。\n\n伪元素和伪类的区别和作用？在 CSS 中，伪元素和伪类都是用于选择和样式化元素的特殊选择器，但它们的用途和语法有所不同。以下是对伪元素和伪类的详细比较，包括它们的定义、作用和主要区别。\n1. 伪类（Pseudo-class）\n定义：伪类是用于选择处于特定状态的元素的选择器。它们通常用于表示元素的交互状态或特定条件下的样式。\n\n语法：伪类以冒号（:）开头，后面跟着伪类的名称。\n\n常见的伪类：\n\n:hover：当鼠标悬停在元素上时应用样式。\n:focus：当元素获得焦点时应用样式（如输入框）。\n:active：当元素被激活（如被点击）时应用样式。\n:nth-child(n)：选择父元素的第 n 个子元素。\n:first-child：选择父元素的第一个子元素。\n:last-child：选择父元素的最后一个子元素。\n\n\n示例：\na:hover &#123;\n  color: red; &#x2F;* 当鼠标悬停在链接上时，链接变为红色 *&#x2F;\n&#125;\n\n2. 伪元素（Pseudo-element）\n定义：伪元素用于选择元素的特定部分或创建虚拟元素。它们允许开发者对元素的某些部分进行样式化，而不需要在 HTML 中添加额外的元素。\n\n语法：伪元素以双冒号（::）开头，后面跟着伪元素的名称（在 CSS2 中使用单冒号 :，但在 CSS3 中推荐使用双冒号）。\n\n常见的伪元素：\n\n::before：在元素的内容之前插入内容。\n::after：在元素的内容之后插入内容。\n::first-line：选择元素的第一行文本。\n::first-letter：选择元素的第一个字母。\n\n\n示例：\np::first-line &#123;\n  font-weight: bold; &#x2F;* 将段落的第一行文本加粗 *&#x2F;\n&#125;\n\n3. 主要区别总结\n\n\n特点\n伪类（Pseudo-class）\n伪元素（Pseudo-element）\n\n\n\n定义\n选择处于特定状态的元素\n选择元素的特定部分或创建虚拟元素\n\n\n语法\n以单冒号 : 开头\n以双冒号 :: 开头\n\n\n作用\n用于表示元素的交互状态\n用于样式化元素的特定部分\n\n\n示例\na:hover\np::first-line\n\n\n4. 总结\n伪类 主要用于选择元素在特定状态下的样式，适合处理用户交互。\n伪元素 主要用于选择元素的特定部分或创建虚拟内容，适合对元素的结构进行样式化。\n\n对 requestAnimationframe 的理解requestAnimationFrame 是一个用于创建高效动画的 JavaScript 方法。它提供了一种在浏览器的下一个重绘周期中执行动画的机制，能够提高动画的性能和流畅度。以下是对 requestAnimationFrame 的详细理解，包括其工作原理、优点和使用示例。\n1. 工作原理\n浏览器优化：requestAnimationFrame 告诉浏览器你希望在下一个重绘周期执行一个动画。浏览器会在适当的时间调用指定的回调函数，通常是在浏览器准备好重绘时。\n帧率控制：使用 requestAnimationFrame 可以使动画与浏览器的刷新率同步，通常为 60fps（每秒 60 帧），从而避免了由于 JavaScript 的执行时间不一致而导致的动画卡顿。\n自动暂停：当用户切换到其他标签页时，requestAnimationFrame 会自动暂停，避免了不必要的计算和资源浪费。\n\n2. 优点\n性能优化：由于 requestAnimationFrame 与浏览器的重绘周期同步，能够有效减少 CPU 和 GPU 的负担，提高动画的性能。\n流畅度：通过与浏览器的刷新率同步，动画效果更加平滑，避免了使用 setTimeout 或 setInterval 时可能出现的抖动和不一致。\n节省资源：在不需要更新动画时（如用户切换标签页），requestAnimationFrame 会自动停止调用，从而节省资源。\n\n3. 使用示例以下是一个简单的使用 requestAnimationFrame 创建动画的示例：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;requestAnimationFrame 示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      #box &#123;\n        width: 100px;\n        height: 100px;\n        background-color: blue;\n        position: absolute;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;script&gt;\n      const box &#x3D; document.getElementById(&quot;box&quot;);\n      let position &#x3D; 0;\n\n      function animate() &#123;\n        position +&#x3D; 2; &#x2F;&#x2F; 每次移动 2 像素\n        box.style.transform &#x3D; &#96;translateX($&#123;position&#125;px)&#96;;\n\n        &#x2F;&#x2F; 当 box 移动到屏幕外时重置位置\n        if (position &lt; window.innerWidth) &#123;\n          requestAnimationFrame(animate); &#x2F;&#x2F; 请求下一帧\n        &#125; else &#123;\n          position &#x3D; 0; &#x2F;&#x2F; 重置位置\n          requestAnimationFrame(animate); &#x2F;&#x2F; 重新开始动画\n        &#125;\n      &#125;\n\n      requestAnimationFrame(animate); &#x2F;&#x2F; 启动动画\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结\nrequestAnimationFrame 是一个用于创建高效动画的 JavaScript 方法，能够与浏览器的重绘周期同步，提供流畅的动画效果。\n它的优点包括性能优化、流畅度和资源节省，适合用于需要频繁更新的动画场景。\n使用 requestAnimationFrame 可以显著提高动画的表现，避免使用传统的定时器方法（如 setTimeout 和 setInterval）时可能出现的问题。\n\n对盒模型的理解在 CSS 中，盒模型（Box Model）是一个重要的概念，用于描述网页元素的布局和尺寸。每个 HTML 元素都被视为一个矩形盒子，盒模型定义了这个盒子的内容、内边距、边框和外边距。理解盒模型对于网页设计和布局至关重要。以下是对盒模型的详细理解：\n1. 盒模型的组成部分盒模型主要由以下四个部分组成：\n\n内容（Content）：\n\n这是盒子的实际内容区域，包含文本、图像等。\n内容的大小由 width 和 height 属性控制。\n\n\n内边距（Padding）：\n\n内边距是内容与边框之间的空间，用于增加内容的可读性。\n内边距的大小可以通过 padding 属性设置，可以单独设置四个方向的内边距（padding-top、padding-right、padding-bottom、padding-left）。\n\n\n边框（Border）：\n\n边框是围绕内容和内边距的线条，可以设置边框的宽度、样式和颜色。\n边框的大小可以通过 border 属性设置，可以单独设置四个方向的边框（border-top、border-right、border-bottom、border-left）。\n\n\n外边距（Margin）：\n\n外边距是盒子与其他元素之间的空间，用于控制元素之间的距离。\n外边距的大小可以通过 margin 属性设置，可以单独设置四个方向的外边距（margin-top、margin-right、margin-bottom、margin-left）。\n\n\n\n2. 盒模型的示意图+---------------------------+\n|         Margin            |  &lt;-- 外边距\n|  +---------------------+  |\n|  |      Border         |  |  &lt;-- 边框\n|  |  +--------------+   |  |\n|  |  |   Padding    |   |  |  &lt;-- 内边距\n|  |  |  +--------+  |   |  |\n|  |  |  | Content |  |   |  |\n|  |  |  +--------+  |   |  |\n|  |  +--------------+   |  |\n|  +---------------------+  |\n+---------------------------+\n\n3. 盒模型的计算在 CSS 中，盒模型的计算方式会影响元素的实际尺寸。默认情况下，盒模型的计算方式是 标准盒模型（content-box），即 width 和 height 只包括内容区域，不包括内边距、边框和外边距。\n\n标准盒模型（content-box）：\n\nwidth 和 height 只包括内容区域。\n计算公式：总宽度 &#x3D; width + padding-left + padding-right + border-left + border-right + margin-left + margin-right\n总高度 &#x3D; height + padding-top + padding-bottom + border-top + border-bottom + margin-top + margin-bottom\n\n\n替代盒模型（border-box）：\n\n使用 box-sizing: border-box; 可以改变盒模型的计算方式，使 width 和 height 包括内边距和边框。\n计算公式：总宽度 &#x3D; width (包括内边距和边框)\n总高度 &#x3D; height (包括内边距和边框)\n\n\n\n4. 使用示例.box &#123;\n  width: 200px; &#x2F;* 内容宽度 *&#x2F;\n  height: 100px; &#x2F;* 内容高度 *&#x2F;\n  padding: 20px; &#x2F;* 内边距 *&#x2F;\n  border: 5px solid black; &#x2F;* 边框 *&#x2F;\n  margin: 10px; &#x2F;* 外边距 *&#x2F;\n  box-sizing: border-box; &#x2F;* 使用替代盒模型 *&#x2F;\n&#125;\n\n5. 总结\n盒模型 是 CSS 中描述元素布局和尺寸的基本概念，由内容、内边距、边框和外边距组成。\n理解盒模型的组成部分和计算方式对于网页设计和布局至关重要，能够帮助开发者更好地控制元素的显示和间距。\n使用 box-sizing 属性可以改变盒模型的计算方式，提供更灵活的布局控制。\n\n为什么有时候⽤ translate 来改变位置⽽不是定位？在 CSS 中，使用 translate 来改变元素的位置与使用定位（如 position: absolute、position: relative 等）有不同的效果和优点。以下是一些原因，说明为什么在某些情况下选择使用 translate 而不是传统的定位方法：\n1. 性能优化\nGPU 加速：使用 transform: translate() 可以利用 GPU 加速，特别是在动画和过渡效果中。浏览器通常会将使用 transform 的元素放入合成层，从而提高渲染性能，减少卡顿。\n流畅的动画：translate 使得动画更加流畅，因为它不会影响文档流，浏览器可以更高效地处理这些变换。\n\n2. 不影响文档流\n保持布局：使用 translate 不会改变元素在文档流中的位置。元素仍然占据原来的空间，这意味着其他元素不会受到影响。这在需要保持布局一致性时非常有用。\n避免重排：使用 translate 不会导致浏览器重排（reflow），而使用定位可能会导致重排，影响性能。\n\n3. 简化布局\n简化定位：在某些情况下，使用 translate 可以简化布局。例如，当需要在某个元素的基础上进行小幅度移动时，使用 translate 可以避免复杂的定位计算。\n响应式设计：在响应式设计中，使用 translate 可以更容易地调整元素的位置，而不需要重新计算其绝对或相对位置。\n\n4. 组合变换\n多重变换：transform 属性允许组合多种变换（如旋转、缩放、倾斜等），这使得在动画和交互效果中更灵活。例如，可以同时使用 translate 和 rotate 来实现复杂的效果。\n\n.element &#123;\n  transform: translate(50px, 100px) rotate(45deg);\n&#125;\n\n5. 适用场景\n动画和过渡：在需要平滑过渡或动画效果时，translate 是一个理想的选择。\n悬浮效果：在悬浮效果中，使用 translate 可以轻松实现元素的移动，而不影响其他元素的布局。\n\n6. 示例.box &#123;\n  width: 100px;\n  height: 100px;\n  background-color: blue;\n  position: relative; &#x2F;* 仍然可以使用定位 *&#x2F;\n  transition: transform 0.3s; &#x2F;* 添加过渡效果 *&#x2F;\n&#125;\n\n.box:hover &#123;\n  transform: translate(20px, 20px); &#x2F;* 鼠标悬停时移动 *&#x2F;\n&#125;\n\n7. 总结\n使用 translate 来改变元素的位置在性能、布局和动画效果上具有明显的优势。\ntranslate 不会影响文档流，避免了重排，适合用于动画和响应式设计。\n在需要保持元素原始位置的同时进行小幅度移动时，translate 是一个理想的选择。\n\nli 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？在 HTML 中，&lt;li&gt;（列表项）之间的空白间隔通常是由以下几个原因引起的：\n1. 默认的 margin 和 padding\n浏览器的默认样式：大多数浏览器对 &lt;ul&gt; 和 &lt;ol&gt; 列表及其子元素 &lt;li&gt; 应用了一些默认的 margin 和 padding。这可能导致列表项之间出现额外的空白。\n\n2. 行内元素的空白\n行内元素的空白：如果 &lt;li&gt; 元素的内容是行内元素（如文本或 &lt;span&gt;），在 HTML 源代码中，&lt;li&gt; 标签之间的空格、换行或其他空白字符会被浏览器渲染为空白。这是因为 HTML 中的空白字符（如空格、换行）在渲染时会被视为实际的空白。\n\n3. 解决方法以下是几种常见的解决方法，可以消除或减少 &lt;li&gt; 之间的空白间隔：\n1. 使用 CSS 重置 margin 和 padding可以通过 CSS 重置 &lt;ul&gt; 和 &lt;ol&gt; 的 margin 和 padding，以及 &lt;li&gt; 的 margin 和 padding：\nul,\nol &#123;\n  margin: 0; &#x2F;* 重置外边距 *&#x2F;\n  padding: 0; &#x2F;* 重置内边距 *&#x2F;\n&#125;\n\nli &#123;\n  margin: 0; &#x2F;* 重置外边距 *&#x2F;\n  padding: 0; &#x2F;* 重置内边距 *&#x2F;\n&#125;\n\n2. 使用 display: flex 或 display: grid使用 Flexbox 或 Grid 布局可以更好地控制列表项之间的间距：\nul &#123;\n  display: flex; &#x2F;* 或 display: grid; *&#x2F;\n  list-style-type: none; &#x2F;* 去掉默认的列表样式 *&#x2F;\n  padding: 0; &#x2F;* 重置内边距 *&#x2F;\n&#125;\n\nli &#123;\n  margin: 0; &#x2F;* 重置外边距 *&#x2F;\n  padding: 0; &#x2F;* 重置内边距 *&#x2F;\n&#125;\n\n3. 移除 HTML 中的空白字符在 HTML 中，确保 &lt;li&gt; 标签之间没有多余的空格或换行：\n&lt;ul&gt;\n  &lt;li&gt;项 1&lt;&#x2F;li&gt;\n  &lt;li&gt;项 2&lt;&#x2F;li&gt;\n  &lt;li&gt;项 3&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n4. 使用 font-size: 0（仅适用于特定情况）在某些情况下，可以将父元素的 font-size 设置为 0，然后为子元素恢复字体大小。这可以消除行内元素之间的空白，但要小心使用，因为这会影响所有子元素的字体大小。\nul &#123;\n  font-size: 0; &#x2F;* 消除空白 *&#x2F;\n&#125;\n\nli &#123;\n  font-size: 16px; &#x2F;* 恢复字体大小 *&#x2F;\n&#125;\n\n4. 示例以下是一个完整的示例，展示了如何消除 &lt;li&gt; 之间的空白间隔：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;消除空白间隔示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      ul &#123;\n        margin: 0;\n        padding: 0;\n        list-style-type: none; &#x2F;* 去掉默认的列表样式 *&#x2F;\n      &#125;\n\n      li &#123;\n        margin: 0;\n        padding: 10px; &#x2F;* 添加内边距 *&#x2F;\n        background-color: lightblue; &#x2F;* 背景颜色 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;ul&gt;\n      &lt;li&gt;项 1&lt;&#x2F;li&gt;\n      &lt;li&gt;项 2&lt;&#x2F;li&gt;\n      &lt;li&gt;项 3&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5. 总结\n&lt;li&gt; 之间的空白间隔通常是由浏览器的默认样式、行内元素的空白字符引起的。\n可以通过重置 margin 和 padding、使用 Flexbox 或 Grid 布局、移除 HTML 中的空白字符等方法来解决这个问题。\n\nCSS3 中有哪些新特性在 CSS3 中，引入了许多新特性和功能，极大地增强了网页设计的灵活性和表现力。以下是一些主要的新特性：\n1. 选择器\n新增选择器：\n:nth-child(n)：选择父元素的第 n 个子元素。\n:nth-of-type(n)：选择父元素中指定类型的第 n 个子元素。\n:last-child、:first-child、:first-of-type、:last-of-type：选择特定位置的子元素。\n:not(selector)：选择不匹配指定选择器的元素。\n\n\n\n2. 盒模型\n**box-sizing**：\n允许开发者控制盒模型的计算方式，使用 box-sizing: border-box; 可以使 width 和 height 包括内边距和边框。\n\n\n\n3. 背景和边框\n多重背景：\n\n支持为元素设置多个背景图像。\n\nbackground-image: url(&quot;image1.png&quot;), url(&quot;image2.png&quot;);\n\n圆角边框：\n\n使用 border-radius 属性可以轻松创建圆角效果。\n\nborder-radius: 10px;\n\n阴影效果：\n\n使用 box-shadow 和 text-shadow 属性可以为元素和文本添加阴影效果。box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);\ntext-shadow: 1px 1px 2px #000;\n\n\n\n4. 文本效果\n文本溢出：\n\n使用 text-overflow 属性可以控制文本溢出时的显示方式。\n\ntext-overflow: ellipsis; &#x2F;* 显示省略号 *&#x2F;\n\n字体特性：\n\n引入了 @font-face 规则，允许使用自定义字体。@font-face &#123;\n  font-family: &quot;MyFont&quot;;\n  src: url(&quot;myfont.woff2&quot;) format(&quot;woff2&quot;);\n&#125;\n\n\n\n5. 变换和过渡\n2D 和 3D 变换：\n\n使用 transform 属性可以对元素进行平移、旋转、缩放和倾斜等变换。\n\ntransform: translate(50px, 100px) rotate(45deg);\n\n过渡效果：\n\n使用 transition 属性可以在属性变化时添加平滑过渡效果。transition: background-color 0.3s ease;\n\n\n\n6. 动画\n关键帧动画：\n使用 @keyframes 定义动画的关键帧，并通过 animation 属性应用动画。@keyframes myAnimation &#123;\n  from &#123;\n    opacity: 0;\n  &#125;\n  to &#123;\n    opacity: 1;\n  &#125;\n&#125;\nanimation: myAnimation 2s;\n\n\n\n7. Flexbox 布局\n弹性盒子布局：\n使用 display: flex; 可以创建灵活的布局，支持元素的对齐和分布。.container &#123;\n  display: flex;\n  justify-content: space-between;\n&#125;\n\n\n\n8. 网格布局\nCSS Grid 布局：\n使用 display: grid; 可以创建复杂的二维布局。.grid-container &#123;\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n&#125;\n\n\n\n9. 媒体查询\n响应式设计：\n媒体查询允许根据设备的特性（如宽度、高度、分辨率等）应用不同的样式。@media (max-width: 600px) &#123;\n  body &#123;\n    background-color: lightblue;\n  &#125;\n&#125;\n\n\n\n10. 其他特性\n渐变背景：\n\n使用 linear-gradient 和 radial-gradient 创建渐变背景。\n\nbackground: linear-gradient(to right, red, blue);\n\n阴影和滤镜：\n\n使用 filter 属性可以应用图像滤镜效果。filter: blur(5px);\n\n\n\n替换元素的概念及计算规则在 CSS 中，替换元素（Replaced Elements）是指那些其内容由外部资源提供的元素。这些元素的内容不是由 HTML 文档中的文本或子元素直接定义的，而是由外部文件（如图像、视频等）提供。常见的替换元素包括 &lt;img&gt;、&lt;input&gt;、&lt;video&gt;、&lt;iframe&gt; 等。\n1. 替换元素的特点\n内容来源：替换元素的内容通常来自外部资源，而不是直接在 HTML 中定义的内容。\n尺寸计算：替换元素的尺寸（宽度和高度）通常由其内容决定，而不是由 CSS 中的 width 和 height 属性直接控制。\n不参与文本流：替换元素的内容不会影响周围文本的布局，通常会在文档流中占据一个矩形区域。\n\n2. 替换元素的计算规则替换元素的计算规则主要涉及其尺寸和布局。以下是一些关键点：\n2.1 尺寸计算\n默认尺寸：替换元素的默认宽度和高度通常由其内容决定。例如，&lt;img&gt; 元素的尺寸由图像的实际尺寸决定。\nCSS 控制：可以使用 CSS 的 width 和 height 属性来控制替换元素的尺寸，但这可能会导致内容失真（例如，拉伸或压缩图像）。\n自动尺寸：如果未设置 width 和 height，替换元素会根据其内容的自然尺寸自动调整。\n\n2.2 盒模型\n替换元素的盒模型与其他元素相似，但其内容区域的计算方式不同。替换元素的内容区域通常是由外部资源的尺寸决定的。\n可以使用 margin、padding 和 border 属性来控制替换元素的外观和布局。\n\n2.3 影响布局\n替换元素在文档流中占据一个矩形区域，但其内容不会影响周围文本的布局。\n替换元素的对齐和位置可以通过 CSS 的 vertical-align 和 float 属性进行控制。\n\n3. 示例以下是一个简单的示例，展示了替换元素的使用：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;替换元素示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      img &#123;\n        width: 200px; &#x2F;* 控制图像的宽度 *&#x2F;\n        height: auto; &#x2F;* 保持图像的纵横比 *&#x2F;\n        border: 2px solid black; &#x2F;* 添加边框 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;替换元素示例&lt;&#x2F;h1&gt;\n    &lt;img src&#x3D;&quot;example.jpg&quot; alt&#x3D;&quot;示例图像&quot; &#x2F;&gt;\n    &lt;p&gt;这是一个段落，替换元素不会影响文本的布局。&lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结\n替换元素 是指其内容由外部资源提供的元素，如 &lt;img&gt;、&lt;input&gt;、&lt;video&gt; 等。\n替换元素的尺寸通常由其内容决定，可以使用 CSS 控制，但可能导致内容失真。\n替换元素在文档流中占据一个矩形区域，但其内容不会影响周围文本的布局。\n\n常见的图片格式及使用场景在网页设计和开发中，选择合适的图片格式对于图像质量、加载速度和用户体验至关重要。以下是一些常见的图片格式及其适用场景：\n1. JPEG (Joint Photographic Experts Group)\n特点：\n\n有损压缩，能够有效减小文件大小。\n支持 16.7 百万种颜色，适合复杂的图像（如照片）。\n不支持透明度。\n\n\n使用场景：\n\n适合用于照片、风景图像和复杂的图像内容。\n常用于网页中的背景图像和产品图片。\n\n\n\n2. PNG (Portable Network Graphics)\n特点：\n\n无损压缩，保留图像质量。\n支持透明度（包括 alpha 通道），适合需要透明背景的图像。\n文件大小通常比 JPEG 大。\n\n\n使用场景：\n\n适合用于图标、图形、插图和需要透明背景的图像。\n常用于网页中的图标、按钮和界面元素。\n\n\n\n3. GIF (Graphics Interchange Format)\n特点：\n\n支持动画，能够在同一文件中包含多帧图像。\n采用无损压缩，但颜色限制在 256 种颜色（8 位）。\n支持透明度，但不支持半透明。\n\n\n使用场景：\n\n适合用于简单的动画和小型图像（如图标和表情符号）。\n常用于社交媒体和网页中的小动画。\n\n\n\n4. SVG (Scalable Vector Graphics)\n特点：\n\n基于 XML 的矢量图形格式，支持无限缩放而不失真。\n文件大小通常较小，适合简单图形和图标。\n支持动画和交互。\n\n\n使用场景：\n\n适合用于图标、图形、插图和需要缩放的图像。\n常用于网页中的图标、图形和响应式设计。\n\n\n\n5. WebP\n特点：\n\n支持有损和无损压缩，能够提供更小的文件大小。\n支持透明度和动画。\n兼容性较新，部分旧浏览器可能不支持。\n\n\n使用场景：\n\n适合用于需要高质量和小文件大小的图像。\n常用于现代网页设计，尤其是在需要优化加载速度的场景。\n\n\n\n6. BMP (Bitmap)\n特点：\n\n无压缩或简单压缩的位图格式，文件大小通常较大。\n不支持透明度。\n\n\n使用场景：\n\n主要用于 Windows 系统中的图像处理，网页中不常用。\n\n\n\n7. TIFF (Tagged Image File Format)\n特点：\n\n支持无损压缩，适合高质量图像。\n文件大小通常较大，支持多种颜色深度。\n\n\n使用场景：\n\n主要用于印刷和专业摄影，网页中不常用。\n\n\n\n总结\n\n\n图片格式\n特点\n使用场景\n\n\n\nJPEG\n有损压缩，适合照片\n照片、背景图像\n\n\nPNG\n无损压缩，支持透明\n图标、插图、需要透明的图像\n\n\nGIF\n支持动画，256 色限制\n动画、简单图像\n\n\nSVG\n矢量图形，无失真\n图标、图形、响应式设计\n\n\nWebP\n有损&#x2F;无损压缩，支持透明和动画\n现代网页设计\n\n\nBMP\n大文件，无压缩\n不常用于网页\n\n\nTIFF\n高质量，无损\n专业摄影、印刷\n\n\n对 CSSSprites 的理解CSS Sprites 是一种优化网页性能的技术，通过将多个图像合并成一张大图像（称为“精灵图”），从而减少 HTTP 请求的数量，提高页面加载速度。以下是对 CSS Sprites 的详细理解，包括其工作原理、优点、使用方法和示例。\n1. 工作原理\n合并图像：将多个小图像（如图标、按钮、背景等）合并成一张大图像。这样，浏览器只需加载一张图像，而不是多个小图像。\n使用 CSS 定位：通过 CSS 的 background-image 和 background-position 属性来显示精灵图中的特定部分。通过调整背景位置，可以显示合并图像中的不同部分。\n\n2. 优点\n减少 HTTP 请求：合并图像后，浏览器只需发起一次请求来加载精灵图，减少了请求的数量，从而提高了页面加载速度。\n提高性能：减少请求数量可以降低服务器负担，提高页面响应速度，尤其是在移动设备上。\n更好的管理：将多个图像合并为一张图像可以更方便地管理和维护图像资源。\n\n3. 使用方法3.1 创建精灵图使用图像编辑工具（如 Photoshop、GIMP 或在线工具）将多个小图像合并为一张大图像。\n3.2 使用 CSS 定义背景使用 CSS 设置精灵图的背景图像，并通过 background-position 属性来显示特定的图像部分。\n4. 示例假设我们有一个精灵图 sprite.png，其中包含三个图标（图标 1、图标 2、图标 3），它们的尺寸为 50x50 像素，合并后的图像宽度为 150 像素。\n.icon &#123;\n  background-image: url(&quot;sprite.png&quot;);\n  background-repeat: no-repeat;\n  display: inline-block; &#x2F;* 使元素成为块级元素 *&#x2F;\n  width: 50px; &#x2F;* 图标宽度 *&#x2F;\n  height: 50px; &#x2F;* 图标高度 *&#x2F;\n&#125;\n\n&#x2F;* 图标1 *&#x2F;\n.icon1 &#123;\n  background-position: 0 0; &#x2F;* 精灵图中的位置 *&#x2F;\n&#125;\n\n&#x2F;* 图标2 *&#x2F;\n.icon2 &#123;\n  background-position: -50px 0; &#x2F;* 精灵图中的位置 *&#x2F;\n&#125;\n\n&#x2F;* 图标3 *&#x2F;\n.icon3 &#123;\n  background-position: -100px 0; &#x2F;* 精灵图中的位置 *&#x2F;\n&#125;\n\n5. HTML 示例&lt;div class&#x3D;&quot;icon icon1&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;icon icon2&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;icon icon3&quot;&gt;&lt;&#x2F;div&gt;\n\n6. 注意事项\n图像尺寸：确保合并后的图像尺寸合理，避免过大的精灵图导致加载时间增加。\n维护：在更新图标时，可能需要重新生成精灵图并更新 CSS。\n响应式设计：在响应式设计中，可能需要考虑不同屏幕尺寸下的图标显示。\n\n7. 总结CSS Sprites 是一种有效的性能优化技术，通过将多个小图像合并为一张大图像，减少 HTTP 请求，提高页面加载速度。使用 CSS 的 background-image 和 background-position 属性，可以灵活地显示精灵图中的不同部分。理解和应用 CSS Sprites 可以显著提升网页的性能和用户体验。\n什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x 这种图片？在移动端开发中，理解物理像素、逻辑像素和像素密度的概念是非常重要的。这些概念直接影响到图像的显示质量和用户体验。以下是对这些术语的详细解释，以及为什么需要使用 @2x、@3x 这种图片的原因。\n1. 物理像素（Physical Pixels）\n定义：物理像素是显示设备上实际存在的最小单元，通常是显示屏上可以点亮的最小点。每个物理像素由显示器的硬件决定，通常以点（dpi）或像素（px）为单位。\n特点：物理像素的数量取决于显示设备的分辨率。例如，一个 1920x1080 的显示器有 1920 个水平物理像素和 1080 个垂直物理像素。\n\n2. 逻辑像素（Logical Pixels）\n定义：逻辑像素是开发者在编写代码时使用的单位，通常与 CSS 中的像素（px）相对应。逻辑像素是一个抽象的概念，表示在不同设备上显示的相对大小。\n特点：逻辑像素的数量与设备的像素密度有关。在高像素密度的设备上，逻辑像素的大小会被缩小，以便在屏幕上显示更清晰的图像。\n\n3. 像素密度（Pixel Density）\n定义：像素密度是指每英寸（dpi）显示的物理像素数量，通常用 PPI（Pixels Per Inch）表示。像素密度越高，图像和文本的显示效果越清晰。\n特点：高像素密度的设备（如 Retina 显示屏）会在同样的物理尺寸下显示更多的逻辑像素。例如，Retina 显示屏的像素密度通常是标准显示屏的 2 倍或 3 倍。\n\n4. @2x 和 @3x 图片的使用在移动端开发中，使用 @2x 和 @3x 这种图片是为了适应不同的像素密度设备，确保图像在高分辨率屏幕上显示清晰。\n\n@2x 图片：表示该图像的物理尺寸是逻辑尺寸的 2 倍，适用于像素密度为 2 的设备（如 Retina 显示屏）。\n@3x 图片：表示该图像的物理尺寸是逻辑尺寸的 3 倍，适用于像素密度为 3 的设备（如某些高端智能手机）。\n\n5. 示例假设你有一个逻辑像素为 100x100 的图标：\n\n@1x：图标的实际尺寸为 100x100 像素。\n@2x：图标的实际尺寸为 200x200 像素，适用于像素密度为 2 的设备。\n@3x：图标的实际尺寸为 300x300 像素，适用于像素密度为 3 的设备。\n\n6. 总结\n物理像素 是显示设备上实际存在的最小单元，逻辑像素 是开发者使用的单位，像素密度 是每英寸显示的物理像素数量。\n在移动端开发中，使用 @2x 和 @3x 图片可以确保图像在高分辨率设备上显示清晰，提升用户体验。\n\nmargin 和 padding 的使用场景在 CSS 中，margin 和 padding 是两个重要的属性，用于控制元素的外部和内部间距。它们的使用场景和目的有所不同。以下是对 margin 和 padding 的详细解释及其使用场景。\n1. margin\n定义：margin 是元素外部的空间，用于控制元素与其他元素之间的距离。它可以影响元素在文档流中的位置。\n\n特点：\n\nmargin 是透明的，不会影响元素的背景颜色。\n可以设置四个方向的外边距：margin-top、margin-right、margin-bottom、margin-left，也可以使用简写属性 margin。\n\n\n使用场景：\n\n分隔元素：用于在元素之间创建空间，避免元素紧贴在一起。例如，在列表项之间添加外边距。\n居中对齐：在块级元素上使用 margin: auto; 可以实现水平居中对齐。\n外部布局：用于控制元素与其父元素或其他兄弟元素之间的距离，适合在布局中使用。\n\n\n\n2. padding\n定义：padding 是元素内部的空间，用于控制元素内容与其边框之间的距离。它可以影响元素的实际尺寸。\n\n特点：\n\npadding 是不透明的，会影响元素的背景颜色。\n可以设置四个方向的内边距：padding-top、padding-right、padding-bottom、padding-left，也可以使用简写属性 padding。\n\n\n使用场景：\n\n增加可读性：在文本元素（如段落、按钮）周围添加内边距，以提高可读性和点击区域。\n背景效果：在元素中使用 padding 可以确保背景颜色或图像不会紧贴内容，提供更好的视觉效果。\n按钮样式：在按钮上使用 padding 来增加点击区域，使按钮看起来更大，更易于点击。\n\n\n\n3. 示例以下是一个简单的示例，展示了 margin 和 padding 的使用：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Margin 和 Padding 示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .box &#123;\n        background-color: lightblue;\n        margin: 20px; &#x2F;* 外边距 *&#x2F;\n        padding: 15px; &#x2F;* 内边距 *&#x2F;\n        border: 2px solid blue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;box&quot;&gt;这是一个带有外边距和内边距的盒子。&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结\nmargin 用于控制元素与其他元素之间的外部间距，适合用于分隔元素和布局。\npadding 用于控制元素内部内容与边框之间的间距，适合用于提高可读性和视觉效果。\n\n对 line-height 的理解及其赋值方式line-height 是 CSS 中一个重要的属性，用于控制文本行之间的垂直间距。它影响文本的可读性和整体布局。以下是对 line-height 的详细理解，包括其作用、赋值方式和使用场景。\n1. line-height 的作用\n控制行间距：line-height 定义了文本行之间的距离，影响文本的垂直对齐和可读性。\n影响文本块的高度：line-height 会影响包含文本的元素的高度，增加行间距会使元素的高度增大。\n提高可读性：适当的行间距可以提高文本的可读性，尤其是在长段落或小字体时。\n\n2. 赋值方式line-height 可以通过多种方式赋值，主要有以下几种：\n2.1 数值（无单位）\n定义：使用无单位的数值（如 1.5）来设置行高。这个数值是相对于元素的字体大小的倍数。\n示例：p &#123;\n  line-height: 1.5; &#x2F;* 行高为字体大小的 1.5 倍 *&#x2F;\n&#125;\n\n2.2 长度单位\n定义：使用具体的长度单位（如 px、em、rem 等）来设置行高。\n示例：p &#123;\n  line-height: 24px; &#x2F;* 行高为 24 像素 *&#x2F;\n&#125;\n\n2.3 百分比\n定义：使用百分比来设置行高，百分比是相对于元素的字体大小。\n示例：p &#123;\n  line-height: 150%; &#x2F;* 行高为字体大小的 150% *&#x2F;\n&#125;\n\n3. 使用场景\n段落文本：在段落文本中，适当的 line-height 可以提高可读性，避免行与行之间过于紧凑。\n标题和副标题：在标题和副标题中，使用较大的 line-height 可以增强视觉效果，使文本更具层次感。\n列表和表格：在列表和表格中，适当的行高可以使内容更整齐，便于阅读。\n\n4. 示例以下是一个简单的示例，展示了如何使用 line-height：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Line Height 示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      p &#123;\n        font-size: 16px; &#x2F;* 字体大小 *&#x2F;\n        line-height: 1.5; &#x2F;* 行高为字体大小的 1.5 倍 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;p&gt;\n      这是一个段落，使用了适当的行高来提高可读性。行高的设置可以影响文本的整体布局和视觉效果。\n    &lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5. 总结\nline-height 是用于控制文本行之间垂直间距的 CSS 属性，影响文本的可读性和布局。\n可以通过无单位数值、长度单位和百分比来赋值。\n适当的行高设置可以提高文本的可读性，增强视觉效果。\n\nCSS 优化和提高性能的方法有哪些？在网页开发中，优化 CSS 和提高性能是确保网站快速加载和良好用户体验的重要步骤。以下是一些常见的 CSS 优化和性能提升的方法：\n1. 合并和压缩 CSS 文件\n合并文件：将多个 CSS 文件合并为一个文件，减少 HTTP 请求的数量，从而提高加载速度。\n压缩文件：使用工具（如 CSSNano、CleanCSS 等）压缩 CSS 文件，去除空格、注释和不必要的字符，减小文件大小。\n\n2. 使用 CSS Sprites\n精灵图：将多个小图像合并为一张大图像，减少图像请求的数量。通过 background-position 属性显示精灵图中的特定部分。\n\n3. 使用选择器优化\n简化选择器：使用简单的选择器（如类选择器和 ID 选择器），避免使用过于复杂的选择器（如后代选择器），以提高选择器的匹配速度。\n避免过度使用通配符选择器（*），因为它会影响性能。\n\n4. 避免使用过多的 CSS 规则\n减少不必要的规则：删除未使用的 CSS 规则，保持样式表的简洁性。\n使用工具：使用工具（如 PurgeCSS）自动检测和删除未使用的 CSS。\n\n5. 使用 CSS 预处理器\n预处理器：使用 Sass、LESS 或 Stylus 等 CSS 预处理器，可以更好地组织和管理 CSS 代码，使用变量、嵌套和混合等功能，提高开发效率。\n\n6. 使用媒体查询\n响应式设计：使用媒体查询根据设备特性（如屏幕宽度）加载不同的样式，避免加载不必要的样式，提高性能。\n\n7. 使用 min-width 和 max-width\n限制宽度：使用 min-width 和 max-width 属性来限制元素的宽度，避免不必要的重排和渲染。\n\n8. 使用 will-change 属性\n性能优化：在需要进行动画或变换的元素上使用 will-change 属性，告诉浏览器该元素即将发生变化，从而进行优化。\n\n.element &#123;\n  will-change: transform; &#x2F;* 提前告知浏览器即将进行变换 *&#x2F;\n&#125;\n\n9. 避免使用 !important\n减少使用：尽量避免使用 !important，因为它会增加 CSS 的复杂性和维护难度，影响性能。\n\n10. 使用异步加载\n异步加载 CSS：在需要时异步加载 CSS 文件，避免阻塞页面渲染。可以使用 JavaScript 动态加载样式表。\n\n11. 使用 font-display 属性\n字体加载优化：使用 font-display 属性控制字体的加载行为，避免因字体加载导致的内容闪烁。\n\n@font-face &#123;\n  font-family: &quot;MyFont&quot;;\n  src: url(&quot;myfont.woff2&quot;) format(&quot;woff2&quot;);\n  font-display: swap; &#x2F;* 立即显示文本，使用备用字体 *&#x2F;\n&#125;\n\n12. 使用 CDN\n内容分发网络：将 CSS 文件托管在 CDN 上，利用 CDN 的缓存和分发能力，提高加载速度。\n\n13. 监测和分析性能\n使用工具：使用浏览器的开发者工具（如 Chrome DevTools）监测 CSS 的加载时间和性能，识别瓶颈并进行优化。\n\nCSS 预处理器&#x2F;后处理器是什么？为什么要使用它们？CSS 预处理器和后处理器是用于增强 CSS 开发的工具，它们提供了额外的功能和灵活性，使得编写和管理 CSS 变得更加高效和可维护。以下是对这两者的详细解释，包括它们的定义、功能和使用原因。\n1. CSS 预处理器定义CSS 预处理器是一种扩展 CSS 的语言，允许开发者使用变量、嵌套、混合、函数等编程特性来编写 CSS。预处理器在编译时将这些扩展的语法转换为标准的 CSS。\n常见的 CSS 预处理器\nSass（Syntactically Awesome Style Sheets）\nLESS\nStylus\n\n功能\n变量：允许定义可重用的值（如颜色、字体大小等）。\n$primary-color: #3498db;\nbody &#123;\n  color: $primary-color;\n&#125;\n\n嵌套：支持嵌套选择器，使得样式结构更清晰。\n.nav &#123;\n  ul &#123;\n    list-style: none;\n  &#125;\n  li &#123;\n    display: inline-block;\n  &#125;\n&#125;\n\n混合：允许定义可重用的样式块。\n@mixin border-radius($radius) &#123;\n  -webkit-border-radius: $radius;\n  -moz-border-radius: $radius;\n  border-radius: $radius;\n&#125;\n.box &#123;\n  @include border-radius(10px);\n&#125;\n\n函数：可以创建自定义函数来处理颜色、计算等。\n\n\n使用原因\n提高可维护性：使用变量和混合可以减少重复代码，使样式表更易于维护。\n增强可读性：嵌套结构使得样式层次更加清晰，便于理解。\n减少代码量：通过重用样式和使用函数，可以减少冗余代码。\n\n2. CSS 后处理器定义CSS 后处理器是在 CSS 编写完成后，对其进行处理的工具，通常用于添加浏览器前缀、优化和压缩 CSS 代码。\n常见的 CSS 后处理器\nPostCSS\nAutoprefixer\nCSSNano\n\n功能\n自动添加浏览器前缀：根据 CSS 属性的使用情况，自动添加适当的浏览器前缀，以确保跨浏览器兼容性。\n&#x2F;* 输入 *&#x2F;\ndisplay: flex;\n\n&#x2F;* 输出 *&#x2F;\n-webkit-box: flex;\n-ms-flexbox: flex;\ndisplay: flex;\n\n优化和压缩：通过压缩和优化 CSS 代码，减少文件大小，提高加载速度。\n\n使用插件：PostCSS 允许使用各种插件来扩展功能，如支持未来的 CSS 特性、嵌套等。\n\n\n使用原因\n提高兼容性：自动添加浏览器前缀可以确保样式在不同浏览器中的一致性。\n优化性能：压缩和优化 CSS 可以减少文件大小，提高页面加载速度。\n灵活性：后处理器可以根据项目需求灵活配置，使用不同的插件来满足特定需求。\n\n3. 总结\nCSS 预处理器 提供了编程特性（如变量、嵌套、混合等），使得 CSS 更加灵活和可维护。\nCSS 后处理器 主要用于处理和优化已编写的 CSS，确保兼容性和性能。\n使用预处理器和后处理器可以显著提高开发效率，减少代码冗余，确保样式在不同浏览器中的一致性。\n\n::before 和 :after 的双冒号和单冒号有什么区别？在 CSS 中，::before 和 ::after 是伪元素，用于在元素的内容之前或之后插入内容。它们的语法中使用了双冒号（::），而在 CSS2 中，伪元素使用的是单冒号（:）。以下是对双冒号和单冒号的详细解释及其区别：\n1. 伪元素的定义\n伪元素 是一种特殊的选择器，用于选择元素的特定部分或在元素中插入内容。常见的伪元素包括 ::before、::after、::first-line 和 ::first-letter。\n\n2. 单冒号与双冒号的区别\n单冒号（:）：在 CSS2 中，伪类和伪元素都使用单冒号。例如，:hover 是伪类，而 :before 和 :after 是伪元素。\n双冒号（::）：在 CSS3 中，引入了双冒号来区分伪类和伪元素。伪类仍然使用单冒号，而伪元素使用双冒号。例如，::before 和 ::after 是伪元素。\n\n3. 兼容性\n浏览器支持：虽然 CSS3 推荐使用双冒号来表示伪元素，但大多数现代浏览器仍然支持单冒号的语法。因此，::before 和 :before 在大多数情况下是等效的。\n最佳实践：为了遵循 CSS3 的标准，建议使用双冒号（::before 和 ::after）来表示伪元素。\n\n4. 示例以下是一个使用 ::before 和 ::after 的示例：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;伪元素示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .example::before &#123;\n        content: &quot;前缀 - &quot;; &#x2F;* 在元素内容之前插入内容 *&#x2F;\n        color: blue;\n      &#125;\n\n      .example::after &#123;\n        content: &quot; - 后缀&quot;; &#x2F;* 在元素内容之后插入内容 *&#x2F;\n        color: red;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;example&quot;&gt;这是一个示例文本。&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5. 总结\n单冒号（:） 和 双冒号（::） 的主要区别在于语法标准。单冒号用于 CSS2，而双冒号是 CSS3 的推荐用法。\n伪类使用单冒号，伪元素使用双冒号。为了遵循现代标准，建议使用双冒号来表示伪元素。\n\ndisplay:inline-block 什么时候会显示间隙？在使用 display: inline-block 时，元素之间可能会出现间隙，这通常是由以下几个原因引起的：\n1. 行内元素的空白字符\nHTML 中的空白字符：当使用 display: inline-block 的元素在 HTML 中相邻时，如果它们之间有空格、换行或其他空白字符，浏览器会将这些空白字符渲染为实际的间隙。这是因为 inline-block 元素被视为行内元素，它们之间的空白字符会被视为可见的空白。\n\n示例&lt;div\n  style&#x3D;&quot;display: inline-block; width: 100px; height: 100px; background-color: red;&quot;\n&gt;&lt;&#x2F;div&gt;\n&lt;div\n  style&#x3D;&quot;display: inline-block; width: 100px; height: 100px; background-color: blue;&quot;\n&gt;&lt;&#x2F;div&gt;\n\n在上面的代码中，两个 div 之间的空格会导致它们之间出现间隙。\n2. 行高（line-height）\n行高的影响：inline-block 元素的行高会影响它们的垂直对齐和间距。如果行高设置得较大，可能会导致元素之间出现额外的间隙。\n\n3. CSS 样式\n边距（margin）：如果为 inline-block 元素设置了边距，尤其是垂直边距，可能会导致元素之间的间隙。\n\n解决方法以下是几种常见的解决方法，可以消除或减少 inline-block 元素之间的间隙：\n1. 移除 HTML 中的空白字符在 HTML 中，确保 inline-block 元素之间没有空格或换行：\n&lt;div\n  style&#x3D;&quot;display: inline-block; width: 100px; height: 100px; background-color: red;&quot;\n&gt;&lt;&#x2F;div&gt;\n&lt;div\n  style&#x3D;&quot;display: inline-block; width: 100px; height: 100px; background-color: blue;&quot;\n&gt;&lt;&#x2F;div&gt;\n\n2. 使用注释在 inline-block 元素之间使用 HTML 注释来消除空白字符：\n&lt;div\n  style&#x3D;&quot;display: inline-block; width: 100px; height: 100px; background-color: red;&quot;\n&gt;&lt;&#x2F;div&gt;\n&lt;!--\n--&gt;\n&lt;div\n  style&#x3D;&quot;display: inline-block; width: 100px; height: 100px; background-color: blue;&quot;\n&gt;&lt;&#x2F;div&gt;\n\n3. 设置字体大小为 0在父元素上设置 font-size: 0;，然后为子元素恢复字体大小：\n.parent &#123;\n  font-size: 0; &#x2F;* 移除空白 *&#x2F;\n&#125;\n\n.child &#123;\n  font-size: 16px; &#x2F;* 恢复字体大小 *&#x2F;\n&#125;\n\n4. 使用负边距在 inline-block 元素上使用负边距来消除间隙：\n.child &#123;\n  margin-right: -4px; &#x2F;* 根据需要调整负边距 *&#x2F;\n&#125;\n\n5. 总结\ndisplay: inline-block 元素之间的间隙通常是由于 HTML 中的空白字符、行高或边距引起的。\n可以通过移除空白字符、使用注释、设置字体大小为 0 或使用负边距等方法来消除或减少这些间隙。\n\n单行、多行文本溢出隐藏在 CSS 中，处理文本溢出是一个常见的需求，尤其是在设计响应式布局时。以下是如何处理单行和多行文本溢出隐藏的详细说明。\n1. 单行文本溢出隐藏要隐藏单行文本的溢出部分，可以使用以下 CSS 属性组合：\n\noverflow: hidden;：隐藏超出元素边界的内容。\nwhite-space: nowrap;：防止文本换行。\ntext-overflow: ellipsis;：在文本溢出时显示省略号。\n\n示例&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;单行文本溢出隐藏&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .single-line &#123;\n        width: 200px; &#x2F;* 设置宽度 *&#x2F;\n        white-space: nowrap; &#x2F;* 不换行 *&#x2F;\n        overflow: hidden; &#x2F;* 隐藏溢出内容 *&#x2F;\n        text-overflow: ellipsis; &#x2F;* 溢出时显示省略号 *&#x2F;\n        border: 1px solid #ccc; &#x2F;* 边框 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;single-line&quot;&gt;这是一个很长的文本，超出部分将被隐藏。&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2. 多行文本溢出隐藏要隐藏多行文本的溢出部分，可以使用 display: -webkit-box; 和 -webkit-line-clamp 属性。这个方法在 WebKit 浏览器（如 Chrome 和 Safari）中有效。\n示例&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;多行文本溢出隐藏&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .multi-line &#123;\n        width: 200px; &#x2F;* 设置宽度 *&#x2F;\n        display: -webkit-box; &#x2F;* 使用弹性盒子布局 *&#x2F;\n        -webkit-box-orient: vertical; &#x2F;* 垂直排列 *&#x2F;\n        -webkit-line-clamp: 3; &#x2F;* 限制显示的行数 *&#x2F;\n        overflow: hidden; &#x2F;* 隐藏溢出内容 *&#x2F;\n        text-overflow: ellipsis; &#x2F;* 溢出时显示省略号 *&#x2F;\n        border: 1px solid #ccc; &#x2F;* 边框 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;multi-line&quot;&gt;\n      这是一个很长的文本，超出部分将被隐藏。这里有更多的内容，继续增加文本以测试多行溢出效果。\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3. 注意事项\n浏览器兼容性：-webkit-line-clamp 是一个非标准属性，主要在 WebKit 和 Blink 引擎的浏览器中有效（如 Chrome 和 Safari）。在 Firefox 和其他浏览器中可能不支持。\n替代方案：对于不支持 -webkit-line-clamp 的浏览器，可以考虑使用 JavaScript 来实现多行文本的溢出处理。\n\n4. 总结\n单行文本溢出：使用 overflow: hidden;、white-space: nowrap; 和 text-overflow: ellipsis; 来处理。\n多行文本溢出：使用 display: -webkit-box; 和 -webkit-line-clamp 来限制显示的行数，并隐藏溢出部分。\n\nSass、Less 是什么？为什么要使用他们？Sass 和 LESS 是两种流行的 CSS 预处理器，它们扩展了 CSS 的功能，使得样式表的编写更加灵活和高效。以下是对这两者的详细介绍，包括它们的定义、功能、优点以及使用原因。\n1. Sass（Syntactically Awesome Style Sheets）定义Sass 是一种 CSS 预处理器，允许开发者使用更高级的语法来编写 CSS。它提供了变量、嵌套、混合、函数等功能，使得样式表的编写更加模块化和可维护。\n功能\n变量：可以定义可重用的值（如颜色、字体大小等）。\n$primary-color: #3498db;\n\n嵌套：支持嵌套选择器，使得样式结构更清晰。\n.nav &#123;\n  ul &#123;\n    list-style: none;\n  &#125;\n  li &#123;\n    display: inline-block;\n  &#125;\n&#125;\n\n混合：允许定义可重用的样式块。\n@mixin border-radius($radius) &#123;\n  border-radius: $radius;\n&#125;\n\n继承：支持样式的继承，减少重复代码。\n.message &#123;\n  border: 1px solid #ccc;\n  padding: 10px;\n&#125;\n.success &#123;\n  @extend .message;\n  border-color: green;\n&#125;\n\n优点\n提高可维护性：使用变量和混合可以减少重复代码，使样式表更易于维护。\n增强可读性：嵌套结构使得样式层次更加清晰，便于理解。\n减少代码量：通过重用样式和使用函数，可以减少冗余代码。\n\n2. LESS定义LESS 是另一种 CSS 预处理器，提供类似于 Sass 的功能，允许开发者使用变量、嵌套、混合等特性来编写 CSS。\n功能\n变量：可以定义可重用的值。\n@primary-color: #3498db;\n\n嵌套：支持嵌套选择器。\n.nav &#123;\n  ul &#123;\n    list-style: none;\n  &#125;\n  li &#123;\n    display: inline-block;\n  &#125;\n&#125;\n\n混合：允许定义可重用的样式块。\n.border-radius(@radius) &#123;\n  border-radius: @radius;\n&#125;\n\n运算：支持简单的数学运算。\nwidth: 100px + 20px; &#x2F;* 120px *&#x2F;\n\n优点\n易于学习：LESS 的语法相对简单，容易上手。\n灵活性：支持动态样式和运算，增强了 CSS 的功能。\n\n3. 为什么要使用 Sass 和 LESS？\n提高开发效率：使用预处理器可以减少重复代码，提高开发效率，尤其是在大型项目中。\n增强可维护性：通过使用变量、混合和嵌套，样式表的结构更加清晰，便于维护和更新。\n支持模块化：可以将样式分割成多个文件，使用 @import 语句将它们组合在一起，增强了代码的组织性。\n功能扩展：预处理器提供了许多 CSS 不具备的功能，如条件语句、循环、函数等，使得样式表的编写更加灵活。\n\n4. 总结\nSass 和 LESS 是流行的 CSS 预处理器，提供了变量、嵌套、混合等功能，增强了 CSS 的可维护性和可读性。\n使用它们可以提高开发效率，减少冗余代码，支持模块化和功能扩展。\n\n对媒体查询的理解？媒体查询（Media Queries）是 CSS3 中的一项重要功能，用于实现响应式设计。它允许开发者根据不同的设备特性（如屏幕宽度、高度、分辨率等）应用不同的样式，从而使网页在各种设备上都能良好显示。以下是对媒体查询的详细理解，包括其定义、语法、使用场景和示例。\n1. 媒体查询的定义媒体查询是一种条件语句，允许开发者根据设备的特性（如视口宽度、设备类型、方向等）来应用特定的 CSS 样式。通过媒体查询，开发者可以为不同的设备和屏幕尺寸提供不同的样式，从而实现响应式布局。\n2. 媒体查询的语法媒体查询的基本语法如下：\n@media media-type and (condition) &#123;\n  &#x2F;* CSS 规则 *&#x2F;\n&#125;\n\n\nmedia-type：指定媒体类型，如 screen（屏幕）、print（打印）等。可以省略，默认是 all。\ncondition：指定条件，如 max-width、min-width、orientation 等。\n\n示例&#x2F;* 针对所有设备 *&#x2F;\n@media all &#123;\n  body &#123;\n    background-color: white;\n  &#125;\n&#125;\n\n&#x2F;* 针对屏幕设备，最大宽度为 600px *&#x2F;\n@media screen and (max-width: 600px) &#123;\n  body &#123;\n    background-color: lightblue;\n  &#125;\n&#125;\n\n&#x2F;* 针对打印设备 *&#x2F;\n@media print &#123;\n  body &#123;\n    font-size: 12pt;\n  &#125;\n&#125;\n\n3. 常用的媒体查询条件\n宽度和高度：\n\nmin-width：视口宽度大于或等于指定值。\nmax-width：视口宽度小于或等于指定值。\nmin-height：视口高度大于或等于指定值。\nmax-height：视口高度小于或等于指定值。\n\n\n设备特性：\n\norientation：设备方向（portrait 或 landscape）。\nresolution：设备的分辨率。\n\n\n\n4. 使用场景\n响应式设计：根据不同的屏幕尺寸和设备类型调整布局和样式，以确保良好的用户体验。\n适配不同设备：为手机、平板和桌面设备提供不同的样式，优化内容的可读性和可访问性。\n打印样式：为打印输出提供特定的样式，确保打印效果良好。\n\n5. 示例以下是一个简单的示例，展示如何使用媒体查询实现响应式设计：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;媒体查询示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        font-family: Arial, sans-serif;\n        margin: 0;\n        padding: 20px;\n      &#125;\n\n      h1 &#123;\n        color: black;\n      &#125;\n\n      &#x2F;* 针对最大宽度为 600px 的设备 *&#x2F;\n      @media screen and (max-width: 600px) &#123;\n        body &#123;\n          background-color: lightblue;\n        &#125;\n\n        h1 &#123;\n          font-size: 24px;\n        &#125;\n      &#125;\n\n      &#x2F;* 针对最大宽度为 400px 的设备 *&#x2F;\n      @media screen and (max-width: 400px) &#123;\n        body &#123;\n          background-color: lightcoral;\n        &#125;\n\n        h1 &#123;\n          font-size: 20px;\n        &#125;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎使用媒体查询！&lt;&#x2F;h1&gt;\n    &lt;p&gt;根据设备的不同，背景颜色和字体大小会有所变化。&lt;&#x2F;p&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n6. 总结\n媒体查询 是 CSS3 中的一项重要功能，允许开发者根据设备特性应用不同的样式。\n媒体查询的使用使得响应式设计成为可能，能够为不同设备提供优化的用户体验。\n通过合理使用媒体查询，可以确保网页在各种设备上都能良好显示，提高可访问性和可读性。\n\n对 CSS 工程化的理解CSS 工程化 是指在大型项目中，通过系统化、模块化和自动化的方式来管理和组织 CSS 代码，以提高开发效率、可维护性和可扩展性。随着项目规模的扩大，传统的 CSS 编写方式可能会导致代码混乱、重复和难以维护，因此 CSS 工程化应运而生。以下是对 CSS 工程化的详细理解，包括其核心概念、方法和工具。\n1. 核心概念\n模块化：将 CSS 代码分割成多个模块，每个模块负责特定的功能或样式。这样可以提高代码的可读性和可维护性，避免样式冲突。\n\n可复用性：通过使用变量、混合、函数等特性，创建可复用的样式组件，减少代码重复，提高开发效率。\n\n命名规范：采用一致的命名规范（如 BEM、OOCSS、SMACSS 等），使得样式类名具有可读性和可预测性，便于团队协作。\n\n自动化：使用构建工具（如 Gulp、Webpack、Grunt 等）自动化 CSS 的编译、压缩、前缀添加等任务，提高开发效率。\n\n\n2. 方法2.1 预处理器使用 CSS 预处理器（如 Sass、LESS）来增强 CSS 的功能，支持变量、嵌套、混合等特性，使得样式表的编写更加灵活和高效。\n2.2 组件化将样式分割成独立的组件，每个组件负责特定的 UI 元素（如按钮、卡片、表单等），并通过类名进行组合。这样可以提高代码的可复用性和可维护性。\n2.3 响应式设计使用媒体查询和灵活的布局（如 Flexbox 和 Grid）来实现响应式设计，确保在不同设备上都有良好的用户体验。\n2.4 版本控制使用版本控制系统（如 Git）来管理 CSS 代码的变更，便于团队协作和代码回滚。\n3. 工具3.1 构建工具\nWebpack：一个模块打包工具，可以处理 CSS、JavaScript、图像等资源，支持热重载和代码分割。\nGulp：一个流式构建工具，可以自动化 CSS 的编译、压缩、前缀添加等任务。\nPostCSS：一个 CSS 后处理器，可以使用插件来增强 CSS 的功能，如自动添加浏览器前缀、压缩等。\n\n3.2 CSS 预处理器\nSass：提供变量、嵌套、混合等功能，增强 CSS 的可维护性。\nLESS：类似于 Sass，提供变量、嵌套和混合等功能。\n\n3.3 CSS 框架\nBootstrap：一个流行的 CSS 框架，提供响应式布局和预定义的组件，帮助快速构建 UI。\nTailwind CSS：一个实用优先的 CSS 框架，允许开发者通过类名组合来构建自定义设计。\n\n4. 总结\nCSS 工程化 是一种系统化、模块化和自动化的 CSS 管理方式，旨在提高开发效率、可维护性和可扩展性。\n通过使用预处理器、构建工具、组件化和命名规范等方法，可以有效管理和组织 CSS 代码，适应大型项目的需求。\nCSS 工程化是现代前端开发的重要组成部分，有助于提升团队协作和代码质量。\n\n如何判断元素是否到达可视区域在网页开发中，判断一个元素是否到达可视区域（即用户当前可见的部分）是一个常见的需求，尤其是在实现懒加载、滚动动画或触发特定事件时。以下是几种常用的方法来判断元素是否在可视区域内。\n1. 使用 getBoundingClientRect()getBoundingClientRect() 方法返回一个 DOMRect 对象，该对象提供了元素的大小及其相对于视口的位置。可以通过比较元素的位置与视口的边界来判断元素是否在可视区域内。\n示例代码function isElementInViewport(el) &#123;\n  const rect &#x3D; el.getBoundingClientRect();\n  return (\n    rect.top &gt;&#x3D; 0 &amp;&amp; &#x2F;&#x2F; 元素顶部在视口内\n    rect.left &gt;&#x3D; 0 &amp;&amp; &#x2F;&#x2F; 元素左侧在视口内\n    rect.bottom &lt;&#x3D;\n      (window.innerHeight || document.documentElement.clientHeight) &amp;&amp; &#x2F;&#x2F; 元素底部在视口内\n    rect.right &lt;&#x3D; (window.innerWidth || document.documentElement.clientWidth) &#x2F;&#x2F; 元素右侧在视口内\n  );\n&#125;\n\n&#x2F;&#x2F; 使用示例\nconst element &#x3D; document.querySelector(&quot;.my-element&quot;);\nif (isElementInViewport(element)) &#123;\n  console.log(&quot;元素在可视区域内&quot;);\n&#125; else &#123;\n  console.log(&quot;元素不在可视区域内&quot;);\n&#125;\n\n2. 使用 Intersection Observer APIIntersection Observer 是一种更现代的 API，用于异步观察目标元素与其祖先元素或视口的交叉状态。它可以有效地判断元素是否进入或离开可视区域。\n示例代码&#x2F;&#x2F; 创建一个 Intersection Observer 实例\nconst observer &#x3D; new IntersectionObserver((entries) &#x3D;&gt; &#123;\n  entries.forEach((entry) &#x3D;&gt; &#123;\n    if (entry.isIntersecting) &#123;\n      console.log(&quot;元素在可视区域内&quot;);\n      &#x2F;&#x2F; 可以在这里执行相关操作\n    &#125; else &#123;\n      console.log(&quot;元素不在可视区域内&quot;);\n    &#125;\n  &#125;);\n&#125;);\n\n&#x2F;&#x2F; 选择要观察的元素\nconst element &#x3D; document.querySelector(&quot;.my-element&quot;);\nobserver.observe(element);\n\n3. 监听滚动事件可以通过监听滚动事件来判断元素是否在可视区域内，但这种方法效率较低，可能会导致性能问题，尤其是在滚动频繁的情况下。\n示例代码window.addEventListener(&quot;scroll&quot;, () &#x3D;&gt; &#123;\n  const element &#x3D; document.querySelector(&quot;.my-element&quot;);\n  if (isElementInViewport(element)) &#123;\n    console.log(&quot;元素在可视区域内&quot;);\n  &#125; else &#123;\n    console.log(&quot;元素不在可视区域内&quot;);\n  &#125;\n&#125;);\n\n4. 总结\n**getBoundingClientRect()**：适合简单的判断，直接获取元素的位置信息。\n**Intersection Observer API**：现代且高效，适合处理多个元素的可视状态，推荐使用。\n监听滚动事件：简单但性能较低，不推荐在高频率的滚动事件中使用。\n\nz-index 属性在什么情况下会失效z-index 属性用于控制元素的堆叠顺序，决定了元素在 z 轴上的位置。虽然 z-index 是一个强大的工具，但在某些情况下，它可能会失效。以下是一些常见的情况，导致 z-index 属性失效的原因：\n1. 没有设置定位属性z-index 只对具有定位属性的元素有效。要使 z-index 生效，元素必须具有以下定位属性之一：\n\nposition: relative;\nposition: absolute;\nposition: fixed;\nposition: sticky;\n\n如果元素没有设置这些定位属性，z-index 将不会生效。\n示例.box1 &#123;\n  position: relative; &#x2F;* z-index 将生效 *&#x2F;\n  z-index: 1;\n&#125;\n\n.box2 &#123;\n  z-index: 2; &#x2F;* z-index 不会生效，因为没有设置定位属性 *&#x2F;\n&#125;\n\n2. 堆叠上下文z-index 的作用范围受到堆叠上下文的影响。每当创建一个新的堆叠上下文时，z-index 的值只在该上下文内有效。新的堆叠上下文可以通过以下方式创建：\n\n具有 position 属性且 z-index 不为 auto 的元素。\n具有 opacity 值小于 1 的元素。\n具有 transform、filter、perspective 等 CSS 属性的元素。\n\n在新的堆叠上下文中，z-index 的值只会影响该上下文内的元素，而不会影响外部元素。\n示例.parent &#123;\n  position: relative;\n  z-index: 1; &#x2F;* 创建新的堆叠上下文 *&#x2F;\n&#125;\n\n.child &#123;\n  position: absolute;\n  z-index: 2; &#x2F;* 只在 .parent 的上下文内有效 *&#x2F;\n&#125;\n\n.other &#123;\n  position: absolute;\n  z-index: 3; &#x2F;* 可能会在 .child 之上或之下，取决于 .parent 的 z-index *&#x2F;\n&#125;\n\n3. 兄弟元素的 z-index即使两个元素都具有相同的父元素和 position 属性，z-index 的值也只在同一堆叠上下文内有效。如果两个元素在不同的堆叠上下文中，z-index 的值将无法比较。\n示例.parent1 &#123;\n  position: relative;\n  z-index: 1;\n&#125;\n\n.parent2 &#123;\n  position: relative;\n  z-index: 2;\n&#125;\n\n.child1 &#123;\n  position: absolute;\n  z-index: 3; &#x2F;* 在 .parent1 的上下文内 *&#x2F;\n&#125;\n\n.child2 &#123;\n  position: absolute;\n  z-index: 1; &#x2F;* 在 .parent2 的上下文内 *&#x2F;\n&#125;\n\n在这个例子中，尽管 child1 的 z-index 值为 3，但由于它在不同的堆叠上下文中，child2 的 z-index 值为 1 可能会在视觉上覆盖 child1。\n4. 透明度和变换如果元素的 opacity 值小于 1，或者应用了 transform、filter 等属性，可能会创建新的堆叠上下文，从而影响 z-index 的效果。\n5. 其他 CSS 属性某些 CSS 属性（如 overflow）也可能影响元素的可见性和堆叠顺序。例如，设置 overflow: hidden; 的父元素可能会裁剪其子元素，即使子元素的 z-index 值较高。\n6. 总结\nz-index 只对具有定位属性的元素有效。\n堆叠上下文的创建会影响 z-index 的作用范围。\nz-index 的值只在同一堆叠上下文内有效，无法跨上下文比较。\n透明度、变换和其他 CSS 属性可能会影响 z-index 的效果。\n\nCSS3 中的 transform 有哪些属性在 CSS3 中，transform 属性用于对元素进行二维或三维变换。它可以应用于任何可定位的元素，并允许开发者对元素进行平移、旋转、缩放和倾斜等操作。以下是 CSS3 中 transform 属性的主要变换函数：\n1. 2D 变换1.1 translate()\n功能：平移元素的位置。\n语法：transform: translate(x, y);\n示例：.element &#123;\n  transform: translate(50px, 100px); &#x2F;* 向右移动 50 像素，向下移动 100 像素 *&#x2F;\n&#125;\n\n1.2 rotate()\n功能：旋转元素。\n语法：transform: rotate(angle);\n示例：.element &#123;\n  transform: rotate(45deg); &#x2F;* 旋转 45 度 *&#x2F;\n&#125;\n\n1.3 scale()\n功能：缩放元素的大小。\n语法：transform: scale(sx, sy);\n示例：.element &#123;\n  transform: scale(1.5, 2); &#x2F;* 水平放大 1.5 倍，垂直放大 2 倍 *&#x2F;\n&#125;\n\n1.4 skew()\n功能：倾斜元素。\n语法：transform: skew(x-angle, y-angle);\n示例：.element &#123;\n  transform: skew(20deg, 10deg); &#x2F;* 水平倾斜 20 度，垂直倾斜 10 度 *&#x2F;\n&#125;\n\n2. 组合变换可以将多个变换函数组合在一起，使用空格分隔：\n.element &#123;\n  transform: translate(50px, 100px) rotate(45deg) scale(1.5);\n&#125;\n\n3. 3D 变换CSS3 还支持 3D 变换，以下是一些常用的 3D 变换函数：\n3.1 translateZ()\n功能：在 Z 轴上平移元素。\n语法：transform: translateZ(value);\n示例：.element &#123;\n  transform: translateZ(100px); &#x2F;* 向观察者方向移动 100 像素 *&#x2F;\n&#125;\n\n3.2 rotateX()\n功能：围绕 X 轴旋转元素。\n语法：transform: rotateX(angle);\n示例：.element &#123;\n  transform: rotateX(45deg); &#x2F;* 绕 X 轴旋转 45 度 *&#x2F;\n&#125;\n\n3.3 rotateY()\n功能：围绕 Y 轴旋转元素。\n语法：transform: rotateY(angle);\n示例：.element &#123;\n  transform: rotateY(45deg); &#x2F;* 绕 Y 轴旋转 45 度 *&#x2F;\n&#125;\n\n3.4 rotateZ()\n功能：围绕 Z 轴旋转元素（与 rotate() 相同）。\n语法：transform: rotateZ(angle);\n\n3.5 scaleZ()\n功能：在 Z 轴上缩放元素。\n语法：transform: scaleZ(sx);\n示例：.element &#123;\n  transform: scaleZ(1.5); &#x2F;* 在 Z 轴上放大 1.5 倍 *&#x2F;\n&#125;\n\n4. 变换原点可以使用 transform-origin 属性来设置变换的原点，默认情况下，变换是围绕元素的中心进行的。\n示例.element &#123;\n  transform-origin: top left; &#x2F;* 设置变换原点为左上角 *&#x2F;\n  transform: rotate(45deg);\n&#125;\n\n5. 总结\nCSS3 中的 transform 属性提供了多种变换函数，包括平移、旋转、缩放和倾斜等。\n可以组合多个变换函数来实现复杂的效果。\n支持 3D 变换，允许在三维空间中操作元素。\n使用 transform-origin 属性可以控制变换的原点。\n\n二、页面布局常见的 CSS 布局单位在 CSS 中，布局单位用于定义元素的尺寸、间距和位置。了解这些单位的使用场景和特点对于网页设计和开发至关重要。以下是一些常见的 CSS 布局单位及其说明：\n1. 绝对单位绝对单位是固定的，不受其他元素或视口大小的影响。\n1.1 像素（px）\n定义：最常用的绝对单位，表示屏幕上的一个点。\n使用场景：适用于需要精确控制尺寸的情况，如图像、边框和字体大小。\n\n.element &#123;\n  width: 200px;\n  height: 100px;\n&#125;\n\n1.2 厘米（cm）和毫米（mm）\n定义：用于打印样式，表示实际的物理尺寸。\n使用场景：适用于打印样式表，通常不用于屏幕显示。\n\n.element &#123;\n  width: 5cm; &#x2F;* 5 厘米宽 *&#x2F;\n&#125;\n\n1.3 英寸（in）\n定义：表示实际的物理尺寸，1 英寸等于 2.54 厘米。\n使用场景：同样适用于打印样式。\n\n.element &#123;\n  width: 2in; &#x2F;* 2 英寸宽 *&#x2F;\n&#125;\n\n1.4 点（pt）和派卡（pc）\n定义：点是印刷行业的单位，1 点等于 1&#x2F;72 英寸；派卡是 12 点。\n使用场景：主要用于打印样式。\n\n.element &#123;\n  font-size: 12pt; &#x2F;* 12 点字体大小 *&#x2F;\n&#125;\n\n2. 相对单位相对单位是相对于其他元素或视口的大小而变化的单位。\n2.1 百分比（%）\n定义：相对于父元素的尺寸。\n使用场景：适用于响应式设计，能够根据父元素的大小动态调整。\n\n.element &#123;\n  width: 50%; &#x2F;* 宽度为父元素的 50% *&#x2F;\n&#125;\n\n2.2 em\n定义：相对于当前元素的字体大小。1em 等于当前元素的字体大小。\n使用场景：适用于字体大小、内边距和边距等，能够实现相对布局。\n\n.element &#123;\n  font-size: 2em; &#x2F;* 字体大小为父元素字体大小的 2 倍 *&#x2F;\n&#125;\n\n2.3 rem\n定义：相对于根元素（通常是 &lt;html&gt;）的字体大小。1rem 等于根元素的字体大小。\n使用场景：适用于全局字体大小和布局，能够保持一致性。\n\n.element &#123;\n  font-size: 1.5rem; &#x2F;* 字体大小为根元素字体大小的 1.5 倍 *&#x2F;\n&#125;\n\n2.4 vw 和 vh\n定义：vw 表示视口宽度的 1%，vh 表示视口高度的 1%。\n使用场景：适用于响应式设计，能够根据视口大小动态调整。\n\n.element &#123;\n  width: 50vw; &#x2F;* 宽度为视口宽度的 50% *&#x2F;\n  height: 100vh; &#x2F;* 高度为视口高度的 100% *&#x2F;\n&#125;\n\n3. 其他单位3.1 vmin 和 vmax\n定义：vmin 是视口宽度和高度中较小的一个的 1%，vmax 是较大的一个的 1%。\n使用场景：适用于响应式设计，能够根据视口的最小或最大尺寸动态调整。\n\n.element &#123;\n  font-size: 5vmin; &#x2F;* 字体大小为视口最小尺寸的 5% *&#x2F;\n&#125;\n\n4. 总结\n绝对单位（如 px、cm、in）用于固定尺寸，适合精确控制。\n相对单位（如 %、em、rem、vw、vh）适用于响应式设计，能够根据父元素或视口动态调整。\nvmin 和 vmax 提供了更灵活的响应式设计选项。\n\npx、em、rem 的区别及使用场景在 CSS 中，px、em 和 rem 是三种常用的单位，用于设置元素的尺寸、间距和字体大小。它们各自有不同的特点和使用场景。以下是对这三种单位的详细解释及其区别：\n1. px（像素）\n定义：px 是绝对单位，表示屏幕上的一个点。它是固定的，不会随着其他元素的变化而变化。\n\n特点：\n\n不受父元素或根元素的影响，始终保持相同的大小。\n在不同的设备和屏幕分辨率上，px 的显示效果可能会有所不同。\n\n\n使用场景：\n\n适用于需要精确控制尺寸的情况，如图像、边框、阴影等。\n在设计中需要保持一致性时，使用 px 可以确保元素的大小不受其他因素影响。\n\n\n\n示例.element &#123;\n  width: 200px; &#x2F;* 固定宽度 *&#x2F;\n  height: 100px; &#x2F;* 固定高度 *&#x2F;\n&#125;\n\n2. em\n定义：em 是相对单位，表示相对于当前元素的字体大小。1em 等于当前元素的字体大小。\n\n特点：\n\n如果在一个元素上使用 em，它会根据该元素的字体大小进行计算。\n如果在嵌套元素中使用 em，则会继承父元素的字体大小，可能导致累积效果。\n\n\n使用场景：\n\n适用于需要相对调整的情况，如内边距、边距和字体大小等。\n在组件中使用 em 可以使得样式相对于组件的字体大小进行调整，增强灵活性。\n\n\n\n示例.element &#123;\n  font-size: 16px; &#x2F;* 当前元素字体大小 *&#x2F;\n&#125;\n\n.child &#123;\n  font-size: 1.5em; &#x2F;* 字体大小为父元素的 1.5 倍，即 24px *&#x2F;\n  padding: 1em; &#x2F;* 内边距为当前字体大小的 1 倍，即 16px *&#x2F;\n&#125;\n\n3. rem\n定义：rem 是相对单位，表示相对于根元素（通常是 &lt;html&gt;）的字体大小。1rem 等于根元素的字体大小。\n\n特点：\n\n不受父元素的影响，始终相对于根元素的字体大小进行计算。\n使得在整个文档中保持一致性，避免了 em 的累积效果。\n\n\n使用场景：\n\n适用于全局字体大小、布局和间距等，能够保持一致性。\n在响应式设计中，使用 rem 可以方便地调整整个页面的比例。\n\n\n\n示例html &#123;\n  font-size: 16px; &#x2F;* 根元素字体大小 *&#x2F;\n&#125;\n\n.element &#123;\n  font-size: 1.5rem; &#x2F;* 字体大小为根元素的 1.5 倍，即 24px *&#x2F;\n  margin: 2rem; &#x2F;* 外边距为根元素字体大小的 2 倍，即 32px *&#x2F;\n&#125;\n\n4. 总结\n\n\n单位\n定义\n特点\n使用场景\n\n\n\npx\n绝对单位，固定大小\n不受其他元素影响\n需要精确控制的情况，如图像、边框\n\n\nem\n相对单位，相对于当前元素的字体大小\n受父元素影响，可能导致累积\n需要相对调整的情况，如内边距、边距\n\n\nrem\n相对单位，相对于根元素的字体大小\n不受父元素影响，保持一致性\n全局字体大小、布局和响应式设计\n\n\n两栏布局的实现实现两栏布局是网页设计中的常见需求，通常用于将内容分为主内容区和侧边栏。以下是几种常见的实现两栏布局的方法，包括使用 CSS Flexbox、CSS Grid 和传统的浮动布局。\n1. 使用 CSS FlexboxFlexbox 是一种现代的布局方式，适合于创建响应式布局。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;两栏布局 - Flexbox&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        margin: 0;\n        font-family: Arial, sans-serif;\n      &#125;\n      .container &#123;\n        display: flex; &#x2F;* 使用 Flexbox 布局 *&#x2F;\n      &#125;\n      .main &#123;\n        flex: 3; &#x2F;* 主内容区占 3&#x2F;4 *&#x2F;\n        padding: 20px;\n        background-color: #f0f0f0;\n      &#125;\n      .sidebar &#123;\n        flex: 1; &#x2F;* 侧边栏占 1&#x2F;4 *&#x2F;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;main&quot;&gt;主内容区&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;sidebar&quot;&gt;侧边栏&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2. 使用 CSS GridCSS Grid 是另一种强大的布局方式，适合于创建复杂的布局。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;两栏布局 - Grid&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        margin: 0;\n        font-family: Arial, sans-serif;\n      &#125;\n      .container &#123;\n        display: grid; &#x2F;* 使用 Grid 布局 *&#x2F;\n        grid-template-columns: 3fr 1fr; &#x2F;* 定义两列，主内容区占 3&#x2F;4，侧边栏占 1&#x2F;4 *&#x2F;\n        gap: 20px; &#x2F;* 列间距 *&#x2F;\n      &#125;\n      .main &#123;\n        padding: 20px;\n        background-color: #f0f0f0;\n      &#125;\n      .sidebar &#123;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;main&quot;&gt;主内容区&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;sidebar&quot;&gt;侧边栏&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3. 使用浮动布局虽然浮动布局是较旧的方法，但仍然可以实现两栏布局。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;两栏布局 - 浮动&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        margin: 0;\n        font-family: Arial, sans-serif;\n      &#125;\n      .container &#123;\n        overflow: hidden; &#x2F;* 清除浮动 *&#x2F;\n      &#125;\n      .main &#123;\n        float: left; &#x2F;* 浮动到左侧 *&#x2F;\n        width: 75%; &#x2F;* 主内容区占 75% *&#x2F;\n        padding: 20px;\n        background-color: #f0f0f0;\n      &#125;\n      .sidebar &#123;\n        float: right; &#x2F;* 浮动到右侧 *&#x2F;\n        width: 25%; &#x2F;* 侧边栏占 25% *&#x2F;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;main&quot;&gt;主内容区&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;sidebar&quot;&gt;侧边栏&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结\nFlexbox：适合于简单的两栏布局，易于实现响应式设计。\nGrid：适合于更复杂的布局，提供更强大的控制能力。\n浮动布局：虽然可以实现两栏布局，但相对较旧，使用时需要注意清除浮动。\n\n三栏布局的实现实现三栏布局是网页设计中的常见需求，通常用于将内容分为左侧栏、主内容区和右侧栏。以下是几种常见的实现三栏布局的方法，包括使用 CSS Flexbox、CSS Grid 和传统的浮动布局。\n1. 使用 CSS FlexboxFlexbox 是一种现代的布局方式，适合于创建响应式布局。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;三栏布局 - Flexbox&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        margin: 0;\n        font-family: Arial, sans-serif;\n      &#125;\n      .container &#123;\n        display: flex; &#x2F;* 使用 Flexbox 布局 *&#x2F;\n      &#125;\n      .sidebar-left &#123;\n        flex: 1; &#x2F;* 左侧栏占 1&#x2F;4 *&#x2F;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n      .main &#123;\n        flex: 2; &#x2F;* 主内容区占 1&#x2F;2 *&#x2F;\n        padding: 20px;\n        background-color: #f0f0f0;\n      &#125;\n      .sidebar-right &#123;\n        flex: 1; &#x2F;* 右侧栏占 1&#x2F;4 *&#x2F;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;sidebar-left&quot;&gt;左侧栏&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;main&quot;&gt;主内容区&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;sidebar-right&quot;&gt;右侧栏&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2. 使用 CSS GridCSS Grid 是另一种强大的布局方式，适合于创建复杂的布局。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;三栏布局 - Grid&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        margin: 0;\n        font-family: Arial, sans-serif;\n      &#125;\n      .container &#123;\n        display: grid; &#x2F;* 使用 Grid 布局 *&#x2F;\n        grid-template-columns: 1fr 2fr 1fr; &#x2F;* 左侧栏占 1&#x2F;4，主内容区占 1&#x2F;2，右侧栏占 1&#x2F;4 *&#x2F;\n        gap: 20px; &#x2F;* 列间距 *&#x2F;\n      &#125;\n      .sidebar-left &#123;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n      .main &#123;\n        padding: 20px;\n        background-color: #f0f0f0;\n      &#125;\n      .sidebar-right &#123;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;sidebar-left&quot;&gt;左侧栏&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;main&quot;&gt;主内容区&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;sidebar-right&quot;&gt;右侧栏&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3. 使用浮动布局虽然浮动布局是较旧的方法，但仍然可以实现三栏布局。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;三栏布局 - 浮动&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        margin: 0;\n        font-family: Arial, sans-serif;\n      &#125;\n      .container &#123;\n        overflow: hidden; &#x2F;* 清除浮动 *&#x2F;\n      &#125;\n      .sidebar-left &#123;\n        float: left; &#x2F;* 浮动到左侧 *&#x2F;\n        width: 25%; &#x2F;* 左侧栏占 25% *&#x2F;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n      .main &#123;\n        float: left; &#x2F;* 浮动到中间 *&#x2F;\n        width: 50%; &#x2F;* 主内容区占 50% *&#x2F;\n        padding: 20px;\n        background-color: #f0f0f0;\n      &#125;\n      .sidebar-right &#123;\n        float: left; &#x2F;* 浮动到右侧 *&#x2F;\n        width: 25%; &#x2F;* 右侧栏占 25% *&#x2F;\n        padding: 20px;\n        background-color: #ccc;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;sidebar-left&quot;&gt;左侧栏&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;main&quot;&gt;主内容区&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;sidebar-right&quot;&gt;右侧栏&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结\nFlexbox：适合于简单的三栏布局，易于实现响应式设计。\nGrid：适合于更复杂的布局，提供更强大的控制能力。\n浮动布局：虽然可以实现三栏布局，但相对较旧，使用时需要注意清除浮动。\n\n水平垂直居中的实现在网页设计中，水平和垂直居中是常见的需求。以下是几种实现水平和垂直居中的方法，适用于不同的布局和场景。\n1. 使用 FlexboxFlexbox 是一种现代的布局方式，适合于实现居中对齐。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Flexbox 居中&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        height: 100vh; &#x2F;* 设置高度为视口高度 *&#x2F;\n        margin: 0;\n        display: flex; &#x2F;* 使用 Flexbox 布局 *&#x2F;\n        justify-content: center; &#x2F;* 水平居中 *&#x2F;\n        align-items: center; &#x2F;* 垂直居中 *&#x2F;\n        background-color: #f0f0f0;\n      &#125;\n      .box &#123;\n        width: 200px;\n        height: 100px;\n        background-color: #3498db;\n        color: white;\n        text-align: center;\n        line-height: 100px; &#x2F;* 使文本垂直居中 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;box&quot;&gt;居中内容&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2. 使用 CSS GridCSS Grid 也可以轻松实现居中对齐。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Grid 居中&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        height: 100vh; &#x2F;* 设置高度为视口高度 *&#x2F;\n        margin: 0;\n        display: grid; &#x2F;* 使用 Grid 布局 *&#x2F;\n        place-items: center; &#x2F;* 同时水平和垂直居中 *&#x2F;\n        background-color: #f0f0f0;\n      &#125;\n      .box &#123;\n        width: 200px;\n        height: 100px;\n        background-color: #3498db;\n        color: white;\n        text-align: center;\n        line-height: 100px; &#x2F;* 使文本垂直居中 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;box&quot;&gt;居中内容&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3. 使用绝对定位通过绝对定位和负边距也可以实现居中。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;绝对定位居中&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        height: 100vh; &#x2F;* 设置高度为视口高度 *&#x2F;\n        margin: 0;\n        position: relative; &#x2F;* 设置相对定位 *&#x2F;\n        background-color: #f0f0f0;\n      &#125;\n      .box &#123;\n        width: 200px;\n        height: 100px;\n        background-color: #3498db;\n        color: white;\n        text-align: center;\n        line-height: 100px; &#x2F;* 使文本垂直居中 *&#x2F;\n        position: absolute; &#x2F;* 设置绝对定位 *&#x2F;\n        top: 50%; &#x2F;* 距离顶部 50% *&#x2F;\n        left: 50%; &#x2F;* 距离左侧 50% *&#x2F;\n        transform: translate(-50%, -50%); &#x2F;* 通过平移实现居中 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;box&quot;&gt;居中内容&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 使用传统的行内块和文本居中对于简单的文本内容，可以使用行内块和文本居中。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;行内块居中&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        height: 100vh; &#x2F;* 设置高度为视口高度 *&#x2F;\n        margin: 0;\n        text-align: center; &#x2F;* 水平居中 *&#x2F;\n        line-height: 100vh; &#x2F;* 垂直居中 *&#x2F;\n        background-color: #f0f0f0;\n      &#125;\n      .box &#123;\n        display: inline-block; &#x2F;* 设置为行内块 *&#x2F;\n        width: 200px;\n        height: 100px;\n        background-color: #3498db;\n        color: white;\n        vertical-align: middle; &#x2F;* 垂直对齐 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;box&quot;&gt;居中内容&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5. 总结\nFlexbox 和 Grid 是现代布局方式，适合于实现响应式居中。\n绝对定位 结合负边距也能实现居中，适合于固定尺寸的元素。\n行内块 和文本居中适合于简单的文本内容。\n\n如何根据设计稿进行移动端适配？根据设计稿进行移动端适配是前端开发中的重要任务，确保网站在不同设备上都能良好显示和使用。以下是一些常见的步骤和最佳实践，以帮助您根据设计稿进行移动端适配：\n1. 使用响应式设计1.1 媒体查询使用 CSS 媒体查询根据不同的屏幕尺寸应用不同的样式。可以根据设计稿中指定的断点来设置样式。\n&#x2F;* 默认样式（适用于桌面） *&#x2F;\nbody &#123;\n  font-size: 16px;\n&#125;\n\n&#x2F;* 针对最大宽度为 768px 的设备（平板和手机） *&#x2F;\n@media (max-width: 768px) &#123;\n  body &#123;\n    font-size: 14px; &#x2F;* 调整字体大小 *&#x2F;\n  &#125;\n&#125;\n\n1.2 使用相对单位使用相对单位（如 em、rem、%、vw 和 vh）来设置元素的尺寸和间距，以便在不同屏幕上保持一致性。\n.container &#123;\n  width: 90%; &#x2F;* 使用百分比 *&#x2F;\n  padding: 2rem; &#x2F;* 使用 rem *&#x2F;\n&#125;\n\n2. 设计稿的断点分析根据设计稿中不同屏幕尺寸的设计，确定适合的断点。常见的断点包括：\n\n手机：最大宽度 480px\n平板：最大宽度 768px\n小型桌面：最大宽度 1024px\n大型桌面：最大宽度 1200px\n\n3. 使用视口（Viewport）设置在 HTML 文档的 &lt;head&gt; 部分添加视口设置，以确保页面在移动设备上正确缩放。\n&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n\n4. 适配字体和图像4.1 字体大小根据设计稿中指定的字体大小，使用媒体查询和相对单位进行调整。\nbody &#123;\n  font-size: 16px; &#x2F;* 默认字体大小 *&#x2F;\n&#125;\n\n@media (max-width: 768px) &#123;\n  body &#123;\n    font-size: 14px; &#x2F;* 调整为适合手机的字体大小 *&#x2F;\n  &#125;\n&#125;\n\n4.2 图像适配使用 CSS 的 max-width 属性确保图像在移动设备上不会超出其容器。\nimg &#123;\n  max-width: 100%; &#x2F;* 确保图像自适应容器宽度 *&#x2F;\n  height: auto; &#x2F;* 保持图像比例 *&#x2F;\n&#125;\n\n5. 组件化设计将设计稿中的元素分解为可重用的组件，使用 CSS 类和 JavaScript 进行管理。这样可以提高代码的可维护性和可重用性。\n6. 测试和调试在不同的设备和浏览器上进行测试，确保适配效果良好。可以使用浏览器的开发者工具模拟不同的设备。\n7. 使用框架和库考虑使用响应式框架（如 Bootstrap、Foundation）或 CSS 库（如 Tailwind CSS），这些工具提供了现成的响应式组件和布局，能够加速开发过程。\n8. 性能优化确保移动端页面的加载速度，优化图像和资源，使用懒加载技术，减少 HTTP 请求。\n9. 交互和触控优化根据设计稿中的交互设计，确保按钮和链接的可点击区域足够大，适合触控操作。通常建议可点击区域至少为 44px x 44px。\n10. 总结根据设计稿进行移动端适配需要综合考虑布局、字体、图像、交互等多个方面。通过使用响应式设计、媒体查询、相对单位和视口设置，可以确保网站在不同设备上都能良好显示和使用。测试和调试是确保适配效果的重要步骤。\n对 Flex 布局的理解及其使用场景Flex 布局（Flexible Box Layout）是 CSS3 中的一种布局模式，旨在提供一种更有效的方式来排列、对齐和分配空间给容器中的项目。Flex 布局特别适合于一维布局（即在一条轴线上排列元素），无论是水平还是垂直方向。以下是对 Flex 布局的详细理解，包括其核心概念、属性、优点和使用场景。\n1. 核心概念Flex 布局的核心在于“容器”和“项目”：\n\n容器：使用 display: flex; 或 display: inline-flex; 声明的元素，成为 Flex 容器。\n项目：容器内的直接子元素，称为 Flex 项目。\n\n2. 主要属性2.1 容器属性\n**display**：设置为 flex 或 inline-flex，定义一个 Flex 容器。\n\n.container &#123;\n  display: flex; &#x2F;* 创建 Flex 容器 *&#x2F;\n&#125;\n\n\n**flex-direction**：定义主轴的方向，决定项目的排列方式。\nrow（默认）：水平从左到右排列。\nrow-reverse：水平从右到左排列。\ncolumn：垂直从上到下排列。\ncolumn-reverse：垂直从下到上排列。\n\n\n\n.container &#123;\n  flex-direction: row; &#x2F;* 水平排列 *&#x2F;\n&#125;\n\n\n**justify-content**：定义主轴上的对齐方式。\nflex-start：项目从容器的起始位置对齐。\nflex-end：项目从容器的结束位置对齐。\ncenter：项目在容器中居中对齐。\nspace-between：项目之间均匀分布，首尾项目靠边。\nspace-around：项目之间均匀分布，首尾项目与边缘有相同的间距。\n\n\n\n.container &#123;\n  justify-content: center; &#x2F;* 水平居中对齐 *&#x2F;\n&#125;\n\n\n**align-items**：定义交叉轴上的对齐方式。\nflex-start：项目在交叉轴的起始位置对齐。\nflex-end：项目在交叉轴的结束位置对齐。\ncenter：项目在交叉轴上居中对齐。\nbaseline：项目的基线对齐。\nstretch（默认）：项目在交叉轴上拉伸以填满容器。\n\n\n\n.container &#123;\n  align-items: center; &#x2F;* 垂直居中对齐 *&#x2F;\n&#125;\n\n\n**flex-wrap**：定义项目是否换行。\nnowrap（默认）：不换行。\nwrap：换行。\nwrap-reverse：反向换行。\n\n\n\n.container &#123;\n  flex-wrap: wrap; &#x2F;* 允许换行 *&#x2F;\n&#125;\n\n2.2 项目属性\n**flex-grow**：定义项目的放大比例，默认值为 0，表示不放大。\n\n.item &#123;\n  flex-grow: 1; &#x2F;* 项目可以放大以填充空间 *&#x2F;\n&#125;\n\n\n**flex-shrink**：定义项目的缩小比例，默认值为 1，表示可以缩小。\n\n.item &#123;\n  flex-shrink: 1; &#x2F;* 项目可以缩小以适应容器 *&#x2F;\n&#125;\n\n\n**flex-basis**：定义项目在分配多余空间之前的初始大小，默认值为 auto。\n\n.item &#123;\n  flex-basis: 100px; &#x2F;* 项目的初始大小为 100px *&#x2F;\n&#125;\n\n\n**align-self**：允许单个项目在交叉轴上有不同的对齐方式，覆盖 align-items。\n\n.item &#123;\n  align-self: flex-end; &#x2F;* 单个项目在交叉轴上靠边对齐 *&#x2F;\n&#125;\n\n3. 优点\n简化布局：Flex 布局使得复杂的布局变得简单，尤其是在处理动态内容时。\n响应式设计：可以轻松实现响应式布局，项目可以根据容器的大小自动调整。\n对齐和分配空间：提供了强大的对齐和空间分配功能，能够轻松实现居中、均匀分布等效果。\n\n4. 使用场景\n导航栏：使用 Flex 布局可以轻松创建水平或垂直的导航菜单。\n卡片布局：在卡片布局中，Flex 布局可以帮助实现均匀分布的卡片。\n表单布局：在表单中，Flex 布局可以用于对齐标签和输入框。\n响应式设计：在响应式设计中，Flex 布局可以根据屏幕大小自动调整项目的排列方式。\n\n5. 示例代码以下是一个简单的 Flex 布局示例：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Flex 布局示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .container &#123;\n        display: flex; &#x2F;* 创建 Flex 容器 *&#x2F;\n        justify-content: space-between; &#x2F;* 项目之间均匀分布 *&#x2F;\n        align-items: center; &#x2F;* 垂直居中对齐 *&#x2F;\n        height: 100px;\n        background-color: #f0f0f0;\n      &#125;\n      .item &#123;\n        width: 100px;\n        height: 50px;\n        background-color: #3498db;\n        color: white;\n        text-align: center;\n        line-height: 50px; &#x2F;* 使文本垂直居中 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;item&quot;&gt;项目 1&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;item&quot;&gt;项目 2&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;item&quot;&gt;项目 3&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n6. 总结Flex 布局是一种强大的工具，适合于一维布局，能够简化复杂的布局任务。通过使用 Flexbox，开发者可以轻松实现响应式设计、对齐和空间分配等功能。理解 Flex 布局的核心概念和属性可以帮助您更好地控制网页的布局和样式。\n响应式设计的概念及基本原理响应式设计（Responsive Design）是一种网页设计方法，旨在使网页能够在各种设备和屏幕尺寸上良好显示和使用。响应式设计通过灵活的布局、图像和 CSS 媒体查询等技术，确保用户在不同设备（如手机、平板、桌面）上都能获得良好的浏览体验。\n1. 响应式设计的概念响应式设计的核心思想是创建一个单一的网页布局，该布局能够根据用户的设备特性（如屏幕宽度、高度、分辨率等）自动调整和适应。这样，开发者只需维护一个代码库，而不必为每种设备创建单独的版本。\n2. 基本原理2.1 媒体查询媒体查询是响应式设计的关键技术之一。它允许开发者根据设备的特性（如屏幕宽度、分辨率、方向等）应用不同的 CSS 样式。通过媒体查询，可以为不同的设备设置特定的样式，从而实现布局的适应性。\n&#x2F;* 默认样式（适用于桌面） *&#x2F;\nbody &#123;\n  font-size: 16px;\n&#125;\n\n&#x2F;* 针对最大宽度为 768px 的设备（平板和手机） *&#x2F;\n@media (max-width: 768px) &#123;\n  body &#123;\n    font-size: 14px; &#x2F;* 调整字体大小 *&#x2F;\n  &#125;\n&#125;\n\n2.2 灵活的布局使用相对单位（如 %、em、rem、vw 和 vh）来设置元素的尺寸和间距，以便在不同屏幕上保持一致性。灵活的布局可以确保元素在不同设备上自适应。\n.container &#123;\n  width: 90%; &#x2F;* 使用百分比 *&#x2F;\n  padding: 2rem; &#x2F;* 使用 rem *&#x2F;\n&#125;\n\n2.3 弹性图像使用 CSS 的 max-width 属性确保图像在移动设备上不会超出其容器。这样可以使图像根据容器的大小自动调整。\nimg &#123;\n  max-width: 100%; &#x2F;* 确保图像自适应容器宽度 *&#x2F;\n  height: auto; &#x2F;* 保持图像比例 *&#x2F;\n&#125;\n\n2.4 视口设置在 HTML 文档的 &lt;head&gt; 部分添加视口设置，以确保页面在移动设备上正确缩放。\n&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n\n3. 响应式设计的优点\n用户体验：提供一致的用户体验，无论用户使用何种设备。\nSEO 优势：响应式设计有助于提高搜索引擎排名，因为 Google 推荐使用响应式设计。\n维护简便：只需维护一个代码库，减少了开发和维护的工作量。\n适应性强：能够适应各种屏幕尺寸和设备类型，满足用户需求。\n\n4. 响应式设计的挑战\n设计复杂性：需要考虑多种设备和屏幕尺寸，设计和开发过程可能变得复杂。\n性能问题：在某些情况下，响应式设计可能导致加载时间较长，尤其是在移动设备上。\n\n5. 总结响应式设计是一种现代网页设计方法，旨在使网页能够在各种设备上良好显示和使用。通过使用媒体查询、灵活的布局、弹性图像和视口设置，开发者可以创建适应性强、用户体验良好的网页。理解响应式设计的基本原理和技术可以帮助您在开发中更好地满足用户需求。\n三、定位与浮动为什么需要清除浮动？清除浮动的方式在 CSS 中，浮动（float）是一种常用的布局方式，用于将元素从正常的文档流中移出并使其向左或向右对齐。然而，使用浮动布局时，可能会导致父元素的高度塌陷，无法包裹浮动的子元素。这是因为浮动元素不再占据正常的文档流，导致父元素的高度计算不准确。因此，清除浮动是必要的，以确保父元素能够正确包裹其子元素。\n1. 为什么需要清除浮动\n高度塌陷：当子元素使用浮动时，父元素的高度可能会变为 0，因为浮动元素不影响父元素的高度。这会导致布局问题，影响页面的整体结构。\n布局混乱：未清除浮动可能导致后续元素的布局混乱，影响页面的可读性和用户体验。\n\n2. 清除浮动的方式有几种常见的方法可以清除浮动，以下是几种常用的清除浮动的方法：\n2.1 使用 overflow 属性在父元素上设置 overflow: hidden; 或 overflow: auto;，可以清除浮动并使父元素包裹浮动的子元素。\n.container &#123;\n  overflow: hidden; &#x2F;* 清除浮动 *&#x2F;\n&#125;\n\n2.2 使用伪元素使用伪元素 ::after 创建一个清除浮动的元素。通过设置 content 属性和 clear 属性，可以清除浮动。\n.container::after &#123;\n  content: &quot;&quot;; &#x2F;* 创建一个空的伪元素 *&#x2F;\n  display: table; &#x2F;* 使其成为块级元素 *&#x2F;\n  clear: both; &#x2F;* 清除浮动 *&#x2F;\n&#125;\n\n2.3 使用清除浮动的类可以创建一个清除浮动的类，并在需要清除浮动的元素上应用该类。\n.clearfix::after &#123;\n  content: &quot;&quot;;\n  display: table;\n  clear: both;\n&#125;\n\n使用示例：\n&lt;div class&#x3D;&quot;container clearfix&quot;&gt;\n  &lt;div class&#x3D;&quot;box&quot; style&#x3D;&quot;float: left; width: 50%;&quot;&gt;左侧内容&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;box&quot; style&#x3D;&quot;float: right; width: 50%;&quot;&gt;右侧内容&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n2.4 使用 clear 属性在浮动元素之后的元素上使用 clear 属性，可以清除浮动。\n.clear &#123;\n  clear: both; &#x2F;* 清除左右浮动 *&#x2F;\n&#125;\n\n使用示例：\n&lt;div class&#x3D;&quot;container&quot;&gt;\n  &lt;div class&#x3D;&quot;box&quot; style&#x3D;&quot;float: left; width: 50%;&quot;&gt;左侧内容&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;box&quot; style&#x3D;&quot;float: right; width: 50%;&quot;&gt;右侧内容&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;!-- 清除浮动 --&gt;\n&lt;&#x2F;div&gt;\n\n3. 总结\n清除浮动 是确保父元素能够正确包裹浮动子元素的重要步骤。\n常见的清除浮动方法包括使用 overflow 属性、伪元素、清除浮动的类和 clear 属性。\n选择合适的清除浮动方法可以提高布局的稳定性和可读性。\n\n使用 clear 属性清除浮动的原理？使用 clear 属性清除浮动的原理主要涉及到 CSS 的浮动模型和文档流的行为。以下是对 clear 属性的详细解释及其工作原理。\n1. 浮动的基本概念当一个元素被设置为浮动（使用 float 属性），它会从正常的文档流中移出，并向左或向右对齐。浮动元素不会占据其原本在文档流中的位置，这会导致其父元素的高度塌陷，因为父元素不再包含浮动的子元素。\n2. clear 属性的作用clear 属性用于控制元素的垂直位置，确保该元素不会与浮动元素重叠。它可以取以下值：\n\nnone（默认值）：不清除浮动。\nleft：清除左侧的浮动元素。\nright：清除右侧的浮动元素。\nboth：清除左右两侧的浮动元素。\n\n3. 清除浮动的原理当一个元素的 clear 属性被设置为 both、left 或 right 时，浏览器会根据以下规则处理该元素：\n\n查找浮动元素：浏览器会检查该元素之前的所有浮动元素。\n确定位置：如果该元素的 clear 属性为 both，它会被移动到浮动元素的下方，确保它不会与任何浮动元素重叠。\n影响文档流：清除浮动的元素会重新影响文档流，使得后续的元素能够正常排列。\n\n4. 示例以下是一个简单的示例，展示如何使用 clear 属性清除浮动：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;清除浮动示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .container &#123;\n        border: 1px solid #000;\n      &#125;\n      .box &#123;\n        float: left; &#x2F;* 浮动元素 *&#x2F;\n        width: 100px;\n        height: 100px;\n        margin: 10px;\n        background-color: #3498db;\n      &#125;\n      .clear &#123;\n        clear: both; &#x2F;* 清除浮动 *&#x2F;\n        height: 0; &#x2F;* 高度为 0，保持不占空间 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;box&quot;&gt;左侧浮动&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;box&quot;&gt;右侧浮动&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;\n      &lt;!-- 清除浮动 --&gt;\n      &lt;div&gt;这是清除浮动后的内容&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5. 总结\n浮动元素：当元素使用 float 属性时，它会从正常文档流中移出，导致父元素的高度塌陷。\nclear 属性：通过设置 clear 属性，可以确保后续元素不会与浮动元素重叠，从而恢复正常的文档流。\n使用场景：在使用浮动布局时，通常需要在浮动元素之后添加一个清除浮动的元素，以确保布局的稳定性。\n\n对 BFC 的理解，如何创建 BFCBFC（Block Formatting Context，块格式化上下文）是 CSS 中的一个重要概念，用于控制块级元素的布局和清除浮动。BFC 是一个独立的渲染区域，内部的元素在这个区域内进行布局，而外部的元素不会影响到这个区域的布局。理解 BFC 的概念有助于解决一些常见的布局问题，如清除浮动、避免 margin 重叠等。\n1. BFC 的特性\n独立性：BFC 内部的元素不会影响外部元素的布局，反之亦然。\n清除浮动：BFC 可以包含浮动元素，确保父元素的高度能够包裹浮动子元素。\n避免 margin 重叠：BFC 内部的元素的 margin 不会与外部元素的 margin 重叠。\n\n2. BFC 的触发条件以下是一些常见的触发 BFC 的条件：\n\n根元素（&lt;html&gt;）。\n浮动元素：float 属性不为 none 的元素。\n绝对定位元素：position 属性为 absolute 或 fixed 的元素。\n块级元素：display 属性为 inline-block、table、table-cell、table-caption 的元素。\noverflow 属性：overflow 属性不为 visible 的元素（如 hidden、auto、scroll）。\n\n3. 如何创建 BFC以下是几种常见的方法来创建 BFC：\n3.1 使用浮动将元素的 float 属性设置为 left 或 right。\n.bfc &#123;\n  float: left; &#x2F;* 创建 BFC *&#x2F;\n&#125;\n\n3.2 使用绝对定位将元素的 position 属性设置为 absolute 或 fixed。\n.bfc &#123;\n  position: absolute; &#x2F;* 创建 BFC *&#x2F;\n&#125;\n\n3.3 使用 display 属性将元素的 display 属性设置为 inline-block、table、table-cell、table-caption。\n.bfc &#123;\n  display: inline-block; &#x2F;* 创建 BFC *&#x2F;\n&#125;\n\n3.4 使用 overflow 属性将元素的 overflow 属性设置为 hidden、auto 或 scroll。\n.bfc &#123;\n  overflow: hidden; &#x2F;* 创建 BFC *&#x2F;\n&#125;\n\n4. 示例以下是一个示例，展示如何使用 BFC 来清除浮动：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;BFC 示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .container &#123;\n        border: 1px solid #000;\n      &#125;\n      .box &#123;\n        float: left; &#x2F;* 浮动元素 *&#x2F;\n        width: 100px;\n        height: 100px;\n        margin: 10px;\n        background-color: #3498db;\n      &#125;\n      .bfc &#123;\n        overflow: hidden; &#x2F;* 创建 BFC *&#x2F;\n        background-color: #f0f0f0;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;box&quot;&gt;浮动元素 1&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;box&quot;&gt;浮动元素 2&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;bfc&quot;&gt;这是一个 BFC 元素，它会包裹浮动元素。&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n5. 总结\nBFC 是一个独立的块格式化上下文，内部元素的布局不会影响外部元素，反之亦然。\nBFC 可以通过设置 float、position、display 或 overflow 属性来创建。\n理解 BFC 的特性和创建方法可以帮助解决常见的布局问题，如清除浮动和避免 margin 重叠。\n\n什么是 margin 重叠问题？如何解决？Margin 重叠问题（Margin Collapsing）是 CSS 中的一种现象，指的是当两个块级元素的外边距（margin）相遇时，它们的外边距会合并成一个外边距，而不是简单地相加。这种现象通常发生在以下几种情况下：\n1. Margin 重叠的情况1.1 垂直方向的重叠\n相邻的块级元素：当两个相邻的块级元素的外边距相遇时，它们的外边距会合并，取较大的外边距值。\n\n&lt;div class&#x3D;&quot;box1&quot;&gt;Box 1&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;box2&quot;&gt;Box 2&lt;&#x2F;div&gt;\n\n.box1 &#123;\n  margin-bottom: 20px; &#x2F;* 下外边距 *&#x2F;\n  background-color: lightblue;\n&#125;\n\n.box2 &#123;\n  margin-top: 30px; &#x2F;* 上外边距 *&#x2F;\n  background-color: lightcoral;\n&#125;\n\n在这个例子中，.box1 的下外边距和 .box2 的上外边距会重叠，最终的外边距为 30px，而不是 50px。\n1.2 父元素与子元素\n父元素的外边距与子元素的外边距：如果一个块级元素的外边距与其第一个子元素的外边距相遇，父元素的外边距会被子元素的外边距所取代。\n\n&lt;div class&#x3D;&quot;parent&quot;&gt;\n  &lt;div class&#x3D;&quot;child&quot;&gt;Child&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n.parent &#123;\n  margin-top: 40px; &#x2F;* 父元素的上外边距 *&#x2F;\n  background-color: lightgreen;\n&#125;\n\n.child &#123;\n  margin-top: 20px; &#x2F;* 子元素的上外边距 *&#x2F;\n  background-color: lightyellow;\n&#125;\n\n在这个例子中，.parent 的上外边距会与 .child 的上外边距重叠，最终的外边距为 40px，而不是 60px。\n2. 解决 Margin 重叠问题有几种方法可以解决 margin 重叠问题：\n2.1 使用 Padding在父元素上添加内边距（padding），可以防止外边距重叠。\n.parent &#123;\n  padding-top: 1px; &#x2F;* 添加内边距 *&#x2F;\n&#125;\n\n2.2 使用边框在父元素上添加边框（border），也可以防止外边距重叠。\n.parent &#123;\n  border-top: 1px solid transparent; &#x2F;* 添加边框 *&#x2F;\n&#125;\n\n2.3 使用 Flexbox 或 Grid使用 Flexbox 或 CSS Grid 布局可以避免 margin 重叠问题，因为这些布局模型会改变元素的布局方式。\n.parent &#123;\n  display: flex; &#x2F;* 使用 Flexbox *&#x2F;\n&#125;\n\n2.4 使用 BFC（块格式化上下文）创建一个 BFC 可以防止 margin 重叠。可以通过设置 overflow、float、position 等属性来创建 BFC。\n.parent &#123;\n  overflow: hidden; &#x2F;* 创建 BFC *&#x2F;\n&#125;\n\n3. 总结\nMargin 重叠问题 是 CSS 中的一个常见现象，主要发生在相邻的块级元素或父子元素之间。\n解决 margin 重叠问题的方法包括使用内边距、边框、Flexbox、Grid 或创建 BFC。\n理解 margin 重叠的原理和解决方法可以帮助您更好地控制布局，避免意外的间距问题。\n\n元素的层叠顺序在 CSS 中，元素的层叠顺序（Stacking Order）决定了在重叠的情况下，哪些元素会在上面显示，哪些元素会在下面显示。理解层叠顺序对于处理复杂的布局和视觉效果非常重要。以下是关于元素层叠顺序的详细解释。\n1. 层叠顺序的基本概念层叠顺序是指在同一位置重叠的元素的显示顺序。层叠顺序由多个因素决定，包括元素的 z-index 值、定位属性、文档流顺序等。\n2. 层叠顺序的规则层叠顺序的计算遵循以下规则：\n2.1 位置属性\n定位属性：元素的 position 属性会影响其层叠顺序。具有以下定位属性的元素会创建新的层叠上下文：\nposition: relative;\nposition: absolute;\nposition: fixed;\nposition: sticky;\n\n\n\n2.2 z-index 属性\nz-index：具有 z-index 属性的元素会影响其层叠顺序。z-index 的值越大，元素越靠上。z-index 只对定位元素有效。\n如果两个元素都具有相同的 z-index 值，则它们的层叠顺序由它们在文档中的顺序决定，后面的元素会覆盖前面的元素。\n\n\n\n2.3 文档流顺序\n文档流顺序：如果两个元素都没有设置 z-index，则它们的层叠顺序由它们在文档中的顺序决定。后面的元素会覆盖前面的元素。\n\n3. 层叠上下文层叠上下文是一个独立的层叠顺序环境。每当创建一个新的层叠上下文时，所有在该上下文中的元素的层叠顺序会相对于该上下文进行计算。以下是创建层叠上下文的常见方式：\n\n根元素（&lt;html&gt;）。\n具有 position 属性且 z-index 不为 auto 的元素。\n具有 opacity 值小于 1 的元素。\n具有 transform、filter、perspective 等 CSS 属性的元素。\n\n4. 示例以下是一个简单的示例，展示了层叠顺序的工作原理：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;层叠顺序示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .box1 &#123;\n        position: relative; &#x2F;* 创建层叠上下文 *&#x2F;\n        z-index: 1; &#x2F;* z-index 值为 1 *&#x2F;\n        width: 200px;\n        height: 200px;\n        background-color: lightblue;\n      &#125;\n      .box2 &#123;\n        position: relative; &#x2F;* 创建层叠上下文 *&#x2F;\n        z-index: 2; &#x2F;* z-index 值为 2 *&#x2F;\n        width: 200px;\n        height: 200px;\n        background-color: lightcoral;\n        margin-top: -100px; &#x2F;* 使其重叠 *&#x2F;\n      &#125;\n      .box3 &#123;\n        width: 200px;\n        height: 200px;\n        background-color: lightgreen;\n        margin-top: -100px; &#x2F;* 使其重叠 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;box1&quot;&gt;Box 1&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;box2&quot;&gt;Box 2&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;box3&quot;&gt;Box 3&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n在这个示例中：\n\nBox 1 的 z-index 为 1，Box 2 的 z-index 为 2，因此 Box 2 会覆盖 Box 1。\nBox 3 没有设置 z-index，因此它的层叠顺序由文档流决定，位于 Box 1 和 Box 2 之下。\n\n5. 总结\n层叠顺序 决定了重叠元素的显示顺序，受 z-index、定位属性和文档流顺序的影响。\n层叠上下文 是一个独立的层叠顺序环境，创建新的层叠上下文会影响其中元素的层叠顺序。\n理解层叠顺序的规则可以帮助您更好地控制元素的显示效果，避免布局问题。\n\nposition 的属性有哪些，区别是什么在 CSS 中，position 属性用于控制元素的定位方式。它有五个主要的取值，每个取值都有不同的行为和应用场景。以下是 position 属性的取值及其区别：\n1. static\n定义：默认值，元素按照正常的文档流进行定位。\n特点：\n不会受到 top、right、bottom 和 left 属性的影响。\n元素的排列顺序由文档流决定，后面的元素会覆盖前面的元素。\n\n\n使用场景：适用于不需要特殊定位的元素。\n\n.element &#123;\n  position: static; &#x2F;* 默认值 *&#x2F;\n&#125;\n\n2. relative\n定义：相对定位，元素相对于其正常位置进行定位。\n特点：\n元素仍然占据其在文档流中的位置，但可以通过 top、right、bottom 和 left 属性进行偏移。\n其他元素仍然会按照正常文档流进行排列。\n\n\n使用场景：适用于需要相对移动的元素，同时保留其在文档流中的位置。\n\n.element &#123;\n  position: relative; &#x2F;* 相对定位 *&#x2F;\n  top: 10px; &#x2F;* 向下移动 10 像素 *&#x2F;\n&#125;\n\n3. absolute\n定义：绝对定位，元素相对于最近的已定位祖先元素进行定位（即 position 不为 static 的元素）。\n特点：\n元素脱离文档流，不占据空间。\n可以使用 top、right、bottom 和 left 属性进行精确定位。\n\n\n使用场景：适用于需要精确控制位置的元素，如弹出菜单、工具提示等。\n\n.element &#123;\n  position: absolute; &#x2F;* 绝对定位 *&#x2F;\n  top: 20px; &#x2F;* 距离最近的已定位祖先元素顶部 20 像素 *&#x2F;\n  left: 30px; &#x2F;* 距离最近的已定位祖先元素左侧 30 像素 *&#x2F;\n&#125;\n\n4. fixed\n定义：固定定位，元素相对于视口进行定位。\n特点：\n元素脱离文档流，不占据空间。\n无论页面滚动，元素始终保持在视口的指定位置。\n\n\n使用场景：适用于需要固定在视口中的元素，如导航栏、返回顶部按钮等。\n\n.element &#123;\n  position: fixed; &#x2F;* 固定定位 *&#x2F;\n  top: 0; &#x2F;* 距离视口顶部 0 像素 *&#x2F;\n  right: 0; &#x2F;* 距离视口右侧 0 像素 *&#x2F;\n&#125;\n\n5. sticky\n定义：粘性定位，元素在跨越特定的滚动位置时会在相对定位和固定定位之间切换。\n特点：\n元素在其父元素的范围内相对定位，直到达到指定的滚动位置，然后变为固定定位。\n可以使用 top、right、bottom 和 left 属性来设置粘性位置。\n\n\n使用场景：适用于需要在滚动时保持可见的元素，如粘性导航栏。\n\n.element &#123;\n  position: sticky; &#x2F;* 粘性定位 *&#x2F;\n  top: 0; &#x2F;* 当滚动到顶部时，元素固定在视口顶部 *&#x2F;\n&#125;\n\n6. 总结\n\n\nposition 值\n定义\n特点\n使用场景\n\n\n\nstatic\n默认定位\n不受 top、right、bottom、left 影响\n不需要特殊定位的元素\n\n\nrelative\n相对定位\n相对于正常位置偏移，仍占据文档流\n需要相对移动的元素\n\n\nabsolute\n绝对定位\n脱离文档流，相对于最近的已定位祖先元素\n需要精确控制位置的元素\n\n\nfixed\n固定定位\n脱离文档流，相对于视口\n固定在视口中的元素\n\n\nsticky\n粘性定位\n在特定滚动位置切换相对和固定定位\n需要在滚动时保持可见的元素\n\n\n理解 position 属性的不同取值及其特点，可以帮助您更好地控制元素的布局和定位。\ndisplay、float、position 的关系在 CSS 中，display、float 和 position 是三个重要的属性，它们用于控制元素的布局和定位。虽然它们各自有不同的功能和用途，但它们之间也存在一定的关系。以下是对这三个属性的详细解释及其相互关系。\n1. display 属性\n定义：display 属性用于定义元素的显示类型，决定元素在文档流中的行为。\n常见值：\nblock：元素作为块级元素显示，独占一行。\ninline：元素作为行内元素显示，不独占一行。\ninline-block：元素既具有块级元素的特性，又具有行内元素的特性。\nnone：元素不显示，不占据空间。\nflex 和 grid：用于创建响应式布局。\n\n\n\n示例.block &#123;\n  display: block; &#x2F;* 块级元素 *&#x2F;\n&#125;\n\n.inline &#123;\n  display: inline; &#x2F;* 行内元素 *&#x2F;\n&#125;\n\n.inline-block &#123;\n  display: inline-block; &#x2F;* 行内块元素 *&#x2F;\n&#125;\n\n2. float 属性\n定义：float 属性用于将元素从正常文档流中移出，并使其向左或向右对齐。\n\n常见值：\n\nleft：元素向左浮动。\nright：元素向右浮动。\nnone（默认值）：元素不浮动。\n\n\n影响：浮动元素会脱离正常文档流，后续元素会围绕浮动元素排列。\n\n\n示例.float-left &#123;\n  float: left; &#x2F;* 向左浮动 *&#x2F;\n&#125;\n\n.float-right &#123;\n  float: right; &#x2F;* 向右浮动 *&#x2F;\n&#125;\n\n3. position 属性\n定义：position 属性用于控制元素的定位方式。\n常见值：\nstatic：默认值，元素按照正常文档流进行定位。\nrelative：相对定位，元素相对于其正常位置进行偏移。\nabsolute：绝对定位，元素相对于最近的已定位祖先元素进行定位。\nfixed：固定定位，元素相对于视口进行定位。\nsticky：粘性定位，元素在特定的滚动位置时切换相对和固定定位。\n\n\n\n示例.relative &#123;\n  position: relative; &#x2F;* 相对定位 *&#x2F;\n&#125;\n\n.absolute &#123;\n  position: absolute; &#x2F;* 绝对定位 *&#x2F;\n&#125;\n\n4. 三者之间的关系\n文档流：\n\ndisplay 属性决定元素在文档流中的行为。块级元素和行内元素的显示方式不同，影响后续元素的排列。\nfloat 属性会使元素脱离正常文档流，后续元素会围绕浮动元素排列。\nposition 属性中的 absolute 和 fixed 定位元素也会脱离文档流，不占据空间。\n\n\n层叠和重叠：\n\n使用 position 属性的元素可以通过 z-index 属性控制层叠顺序，而 float 元素的层叠顺序则由文档流顺序决定。\ndisplay 属性的值（如 flex 和 grid）可以影响元素的排列方式和层叠顺序。\n\n\n布局方式：\n\nfloat 通常用于实现简单的文本环绕效果，但在现代布局中，使用 flex 和 grid 更为常见。\nposition 属性用于精确控制元素的位置，适合需要固定或绝对定位的场景。\n\n\n\n5. 总结\n**display**：控制元素的显示类型和文档流行为。\n**float**：用于将元素从文档流中移出并进行左右对齐。\n**position**：用于控制元素的定位方式，影响元素在页面中的位置。\n\n理解这三个属性的关系和区别，可以帮助您更好地控制网页的布局和样式。\nabsolute 与 fixed 共同点与不同点absolute 和 fixed 是 CSS 中的两种定位方式，它们都属于 position 属性的取值。虽然它们有一些共同点，但也存在显著的不同之处。以下是对这两种定位方式的详细比较。\n共同点\n脱离文档流：\n\n两者都脱离了正常的文档流。这意味着它们不会占据空间，后续的元素会按照正常文档流排列，不会受到它们的影响。\n\n\n使用 top、right、bottom 和 left 属性：\n\n两者都可以使用这些属性来精确控制元素的位置。可以通过设置这些属性来指定元素相对于其定位上下文的位置。\n\n\n不影响其他元素：\n\n由于它们脱离了文档流，absolute 和 fixed 定位的元素不会影响其他元素的布局。\n\n\n\n不同点\n\n\n特性\nabsolute 定位\nfixed 定位\n\n\n\n定位上下文\n相对于最近的已定位祖先元素（即 position 不为 static 的元素）\n相对于视口（浏览器窗口）\n\n\n滚动行为\n随着页面滚动而移动，保持相对位置\n始终固定在视口中，不随页面滚动而移动\n\n\n使用场景\n适用于需要相对于某个元素进行定位的情况，如弹出菜单、工具提示等\n适用于需要固定在视口中的元素，如导航栏、返回顶部按钮等\n\n\n示例1. absolute 定位示例&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Absolute 定位示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .container &#123;\n        position: relative; &#x2F;* 创建定位上下文 *&#x2F;\n        width: 300px;\n        height: 300px;\n        border: 1px solid #000;\n      &#125;\n      .absolute &#123;\n        position: absolute; &#x2F;* 绝对定位 *&#x2F;\n        top: 20px; &#x2F;* 距离最近的已定位祖先元素顶部 20 像素 *&#x2F;\n        left: 20px; &#x2F;* 距离最近的已定位祖先元素左侧 20 像素 *&#x2F;\n        background-color: lightblue;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;absolute&quot;&gt;绝对定位元素&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2. fixed 定位示例&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Fixed 定位示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .fixed &#123;\n        position: fixed; &#x2F;* 固定定位 *&#x2F;\n        top: 10px; &#x2F;* 距离视口顶部 10 像素 *&#x2F;\n        right: 10px; &#x2F;* 距离视口右侧 10 像素 *&#x2F;\n        background-color: lightcoral;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;fixed&quot;&gt;固定定位元素&lt;&#x2F;div&gt;\n    &lt;div style&#x3D;&quot;height: 2000px;&quot;&gt;滚动页面&lt;&#x2F;div&gt;\n    &lt;!-- 用于演示滚动效果 --&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n总结\n共同点：absolute 和 fixed 都脱离文档流，使用 top、right、bottom 和 left 属性进行定位，并且不影响其他元素的布局。\n不同点：absolute 定位相对于最近的已定位祖先元素，而 fixed 定位相对于视口，且固定在视口中，不随页面滚动而移动。\n\n理解这两种定位方式的共同点和不同点，可以帮助您在布局中选择合适的定位方式。\n对 sticky 定位的理解Sticky 定位（position: sticky）是 CSS 中的一种定位方式，它结合了相对定位和固定定位的特性。Sticky 定位允许元素在滚动时保持在视口的特定位置，直到其父元素的边界被滚动出视口。以下是对 sticky 定位的详细理解，包括其工作原理、使用场景和示例。\n1. 工作原理\n相对定位：当页面滚动到元素的初始位置时，sticky 元素会表现得像相对定位的元素，保持在其正常文档流中的位置。\n固定定位：一旦页面滚动到指定的阈值（通常是元素的 top、right、bottom 或 left 属性所定义的位置），sticky 元素会变为固定定位，固定在视口的指定位置。\n父元素的边界：sticky 元素的固定状态会受到其父元素的边界限制。当父元素的底部被滚动出视口时，sticky 元素会停止固定，恢复到正常的文档流中。\n\n2. 使用场景\n导航栏：可以用于创建粘性导航栏，使其在滚动时保持在视口的顶部。\n侧边栏：在长页面中，侧边栏可以在滚动时保持可见，直到其父元素的底部被滚动出视口。\n标题：在长文章中，章节标题可以使用 sticky 定位，使其在滚动时保持在视口的顶部，方便用户查看。\n\n3. 示例以下是一个简单的示例，展示如何使用 sticky 定位：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Sticky 定位示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      body &#123;\n        font-family: Arial, sans-serif;\n        line-height: 1.6;\n      &#125;\n      .header &#123;\n        background-color: #3498db;\n        color: white;\n        padding: 10px;\n        text-align: center;\n      &#125;\n      .sticky &#123;\n        position: sticky; &#x2F;* 粘性定位 *&#x2F;\n        top: 0; &#x2F;* 当滚动到顶部时固定 *&#x2F;\n        background-color: #f0f0f0;\n        padding: 10px;\n        border: 1px solid #ccc;\n        z-index: 1000; &#x2F;* 确保在其他元素之上 *&#x2F;\n      &#125;\n      .content &#123;\n        height: 2000px; &#x2F;* 用于演示滚动效果 *&#x2F;\n        padding: 20px;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;header&quot;&gt;Sticky 定位示例&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;sticky&quot;&gt;我会在滚动时保持在顶部&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;content&quot;&gt;\n      &lt;p&gt;滚动页面以查看粘性效果...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n      &lt;p&gt;更多内容...&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 注意事项\n兼容性：虽然大多数现代浏览器都支持 sticky 定位，但在某些旧版浏览器中可能不支持。\n父元素的高度：sticky 元素的行为受到其父元素的高度限制。如果父元素的高度不足以容纳 sticky 元素的滚动，可能会导致意外的行为。\nz-index：在使用 sticky 定位时，可能需要设置 z-index 属性，以确保 sticky 元素在其他元素之上。\n\n5. 总结\nSticky 定位 是一种结合了相对定位和固定定位的定位方式，允许元素在滚动时保持在视口的特定位置。\n它适用于导航栏、侧边栏和标题等场景，能够提高用户体验。\n理解 sticky 定位的工作原理和使用场景，可以帮助您在布局中更好地利用这一特性。\n\n四、场景应用实现一个三角形在 CSS 中，可以通过设置元素的边框来创建一个三角形。以下是实现三角形的几种常见方法，主要使用边框属性。\n方法 1：使用边框通过设置一个元素的宽度和高度为 0，并利用边框的颜色和透明度来创建三角形。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;三角形示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .triangle-up &#123;\n        width: 0;\n        height: 0;\n        border-left: 50px solid transparent; &#x2F;* 左边框 *&#x2F;\n        border-right: 50px solid transparent; &#x2F;* 右边框 *&#x2F;\n        border-bottom: 100px solid #3498db; &#x2F;* 底边框 *&#x2F;\n      &#125;\n\n      .triangle-down &#123;\n        width: 0;\n        height: 0;\n        border-left: 50px solid transparent; &#x2F;* 左边框 *&#x2F;\n        border-right: 50px solid transparent; &#x2F;* 右边框 *&#x2F;\n        border-top: 100px solid #e74c3c; &#x2F;* 顶边框 *&#x2F;\n      &#125;\n\n      .triangle-left &#123;\n        width: 0;\n        height: 0;\n        border-top: 50px solid transparent; &#x2F;* 上边框 *&#x2F;\n        border-bottom: 50px solid transparent; &#x2F;* 下边框 *&#x2F;\n        border-right: 100px solid #2ecc71; &#x2F;* 右边框 *&#x2F;\n      &#125;\n\n      .triangle-right &#123;\n        width: 0;\n        height: 0;\n        border-top: 50px solid transparent; &#x2F;* 上边框 *&#x2F;\n        border-bottom: 50px solid transparent; &#x2F;* 下边框 *&#x2F;\n        border-left: 100px solid #f1c40f; &#x2F;* 左边框 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;triangle-up&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;triangle-down&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;triangle-left&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;triangle-right&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解释\n三角形的创建：\n上三角形：通过设置 border-bottom 的颜色和高度，结合 border-left 和 border-right 的透明边框，形成一个向上的三角形。\n下三角形：通过设置 border-top 的颜色和高度，结合 border-left 和 border-right 的透明边框，形成一个向下的三角形。\n左三角形：通过设置 border-right 的颜色和宽度，结合 border-top 和 border-bottom 的透明边框，形成一个向左的三角形。\n右三角形：通过设置 border-left 的颜色和宽度，结合 border-top 和 border-bottom 的透明边框，形成一个向右的三角形。\n\n\n\n方法 2：使用 CSS Clip-path另一种创建三角形的方法是使用 clip-path 属性。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;三角形示例 - Clip-path&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .triangle &#123;\n        width: 0;\n        height: 0;\n        background-color: #3498db;\n        clip-path: polygon(50% 0%, 0% 100%, 100% 100%); &#x2F;* 创建三角形 *&#x2F;\n        width: 100px; &#x2F;* 设置宽度 *&#x2F;\n        height: 100px; &#x2F;* 设置高度 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;triangle&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解释\nclip-path：使用 clip-path 属性的 polygon 函数定义三角形的三个顶点。polygon(50% 0%, 0% 100%, 100% 100%) 表示三角形的三个顶点分别位于顶部中心、左下角和右下角。\n\n总结\n使用边框属性是创建三角形的常见方法，适用于简单的三角形。\n使用 clip-path 属性可以创建更复杂的形状，适用于需要更灵活的形状设计。\n\n实现一个扇形在 CSS 中，可以通过使用 conic-gradient 或者 SVG 来实现扇形。以下是这两种方法的详细示例。\n方法 1：使用 CSS conic-gradientconic-gradient 是 CSS 中的一种渐变函数，可以用来创建扇形效果。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;扇形示例 - CSS&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .fan-shape &#123;\n        width: 200px; &#x2F;* 扇形的宽度 *&#x2F;\n        height: 200px; &#x2F;* 扇形的高度 *&#x2F;\n        border-radius: 50%; &#x2F;* 使其成为圆形 *&#x2F;\n        background: conic-gradient(\n          #3498db 0deg 90deg,\n          &#x2F;* 蓝色扇形 *&#x2F; #e74c3c 90deg 180deg,\n          &#x2F;* 红色扇形 *&#x2F; #f1c40f 180deg 270deg,\n          &#x2F;* 黄色扇形 *&#x2F; #2ecc71 270deg 360deg &#x2F;* 绿色扇形 *&#x2F;\n        );\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;fan-shape&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解释\n扇形的创建：\n使用 conic-gradient 函数定义扇形的颜色和角度。\n每个颜色段的起始和结束角度定义了扇形的范围。例如，#3498db 0deg 90deg 表示从 0 度到 90 度的蓝色扇形。\n\n\n\n方法 2：使用 SVGSVG（可缩放矢量图形）也可以用来创建扇形，适合需要更复杂形状的场景。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;扇形示例 - SVG&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;svg width&#x3D;&quot;200&quot; height&#x3D;&quot;200&quot; viewBox&#x3D;&quot;0 0 200 200&quot;&gt;\n      &lt;path d&#x3D;&quot;M100,100 L100,0 A100,100 0 0,1 200,100 Z&quot; fill&#x3D;&quot;#3498db&quot; &#x2F;&gt;\n      &lt;!-- 蓝色扇形 --&gt;\n      &lt;path d&#x3D;&quot;M100,100 L200,100 A100,100 0 0,1 100,200 Z&quot; fill&#x3D;&quot;#e74c3c&quot; &#x2F;&gt;\n      &lt;!-- 红色扇形 --&gt;\n      &lt;path d&#x3D;&quot;M100,100 L100,200 A100,100 0 0,1 0,100 Z&quot; fill&#x3D;&quot;#f1c40f&quot; &#x2F;&gt;\n      &lt;!-- 黄色扇形 --&gt;\n      &lt;path d&#x3D;&quot;M100,100 L0,100 A100,100 0 0,1 100,0 Z&quot; fill&#x3D;&quot;#2ecc71&quot; &#x2F;&gt;\n      &lt;!-- 绿色扇形 --&gt;\n    &lt;&#x2F;svg&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解释\nSVG 扇形的创建：\n使用 &lt;path&gt; 元素定义扇形的路径。\nM100,100 表示移动到中心点 (100, 100)。\nL100,0 表示绘制一条线到顶部。\nA100,100 0 0,1 200,100 表示绘制一个弧线，形成扇形的边缘。\nZ 表示闭合路径。\n\n\n\n总结\n使用 CSS conic-gradient 是创建简单扇形的快速方法，适合于现代浏览器。\n使用 SVG 可以创建更复杂的扇形，适合需要更高自定义的场景。\n\n实现一个宽高自适应的正方形要实现一个宽高自适应的正方形，可以使用 CSS 的 padding 属性结合 width 或 height 属性。以下是几种常见的方法来创建一个宽高自适应的正方形。\n方法 1：使用 padding-bottom通过设置 padding-bottom 为 100%，可以创建一个正方形。这个方法利用了 padding 的百分比是相对于父元素的宽度来计算的。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;自适应正方形示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .square &#123;\n        width: 100%; &#x2F;* 宽度自适应 *&#x2F;\n        padding-bottom: 100%; &#x2F;* 高度为宽度的 100% *&#x2F;\n        background-color: #3498db; &#x2F;* 背景颜色 *&#x2F;\n        position: relative; &#x2F;* 使子元素绝对定位 *&#x2F;\n      &#125;\n      .content &#123;\n        position: absolute; &#x2F;* 绝对定位 *&#x2F;\n        top: 50%; &#x2F;* 垂直居中 *&#x2F;\n        left: 50%; &#x2F;* 水平居中 *&#x2F;\n        transform: translate(-50%, -50%); &#x2F;* 使内容居中 *&#x2F;\n        color: white; &#x2F;* 字体颜色 *&#x2F;\n        font-size: 20px; &#x2F;* 字体大小 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;square&quot;&gt;\n      &lt;div class&#x3D;&quot;content&quot;&gt;正方形&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解释\n正方形的创建：\nwidth: 100% 使正方形的宽度自适应父元素的宽度。\npadding-bottom: 100% 确保高度与宽度相等，从而形成正方形。\n使用 position: relative 和 position: absolute 来使内容在正方形中居中。\n\n\n\n方法 2：使用 CSS Grid使用 CSS Grid 也可以轻松实现一个自适应的正方形。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;自适应正方形示例 - Grid&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .container &#123;\n        display: grid; &#x2F;* 使用 Grid 布局 *&#x2F;\n        width: 100%; &#x2F;* 宽度自适应 *&#x2F;\n        height: 0; &#x2F;* 高度为 0 *&#x2F;\n        padding-top: 100%; &#x2F;* 高度为宽度的 100% *&#x2F;\n        position: relative; &#x2F;* 使子元素绝对定位 *&#x2F;\n      &#125;\n      .square &#123;\n        background-color: #3498db; &#x2F;* 背景颜色 *&#x2F;\n        position: absolute; &#x2F;* 绝对定位 *&#x2F;\n        top: 0; &#x2F;* 顶部对齐 *&#x2F;\n        left: 0; &#x2F;* 左侧对齐 *&#x2F;\n        right: 0; &#x2F;* 右侧对齐 *&#x2F;\n        bottom: 0; &#x2F;* 底部对齐 *&#x2F;\n      &#125;\n      .content &#123;\n        display: flex; &#x2F;* 使用 Flexbox 居中内容 *&#x2F;\n        justify-content: center; &#x2F;* 水平居中 *&#x2F;\n        align-items: center; &#x2F;* 垂直居中 *&#x2F;\n        color: white; &#x2F;* 字体颜色 *&#x2F;\n        font-size: 20px; &#x2F;* 字体大小 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;square&quot;&gt;\n        &lt;div class&#x3D;&quot;content&quot;&gt;正方形&lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解释\n正方形的创建：\n使用 padding-top: 100% 来确保高度与宽度相等。\nposition: absolute 使 .square 元素填满整个容器。\n使用 Flexbox 来居中内容。\n\n\n\n总结\n使用 padding 属性是创建自适应正方形的常见方法，适用于需要根据父元素宽度自适应的场景。\n使用 CSS Grid 也可以轻松实现自适应正方形，适合更复杂的布局需求。\n\n画一条 0.5px 的线在 CSS 中，绘制一条 0.5px 的线可以通过设置元素的边框或使用 height 属性来实现。由于某些浏览器可能不支持小于 1px 的边框，因此可以使用 transform 属性来实现更细的线条。以下是几种实现 0.5px 线的示例。\n方法 1：使用边框通过设置边框的宽度为 0.5px 来创建一条线。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;0.5px 线示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .line &#123;\n        border-top: 0.5px solid #3498db; &#x2F;* 设置边框为 0.5px *&#x2F;\n        width: 100%; &#x2F;* 线的宽度 *&#x2F;\n        margin: 20px 0; &#x2F;* 上下间距 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;line&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n方法 2：使用 height 和 transform通过设置一个元素的高度为 1px，并使用 transform 属性缩放来实现 0.5px 的线。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;0.5px 线示例 - Transform&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .line &#123;\n        height: 1px; &#x2F;* 设置高度为 1px *&#x2F;\n        background-color: #3498db; &#x2F;* 线的颜色 *&#x2F;\n        transform: scaleY(0.5); &#x2F;* 垂直缩放为 0.5 *&#x2F;\n        transform-origin: top; &#x2F;* 缩放的原点 *&#x2F;\n        width: 100%; &#x2F;* 线的宽度 *&#x2F;\n        margin: 20px 0; &#x2F;* 上下间距 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;line&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n方法 3：使用 SVG使用 SVG 也可以绘制一条 0.5px 的线，适合需要更高精度的场景。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;0.5px 线示例 - SVG&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;svg width&#x3D;&quot;100%&quot; height&#x3D;&quot;1&quot;&gt;\n      &lt;line\n        x1&#x3D;&quot;0&quot;\n        y1&#x3D;&quot;0&quot;\n        x2&#x3D;&quot;100%&quot;\n        y2&#x3D;&quot;0&quot;\n        stroke&#x3D;&quot;#3498db&quot;\n        stroke-width&#x3D;&quot;0.5&quot;\n      &#x2F;&gt;\n    &lt;&#x2F;svg&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n总结\n使用边框 是创建 0.5px 线的简单方法，但某些浏览器可能不支持小于 1px 的边框。\n使用 transform 可以通过缩放实现更细的线条，适合需要更高精度的场景。\n使用 SVG 是绘制精确线条的另一种方法，适合需要更复杂图形的场景。\n\n设置小于 12px 的字体在 CSS 中，可以设置小于 12px 的字体大小。虽然大多数浏览器都支持小于 12px 的字体大小，但在某些情况下，可能会出现渲染问题，尤其是在高分辨率显示器上。以下是如何设置小于 12px 字体大小的示例。\n示例代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;小于 12px 字体示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      .small-font &#123;\n        font-size: 10px; &#x2F;* 设置字体大小为 10px *&#x2F;\n        color: #3498db; &#x2F;* 字体颜色 *&#x2F;\n      &#125;\n      .smaller-font &#123;\n        font-size: 8px; &#x2F;* 设置字体大小为 8px *&#x2F;\n        color: #e74c3c; &#x2F;* 字体颜色 *&#x2F;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div class&#x3D;&quot;small-font&quot;&gt;这是 10px 的字体。&lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;smaller-font&quot;&gt;这是 8px 的字体。&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n解释\n字体大小设置：\n.small-font 类的字体大小设置为 10px。\n.smaller-font 类的字体大小设置为 8px。\n\n\n\n注意事项\n可读性：使用小于 12px 的字体可能会影响可读性，尤其是在移动设备上。确保文本仍然易于阅读。\n浏览器兼容性：虽然大多数现代浏览器支持小于 12px 的字体，但在某些情况下，可能会出现渲染问题。建议在不同设备和浏览器上进行测试。\n使用相对单位：考虑使用相对单位（如 em 或 rem）来设置字体大小，以便在不同的上下文中保持一致性。\n\n总结您可以轻松设置小于 12px 的字体大小，只需在 CSS 中指定所需的像素值。\n网站的 light 和 dark 如何切换，可结合 tailwind css 和 React在使用 React 和 Tailwind CSS 的项目中实现光明（Light）和黑暗（Dark）模式的切换，可以通过状态管理和 CSS 类的切换来完成。以下是一个简单的实现示例。\n1. 设置 Tailwind CSS确保在项目中安装了 Tailwind CSS。可以通过 npm 安装并配置 Tailwind CSS。\n安装 Tailwind CSSnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n\n配置 tailwind.config.js在 tailwind.config.js 中，确保启用 JIT 模式并设置内容路径：\nmodule.exports &#x3D; &#123;\n  mode: &quot;jit&quot;,\n  purge: [&quot;.&#x2F;src&#x2F;**&#x2F;*.&#123;js,jsx,ts,tsx&#125;&quot;, &quot;.&#x2F;public&#x2F;index.html&quot;],\n  darkMode: &quot;class&quot;, &#x2F;&#x2F; Enable dark mode\n  theme: &#123;\n    extend: &#123;&#125;,\n  &#125;,\n  variants: &#123;\n    extend: &#123;&#125;,\n  &#125;,\n  plugins: [],\n&#125;;\n\n在 CSS 文件中引入 Tailwind在 src/index.css 中引入 Tailwind 的基础样式：\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n2. 创建 React 组件创建一个简单的 React 组件，包含光明和黑暗模式的切换功能。\n示例代码&#x2F;&#x2F; src&#x2F;App.js\nimport React, &#123; useState, useEffect &#125; from &quot;react&quot;;\n\nfunction App() &#123;\n  const [darkMode, setDarkMode] &#x3D; useState(false);\n\n  &#x2F;&#x2F; 从 localStorage 获取主题设置\n  useEffect(() &#x3D;&gt; &#123;\n    const savedTheme &#x3D; localStorage.getItem(&quot;theme&quot;);\n    if (savedTheme &#x3D;&#x3D;&#x3D; &quot;dark&quot;) &#123;\n      setDarkMode(true);\n    &#125;\n  &#125;, []);\n\n  &#x2F;&#x2F; 切换主题\n  const toggleTheme &#x3D; () &#x3D;&gt; &#123;\n    setDarkMode(!darkMode);\n    if (!darkMode) &#123;\n      localStorage.setItem(&quot;theme&quot;, &quot;dark&quot;);\n    &#125; else &#123;\n      localStorage.setItem(&quot;theme&quot;, &quot;light&quot;);\n    &#125;\n  &#125;;\n\n  return (\n    &lt;div\n      className&#x3D;&#123;&#96;min-h-screen transition duration-500 $&#123;\n        darkMode ? &quot;bg-gray-800 text-white&quot; : &quot;bg-white text-black&quot;\n      &#125;&#96;&#125;\n    &gt;\n      &lt;div className&#x3D;&quot;container mx-auto p-4&quot;&gt;\n        &lt;h1 className&#x3D;&quot;text-2xl font-bold&quot;&gt;光明&#x2F;黑暗模式切换&lt;&#x2F;h1&gt;\n        &lt;button\n          onClick&#x3D;&#123;toggleTheme&#125;\n          className&#x3D;&quot;mt-4 px-4 py-2 bg-blue-500 text-white rounded&quot;\n        &gt;\n          切换模式\n        &lt;&#x2F;button&gt;\n        &lt;p className&#x3D;&quot;mt-4&quot;&gt;这是一个示例文本。&lt;&#x2F;p&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nexport default App;\n\n3. 解释\n状态管理：\n\n使用 useState 来管理 darkMode 状态，表示当前是否为黑暗模式。\n使用 useEffect 从 localStorage 中获取用户的主题设置，以便在页面加载时应用。\n\n\n切换主题：\n\ntoggleTheme 函数用于切换 darkMode 状态，并将当前主题保存到 localStorage。\n\n\n动态类名：\n\n使用模板字符串动态设置 className，根据 darkMode 状态应用不同的背景和文本颜色。\n\n\n\n4. 运行项目确保在项目目录中运行以下命令以启动开发服务器：\nnpm start\n\n5. 总结通过结合 React 和 Tailwind CSS，可以轻松实现光明和黑暗模式的切换功能。使用 localStorage 可以确保用户的选择在页面刷新后仍然有效。您可以根据需要进一步自定义样式和功能。\n网站的黑白色和正常色调如何实现在网站中实现黑白色（灰度）和正常色调的切换，可以通过 CSS 和 JavaScript 来控制元素的样式。以下是一个使用 React 和 Tailwind CSS 的示例，展示如何实现这种切换功能。\n1. 设置 Tailwind CSS确保在项目中安装了 Tailwind CSS。可以通过 npm 安装并配置 Tailwind CSS。\n安装 Tailwind CSSnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n\n配置 tailwind.config.js在 tailwind.config.js 中，确保启用 JIT 模式并设置内容路径：\nmodule.exports &#x3D; &#123;\n  mode: &quot;jit&quot;,\n  purge: [&quot;.&#x2F;src&#x2F;**&#x2F;*.&#123;js,jsx,ts,tsx&#125;&quot;, &quot;.&#x2F;public&#x2F;index.html&quot;],\n  theme: &#123;\n    extend: &#123;&#125;,\n  &#125;,\n  variants: &#123;\n    extend: &#123;&#125;,\n  &#125;,\n  plugins: [],\n&#125;;\n\n在 CSS 文件中引入 Tailwind在 src/index.css 中引入 Tailwind 的基础样式：\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n2. 创建 React 组件创建一个简单的 React 组件，包含黑白色和正常色调的切换功能。\n示例代码&#x2F;&#x2F; src&#x2F;App.js\nimport React, &#123; useState, useEffect &#125; from &quot;react&quot;;\n\nfunction App() &#123;\n  const [isGrayscale, setIsGrayscale] &#x3D; useState(false);\n\n  &#x2F;&#x2F; 从 localStorage 获取颜色设置\n  useEffect(() &#x3D;&gt; &#123;\n    const savedColorMode &#x3D; localStorage.getItem(&quot;colorMode&quot;);\n    if (savedColorMode &#x3D;&#x3D;&#x3D; &quot;grayscale&quot;) &#123;\n      setIsGrayscale(true);\n    &#125;\n  &#125;, []);\n\n  &#x2F;&#x2F; 切换颜色模式\n  const toggleColorMode &#x3D; () &#x3D;&gt; &#123;\n    setIsGrayscale(!isGrayscale);\n    if (!isGrayscale) &#123;\n      localStorage.setItem(&quot;colorMode&quot;, &quot;grayscale&quot;);\n    &#125; else &#123;\n      localStorage.setItem(&quot;colorMode&quot;, &quot;normal&quot;);\n    &#125;\n  &#125;;\n\n  return (\n    &lt;div\n      className&#x3D;&#123;&#96;min-h-screen transition duration-500 $&#123;\n        isGrayscale ? &quot;filter grayscale&quot; : &quot;&quot;\n      &#125;&#96;&#125;\n    &gt;\n      &lt;div className&#x3D;&quot;container mx-auto p-4&quot;&gt;\n        &lt;h1 className&#x3D;&quot;text-2xl font-bold&quot;&gt;黑白色与正常色调切换&lt;&#x2F;h1&gt;\n        &lt;button\n          onClick&#x3D;&#123;toggleColorMode&#125;\n          className&#x3D;&quot;mt-4 px-4 py-2 bg-blue-500 text-white rounded&quot;\n        &gt;\n          切换颜色模式\n        &lt;&#x2F;button&gt;\n        &lt;p className&#x3D;&quot;mt-4&quot;&gt;这是一个示例文本。&lt;&#x2F;p&gt;\n        &lt;p className&#x3D;&quot;mt-4&quot;&gt;您可以在黑白色和正常色调之间切换。&lt;&#x2F;p&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nexport default App;\n\n3. 解释\n状态管理：\n\n使用 useState 来管理 isGrayscale 状态，表示当前是否为黑白色模式。\n使用 useEffect 从 localStorage 中获取用户的颜色设置，以便在页面加载时应用。\n\n\n切换颜色模式：\n\ntoggleColorMode 函数用于切换 isGrayscale 状态，并将当前颜色模式保存到 localStorage。\n\n\n动态类名：\n\n使用模板字符串动态设置 className，根据 isGrayscale 状态应用 filter grayscale 类。\n\n\n\n4. 运行项目确保在项目目录中运行以下命令以启动开发服务器：\nnpm start\n\n5. 总结通过结合 React 和 Tailwind CSS，可以轻松实现黑白色和正常色调的切换功能。使用 localStorage 可以确保用户的选择在页面刷新后仍然有效。您可以根据需要进一步自定义样式和功能。\n","slug":"interview-css","date":"2024-12-28T06:03:24.000Z","categories_index":"interview","tags_index":"css","author_index":"X-29"},{"id":"3aa405af8114bdbedccc4d79b50ad9ac","title":"interview-html","content":"src 和 href 的区别在 HTML 中，src 和 href 是两个常用的属性，它们的主要区别在于它们的用途和适用的标签。以下是详细的解释：\n1. src 属性\n全称：source（源）\n用途：用于指定外部资源的路径，通常用于嵌入媒体文件，如图像、音频、视频等。\n适用标签：\n&lt;img&gt;：用于图像\n&lt;script&gt;：用于 JavaScript 文件\n&lt;iframe&gt;：用于嵌入其他网页\n&lt;audio&gt; 和 &lt;video&gt;：用于音频和视频文件\n\n\n\n示例：&lt;img src&#x3D;&quot;image.jpg&quot; alt&#x3D;&quot;示例图像&quot; &#x2F;&gt;\n&lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;iframe src&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot;&gt;&lt;&#x2F;iframe&gt;\n\n2. href 属性\n全称：hyperlink reference（超链接引用）\n用途：用于指定链接的目标地址，通常用于创建超链接。\n适用标签：\n&lt;a&gt;：用于超链接\n&lt;link&gt;：用于链接外部样式表\n\n\n\n示例：&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot;&gt;访问示例网站&lt;&#x2F;a&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;styles.css&quot; &#x2F;&gt;\n\n总结HTML 语义化是指使用 HTML 标签来准确地描述网页内容的意义和结构，而不仅仅是为了视觉效果。语义化的 HTML 使得网页更易于理解、维护和优化，尤其是在搜索引擎优化（SEO）和无障碍访问方面。\n1. 语义化的好处\n提高可读性：语义化的标签使得代码更易于阅读和理解，开发者可以快速识别网页的结构和内容。\n增强 SEO：搜索引擎能够更好地理解网页内容，从而提高网页在搜索结果中的排名。\n改善无障碍访问：使用语义化标签可以帮助屏幕阅读器等辅助技术更好地解析网页内容，提升残障人士的访问体验。\n便于维护：清晰的结构使得后续的维护和更新变得更加简单。\n\n2. 常用的语义化标签\n&lt;header&gt;：定义文档的头部，通常包含网站的标题、导航等。\n&lt;nav&gt;：定义导航链接的部分。\n&lt;main&gt;：定义文档的主要内容。\n&lt;article&gt;：定义独立的内容块，通常是博客文章或新闻报道。\n&lt;section&gt;：定义文档中的一个区域，通常包含相关的内容。\n&lt;aside&gt;：定义与主内容相关但不直接相关的内容，如侧边栏。\n&lt;footer&gt;：定义文档的底部，通常包含版权信息、联系信息等。\n\n3. 示例以下是一个简单的 HTML 结构示例，展示了如何使用语义化标签：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;语义化 HTML 示例&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;header&gt;\n      &lt;h1&gt;我的网站&lt;&#x2F;h1&gt;\n      &lt;nav&gt;\n        &lt;ul&gt;\n          &lt;li&gt;&lt;a href&#x3D;&quot;#home&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n          &lt;li&gt;&lt;a href&#x3D;&quot;#about&quot;&gt;关于我们&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n          &lt;li&gt;&lt;a href&#x3D;&quot;#contact&quot;&gt;联系我们&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;nav&gt;\n    &lt;&#x2F;header&gt;\n    &lt;main&gt;\n      &lt;article&gt;\n        &lt;h2&gt;第一篇文章&lt;&#x2F;h2&gt;\n        &lt;p&gt;这是文章的内容。&lt;&#x2F;p&gt;\n      &lt;&#x2F;article&gt;\n      &lt;section&gt;\n        &lt;h2&gt;相关信息&lt;&#x2F;h2&gt;\n        &lt;p&gt;这是与文章相关的信息。&lt;&#x2F;p&gt;\n      &lt;&#x2F;section&gt;\n    &lt;&#x2F;main&gt;\n    &lt;aside&gt;\n      &lt;h2&gt;侧边栏&lt;&#x2F;h2&gt;\n      &lt;p&gt;这是侧边栏的内容。&lt;&#x2F;p&gt;\n    &lt;&#x2F;aside&gt;\n    &lt;footer&gt;\n      &lt;p&gt;© 2023 我的公司&lt;&#x2F;p&gt;\n    &lt;&#x2F;footer&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结HTML 语义化不仅有助于提升网页的可读性和可维护性，还能增强搜索引擎的理解能力和无障碍访问体验。使用合适的语义化标签是现代网页开发的重要实践。\nDOCTYPE(⽂档类型) 的作⽤DOCTYPE（文档类型声明）是 HTML 文档的第一行代码，用于告诉浏览器该文档使用的 HTML 或 XHTML 版本。它的主要作用包括以下几个方面：\n1. 指定文档类型DOCTYPE 声明帮助浏览器识别文档的类型和版本，从而正确解析和渲染网页。不同的 HTML 版本有不同的语法和特性，DOCTYPE 确保浏览器使用正确的规则来处理文档。\n2. 启用标准模式使用 DOCTYPE 声明可以使浏览器进入标准模式（Standards Mode），在这种模式下，浏览器会遵循 W3C 的标准来渲染页面。没有 DOCTYPE 声明时，浏览器可能会进入怪异模式（Quirks Mode），这可能导致页面在不同浏览器中的表现不一致。\n3. 提高兼容性通过明确指定文档类型，开发者可以确保网页在不同浏览器和设备上的兼容性。这样可以减少因浏览器解析差异而导致的显示问题。\n4. 示例以下是几种常见的 DOCTYPE 声明示例：\n\nHTML5：\n&lt;!DOCTYPE html&gt;\n\nHTML 4.01：\n&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;\n\nXHTML 1.0：\n&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Strict&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-strict.dtd&quot;&gt;\n\n5. 总结DOCTYPE 声明在 HTML 文档中起着至关重要的作用，它不仅指定了文档的类型和版本，还影响浏览器的渲染模式和兼容性。为了确保网页的正确显示和良好的用户体验，建议在每个 HTML 文档的开头都包含适当的 DOCTYPE 声明。\nscript 标签中 defer 和 async 的区别在 HTML 中，&lt;script&gt; 标签用于引入和执行 JavaScript 代码。为了优化网页的加载性能，&lt;script&gt; 标签可以使用 defer 和 async 属性。这两个属性的主要区别在于它们的加载和执行方式。以下是详细的解释：\n1. defer 属性\n加载方式：当使用 defer 属性时，脚本会在文档解析完成后异步加载，但会在 DOMContentLoaded 事件之前执行。\n执行顺序：多个带有 defer 的脚本会按照它们在文档中出现的顺序依次执行。\n适用场景：适合需要在 DOM 完全加载后执行的脚本，尤其是当脚本之间有依赖关系时。\n\n示例：&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;使用 defer&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;script1.js&quot; defer&gt;&lt;&#x2F;script&gt;\n    &lt;script src&#x3D;&quot;script2.js&quot; defer&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n2. async 属性\n加载方式：当使用 async 属性时，脚本会异步加载，并且在加载完成后立即执行，而不等待文档解析完成。\n执行顺序：多个带有 async 的脚本的执行顺序是不确定的，取决于它们的加载时间。\n适用场景：适合独立的脚本，不依赖于其他脚本或 DOM 的内容。\n\n示例：&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;使用 async&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;script1.js&quot; async&gt;&lt;&#x2F;script&gt;\n    &lt;script src&#x3D;&quot;script2.js&quot; async&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n3. 总结\n**defer**：脚本异步加载，执行顺序按照文档中的顺序，适合需要在 DOM 加载完成后执行的脚本。\n**async**：脚本异步加载，执行顺序不确定，适合独立的脚本。\n\n选择使用 defer 还是 async 取决于脚本的依赖关系和执行时机。如果脚本需要在 DOM 完全加载后执行，使用 defer；如果脚本是独立的，可以使用 async。\n常⽤的 meta 标签有哪些在 HTML 中，&lt;meta&gt; 标签用于提供关于文档的元数据，这些元数据不会直接显示在网页上，但对浏览器、搜索引擎和其他服务非常重要。以下是一些常用的 &lt;meta&gt; 标签及其作用：\n1. 字符集声明&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\n\n作用：指定文档的字符编码，UTF-8 是一种常用的字符编码，支持多种语言字符。\n\n2. 页面描述&lt;meta\n  name&#x3D;&quot;description&quot;\n  content&#x3D;&quot;这是一个示例网页，用于展示常用的 meta 标签。&quot;\n&#x2F;&gt;\n\n\n作用：提供网页的简短描述，搜索引擎通常会在搜索结果中显示这个描述。\n\n3. 关键词&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;HTML, meta 标签, 示例, 编程&quot; &#x2F;&gt;\n\n\n作用：列出与网页内容相关的关键词，虽然现代搜索引擎对这个标签的重视程度降低，但仍然可以提供一些帮助。\n\n4. 作者信息&lt;meta name&#x3D;&quot;author&quot; content&#x3D;&quot;张三&quot; &#x2F;&gt;\n\n\n作用：指定网页的作者信息。\n\n5. 视口设置&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n\n\n作用：控制网页在移动设备上的布局和缩放，确保网页在不同设备上良好显示。\n\n6. 兼容性设置&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n\n\n作用：指定 Internet Explorer 的渲染模式，IE=edge 表示使用最新的渲染引擎。\n\n7. 版权信息&lt;meta name&#x3D;&quot;copyright&quot; content&#x3D;&quot;© 2023 我的公司&quot; &#x2F;&gt;\n\n\n作用：提供网页的版权信息。\n\n8. 社交媒体分享&lt;meta property&#x3D;&quot;og:title&quot; content&#x3D;&quot;示例网页&quot; &#x2F;&gt;\n&lt;meta\n  property&#x3D;&quot;og:description&quot;\n  content&#x3D;&quot;这是一个示例网页，用于展示常用的 meta 标签。&quot;\n&#x2F;&gt;\n&lt;meta property&#x3D;&quot;og:image&quot; content&#x3D;&quot;image.jpg&quot; &#x2F;&gt;\n&lt;meta property&#x3D;&quot;og:url&quot; content&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot; &#x2F;&gt;\n\n\n作用：用于社交媒体分享时的元数据，og 表示 Open Graph 协议，帮助在社交平台上更好地展示链接。\n\n9. 其他常用标签\n刷新页面：&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;30&quot; &#x2F;&gt;\n\n作用：每 30 秒刷新一次页面。\n\n\n\n总结&lt;meta&gt; 标签在网页中扮演着重要的角色，提供了关于文档的各种信息，帮助浏览器和搜索引擎更好地理解和处理网页内容。根据需要，可以选择合适的 &lt;meta&gt; 标签来优化网页的表现和可访问性。\nHTML5 有哪些更新HTML5 是 HTML 的最新版本，相较于之前的版本，HTML5 引入了许多新特性和改进。以下是一些主要的更新和新特性：\n1. 新的语义元素HTML5 引入了一些新的语义标签，使得网页结构更加清晰和易于理解：\n\n&lt;header&gt;：定义文档的头部。\n&lt;nav&gt;：定义导航链接的部分。\n&lt;main&gt;：定义文档的主要内容。\n&lt;section&gt;：定义文档中的一个区域。\n&lt;article&gt;：定义独立的内容块。\n&lt;aside&gt;：定义与主内容相关但不直接相关的内容。\n&lt;footer&gt;：定义文档的底部。\n\n2. 新的表单控件HTML5 增强了表单功能，新增了一些输入类型和属性：\n\n新的输入类型：email、url、date、time、number、range、color 等。\n新的表单属性：placeholder、required、pattern、autocomplete 等。\n\n3. 多媒体支持HTML5 提供了原生的音频和视频支持，使用 &lt;audio&gt; 和 &lt;video&gt; 标签，无需依赖外部插件：\n&lt;audio controls&gt;\n  &lt;source src&#x3D;&quot;audio.mp3&quot; type&#x3D;&quot;audio&#x2F;mpeg&quot; &#x2F;&gt;\n  您的浏览器不支持音频元素。\n&lt;&#x2F;audio&gt;\n\n&lt;video width&#x3D;&quot;320&quot; height&#x3D;&quot;240&quot; controls&gt;\n  &lt;source src&#x3D;&quot;video.mp4&quot; type&#x3D;&quot;video&#x2F;mp4&quot; &#x2F;&gt;\n  您的浏览器不支持视频元素。\n&lt;&#x2F;video&gt;\n\n4. Canvas 和 SVGHTML5 引入了 &lt;canvas&gt; 元素，允许在网页上动态绘制图形和动画：\n&lt;canvas\n  id&#x3D;&quot;myCanvas&quot;\n  width&#x3D;&quot;200&quot;\n  height&#x3D;&quot;100&quot;\n  style&#x3D;&quot;border:1px solid #000000;&quot;\n&gt;&lt;&#x2F;canvas&gt;\n\n5. 本地存储HTML5 提供了本地存储 API，允许在用户的浏览器中存储数据，分为两种：\n\nlocalStorage：持久存储，数据不会过期。\nsessionStorage：会话存储，数据在浏览器会话结束时清除。\n\n6. 地理位置 APIHTML5 引入了地理位置 API，允许网页获取用户的地理位置信息：\nnavigator.geolocation.getCurrentPosition(function (position) &#123;\n  console.log(position.coords.latitude, position.coords.longitude);\n&#125;);\n\n7. WebSocketsHTML5 引入了 WebSockets，允许在客户端和服务器之间建立持久的双向通信通道，适用于实时应用。\n8. 离线应用HTML5 提供了应用缓存（Application Cache）和 Service Workers，允许网页在离线状态下运行。\n9. 新的 APIHTML5 还引入了许多新的 API，如：\n\n拖放 API：支持拖放操作。\nWeb Workers：允许在后台线程中运行 JavaScript，提升性能。\nWeb Storage：提供更简单的本地存储解决方案。\n\n总结HTML5 带来了许多新的特性和改进，使得网页开发更加灵活和强大。通过引入新的语义元素、多媒体支持、存储解决方案和各种 API，HTML5 使得开发者能够创建更丰富和互动的用户体验。\nimg 的 srcset 属性的作⽤？&lt;img&gt; 标签中的 srcset 属性用于提供多个图像资源，以便浏览器根据不同的条件（如屏幕分辨率、视口大小等）选择最合适的图像进行加载。这种技术被称为响应式图像，可以提高网页的加载性能和用户体验。\n1. 主要作用\n适应不同设备：srcset 允许开发者为不同的设备和屏幕分辨率提供不同的图像版本，从而确保在各种设备上都能获得最佳的视觉效果。\n优化加载性能：通过根据设备的特性选择合适的图像，减少不必要的带宽消耗，提高页面加载速度。\n提高图像质量：在高分辨率设备（如 Retina 显示屏）上，可以提供更高质量的图像，确保图像清晰可见。\n\n2. 使用方式srcset 属性通常与 sizes 属性一起使用，sizes 属性定义了图像在不同条件下的显示大小。以下是一个示例：\n&lt;img\n  src&#x3D;&quot;image-small.jpg&quot;\n  srcset&#x3D;&quot;image-small.jpg 600w, image-medium.jpg 1200w, image-large.jpg 1800w&quot;\n  sizes&#x3D;&quot;(max-width: 600px) 100vw, \n           (max-width: 1200px) 50vw, \n           33vw&quot;\n  alt&#x3D;&quot;示例图像&quot;\n&#x2F;&gt;\n\n3. 示例解析\n**src**：提供了默认图像（在不支持 srcset 的浏览器中使用）。\n**srcset**：列出了不同图像及其对应的宽度（600w、1200w、1800w），浏览器会根据设备的屏幕宽度选择合适的图像。\n**sizes**：定义了在不同条件下图像的显示大小：\n当视口宽度小于或等于 600px 时，图像宽度为 100%（100vw）。\n当视口宽度小于或等于 1200px 时，图像宽度为 50%（50vw）。\n在其他情况下，图像宽度为 33%（33vw）。\n\n\n\n4. 总结srcset 属性使得开发者能够为不同的设备和条件提供多种图像选择，从而优化网页的加载性能和用户体验。通过合理使用 srcset 和 sizes，可以确保在各种设备上都能展示出最佳的图像效果。\n行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？在 HTML 中，元素可以根据其显示特性分为三种类型：行内元素、块级元素和空（void）元素。以下是对这三种元素的详细分类和说明：\n1. 行内元素行内元素（Inline Elements）是指不会在前后产生换行的元素，它们通常用于文本内容的格式化。常见的行内元素包括：\n\n&lt;a&gt;：超链接\n&lt;span&gt;：通用的行内容器\n&lt;strong&gt;：加粗文本\n&lt;em&gt;：斜体文本\n&lt;b&gt;：加粗文本（不带语义）\n&lt;i&gt;：斜体文本（不带语义）\n&lt;img&gt;：图像\n&lt;br&gt;：换行\n&lt;code&gt;：代码片段\n&lt;small&gt;：小号文本\n&lt;sub&gt;：下标\n&lt;sup&gt;：上标\n&lt;time&gt;：时间\n&lt;label&gt;：表单标签\n\n2. 块级元素块级元素（Block Elements）是指在前后会产生换行的元素，它们通常用于构建页面的结构。常见的块级元素包括：\n\n&lt;div&gt;：通用的块级容器\n&lt;p&gt;：段落\n&lt;h1&gt; 到 &lt;h6&gt;：标题（从大到小）\n&lt;ul&gt;：无序列表\n&lt;ol&gt;：有序列表\n&lt;li&gt;：列表项\n&lt;header&gt;：文档头部\n&lt;footer&gt;：文档底部\n&lt;section&gt;：文档中的一个区域\n&lt;article&gt;：独立的内容块\n&lt;aside&gt;：与主内容相关但不直接相关的内容\n&lt;table&gt;：表格\n&lt;form&gt;：表单\n\n3. 空（void）元素空元素（Void Elements）是指没有结束标签的元素，它们通常用于插入内容或提供功能。常见的空元素包括：\n\n&lt;br&gt;：换行\n&lt;hr&gt;：水平线\n&lt;img&gt;：图像\n&lt;input&gt;：输入框\n&lt;link&gt;：链接外部资源（如样式表）\n&lt;meta&gt;：提供文档的元数据\n&lt;base&gt;：指定相对 URL 的基准 URL\n&lt;source&gt;：为 &lt;audio&gt; 和 &lt;video&gt; 提供多个资源\n&lt;track&gt;：为 &lt;video&gt; 提供文本轨道\n&lt;area&gt;：定义图像地图中的区域\n\n总结\n行内元素：不会产生换行，通常用于文本格式化。\n块级元素：会产生换行，通常用于构建页面结构。\n空元素：没有结束标签，通常用于插入内容或提供功能。\n\n说一下 web workerWeb Worker 是一种在浏览器中运行 JavaScript 的机制，允许开发者在后台线程中执行脚本，从而实现多线程编程。Web Worker 的主要目的是提高网页的性能，尤其是在处理大量计算或长时间运行的任务时，避免阻塞主线程（UI 线程），从而保持用户界面的响应性。\n1. Web Worker 的特点\n并行执行：Web Worker 在独立的线程中运行，可以与主线程并行执行，避免了长时间的计算导致用户界面卡顿。\n不访问 DOM：Web Worker 不能直接访问 DOM 和窗口对象，但可以通过消息传递与主线程进行通信。\n异步处理：Web Worker 的任务是异步的，主线程可以继续执行其他操作，而不必等待 Worker 完成任务。\n\n2. 创建 Web Worker要创建一个 Web Worker，通常需要以下步骤：\n\n创建 Worker 脚本：编写一个 JavaScript 文件，包含 Worker 要执行的代码。\n&#x2F;&#x2F; worker.js\nself.onmessage &#x3D; function (event) &#123;\n  const result &#x3D; event.data * 2; &#x2F;&#x2F; 处理数据\n  self.postMessage(result); &#x2F;&#x2F; 将结果发送回主线程\n&#125;;\n\n在主线程中创建 Worker 实例：\n&#x2F;&#x2F; main.js\nconst worker &#x3D; new Worker(&quot;worker.js&quot;);\n\nworker.onmessage &#x3D; function (event) &#123;\n  console.log(&quot;Worker 返回的结果:&quot;, event.data);\n&#125;;\n\nworker.postMessage(10); &#x2F;&#x2F; 向 Worker 发送数据\n\n3. 消息传递主线程和 Worker 之间通过 postMessage 方法进行消息传递。主线程可以使用 worker.postMessage(data) 向 Worker 发送数据，而 Worker 可以使用 self.postMessage(data) 向主线程发送数据。\n4. 终止 Worker可以使用 worker.terminate() 方法终止 Worker 的执行。Worker 一旦被终止，将无法再恢复。\n5. 使用场景Web Worker 适用于以下场景：\n\n复杂计算：处理大量数据或复杂算法时，可以将计算任务放在 Worker 中执行。\n数据处理：在后台处理数据（如图像处理、文件解析等），避免阻塞主线程。\n实时应用：在实时应用中（如在线游戏、聊天应用等），可以使用 Worker 处理网络请求和数据更新。\n\n6. 注意事项\nWeb Worker 不能访问 DOM，因此需要通过消息传递与主线程进行交互。\nWorker 脚本必须在同源策略下加载，不能跨域。\nWorker 的创建和通信会有一定的性能开销，因此适合用于长时间运行的任务。\n\n总结Web Worker 是一种强大的工具，可以帮助开发者在浏览器中实现多线程编程，提升网页的性能和用户体验。通过将计算密集型任务放在后台线程中执行，Web Worker 可以有效避免主线程的阻塞，保持用户界面的流畅性。\nHTML5 的离线储存怎么使用，它的工作原理是什么HTML5 的离线存储主要通过两种技术实现：应用缓存（Application Cache）和Web Storage（包括 localStorage 和 sessionStorage）。以下是这两种技术的详细介绍及其工作原理。\n1. 应用缓存（Application Cache）工作原理应用缓存允许开发者指定哪些资源（如 HTML、CSS、JavaScript、图像等）可以在用户的设备上缓存，以便在离线状态下访问。应用缓存的工作原理如下：\n\nManifest 文件：开发者需要创建一个清单文件（manifest file），该文件列出了需要缓存的资源和其他相关信息。\n浏览器缓存：当用户首次访问网页时，浏览器会下载并缓存清单文件中列出的所有资源。\n离线访问：当用户处于离线状态时，浏览器会从缓存中加载资源，而不是从网络请求。\n\n示例&lt;!DOCTYPE html&gt;\n&lt;html manifest&#x3D;&quot;example.appcache&quot;&gt;\n  &lt;head&gt;\n    &lt;title&gt;离线应用示例&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎使用离线应用&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nmanifest 文件（example.appcache）：\nCACHE MANIFEST\n# 版本 1.0\n\nCACHE:\nindex.html\nstyles.css\nscript.js\n\nNETWORK:\n*\n\n\nCACHE：列出需要缓存的资源。\nNETWORK：列出需要从网络请求的资源，* 表示所有其他资源。\n\n注意事项\n应用缓存已被标记为过时，建议使用 Service Workers 作为替代方案。\n\n2. Web StorageWeb Storage 提供了两种存储机制：localStorage 和 sessionStorage。\n2.1 localStorage\n持久性：数据存储在用户的浏览器中，直到被显式删除，数据不会过期。\n存储大小：通常可以存储约 5MB 的数据。\n\n使用示例：\n&#x2F;&#x2F; 存储数据\nlocalStorage.setItem(&quot;key&quot;, &quot;value&quot;);\n\n&#x2F;&#x2F; 读取数据\nconst value &#x3D; localStorage.getItem(&quot;key&quot;);\n\n&#x2F;&#x2F; 删除数据\nlocalStorage.removeItem(&quot;key&quot;);\n\n&#x2F;&#x2F; 清空所有数据\nlocalStorage.clear();\n\n2.2 sessionStorage\n会话性：数据仅在当前会话中有效，浏览器窗口关闭后数据会被清除。\n存储大小：通常可以存储约 5MB 的数据。\n\n使用示例：\n&#x2F;&#x2F; 存储数据\nsessionStorage.setItem(&quot;sessionKey&quot;, &quot;sessionValue&quot;);\n\n&#x2F;&#x2F; 读取数据\nconst sessionValue &#x3D; sessionStorage.getItem(&quot;sessionKey&quot;);\n\n&#x2F;&#x2F; 删除数据\nsessionStorage.removeItem(&quot;sessionKey&quot;);\n\n&#x2F;&#x2F; 清空所有数据\nsessionStorage.clear();\n\n3. 总结\n应用缓存：允许开发者缓存网页资源以便离线访问，但已被标记为过时，建议使用 Service Workers。\nWeb Storage：提供 localStorage 和 sessionStorage，用于在浏览器中存储数据，适合需要持久化或会话性的数据存储。\n\n通过合理使用这些技术，开发者可以创建更好的用户体验，允许用户在离线状态下访问网页和应用。\n浏览器是如何对 HTML5 的离线储存资源进行管理和加载？浏览器对 HTML5 的离线存储资源进行管理和加载的方式主要依赖于应用缓存（Application Cache）和 Web Storage（localStorage 和 sessionStorage）。以下是这两种技术的详细管理和加载机制：\n1. 应用缓存（Application Cache）管理和加载过程\n清单文件（Manifest File）：\n\n开发者创建一个清单文件，列出需要缓存的资源。\n清单文件的 MIME 类型应为 text/cache-manifest。\n\n\n首次加载：\n\n当用户首次访问网页时，浏览器会请求清单文件。\n浏览器解析清单文件，下载并缓存文件中列出的所有资源。\n\n\n资源更新：\n\n如果清单文件的内容发生变化（例如，版本号更新），浏览器会重新下载清单文件并更新缓存。\n开发者可以通过在清单文件中添加注释（如 # version 1.0）来强制浏览器更新缓存。\n\n\n离线访问：\n\n当用户处于离线状态时，浏览器会从缓存中加载资源，而不是从网络请求。\n如果请求的资源不在缓存中，浏览器会显示错误页面。\n\n\n事件管理：\n\n浏览器会触发一些事件，如 updateready，开发者可以通过 JavaScript 监听这些事件，以便在资源更新时进行相应处理。\n\n\n\n注意事项\n应用缓存已被标记为过时，建议使用 Service Workers 作为替代方案。\n\n2. Web Storage管理和加载过程\n数据存储：\n\n开发者可以使用 localStorage 和 sessionStorage API 存储数据。\n数据以键值对的形式存储，localStorage 的数据在浏览器关闭后仍然存在，而 sessionStorage 的数据在浏览器会话结束后被清除。\n\n\n数据访问：\n\n开发者可以通过 getItem 方法读取存储的数据，通过 setItem 方法存储数据。\n数据的存储和读取是同步的，操作简单且快速。\n\n\n数据管理：\n\n开发者可以使用 removeItem 方法删除特定的键值对，使用 clear 方法清空所有存储的数据。\n\n\n存储限制：\n\n大多数浏览器对 localStorage 和 sessionStorage 的存储大小限制在 5MB 左右，具体取决于浏览器的实现。\n\n\n\n3. 总结\n应用缓存：通过清单文件管理和加载离线资源，允许用户在离线状态下访问网页。虽然功能强大，但已被标记为过时，建议使用 Service Workers。\nWeb Storage：提供简单的 API 来管理和加载数据，适合需要持久化或会话性的数据存储。\n\n通过这些机制，浏览器能够有效地管理和加载 HTML5 的离线存储资源，提升用户体验，允许用户在没有网络连接的情况下访问网页和应用。\ntitle 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？在 HTML 中，&lt;title&gt;、&lt;h1&gt;、&lt;b&gt;、&lt;strong&gt;、&lt;i&gt; 和 &lt;em&gt; 等标签各自有不同的语义和用途。以下是它们之间的区别：\n1. &lt;title&gt; 与 &lt;h1&gt;\n**&lt;title&gt;**：\n\n用途：定义文档的标题，显示在浏览器的标题栏或标签页上。\n位置：位于 &lt;head&gt; 部分。\n语义：用于描述网页的主题或内容，通常对搜索引擎优化（SEO）非常重要。\n\n&lt;head&gt;\n  &lt;title&gt;我的网页标题&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n**&lt;h1&gt;**：\n\n用途：定义文档的主标题，通常是页面内容的主要主题。\n位置：位于 &lt;body&gt; 部分，可以出现在任何地方。\n语义：表示页面的主要内容，通常是 SEO 中最重要的标题标签。\n\n&lt;h1&gt;欢迎来到我的网页&lt;&#x2F;h1&gt;\n\n2. &lt;b&gt; 与 &lt;strong&gt;\n**&lt;b&gt;**：\n\n用途：用于加粗文本，但没有语义意义。\n语义：仅用于视觉效果，不传达任何重要性。\n\n&lt;p&gt;这是一个&lt;b&gt;加粗&lt;&#x2F;b&gt;的文本。&lt;&#x2F;p&gt;\n\n**&lt;strong&gt;**：\n\n用途：用于强调文本，通常以加粗显示。\n语义：表示文本的重要性，通常用于传达更强的语气或重要性。\n\n&lt;p&gt;这是一个&lt;strong&gt;重要&lt;&#x2F;strong&gt;的文本。&lt;&#x2F;p&gt;\n\n3. &lt;i&gt; 与 &lt;em&gt;\n**&lt;i&gt;**：\n\n用途：用于斜体文本，但没有语义意义。\n语义：仅用于视觉效果，不传达任何强调。\n\n&lt;p&gt;这是一个&lt;i&gt;斜体&lt;&#x2F;i&gt;的文本。&lt;&#x2F;p&gt;\n\n**&lt;em&gt;**：\n\n用途：用于强调文本，通常以斜体显示。\n语义：表示文本的强调，通常用于传达更强的语气。\n\n&lt;p&gt;这是一个&lt;em&gt;强调&lt;&#x2F;em&gt;的文本。&lt;&#x2F;p&gt;\n\n总结\n**&lt;title&gt;**：文档的标题，位于 &lt;head&gt; 中，影响浏览器标签和 SEO。\n**&lt;h1&gt;**：页面的主标题，位于 &lt;body&gt; 中，表示主要内容。\n**&lt;b&gt;**：加粗文本，无语义意义。\n**&lt;strong&gt;**：强调文本，表示重要性。\n**&lt;i&gt;**：斜体文本，无语义意义。\n**&lt;em&gt;**：强调文本，表示语气的强调。\n\n使用语义化的标签（如 &lt;strong&gt; 和 &lt;em&gt;）有助于提高网页的可访问性和 SEO 效果，而仅用于视觉效果的标签（如 &lt;b&gt; 和 &lt;i&gt;）则应谨慎使用。\niframe 有那些优点和缺点？&lt;iframe&gt;（内联框架）是 HTML 中用于嵌入另一个 HTML 页面或文档的元素。使用 &lt;iframe&gt; 有其优点和缺点，以下是详细的分析：\n优点\n内容嵌入：\n\n可以轻松嵌入其他网页、视频、地图等内容，而无需重定向用户到新页面。\n\n\n隔离性：\n\n嵌入的内容在自己的上下文中运行，与主页面的 JavaScript 和 CSS 相互独立，减少了样式和脚本冲突的可能性。\n\n\n跨域内容：\n\n可以嵌入来自不同域的内容，允许在同一页面上显示外部资源（如社交媒体小部件、广告等）。\n\n\n便于实现复杂布局：\n\n可以在页面中创建复杂的布局，允许在同一页面中显示多个不同的内容区域。\n\n\n动态加载：\n\n可以根据需要动态加载内容，减少初始页面加载的负担。\n\n\n\n缺点\n性能问题：\n\n嵌入的页面会增加额外的 HTTP 请求，可能导致页面加载速度变慢，尤其是当嵌入的内容较大时。\n\n\nSEO 问题：\n\n搜索引擎可能不会索引 &lt;iframe&gt; 中的内容，这可能影响嵌入内容的可见性和 SEO 效果。\n\n\n安全性问题：\n\n嵌入的内容可能包含恶意代码，导致安全风险。需要确保嵌入的内容来自可信来源。\n可能受到点击劫持（Clickjacking）攻击的风险。\n\n\n用户体验：\n\n嵌入的内容可能导致用户体验不佳，尤其是在移动设备上，可能会影响响应式设计。\n\n\n跨域限制：\n\n对于跨域的 &lt;iframe&gt;，JavaScript 访问嵌入内容的限制（同源策略）可能会导致功能受限。\n\n\n\n总结&lt;iframe&gt; 是一个强大的工具，可以方便地嵌入外部内容，但在使用时需要权衡其优缺点。开发者应考虑性能、安全性和用户体验等因素，合理使用 &lt;iframe&gt;，确保嵌入的内容来自可信来源，并在必要时采取安全措施。\nlabel 的作用是什么？如何使用？&lt;label&gt; 标签在 HTML 中用于为表单控件提供可点击的标签。它的主要作用是增强表单的可用性和可访问性，使用户能够更容易地与表单元素进行交互。以下是关于 &lt;label&gt; 的详细说明及其使用方法：\n1. 作用\n提高可用性：当用户点击 &lt;label&gt; 标签时，浏览器会自动将焦点转移到与之关联的表单控件（如输入框、复选框等），这使得用户在填写表单时更加方便。\n增强可访问性：为表单控件提供描述性标签，有助于使用屏幕阅读器的用户理解表单的功能，提高无障碍访问性。\n\n2. 使用方法&lt;label&gt; 标签可以通过两种方式与表单控件关联：\n2.1 使用 for 属性使用 for 属性将 &lt;label&gt; 标签与特定的表单控件关联。for 属性的值应与表单控件的 id 属性相同。\n&lt;label for&#x3D;&quot;username&quot;&gt;用户名：&lt;&#x2F;label&gt;\n&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;\n\n在这个示例中，当用户点击“用户名”标签时，焦点会转移到输入框中。\n2.2 包裹表单控件另一种方式是将表单控件直接放在 &lt;label&gt; 标签内，这样也可以实现关联。\n&lt;label\n  &gt;用户名：\n  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;\n&lt;&#x2F;label&gt;\n\n在这个示例中，点击“用户名”文本或输入框都会将焦点转移到输入框中。\n3. 示例以下是一个完整的表单示例，展示了如何使用 &lt;label&gt; 标签：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;表单示例&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;form&gt;\n      &lt;label for&#x3D;&quot;username&quot;&gt;用户名：&lt;&#x2F;label&gt;\n      &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; required &#x2F;&gt;\n      &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;\n\n      &lt;label for&#x3D;&quot;password&quot;&gt;密码：&lt;&#x2F;label&gt;\n      &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; required &#x2F;&gt;\n      &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;\n\n      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;\n    &lt;&#x2F;form&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结\n&lt;label&gt; 标签用于为表单控件提供可点击的标签，增强用户体验和可访问性。\n可以通过 for 属性与表单控件关联，或将表单控件包裹在 &lt;label&gt; 标签内。\n使用 &lt;label&gt; 标签可以提高表单的可用性，特别是对于使用辅助技术的用户。\n\nCanvas 和 SVG 的区别Canvas 和 SVG 是两种在网页上绘制图形的技术，各自有不同的特点和适用场景。以下是它们之间的主要区别：\n1. 定义和基本概念\nCanvas：\n\nCanvas 是一个 HTML 元素（&lt;canvas&gt;），用于在网页上以像素为基础绘制图形。\n使用 JavaScript API 进行绘制，适合动态生成图形和动画。\n\n\nSVG：\n\nSVG（可缩放矢量图形）是一种基于 XML 的矢量图形格式，用于描述二维图形。\n图形是由路径、形状和文本等元素组成，适合静态图形和可缩放的图像。\n\n\n\n2. 渲染方式\nCanvas：\n\n以位图（像素）方式渲染，绘制后无法直接修改单个图形元素。\n每次重绘时需要重新绘制所有内容，适合需要频繁更新的场景（如游戏、动画）。\n\n\nSVG：\n\n以矢量方式渲染，图形元素可以独立操作和修改。\n可以通过 CSS 和 JavaScript 直接操作和动画化单个元素，适合静态图形和交互式图形。\n\n\n\n3. 性能\nCanvas：\n\n在处理大量图形时性能较好，适合高频率的重绘（如游戏）。\n由于是位图，图形质量在缩放时可能会降低。\n\n\nSVG：\n\n在处理复杂图形时性能可能较差，尤其是当图形元素数量较多时。\n矢量图形在缩放时不会失去质量，适合需要高质量图形的场景。\n\n\n\n4. 文件大小\nCanvas：\n\n通常生成的图形是位图，文件大小取决于图像的分辨率和复杂度。\n\n\nSVG：\n\n由于是基于 XML 的文本格式，文件大小通常较小，尤其是对于简单图形。\n复杂图形可能导致文件大小增加，但仍然比位图小。\n\n\n\n5. 适用场景\nCanvas：\n\n适合游戏、动画、实时数据可视化等需要频繁更新的场景。\n适合处理大量像素数据的应用。\n\n\nSVG：\n\n适合图标、图表、静态图形和需要高质量缩放的场景。\n适合需要交互和动画的矢量图形。\n\n\n\n6. 示例\nCanvas 示例：\n\n&lt;canvas\n  id&#x3D;&quot;myCanvas&quot;\n  width&#x3D;&quot;400&quot;\n  height&#x3D;&quot;200&quot;\n  style&#x3D;&quot;border:1px solid #000000;&quot;\n&gt;&lt;&#x2F;canvas&gt;\n&lt;script&gt;\n  var canvas &#x3D; document.getElementById(&quot;myCanvas&quot;);\n  var ctx &#x3D; canvas.getContext(&quot;2d&quot;);\n  ctx.fillStyle &#x3D; &quot;#FF0000&quot;;\n  ctx.fillRect(20, 20, 150, 100);\n&lt;&#x2F;script&gt;\n\n\nSVG 示例：\n\n&lt;svg width&#x3D;&quot;400&quot; height&#x3D;&quot;200&quot;&gt;\n  &lt;rect x&#x3D;&quot;20&quot; y&#x3D;&quot;20&quot; width&#x3D;&quot;150&quot; height&#x3D;&quot;100&quot; fill&#x3D;&quot;red&quot; &#x2F;&gt;\n&lt;&#x2F;svg&gt;\n\n总结\nCanvas：适合动态、频繁更新的图形，使用位图渲染，性能较好，但不支持直接操作单个元素。\nSVG：适合静态和可缩放的图形，使用矢量渲染，支持直接操作和动画化单个元素，但在处理复杂图形时性能可能较差。\n\n根据具体需求选择合适的技术，可以更好地实现图形效果和用户体验。如果您有更多问题或需要进一步的解释，请随时问我！\nhead 标签有什么作用，其中什么标签必不可少？&lt;head&gt; 标签是 HTML 文档的一个重要部分，位于文档的开头，主要用于包含文档的元数据和其他信息。以下是 &lt;head&gt; 标签的主要作用及其中必不可少的标签：\n1. &lt;head&gt; 标签的作用\n元数据：包含关于文档的信息，如标题、字符集、描述、关键词等，这些信息不会直接显示在网页上，但对浏览器和搜索引擎非常重要。\n链接外部资源：可以链接外部样式表、脚本文件和其他资源，帮助网页实现样式和功能。\n设置文档的行为：可以通过 &lt;meta&gt; 标签设置文档的视口、兼容性等属性，影响网页在不同设备和浏览器中的表现。\n\n2. 必不可少的标签在 &lt;head&gt; 标签中，有几个标签是必不可少的，尤其是对于现代网页的基本结构：\n\n**&lt;title&gt;**：\n\n作用：定义文档的标题，显示在浏览器的标题栏或标签页上。\n示例：&lt;title&gt;我的网页标题&lt;&#x2F;title&gt;\n\n\n**&lt;meta charset=&quot;UTF-8&quot;&gt;**：\n\n作用：指定文档的字符编码，UTF-8 是一种常用的字符编码，支持多种语言字符。\n示例：&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\n\n\n这两个标签是构建 HTML 文档的基本要素，确保网页能够正确显示和被搜索引擎索引。\n3. 其他常用标签除了上述必不可少的标签，&lt;head&gt; 中还可以包含其他常用标签：\n\n**&lt;meta name=&quot;description&quot; content=&quot;网页描述&quot;&gt;**：提供网页的简短描述，搜索引擎通常会在搜索结果中显示这个描述。\n**&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;**：控制网页在移动设备上的布局和缩放。\n**&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;**：链接外部样式表。\n**&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;**：链接外部 JavaScript 文件。\n\n4. 示例以下是一个完整的 HTML 文档示例，展示了 &lt;head&gt; 标签的基本结构：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;这是一个示例网页。&quot; &#x2F;&gt;\n    &lt;title&gt;我的网页标题&lt;&#x2F;title&gt;\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;styles.css&quot; &#x2F;&gt;\n    &lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎来到我的网页&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n总结&lt;head&gt; 标签在 HTML 文档中起着至关重要的作用，包含了文档的元数据和外部资源链接。其中，&lt;title&gt; 和 &lt;meta charset=&quot;UTF-8&quot;&gt; 是必不可少的标签，确保网页的基本功能和正确显示。\n文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?1. 文档声明（Doctype）和 &lt;!DOCTYPE html&gt; 的作用文档声明（Doctype） 是 HTML 文档的第一行代码，用于告诉浏览器该文档使用的 HTML 或 XHTML 版本。&lt;!DOCTYPE html&gt; 是 HTML5 的文档声明，具有以下作用：\n\n指定文档类型：&lt;!DOCTYPE html&gt; 告诉浏览器该文档是 HTML5 格式，确保浏览器以正确的方式解析和渲染页面。\n启用标准模式：使用 &lt;!DOCTYPE html&gt; 可以使浏览器进入标准模式（Standards Mode），在这种模式下，浏览器会遵循 W3C 的标准来渲染页面，确保不同浏览器之间的表现一致。\n提高兼容性：通过明确指定文档类型，开发者可以确保网页在不同浏览器和设备上的兼容性，减少因浏览器解析差异而导致的显示问题。\n\n2. 严格模式与混杂模式的区分\n严格模式（Standards Mode）：\n\n在严格模式下，浏览器会遵循 W3C 的标准来渲染页面，确保页面的表现符合现代网页开发的最佳实践。\n严格模式下，某些过时的 HTML 和 CSS 特性将被忽略，开发者需要使用符合标准的代码。\n\n\n混杂模式（Quirks Mode）：\n\n在混杂模式下，浏览器会模拟旧版浏览器的行为，以兼容早期的网页设计。这种模式主要是为了支持旧版网页的显示。\n混杂模式下，浏览器可能会使用一些非标准的渲染规则，导致不同浏览器之间的表现不一致。\n\n\n\n3. 严格模式与混杂模式的意义\n严格模式的意义：\n\n提供一致的渲染行为，确保网页在不同浏览器中的表现一致。\n鼓励开发者使用符合标准的 HTML 和 CSS，提升网页的可维护性和可访问性。\n有助于提高网页的性能和安全性。\n\n\n混杂模式的意义：\n\n允许旧版网页在现代浏览器中继续正常显示，避免因标准的变化而导致的显示问题。\n为开发者提供了一个过渡期，使他们能够逐步更新和改进旧版网页。\n\n\n\n4. 示例以下是一个简单的 HTML5 文档示例，展示了如何使用 &lt;!DOCTYPE html&gt;：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;示例网页&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;欢迎来到我的网页&lt;&#x2F;h1&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n总结\n文档声明（Doctype） 是 HTML 文档的第一行代码，用于指定文档类型和启用标准模式。\n严格模式 和 混杂模式 的区别在于渲染行为和对标准的遵循程度，严格模式遵循 W3C 标准，而混杂模式则兼容旧版网页。\n使用 &lt;!DOCTYPE html&gt; 可以确保网页在现代浏览器中以标准模式渲染，从而提高网页的兼容性和一致性。\n\n浏览器乱码的原因是什么？如何解决？浏览器乱码通常是指网页内容无法正确显示，出现了不正常的字符或符号。这种情况通常是由于字符编码不匹配引起的。以下是浏览器乱码的常见原因及其解决方法：\n1. 乱码的原因\n字符编码不一致：\n\n网页的字符编码与浏览器解析时使用的字符编码不一致。例如，网页使用 UTF-8 编码，但浏览器却以 ISO-8859-1 编码解析。\n\n\n缺少字符集声明：\n\n网页没有在 &lt;head&gt; 部分声明字符集，导致浏览器无法正确识别字符编码。\n\n\n文件保存编码不一致：\n\nHTML 文件在保存时使用的编码与网页中声明的编码不一致。例如，文件以 UTF-8 编码保存，但在 HTML 中声明为 ISO-8859-1。\n\n\n服务器配置问题：\n\n服务器未正确设置响应头中的字符编码，导致浏览器无法正确解析内容。\n\n\n\n2. 解决方法2.1 声明字符集确保在 HTML 文档的 &lt;head&gt; 部分正确声明字符集，通常使用 UTF-8 编码：\n&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\n2.2 确保文件保存编码一致在保存 HTML 文件时，确保使用与声明的字符集一致的编码格式。大多数现代文本编辑器（如 VSCode、Sublime Text 等）都支持选择文件编码。\n2.3 服务器配置确保服务器正确设置响应头中的字符编码。例如，在 Apache 服务器中，可以在 .htaccess 文件中添加以下行：\nAddDefaultCharset UTF-8\n\n在 Nginx 服务器中，可以在配置文件中添加：\ncharset utf-8;\n\n2.4 检查浏览器设置在某些情况下，用户的浏览器设置可能会影响字符编码的解析。可以尝试手动设置浏览器的字符编码为 UTF-8，通常在浏览器的“查看”或“编码”菜单中可以找到相关选项。\n3. 总结浏览器乱码通常是由于字符编码不一致引起的。通过在 HTML 文档中正确声明字符集、确保文件保存编码一致、配置服务器响应头以及检查浏览器设置，可以有效解决乱码问题。使用 UTF-8 编码是现代网页开发的最佳实践，能够支持多种语言字符，减少乱码的可能性。\n渐进增强和优雅降级之间的区别渐进增强（Progressive Enhancement）和优雅降级（Graceful Degradation）是两种不同的网页设计和开发策略，它们的目标都是为了提高用户体验，但实现方式有所不同。以下是这两者之间的主要区别：\n1. 渐进增强（Progressive Enhancement）\n定义：渐进增强是一种从基础功能开始构建网页的策略，首先确保所有用户都能访问到核心内容和功能，然后在此基础上逐步添加更高级的功能和样式，以提升用户体验。\n实现方式：\n基础内容：首先提供基本的 HTML 内容，确保在所有浏览器和设备上都能正常显示。\n增强功能：在此基础上，使用 CSS 和 JavaScript 添加样式和交互功能，针对支持这些技术的浏览器进行优化。\n\n\n优点：\n确保所有用户都能访问到核心内容，无论他们使用的设备或浏览器的能力如何。\n提高了无障碍性，确保即使在不支持高级功能的环境中，用户也能获得良好的体验。\n\n\n\n2. 优雅降级（Graceful Degradation）\n定义：优雅降级是一种从完整功能开始构建网页的策略，首先为现代浏览器和设备提供丰富的功能和样式，然后确保在较旧或不支持的浏览器中仍能保持基本的可用性。\n\n实现方式：\n\n完整功能：首先开发一个功能丰富的网页，使用最新的 HTML、CSS 和 JavaScript 特性。\n降级处理：在较旧或不支持的浏览器中，提供替代方案或简化版本，以确保基本功能仍然可用。\n\n\n优点：\n\n可以充分利用现代浏览器的功能，提供丰富的用户体验。\n在设计时考虑到向后兼容性，确保在较旧的环境中仍能正常工作。\n\n\n\n3. 主要区别\n\n\n特点\n渐进增强（Progressive Enhancement）\n优雅降级（Graceful Degradation）\n\n\n\n开发策略\n从基础功能开始，逐步增强\n从完整功能开始，逐步降级\n\n\n核心内容\n确保所有用户都能访问核心内容\n以现代浏览器为目标，确保基本可用性\n\n\n用户体验\n所有用户都能获得良好体验\n现代用户获得最佳体验，旧用户获得基本体验\n\n\n无障碍性\n更加注重无障碍性\n可能忽视较旧设备的用户体验\n\n\n4. 总结\n渐进增强 强调从基础开始，确保所有用户都能访问核心内容，然后逐步添加增强功能，适合关注无障碍性和兼容性的项目。\n优雅降级 强调从完整功能开始，确保现代用户获得最佳体验，同时考虑到较旧环境的兼容性，适合需要充分利用现代技术的项目。\n\n选择哪种策略取决于项目的需求、目标用户群体和技术栈。理解这两者的区别有助于开发者在设计和开发网页时做出更合适的决策。\n说一下 HTML5 drag APIHTML5 Drag API 是一组用于实现拖放功能的接口，允许用户通过拖动元素来进行交互。这个 API 提供了一种简单的方法来处理拖放操作，使得网页应用程序能够更直观地与用户进行交互。以下是对 HTML5 Drag API 的详细介绍，包括其工作原理、主要事件和使用示例。\n1. 工作原理HTML5 Drag API 主要依赖于以下几个步骤：\n\n可拖动元素：通过设置 draggable 属性为 true，使元素可被拖动。\n拖动事件：在拖动过程中，浏览器会触发一系列事件，开发者可以通过这些事件来处理拖放操作。\n放置目标：在目标元素上处理放置操作，允许用户将拖动的元素放置到指定位置。\n\n2. 主要事件HTML5 Drag API 定义了一些重要的事件，开发者可以通过这些事件来处理拖放操作：\n\ndragstart：当用户开始拖动元素时触发。可以在此事件中设置拖动的数据。\ndrag：在拖动过程中持续触发，通常用于更新拖动效果。\ndragend：当拖动操作结束时触发，无论是成功放置还是取消。\ndragover：当拖动的元素在放置目标上方时触发。需要调用 event.preventDefault() 来允许放置。\ndragenter：当拖动的元素进入放置目标区域时触发。\ndragleave：当拖动的元素离开放置目标区域时触发。\ndrop：当拖动的元素被放置到目标区域时触发。\n\n3. 使用示例以下是一个简单的示例，展示了如何使用 HTML5 Drag API 实现拖放功能：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;zh&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;HTML5 Drag API 示例&lt;&#x2F;title&gt;\n    &lt;style&gt;\n      #dragItem &#123;\n        width: 100px;\n        height: 100px;\n        background-color: lightblue;\n        margin: 10px;\n        cursor: move;\n      &#125;\n      #dropZone &#123;\n        width: 300px;\n        height: 300px;\n        border: 2px dashed #ccc;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;dragItem&quot; draggable&#x3D;&quot;true&quot;&gt;拖动我&lt;&#x2F;div&gt;\n    &lt;div id&#x3D;&quot;dropZone&quot;&gt;放置区域&lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      const dragItem &#x3D; document.getElementById(&quot;dragItem&quot;);\n      const dropZone &#x3D; document.getElementById(&quot;dropZone&quot;);\n\n      &#x2F;&#x2F; 处理 dragstart 事件\n      dragItem.addEventListener(&quot;dragstart&quot;, (event) &#x3D;&gt; &#123;\n        event.dataTransfer.setData(&quot;text&#x2F;plain&quot;, &quot;这是拖动的数据&quot;);\n        event.target.style.opacity &#x3D; 0.5; &#x2F;&#x2F; 拖动时改变透明度\n      &#125;);\n\n      &#x2F;&#x2F; 处理 dragend 事件\n      dragItem.addEventListener(&quot;dragend&quot;, (event) &#x3D;&gt; &#123;\n        event.target.style.opacity &#x3D; 1; &#x2F;&#x2F; 恢复透明度\n      &#125;);\n\n      &#x2F;&#x2F; 处理 dragover 事件\n      dropZone.addEventListener(&quot;dragover&quot;, (event) &#x3D;&gt; &#123;\n        event.preventDefault(); &#x2F;&#x2F; 允许放置\n      &#125;);\n\n      &#x2F;&#x2F; 处理 drop 事件\n      dropZone.addEventListener(&quot;drop&quot;, (event) &#x3D;&gt; &#123;\n        event.preventDefault(); &#x2F;&#x2F; 防止默认行为\n        const data &#x3D; event.dataTransfer.getData(&quot;text&#x2F;plain&quot;);\n        alert(&#96;放置了: $&#123;data&#125;&#96;);\n      &#125;);\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n4. 总结HTML5 Drag API 提供了一种简单而强大的方式来实现拖放功能。通过设置 draggable 属性和处理相关事件，开发者可以创建直观的用户交互体验。这个 API 在现代网页应用中非常有用，尤其是在需要用户自定义布局或交互的场景中。\nPWA 是什么和 ServiceWorker 有什么区别？PWA（渐进式 Web 应用程序）和 Service Worker 是现代 Web 开发中的两个重要概念，它们虽然相关，但各自的功能和目的不同。以下是对 PWA 和 Service Worker 的详细解释及其区别。\n1. 什么是 PWA？渐进式 Web 应用程序（PWA） 是一种结合了网页和移动应用程序优点的应用程序。PWA 旨在提供类似于原生应用的用户体验，具有以下特性：\n\n响应式：PWA 可以在各种设备上运行，包括桌面、平板和手机。\n离线支持：通过使用 Service Worker，PWA 可以在没有网络连接的情况下工作。\n快速加载：PWA 通过缓存和预加载技术，能够快速加载和响应用户操作。\n可安装性：用户可以将 PWA 添加到主屏幕，像原生应用一样使用。\n安全性：PWA 需要在 HTTPS 上运行，以确保安全性。\n\n2. 什么是 Service Worker？Service Worker 是一种在浏览器和网络之间运行的脚本，允许开发者控制网络请求、缓存资源和处理离线功能。Service Worker 的主要特性包括：\n\n拦截网络请求：Service Worker 可以拦截和处理网络请求，从而实现自定义的缓存策略。\n离线支持：通过缓存静态资源，Service Worker 使得应用在离线状态下仍然可用。\n后台同步：Service Worker 可以在网络恢复时进行后台数据同步。\n推送通知：Service Worker 可以接收和显示推送通知。\n\n3. PWA 和 Service Worker 的区别\n\n\n特性\nPWA\nService Worker\n\n\n\n定义\n一种结合了网页和原生应用优点的应用程序\n一种在浏览器和网络之间运行的脚本\n\n\n功能\n提供类似原生应用的用户体验，支持离线、可安装等\n控制网络请求、缓存资源、处理离线功能\n\n\n依赖关系\nPWA 通常依赖于 Service Worker 来实现离线和缓存功能\nService Worker 是实现 PWA 功能的关键组件\n\n\n用户体验\n提供响应式、快速、可安装的用户体验\n主要用于后台处理，不直接影响用户界面\n\n\n安全性\n需要在 HTTPS 上运行\n需要在 HTTPS 上注册\n\n\n4. 总结\nPWA 是一种应用程序类型，旨在提供类似原生应用的用户体验，具有离线支持、快速加载和可安装性等特性。\nService Worker 是实现 PWA 功能的关键技术，允许开发者控制网络请求、缓存资源和处理离线功能。\n\nPWA 如何实现，可结合 Nextjs在 Next.js 中实现渐进式 Web 应用程序（PWA）可以通过使用 next-pwa 插件来简化过程。PWA 使得网站能够像原生应用一样工作，支持离线访问、推送通知等功能。以下是如何在 Next.js 项目中实现 PWA 的步骤。\n1. 创建 Next.js 项目如果您还没有创建 Next.js 项目，可以使用以下命令创建一个新的项目：\nnpx create-next-app my-pwa-app\ncd my-pwa-app\n\n2. 安装 next-pwa在项目中安装 next-pwa 插件：\nnpm install next-pwa\n\n3. 配置 next-pwa在项目根目录下创建或修改 next.config.js 文件，配置 next-pwa 插件。\n&#x2F;&#x2F; next.config.js\nconst withPWA &#x3D; require(&quot;next-pwa&quot;)(&#123;\n  dest: &quot;public&quot;, &#x2F;&#x2F; 将生成的 service worker 存放在 public 目录\n  register: true,\n  skipWaiting: true,\n&#125;);\n\nmodule.exports &#x3D; withPWA(&#123;\n  &#x2F;&#x2F; 其他 Next.js 配置\n&#125;);\n\n4. 创建 manifest.json在 public 目录下创建一个 manifest.json 文件，定义 PWA 的基本信息。\n&#123;\n  &quot;name&quot;: &quot;My PWA App&quot;,\n  &quot;short_name&quot;: &quot;PWA&quot;,\n  &quot;description&quot;: &quot;A simple PWA example with Next.js&quot;,\n  &quot;start_url&quot;: &quot;.&quot;,\n  &quot;display&quot;: &quot;standalone&quot;,\n  &quot;background_color&quot;: &quot;#ffffff&quot;,\n  &quot;theme_color&quot;: &quot;#000000&quot;,\n  &quot;icons&quot;: [\n    &#123;\n      &quot;src&quot;: &quot;&#x2F;icon-192x192.png&quot;,\n      &quot;sizes&quot;: &quot;192x192&quot;,\n      &quot;type&quot;: &quot;image&#x2F;png&quot;\n    &#125;,\n    &#123;\n      &quot;src&quot;: &quot;&#x2F;icon-512x512.png&quot;,\n      &quot;sizes&quot;: &quot;512x512&quot;,\n      &quot;type&quot;: &quot;image&#x2F;png&quot;\n    &#125;\n  ]\n&#125;\n\n5. 添加图标在 public 目录下添加应用程序图标，确保图标的尺寸与 manifest.json 中的定义相匹配。例如，您可以添加 icon-192x192.png 和 icon-512x512.png。\n6. 更新 _document.js在 pages/_document.js 中，添加对 manifest.json 的引用和设置 theme-color。\n&#x2F;&#x2F; pages&#x2F;_document.js\nimport Document, &#123; Html, Head, Main, NextScript &#125; from &quot;next&#x2F;document&quot;;\n\nclass MyDocument extends Document &#123;\n  render() &#123;\n    return (\n      &lt;Html&gt;\n        &lt;Head&gt;\n          &lt;link rel&#x3D;&quot;manifest&quot; href&#x3D;&quot;&#x2F;manifest.json&quot; &#x2F;&gt;\n          &lt;meta name&#x3D;&quot;theme-color&quot; content&#x3D;&quot;#000000&quot; &#x2F;&gt;\n          &lt;link rel&#x3D;&quot;apple-touch-icon&quot; href&#x3D;&quot;&#x2F;icon-192x192.png&quot; &#x2F;&gt;\n        &lt;&#x2F;Head&gt;\n        &lt;body&gt;\n          &lt;Main &#x2F;&gt;\n          &lt;NextScript &#x2F;&gt;\n        &lt;&#x2F;body&gt;\n      &lt;&#x2F;Html&gt;\n    );\n  &#125;\n&#125;\n\nexport default MyDocument;\n\n7. 运行项目确保在项目目录中运行以下命令以启动开发服务器：\nnpm run dev\n\n8. 测试 PWA 功能\n打开浏览器，访问 http://localhost:3000。\n打开开发者工具（F12），切换到 “Application” 标签。\n在 “Manifest” 部分，您应该能看到 manifest.json 的内容。\n在 “Service Workers” 部分，您应该能看到注册的 service worker。\n尝试将应用程序添加到主屏幕，您应该能看到 PWA 的图标和名称。\n\n9. 部署在部署时，确保使用支持 HTTPS 的服务器，因为 PWA 需要在安全上下文中运行。您可以使用 Vercel、Netlify 或其他支持 HTTPS 的平台进行部署。\n总结通过使用 next-pwa 插件，您可以轻松地将 PWA 功能集成到 Next.js 应用程序中。配置 manifest.json 和 service worker 是实现 PWA 的关键步骤。您可以根据需要进一步自定义 PWA 的功能和样式。\nWeb components 是什么？Web Components 是一组用于创建可重用的自定义元素和封装功能的标准技术，使得开发者能够构建可组合的、可重用的组件。这些组件可以在任何 Web 应用程序中使用，无论是使用原生 JavaScript、框架（如 React、Vue、Angular）还是其他库。Web Components 主要由以下四个核心技术组成：\n1. 自定义元素（Custom Elements）自定义元素允许开发者定义新的 HTML 标签，并为这些标签提供特定的功能和行为。通过自定义元素，开发者可以创建自己的组件，并在 HTML 中像使用原生元素一样使用它们。\n示例class MyElement extends HTMLElement &#123;\n  constructor() &#123;\n    super();\n    this.attachShadow(&#123;\n      mode: &quot;open&quot;,\n    &#125;).innerHTML &#x3D; &#96;&lt;p&gt;Hello, Web Components!&lt;&#x2F;p&gt;&#96;;\n  &#125;\n&#125;\n\ncustomElements.define(&quot;my-element&quot;, MyElement);\n\n在 HTML 中使用自定义元素：\n&lt;my-element&gt;&lt;&#x2F;my-element&gt;\n\n2. Shadow DOMShadow DOM 是一种封装技术，允许开发者将组件的内部结构和样式与外部文档隔离。通过使用 Shadow DOM，组件的样式和行为不会受到外部样式的影响，从而避免了样式冲突。\n示例class MyElement extends HTMLElement &#123;\n  constructor() &#123;\n    super();\n    const shadow &#x3D; this.attachShadow(&#123; mode: &quot;open&quot; &#125;);\n    shadow.innerHTML &#x3D; &#96;\n            &lt;style&gt;\n                p &#123; color: blue; &#125;\n            &lt;&#x2F;style&gt;\n            &lt;p&gt;Hello, Shadow DOM!&lt;&#x2F;p&gt;\n        &#96;;\n  &#125;\n&#125;\n\n3. HTML 模板（HTML Templates）HTML 模板允许开发者定义可重用的 HTML 片段，这些片段在页面加载时不会被渲染，只有在需要时才会被克隆和插入到文档中。模板可以与自定义元素和 Shadow DOM 一起使用，以创建复杂的组件。\n示例&lt;template id&#x3D;&quot;my-template&quot;&gt;\n  &lt;style&gt;\n    p &#123;\n      color: green;\n    &#125;\n  &lt;&#x2F;style&gt;\n  &lt;p&gt;Hello, Template!&lt;&#x2F;p&gt;\n&lt;&#x2F;template&gt;\n\n在 JavaScript 中使用模板：\nconst template &#x3D; document.getElementById(&quot;my-template&quot;).content;\nconst clone &#x3D; document.importNode(template, true);\ndocument.body.appendChild(clone);\n\n4. HTML 导入（HTML Imports）HTML 导入是一种允许开发者将 HTML 文档导入到其他 HTML 文档中的技术。虽然 HTML 导入在早期的 Web Components 规范中存在，但它已被弃用，建议使用 ES 模块来实现类似的功能。\n5. Web Components 的优点\n可重用性：开发者可以创建可重用的组件，减少代码重复。\n封装性：通过 Shadow DOM，组件的样式和行为被封装，避免了样式冲突。\n互操作性：Web Components 可以在任何现代浏览器中使用，并与任何 JavaScript 框架或库兼容。\n标准化：Web Components 是基于标准的技术，具有良好的浏览器支持。\n\n6. 总结Web Components 是一种强大的技术，允许开发者创建可重用的、自定义的组件，具有封装性和互操作性。通过自定义元素、Shadow DOM 和 HTML 模板等技术，Web Components 提供了一种构建现代 Web 应用程序的灵活方式。\n","slug":"interview-html","date":"2024-12-22T10:43:24.000Z","categories_index":"interview","tags_index":"html","author_index":"X-29"},{"id":"6d1a44d72f500b2ae165cfd01771a531","title":"rollup","content":"rollup前端工程化历程\n除屑优化(tree shaking)除了可以使用 ES 模块之外，Rollup 还可以静态分析你导入的代码，并将排除任何实际上没有使用的内容，从上面的引入和最后的打包结果就可以看到，没有使用到的内容直接被删除了。\n\n\n\n\n\n\n\n\n\n注意，除屑优化的核心思想是在编译阶段通过静态分析确定代码的使用情况，而不是在运行时。\n所以除屑优化一般是建立在ES6 模块化语法基础之上的，ESM 的导入导出是静态的。\nCommonJS 模块的导入和导出是动态的，无法在编译阶段静态确定代码的使用情况。一般情况下，除屑优化工具无法在 CommonJS 模块中进行精确的除屑，因为无法静态分析模块间的导入和导出关系。\n然而，一些构建工具（如 Webpack）会尝试通过静态分析和启发式方法对 CommonJS 模块进行近似的除屑优化。它们会尽可能地识别出那些可以在编译阶段确定未被使用的代码，并进行剔除。但这种处理方式可能不如对 ES6 模块的优化效果好，且有一定的限制。\n除屑优化的原理：\n\n静态分析：对 JavaScript 代码进行静态分析，识别出模块的导入和导出关系。\n标记未使用代码：标记出在导入和导出关系上没有被使用的代码。这些代码可能是模块的导出函数、变量、类等。\n剔除未使用代码：根据标记结果，构建工具会将未被使用的代码从最终的打包结果中剔除，只保留被使用的部分。\n\n由于是静态分析，所以我们在写代码的时候，需要注意自己的写法，简单来说，尽量的使用最小导入，比如你可以比较一下我们这里导入代码之后，打包的区别：\n&#x2F;&#x2F; 直接默认导入整个对象\nimport util from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; util.getRandomNum(1, 10)\nconsole.log(r)\n​\n&#x2F;&#x2F; 具名导入具体的函数\nimport &#123; getRandomNum &#125; from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; getRandomNum(1, 10)\nconsole.log(r)\n\n与 webpack 打包的区别这个打包结果其实就已经和我们熟知的webpack有了很鲜明的区别，我们把 webpack 安装一下试试\npnpm add webpack webpack-cli -D\n\n运行 webpack-cli：\n# --entry 入口文件 -o 打包文件夹位置 --mode 打包模式\nnpx webpack --entry .&#x2F;src&#x2F;index.js -o dist --mode development\n\n当然我们可以选择生成模式进行打包\nnpx webpack --entry .&#x2F;src&#x2F;index.js -o dist --mode production\n\n(() &#x3D;&gt; &#123;\n  &quot;use strict&quot;;\n  const o &#x3D;\n    ((t &#x3D; 1),\n    (a &#x3D; 10),\n    (t &#x3D; Math.ceil(t)),\n    (a &#x3D; Math.floor(a)),\n    Math.floor(Math.random() * (a - t + 1)) + t);\n  var t, a;\n  console.log(o);\n&#125;)();\n\n现在打包出来的内容就直接是压缩之后的代码了\n配置文件Rollup配置文件是一个 ES 模块。通常，它被称为 rollup.config.js 或 rollup.config.mjs，并位于项目的根目录中。它导出一个默认对象，其中包含所需的选项：\n\n\n\n\n\n\n\n\n\n注意 : 如果想要类型提示，请在 rollup.config.js 文件顶部添加以下代码：\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\n\nexport default &#123;\n  input: &quot;src&#x2F;index.js&quot;,\n  output: &#123;\n    file: &quot;dist&#x2F;bundle.js&quot;,\n    format: &quot;esm&quot;,\n  &#125;,\n&#125;;\n\n\n\n\n\n\n\n\n\n\n注意：nodejs 环境下要运行 esm 模块化的内容，要么文件名后缀处理为 .mjs，要么 package.json 文件中配置 “type”:”module” ，因为 Rollup 将遵循 Node ESM 语义。\n常用配置多产物配置我们可以将 output 改造成一个数组，对外暴露出不同格式的产物供他人使用，不仅包括 ESM，也需要包括诸如CommonJS、UMD等格式，保证良好的兼容性\nimport &#123; defineConfig &#125; from &quot;rollup&quot;;\n\nexport default defineConfig(&#123;\n  input: &quot;src&#x2F;index.js&quot;,\n  output: [\n    &#123;\n      file: &quot;dist&#x2F;bundle-iife.js&quot;,\n      format: &quot;iife&quot;,\n    &#125;,\n    &#123;\n      file: &quot;dist&#x2F;bundle-esm.js&quot;,\n      format: &quot;esm&quot;,\n    &#125;,\n    &#123;\n      file: &quot;dist&#x2F;bundle-cjs.js&quot;,\n      format: &quot;cjs&quot;,\n    &#125;,\n    &#123;\n      file: &quot;dist&#x2F;bundle-umd.js&quot;,\n      format: &quot;umd&quot;,\n      name: &quot;bundle&quot;,\n    &#125;,\n  ],\n&#125;);\n\n多入口配置除了多产物配置，Rollup 中也支持多入口配置\nmain.js\n&#x2F;&#x2F; src&#x2F;main.js\nimport util from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; util.getRandomNum(1, 10);\nconsole.log(&quot;🚀 ~ r:&quot;, r);\n\nconst obj &#x3D; &#123;\n  a: 1,\n  b: &#123;\n    c: 3,\n  &#125;,\n&#125;;\nconst cloneObj &#x3D; util.deepClone(obj);\ncloneObj.b.c &#x3D; 4;\nconsole.log(&quot;🚀 ~ obj:&quot;, obj);\nconsole.log(&quot;🚀 ~ cloneObj:&quot;, cloneObj);\n\nrollup.config.js\nimport &#123; defineConfig &#125; from &#39;rollup&#39;\n\nexport default defineConfig(&#123;\n  input: [&#39;src&#x2F;index.js&#39;,&#39;src&#x2F;main.js&#39;],\n  output: [\n    &#123;\n      dir: &#39;dist&#39;,\n      format: &#39;cjs&#39;\n    &#125;\n  ],\n&#125;)\n\n通常情况下多产物和多入口两者会被结合起来使用\nimport &#123; defineConfig &#125; from &#39;rollup&#39;\nexport default defineConfig(&#123;\n  input: [&#39;src&#x2F;index.js&#39;,&#39;src&#x2F;main.js&#39;],\n  output: [\n    &#123;\n      dir: &#39;cjs&#39;,\n      format: &#39;cjs&#39;\n    &#125;,\n    &#123;\n      dir: &#39;esm&#39;,\n      format: &#39;esm&#39;\n    &#125;\n  ],\n&#125;)\n\n当然，上面这样的写的话，生成的产物会把两个入口一起进行构建，我们可能的想法是一个入口一种构建方式：\nimport &#123; defineConfig &#125; from &#39;rollup&#39;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;umd&#x2F;&#39;,\n    format: &#39;umd&#39;,\n    name: &#39;bundle&#39;\n  &#125;\n&#125;\n\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: &#39;src&#x2F;main.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\nexport default [buildIndexOptions, buildMainOptions];\n\n动态导入与默认代码分割使用路由来说明懒加载是大家喜闻乐见的方式，估计大多数同学对于懒加载都只是停留在路由的懒加载，其实，任何时候，我们都可以使用 import 动态懒加载的方式。重新编辑一下 main.js 入口：\n&#x2F;&#x2F; src&#x2F;main.js\nfunction run() &#123;\n  &#x2F;&#x2F; 如果不清楚import动态导入返回的是什么，可以先打印一下下面结果\n  &#x2F;&#x2F; import(&quot;.&#x2F;util.js&quot;).then(chunk &#x3D;&gt; console.log(&quot;🚀 ~ chunk:&quot;, chunk));\n\n  import(&quot;.&#x2F;util.js&quot;).then((&#123; default: foo &#125;) &#x3D;&gt; &#123;\n    const r &#x3D; foo.getRandomNum(1, 10);\n    console.log(&quot;🚀 ~ r:&quot;, r);\n  &#125;);\n&#125;\nrun();\n\n重新运行可以看到 dist 目录形成了下面的结构:\n.\n├── dist\n│ ├── esm\n│ │ ├── main.js\n│ │ └── util-371e3ef9.js\n│ └── umd\n│     └── index.js\n└── ...\n\nRollup 将使用动态导入创建一个仅在需要时加载的单独块。所以你可以看到这里多了一个util-371e3ef9.js的文件\n\n\n\n\n\n\n\n\n\n注意： 为了让 Rollup 知道在哪里放置第二个块，我们不使用 --file 选项，而是使用 --dir 选项设置一个输出文件夹\n其中，util-371e3ef9.js是自动生成的chunk-[hash].js的名字，[hash] 是基于内容的哈希字符串。你可以通过指定 output.chunkFileNames (chunk 文件)和 output.entryFileNames (打包入口文件)选项来提供自己的命名模式。\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: &#39;src&#x2F;main.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\n\n而且，很智能的是，如果这个时候，我定义了又多个入口点都调用了util.js文件，会自动的引入分割出来的文件\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildMainOptions &#x3D; &#123;\n  input: [&#39;src&#x2F;main.js&#39;, &#39;src&#x2F;main2.js&#39;],\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\n\n在打包后的 main2.js 中，可以看到这样的引用：\nimport util from &quot;.&#x2F;chunk-util-371e3ef9.js&quot;;\n\n使用插件到目前为止，我们已经用入口文件和通过相对路径导入的模块打了一个简单的包。随着你需要打包更复杂的代码，通常需要更灵活的配置，例如导入使用 NPM 安装的模块、使用 Babel 编译代码、处理 JSON 文件等等。\n插件列表 ： the Rollup Awesome List。\n@rollup&#x2F;plugin-node-resolve比如我们现在引入 lodash-es 库\npnpm add lodash-es -D\n\n在 index.js 中使用\nimport &#123; chunk &#125; from &quot;lodash-es&quot;;\nconst r &#x3D; chunk([1, 2, 3, 4], 2);\nconsole.log(&quot;🚀 ~ r:&quot;, r);\n\n现在直接打包\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;\n&#125;\nexport default buildIndexOptions\n\n会出现下面的警告：\nsrc&#x2F;index.js → dist&#x2F;esm&#x2F;...\n(!) Unresolved dependencies\nhttps:&#x2F;&#x2F;rollupjs.org&#x2F;troubleshooting&#x2F;#warning-treating-module-as-external-dependency\nlodash-es (imported by &quot;src&#x2F;index.js&quot;)\ncreated dist&#x2F;esm&#x2F; in 13ms\n\n意思是，不能解析lodash-es这个依赖，报出了警告，问你是不是需要external，并提示你点击链接有这个警告的解释。当我们点击这个链接，按照提示解决这个 external 警告问题，很简单，就加上 external，也就是把lodash-es这个库给排除出去\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n+  external: [&#39;lodash-es&#39;]\n&#125;\nexport default buildIndexOptions\n\n再此打包，果然没警告了，而且我们在 nodejs 环境中确实也能正常运行了\n\n\n\n\n\n\n\n\n\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n注意：对于没有太多开发经验的同学来说，这里感觉问题解决了，但是需要理解为什么\n重要的事情说三遍，这里虽然看似一个很小的问题，但是却有很多基本理论点\n1、rollup 默认只能解析导入的相对路径，也就是/ ， ./或者../开头的路径，对于bare import，也就是import &#123; chunk &#125; from &#39;lodash-es&#39;;这种直接导入的第三方包的格式，并不支持\n2、rollup相比webpack最大的优势并不是构建一个足够大的应用打包，大多是情况下，我们使用rollup用来构建工具库，因此，这里导入的lodash-es并没有报错，而仅仅报出警告，因为rollup认为lodash-es这个库并没有加入构建，那么你的意思是将来用作第三方库来使用，因此将lodash-es使用配置external排除掉就好。\n3、lodash-es这个包本身就是支持 ESM 的\n4、最后打包好的index.js文件只所以在nodejs环境下运行，是因为nodejs可以帮我们解析bare import，我们可以试着将index.js放入到html文件中运行，你就可以看到其中的问题所在，在 html 环境中就会报错了：index.html:1 Uncaught TypeError: Failed to resolve module specifier &quot;lodash-es&quot;. Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;.\n如果希望在最后的打包中，将lodash-es内容解析打包进去，就可以使用@rollup/plugin-node-resolve\n安装:\npnpm add @rollup&#x2F;plugin-node-resolve --save-dev\n\n使用：\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [nodeResolve()]\n  &#x2F;&#x2F; external: [&#39;lodash-es&#39;]\n&#125;\nexport default buildIndexOptions\n\n现在，再此进行打包，无论是打包时间，还是打包内容和之前都很不一样了，把lodash-es中，关于chunk()函数的内容，都打包进了index.js文件中\noutput.manualChunks上面讲了对于动态加载模块，rollup 帮我们自动做了代码分割，其实我们也可以手动的操作，直接在 rollup 配置中声明\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n    entryFileNames: &#39;[name].js&#39;,\n    chunkFileNames: &#39;chunk-[name]-[hash].js&#39;,\n    manualChunks: &#123;\n      &#39;lodash-es&#39;: [&#39;lodash-es&#39;],\n    &#125;\n    &#x2F;&#x2F;也可以是函数形式\n    &#x2F;&#x2F; manualChunks(id)&#123;\n    &#x2F;&#x2F;   if(id.includes(&#39;lodash-es&#39;))&#123;\n    &#x2F;&#x2F;     return &#39;lodash-es&#39;\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F; &#125;\n\t&#125;,\n  plugins: [nodeResolve()]\n&#125;\n\n@rollup&#x2F;plugin-commonjs上面最开始导入lodash-es，没有加入external和plugins，之所以还能直接运行，还因为lodash-es本身就是支持 ESM 的，因为 rollup 默认并不支持 Commonjs 模块化，比如将 lodash-es 换位 lodash，马上就能看到不一样的效果,直接打包失败\n[!] RollupError: &quot;chunk&quot; is not exported by &quot;node_modules&#x2F;.pnpm&#x2F;lodash@4.17.21&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js&quot;, imported by &quot;src&#x2F;index.js&quot;.\nhttps:&#x2F;&#x2F;rollupjs.org&#x2F;troubleshooting&#x2F;#error-name-is-not-exported-by-module\n\n这个错误在官网上解释的很清楚了，无非就是 commonjs 没有这种导出，因此我们需要@rollup/plugin-commonjs帮我们处理 commonjs 模块化的问题\n安装:\npnpm add @rollup&#x2F;plugin-commonjs --save-dev\n\n使用:\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\n+import commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n+  plugins: [nodeResolve(), commonjs()]\n&#125;\nexport default buildIndexOptions\n\n@rollup&#x2F;plugin-babel使用 Babel 来使用尚未被浏览器和 Node.js 支持的最新 JavaScript 特性。\n使用 Babel 和 Rollup 最简单的方法是使用 @rollup&#x2F;plugin-babel\n安装:\npnpm add @rollup&#x2F;plugin-babel -D\n\n使用：\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\n+import babel from &#39;@rollup&#x2F;plugin-babel&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n+    babel(&#123; babelHelpers: &#39;bundled&#39; &#125;)\n  ]\n&#125;\nexport default buildIndexOptions\n\n不过这么做之后，打包代码并不会有什么变化，因为我们都知道 babel 是需要预设的.\n安装 babel-core 和 env 预设\npnpm add -D @babel&#x2F;core @babel&#x2F;preset-env\n\n在 Babel 实际编译代码之前，需要进行配置。在项目根目录创建一个名为 .babelrc.json 的新文件\n&#123;\n  &quot;presets&quot;: [&quot;@babel&#x2F;preset-env&quot;]\n&#125;\n\n具体的 babel 设置，可以参考babel 文档\n题外话：@babel&#x2F;runtime我们在index.js代码中加入如下的 api\nimport &#123; getRandomNum &#125; from &quot;.&#x2F;util.js&quot;;\nconst r &#x3D; getRandomNum(1, 10);\nconsole.log(r);\n\nconst arr &#x3D; [1, 2, 3, 4].map((item) &#x3D;&gt; item * item);\nconsole.log(&quot;🚀 ~ arr:&quot;, arr);\n\nPromise.resolve(1).then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);\n\n我们通过 babel 处理之后会发现一些问题：\n@babel&#x2F;preset-env 只转换了语法，也就是我们看到的箭头函数、const 一类，但是对于进一步需要转换内置对象、实例方法等等 API，就显得无能为力了，这些代码需要polyfill(兼容性垫片) 。所以这个我需要@babel/runtime来帮我们处理。\n@babel/runtime是一个核心， 一种实现方式，但是在实现 polyfill 垫片的过程中，可能会产生很多重复的代码，所以需要@babel/plugin-transform-runtime防止污染全局， 抽离公共的 helper function , 防止冗余，当然在处理 polyfill 的时候，我们还需要 core-js 的辅助，基于 babel，我们可以使用@babel/runtime-corejs3\n安装：\npnpm add @babel&#x2F;plugin-transform-runtime -D\npnpm add @babel&#x2F;runtime @babel&#x2F;runtime-corejs3\n\n要使用@babel/plugin-transform-runtime，@rollup/plugin-babel的babelHelper处理必须改为 runtime\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\nimport babel from &#39;@rollup&#x2F;plugin-babel&#39;;\nimport typescript from &#39;@rollup&#x2F;plugin-typescript&#39;;\n&#x2F;**\n * @type &#123;import(&#39;rollup&#39;).RollupOptions&#125;\n *&#x2F;\nconst buildIndexOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  output: &#123;\n    dir: &#39;dist&#x2F;esm&#x2F;&#39;,\n    format: &#39;esm&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n    babel(&#123;\n      babelHelpers: &#39;runtime&#39;,\n      include: &#39;src&#x2F;**&#39;,\n      exclude: &#39;node_modules&#x2F;**&#39;,\n      extensions:[&#39;.js&#39;, &#39;.ts&#39;]\n    &#125;),\n    typescript(),\n  ]\n&#125;\nexport default buildIndexOptions\n\n.babelrc.json：\n&#123;\n  &quot;presets&quot;: [\n    [\n      &quot;@babel&#x2F;preset-env&quot;,\n      &#123;\n        &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;,\n        &quot;useBuiltIns&quot;: &quot;usage&quot;,\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ],\n  &quot;plugins&quot;: [\n    [\n      &quot;@babel&#x2F;plugin-transform-runtime&quot;,\n      &#123;\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ]\n&#125;\n\n这个时候你再进行构建，会发现打包后的文件多出了一大堆，这其实就是 polyfill 中的代码。\n@rollup&#x2F;plugin-typescript要使用 typescript 就需要依赖这个插件，当然这个插件本身还依赖了typescript和tslib，因此我们需要导入 3 个包\npnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\nutil.ts\n&#x2F;**\n * 深拷贝\n * @param obj 需要深拷贝的对象\n * @returns 深拷贝对象\n *&#x2F;\nexport const deepClone &#x3D; &lt;T&gt;(obj: T): T &#x3D;&gt; &#123;\n  if (typeof obj !&#x3D;&#x3D; &quot;object&quot; || obj &#x3D;&#x3D;&#x3D; null) &#123;\n    return obj;\n  &#125;\n  const result: any &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\n  for (let key in obj) &#123;\n    if (obj.hasOwnProperty(key)) &#123;\n      result[key] &#x3D; deepClone(obj[key]);\n    &#125;\n  &#125;\n  return result;\n&#125;;\n\nexport const getRandomNum &#x3D; (min: number, max: number): number &#x3D;&gt; &#123;\n  let num &#x3D; Math.floor(Math.random() * (min - max) + max);\n  return num;\n&#125;;\n\nIndex.ts\nimport &#123; getRandomNum,deepClone &#125; from &#39;.&#x2F;util.ts&#39;;\nconst r &#x3D; getRandomNum(1, 10);\nconsole.log(r);\n\nconst obj &#x3D; &#123; a: 1, b: &#123; c: 3 &#125; &#125;;\nconst obj2 &#x3D; deepClone(obj);\nobj2.b.c &#x3D; 4;\n\nconsole.log(obj);\nconsole.log(obj2);\n\n当然，配置文件我们也完全可以是 ts 的\nrollup.config.ts\nimport &#123; RollupOptions &#125; from &quot;rollup&quot;\nimport &#123; nodeResolve &#125; from &#39;@rollup&#x2F;plugin-node-resolve&#39;;\nimport commonjs from &#39;@rollup&#x2F;plugin-commonjs&#39;;\nimport babel from &#39;@rollup&#x2F;plugin-babel&#39;;\nimport typescript from &#39;@rollup&#x2F;plugin-typescript&#39;;\n\nconst config: RollupOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.ts&#39;,\n  output: &#123;\n    file: &#39;dist&#x2F;umd&#x2F;index.js&#39;,\n    format: &#39;umd&#39;,\n    name: &#39;rollupDemo&#39;,\n  &#125;,\n  plugins: [\n    nodeResolve(),\n    commonjs(),\n    babel(&#123;\n      babelHelpers: &#39;runtime&#39;,\n      include: &#39;src&#x2F;**&#39;,\n      exclude: &#39;node_modules&#x2F;**&#39;,\n      extensions:[&#39;.js&#39;, &#39;.ts&#39;]\n    &#125;),\n    typescript(),\n  ],\n&#125;\nexport default config;\n\ntsconfig.json\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;esnext&quot;,\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;],\n    &quot;skipLibCheck&quot;: true,\n\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;noEmit&quot;: true,\n    &quot;allowImportingTsExtensions&quot;: true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;, &quot;rollup.config.ts&quot;]\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意： 别忘记 tsconfig.json 文件中需要加入 rollup.config.ts 配置文件,不然要报错\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    ......\n  &#125;,\n+  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;rollup.config.ts&quot;],\n&#125;\n\n运行：\nnpx rollup -c rollup.config.ts --configPlugin typescript\n\n构建 react 应用node_modules# react\npnpm add react react-dom\n\n# @types&#x2F;react\npnpm add @types&#x2F;react @types&#x2F;react-dom -D\n\n# react预设\npnpm add @babel&#x2F;preset-react -D\n\n# rollup\npnpm add rollup -D\n\n# rollup常规插件\npnpm add @rollup&#x2F;plugin-node-resolve @rollup&#x2F;plugin-commonjs -D\n\n# typescript相关\npnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\n# @rollup&#x2F;plugin-babel相关\npnpm add @rollup&#x2F;plugin-babel @babel&#x2F;core @babel&#x2F;preset-env -D\n\n# @babel&#x2F;runtime相关\npnpm add @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime @babel&#x2F;runtime-corejs3 -D\n\n# html文件模板\npnpm add rollup-plugin-generate-html-template -D\n\n# 替换字符串\npnpm add @rollup&#x2F;plugin-replace -D\n\n# 开发服务器与live server\npnpm add rollup-plugin-serve rollup-plugin-livereload -D\n\n# clear插件\npnpm add rollup-plugin-clear -D\n\n# scss\npnpm add rollup-plugin-scss sass -D\n\n# postcss\npnpm add postcss rollup-plugin-postcss -D\n\n# 图片处理\npnpm add @rollup&#x2F;plugin-image -D\n\n# nodejs typescript类型\npnpm add @types&#x2F;node -D\n\n# 别名插件\npnpm add @rollup&#x2F;plugin-alias -D\n\n# terser\npnpm add @rollup&#x2F;plugin-terser -D\n\n# visualizer\npnpm add rollup-plugin-visualizer -D\n\ntsconfig.json&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;module&quot;: &quot;esnext&quot;,\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;, &quot;dom.iterable&quot;],\n    &quot;skipLibCheck&quot;: true,\n\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;noEmit&quot;: true,\n    &quot;allowImportingTsExtensions&quot;: true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;jsx&quot;: &quot;preserve&quot;,\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;,\n    &quot;paths&quot;: &#123;\n      &quot;@&#x2F;*&quot;: [&quot;src&#x2F;*&quot;]\n    &#125;\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;, &quot;rollup.config.ts&quot;, &quot;global.d.ts&quot;]\n&#125;\n\n.babelrc.json&#123;\n  &quot;presets&quot;: [\n    [\n      &quot;@babel&#x2F;preset-env&quot;,\n      &#123;\n        &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;,\n        &quot;useBuiltIns&quot;: &quot;usage&quot;,\n        &quot;corejs&quot;: 3\n      &#125;\n    ],\n    [&quot;@babel&#x2F;preset-react&quot;]\n  ],\n  &quot;plugins&quot;: [\n    [\n      &quot;@babel&#x2F;plugin-transform-runtime&quot;,\n      &#123;\n        &quot;corejs&quot;: 3\n      &#125;\n    ]\n  ]\n&#125;\n\nrollup.config.tsimport &#123; RollupOptions &#125; from &quot;rollup&quot;;\nimport &#123; nodeResolve &#125; from &quot;@rollup&#x2F;plugin-node-resolve&quot;;\nimport commonjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\nimport babel from &quot;@rollup&#x2F;plugin-babel&quot;;\nimport typescript from &quot;@rollup&#x2F;plugin-typescript&quot;;\nimport htmlTemplate from &quot;rollup-plugin-generate-html-template&quot;;\nimport serve from &quot;rollup-plugin-serve&quot;;\nimport livereload from &quot;rollup-plugin-livereload&quot;;\nimport replace from &quot;@rollup&#x2F;plugin-replace&quot;;\nimport postcss from &quot;rollup-plugin-postcss&quot;;\nimport alias from &quot;@rollup&#x2F;plugin-alias&quot;;\nimport clear from &quot;rollup-plugin-clear&quot;;\nimport image from &quot;@rollup&#x2F;plugin-image&quot;\nimport terser from &#39;@rollup&#x2F;plugin-terser&#39;;\nimport &#123; fileURLToPath &#125; from &quot;node:url&quot;;\nimport &#123; visualizer &#125; from &quot;rollup-plugin-visualizer&quot;;\n\nconst config: RollupOptions &#x3D; &#123;\n  input: &quot;src&#x2F;main.tsx&quot;,\n  output: &#123;\n    dir: &quot;dist&#x2F;&quot;,\n    format: &quot;esm&quot;,\n    name: &quot;rollupDemo&quot;,\n    sourcemap: true,\n    plugins: [terser()],\n    entryFileNames: &quot;[name].[hash:6].js&quot;,\n    chunkFileNames: &quot;chunks&#x2F;chunk-[name]-[hash].js&quot;,\n    &#x2F;&#x2F; 代码分割\n    &#x2F;&#x2F; manualChunks: &#123;\n    &#x2F;&#x2F;   react: [&quot;react&quot;, &quot;react-dom&quot;]\n    &#x2F;&#x2F; &#125;,\n    globals: &#123;\n      react: &quot;React&quot;,\n      &quot;react-dom&quot;: &quot;ReactDOM&quot;,\n    &#125;,\n    paths: &#123;\n      react: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;react@18.2.0&#x2F;+esm&quot;,\n      &quot;react-dom&quot;: &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;react-dom@18.2.0&#x2F;+esm&quot;,\n    &#125;\n  &#125;,\n  external: [&quot;react&quot;, &quot;react-dom&quot;],\n  plugins: [\n    visualizer(),\n    nodeResolve(&#123;\n      extensions: [&quot;.js&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;],\n    &#125;),\n    commonjs(),\n    typescript(),\n    babel(&#123;\n      babelHelpers: &quot;runtime&quot;,\n      include: &quot;src&#x2F;**&quot;,\n      exclude: &quot;node_modules&#x2F;**&quot;,\n      extensions: [&quot;.js&quot;, &quot;.ts&quot;, &quot;jsx&quot;, &quot;tsx&quot;],\n    &#125;),\n    alias(&#123;\n      entries: [\n        &#123;\n          find: &quot;@&quot;,\n          replacement: fileURLToPath(new URL(&quot;src&quot;, import.meta.url)),\n        &#125;,\n      ],\n    &#125;),\n    postcss(&#123;\n      extensions: [&quot;.js&quot;], &#x2F;&#x2F; 将scss解析成css\n      extract: true,\n      modules: true,\n    &#125;),\n    replace(&#123;\n      preventAssignment: true,\n      &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;), &#x2F;&#x2F; 否则会报：process is not defined的错\n    &#125;),\n    clear(&#123;\n      targets: [&quot;dist&quot;],\n    &#125;),\n    htmlTemplate(&#123;\n      template: &quot;public&#x2F;index.html&quot;,\n      target: &quot;dist&#x2F;index.html&quot;,\n      attrs: [&#39;type&#x3D;&quot;module&quot;&#39;],\n    &#125;),\n    image(),\n    serve(&quot;dist&quot;),\n    livereload(&quot;src&quot;),\n  ],\n&#125;;\nexport default config;\n\nnpm 发包npm 发布node_modules# rollup\npnpm add rollup -D\n\n# rollup常规插件\npnpm add @rollup&#x2F;plugin-node-resolve @rollup&#x2F;plugin-commonjs -D\n\n# typescript相关\npnpm add typescript tslib @rollup&#x2F;plugin-typescript -D\n\n# @rollup&#x2F;plugin-babel相关\npnpm add @rollup&#x2F;plugin-babel @babel&#x2F;core @babel&#x2F;preset-env -D\n\n# lodash-es\npnpm add lodash-es\n\n# @types&#x2F;lodash-es\npnpm add @types&#x2F;lodash-es -D\n\ntsconfig.json 文件&#x2F;&#x2F; tsconfig.json\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;es5&quot;,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;declaration&quot;: true,&#x2F;&#x2F; 根据ts文件自动生成.d.ts声明文件和js文件\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只输出.d.ts声明文件，不生成js文件\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 输出目录\n\t\t......\n  &#125;\n&#125;\n\n本地调试 link 安装最终打包的文件夹是 dist 文件夹，我们可以把 package.json 文件和 README.md 文件都拷贝到 dist 目录中。\nnpm link 地址其实就是全局安装地址：\nmac: /usr/local/lib/node_modules/\nWindows: c:\\用户(Users)\\你的用户名\\AppData(隐藏文件夹)\\Roaming\\npm\\node_modules\npnpm link\n在库文件的 dist 目录下执行：\npnpm link --global\n\n这个命令会读取 package.json 文件中的 name，作为包文件的名字，你可以理解为，相当于 pnpm 将我们打包的项目，全局安装在了本地\n在目标项目中，使用命令\npnpm link --global 包名\n\n进行安装。\n卸载 link pnpm unlink\n发布到 npm常用命令：\n\nnpm whoami 检测当前登录状态\nnpm config ls 显示当前 npm 配置信息\nnpm addUser 、npm login 登录\nnpm config set registry 链接地址 切换源地址\nnpm publish 发布\n\n\n\n\n\n\n\n\n\n\n注意必须使用 npm 源镜像才能发布，如果使用的是阿里源等镜像，需要切换成源镜像才能发布 https://registry.npmjs.org/\nJavaScript APIRollup 提供了一个可从 Node.js 使用的 JavaScript API。你很少需要使用它，不过通过这个 API 我们可以比较明显的知道 rollup 的构建大致流程。\n内容其实并不多，主要核心两个函数，rollup()与 watch()\n\nrollup.rollup\n\ninputOptions 对象\noutputOptions 对象\n\n\nrollup.watch\n\nwatchOptions\n\n\n\n其实用起来的基本思路和配置文件差不多。直接来看一下效果：\nconst rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nconst outputOptions &#x3D; &#123;\n  dir: &#39;dist&#39;,\n  format: &#39;esm&#39;,\n  sourcemap: true,\n  entryFileNames: &#39;[name].[hash].js&#39;\n&#125;\n\nasync function build() &#123;\n  let bundle;\n  let buildFailed &#x3D; false;\n  try &#123;\n    bundle &#x3D; await rollup.rollup(inputOptions);\n    await bundle.write(outputOptions);\n  &#125; catch (error) &#123;\n    buildFailed &#x3D; true;\n    console.error(error);\n  &#125;\n\n  if (bundle) &#123;\n    &#x2F;&#x2F; 关闭打包过程\n    await bundle.close();\n  &#125;\n  process.exit(buildFailed ? 1 : 0);\n&#125;\n\nbuild();\n\nconst watchOptions &#x3D; &#123;\n  ...inputOptions,\n  output: [outputOptions],\n  watch: &#123;\n    include: &#39;src&#x2F;**&#39;,\n    exclude: &#39;node_modules&#x2F;**&#39;\n  &#125;\n&#125;;\nconst watcher &#x3D; rollup.watch(watchOptions);\n\nwatcher.on(&#39;event&#39;, event &#x3D;&gt; &#123;\n  console.log(event);\n  &#x2F;&#x2F;确保每次打包完成后正确的关闭打包\n  if (event.result) &#123;\n    event.result.close();\n  &#125;\n&#125;)\n\n其实整个过程无非就是把我们之前配置的流程转换位了 js 代码的形式。watch api很明显就是命令行中使用 --watch 标志运行 Rollup 时的效果。\n两大构建工作流我们主要来看一下rollup()函数，从rollup()函数就可以看出，rollup 打包构建流程主要是两大步骤：\n1、build主要负责创建模块依赖，初始化哥哥模块的 AST(抽象语法树)，以及模块之间的依赖关系\nconst rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nasync function build() &#123;\n  const bundle &#x3D; await rollup.rollup(inputOptions);\n  console.log(bundle); &#x2F;&#x2F; 打印bundle对象\n  console.log(bundle.cache.modules); &#x2F;&#x2F;打印模块内容\n&#125;\n\nbuild();\n\n&#x2F;&#x2F; 打印bundle对象\n&#123;\n  cache: &#123;\n    modules: [ [Object], [Object], [Object] ],\n    plugins: [Object: null prototype] &#123;&#125;\n  &#125;,\n  close: [AsyncFunction: close],\n  closed: false,\n  generate: [AsyncFunction: generate],\n  watchFiles: [\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n    &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;\n  ],\n  write: [AsyncFunction: write]\n&#125;\n\n&#x2F;&#x2F; 打印模块内容\n[\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 262,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;&#x2F;**\\n&#39; +\n      &#39; * 随机数\\n&#39; +\n      &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n      &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n      &#39; * @returns min-max之间的随机整数\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n      &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n      &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n      &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default randomNumber&#39;,\n    customTransformCache: false,\n    dependencies: [],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;&#x2F;**\\n&#39; +\n      &#39; * 随机数\\n&#39; +\n      &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n      &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n      &#39; * @returns min-max之间的随机整数\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n      &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n      &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n      &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default randomNumber&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;&#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;,\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 349,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;&#x2F;**\\n&#39; +\n      &#39; * 深拷贝\\n&#39; +\n      &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n      &#39; * @returns 深拷贝对象\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n      &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n      &#39;    return obj\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n      &#39;  for(let key in obj) &#123;\\n&#39; +\n      &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n      &#39;      result[key] &#x3D; deepClone(obj[key])\\n&#39; +\n      &#39;    &#125;\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  return result\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;export default deepClone&#39;,\n    customTransformCache: false,\n    dependencies: [],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;&#x2F;**\\n&#39; +\n      &#39; * 深拷贝\\n&#39; +\n      &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n      &#39; * @returns 深拷贝对象\\n&#39; +\n      &#39; *&#x2F;\\n&#39; +\n      &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n      &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n      &#39;    return obj\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n      &#39;  for(let key in obj) &#123;\\n&#39; +\n      &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n      &#39;      result[key] &#x3D; deepClone(obj[key])\\n&#39; +\n      &#39;    &#125;\\n&#39; +\n      &#39;  &#125;\\n&#39; +\n      &#39;  return result\\n&#39; +\n      &#39;&#125;\\n&#39; +\n      &#39;export default deepClone&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;&#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;,\n  &#123;\n    assertions: &#123;&#125;,\n    ast: Node &#123;\n      type: &#39;Program&#39;,\n      start: 0,\n      end: 131,\n      body: [Array],\n      sourceType: &#39;module&#39;\n    &#125;,\n    code: &#39;import randomNumber from &quot;.&#x2F;randomNumber.js&quot;;\\n&#39; +\n      &#39;import deepClone from &quot;.&#x2F;deepClone.js&quot;;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default &#123; randomNumber, deepClone &#125;\\n&#39; +\n      &#39;\\n&#39;,\n    customTransformCache: false,\n    dependencies: [\n      &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;randomNumber.js&#39;,\n      &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;deepClone.js&#39;\n    ],\n    id: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n    meta: &#123;&#125;,\n    moduleSideEffects: true,\n    originalCode: &#39;import randomNumber from &quot;.&#x2F;randomNumber.js&quot;;\\n&#39; +\n      &#39;import deepClone from &quot;.&#x2F;deepClone.js&quot;;\\n&#39; +\n      &#39;\\n&#39; +\n      &#39;export default &#123; randomNumber, deepClone &#125;\\n&#39; +\n      &#39;\\n&#39;,\n    originalSourcemap: null,\n    resolvedIds: [Object: null prototype] &#123;\n      &#39;.&#x2F;randomNumber.js&#39;: [Object],\n      &#39;.&#x2F;deepClone.js&#39;: [Object]\n    &#125;,\n    sourcemapChain: [],\n    syntheticNamedExports: false,\n    transformDependencies: [],\n    transformFiles: undefined\n  &#125;\n]\n\n通过上面两个打印语句的结果，其实就可以分析出，在build阶段产生的bunlde对象，并没有模块打包，这个对象的作用在于存储各个模块的内容及依赖关系，并且提供了generate(不写入)，write(写入磁盘)方法，方便后续 output 阶段输出产物\n2、output通过 rollup()函数返回的对象 bundle 有两个重要的函数\n\ngenerate 生成打包产物，不写入磁盘\nwrite 生成打包产物，写入磁盘\n\nconst rollup &#x3D; require(&#39;rollup&#39;);\n\nconst inputOptions &#x3D; &#123;\n  input: &#39;src&#x2F;index.js&#39;,\n  external: [],\n  plugins: []\n&#125;\n\nconst outputOptions &#x3D; &#123;\n  dir: &#39;dist&#39;,\n  format: &#39;esm&#39;,\n  sourcemap: true,\n  entryFileNames: &#39;[name].[hash].js&#39;\n&#125;\n\nasync function build() &#123;\n  const bundle &#x3D; await rollup.rollup(inputOptions);\n  const resp &#x3D; await bundle.generate(outputOptions);\n  console.log(resp)\n&#125;\n\nbuild();\n\n执行结果：\n&#123;\n  output: [\n    &#123;\n      exports: [Array],\n      facadeModuleId: &#39;&#x2F;Users&#x2F;yingside&#x2F;Desktop&#x2F;rollup-api-demo&#x2F;src&#x2F;index.js&#39;,\n      isDynamicEntry: false,\n      isEntry: true,\n      isImplicitEntry: false,\n      moduleIds: [Array],\n      name: &#39;index&#39;,\n      type: &#39;chunk&#39;,\n      dynamicImports: [],\n      fileName: &#39;index.1730c9fc.js&#39;,\n      implicitlyLoadedBefore: [],\n      importedBindings: &#123;&#125;,\n      imports: [],\n      modules: [Object: null prototype],\n      referencedFiles: [],\n      code: &#39;&#x2F;**\\n&#39; +\n        &#39; * 随机数\\n&#39; +\n        &#39; * @param &#123;*&#125; min 最小值\\n&#39; +\n        &#39; * @param &#123;*&#125; max 最大值\\n&#39; +\n        &#39; * @returns min-max之间的随机整数\\n&#39; +\n        &#39; *&#x2F;\\n&#39; +\n        &#39;const randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n&#39; +\n        &#39;  min &#x3D; Math.ceil(min);\\n&#39; +\n        &#39;  max &#x3D; Math.floor(max);\\n&#39; +\n        &#39;  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#39; +\n        &#39;&#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;&#x2F;**\\n&#39; +\n        &#39; * 深拷贝\\n&#39; +\n        &#39; * @param obj 需要深拷贝的对象\\n&#39; +\n        &#39; * @returns 深拷贝对象\\n&#39; +\n        &#39; *&#x2F;\\n&#39; +\n        &#39;const deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n&#39; +\n        &quot;  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n&quot; +\n        &#39;    return obj\\n&#39; +\n        &#39;  &#125;\\n&#39; +\n        &#39;  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n&#39; +\n        &#39;  for(let key in obj) &#123;\\n&#39; +\n        &#39;    if(obj.hasOwnProperty(key)) &#123;\\n&#39; +\n        &#39;      result[key] &#x3D; deepClone(obj[key]);\\n&#39; +\n        &#39;    &#125;\\n&#39; +\n        &#39;  &#125;\\n&#39; +\n        &#39;  return result\\n&#39; +\n        &#39;&#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;var index &#x3D; &#123; randomNumber, deepClone &#125;;\\n&#39; +\n        &#39;\\n&#39; +\n        &#39;export &#123; index as default &#125;;\\n&#39; +\n        &#39;&#x2F;&#x2F;# sourceMappingURL&#x3D;index.1730c9fc.js.map\\n&#39;,\n      map: [SourceMap],\n      preliminaryFileName: &#39;index.!~&#123;001&#125;~.js&#39;,\n      sourcemapFileName: &#39;index.1730c9fc.js.map&#39;\n    &#125;,\n    &#123;\n      fileName: &#39;index.1730c9fc.js.map&#39;,\n      name: undefined,\n      needsCodeReference: false,\n      source: &#96;&#123;&quot;version&quot;:3,&quot;file&quot;:&quot;index.1730c9fc.js&quot;,&quot;sources&quot;:[&quot;..&#x2F;src&#x2F;randomNumber.js&quot;,&quot;..&#x2F;src&#x2F;deepClone.js&quot;,&quot;..&#x2F;src&#x2F;index.js&quot;],&quot;sourcesContent&quot;:[&quot;&#x2F;**\\n * 随机数\\n * @param &#123;*&#125; min 最小值\\n * @param &#123;*&#125; max 最大值\\n * @returns min-max之间的随机整数\\n *&#x2F;\\nconst randomNumber &#x3D; (min, max) &#x3D;&gt; &#123;\\n  min &#x3D; Math.ceil(min);\\n  max &#x3D; Math.floor(max);\\n  return Math.floor(Math.random() * (max - min + 1)) + min;\\n&#125;\\n\\nexport default randomNumber&quot;,&quot;&#x2F;**\\n * 深拷贝\\n * @param obj 需要深拷贝的对象\\n * @returns 深拷贝对象\\n *&#x2F;\\nconst deepClone &#x3D; (obj) &#x3D;&gt; &#123;\\n  if(typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\\n    return obj\\n  &#125;\\n  const result &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;\\n  for(let key in obj) &#123;\\n    if(obj.hasOwnProperty(key)) &#123;\\n      result[key] &#x3D; deepClone(obj[key])\\n    &#125;\\n  &#125;\\n  return result\\n&#125;\\nexport default deepClone&quot;,&quot;import randomNumber from \\&quot;.&#x2F;randomNumber.js\\&quot;;\\nimport deepClone from \\&quot;.&#x2F;deepClone.js\\&quot;;\\n\\nexport default &#123; randomNumber, deepClone &#125;\\n\\n&quot;],&quot;names&quot;:[],&quot;mappings&quot;:&quot;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,KAAK;AACnC,EAAE,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACvB,EAAE,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACxB,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;AAC3D;;ACVA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,GAAG,CAAC,GAAG,KAAK;AAC3B,EAAE,GAAG,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,EAAE;AAC9C,IAAI,OAAO,GAAG;AACd,GAAG;AACH,EAAE,MAAM,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;AAC9C,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,EAAE;AACtB,IAAI,GAAG,GAAG,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;AAChC,MAAM,MAAM,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,EAAC;AACvC,KAAK;AACL,GAAG;AACH,EAAE,OAAO,MAAM;AACf;;ACbA,YAAe,EAAE,YAAY,EAAE,SAAS;;;;&quot;&#125;&#96;,\n      type: &#39;asset&#39;\n    &#125;\n  ]\n&#125;\n\n插件机制\n\n\n\n\n\n\n\n\n代码：github.com&#x2F;Sunny-117&#x2F;r…\nRollup 插件概述\n\n\n\n\n\n\n\n\nRollup 插件是一个对象，具有 属性、构建钩子 和 输出生成钩子 中的一个或多个，并遵循我们的 约定。插件应作为一个导出一个函数的包进行发布，该函数可以使用插件特定的选项进行调用并返回此类对象。\n简单来说，rollup 插件一般会做成一个函数，函数返回一个对象，返回的对象中包含一些属性和不同阶段的钩子函数。\n约定插件应该有一个明确的名称，并以rollup-plugin-作为前缀。\n属性name：插件的名称，用于在警告和错误消息中标识插件。\nversion：插件的版本\n钩子函数的特点\n钩子函数区分不同的调用时机\n钩子函数是有执行顺序的\n钩子函数有不同的执行方式\n钩子函数也可以是对象的形式\n对象形式的钩子函数可以改变钩子的执行，让不同插件的同名钩子函数获取不通的执行先后\n\n钩子函数的调用时机这里的调用时机，其实就是以我们上面的 API，build 和 output 两大工作流的不同阶段进行分类。根据这两个不同阶段，rollup 提供的不同的函数让我们调用\n\nconst bundle &#x3D; await rollup.rollup(inputOptions) 执行期间的构建钩子函数 - build-hooks\nawait bundle.generate(outputOptions)&#x2F;write(outputOptions) 执行期间的输出钩子函数-output-generation-hooks\n\n钩子函数的执行方式除了上面简单的划分为两个阶段的调用时机之外，我们还可以以钩子函数的执行方式来分类。\n\nasync/sync：异步&#x2F;同步钩子，async 标记的钩子可以返回一个解析为相同类型的值的 Promise；否则，该钩子被标记为 sync。\nfirst：如果有多个插件实现此钩子，则钩子按顺序运行，直到钩子返回一个不是 null 或 undefined 的值。\nsequential：如果有多个插件实现此钩子，则所有这些钩子将按指定的插件顺序运行。如果钩子是 async，则此类后续钩子将等待当前钩子解决后再运行。\nparallel：如果有多个插件实现此钩子，则所有这些钩子将按指定的插件顺序运行。如果钩子是 async，则此类后续钩子将并行运行，而不是等待当前钩子。\n\n钩子函数也可以是对象除了函数之外，钩子也可以是对象。在这种情况下，实际的钩子函数（或 banner/footer/intro/outro 的值）必须指定为 handler。这允许你提供更多的可选属性，以改变钩子的执行：\n\norder: “pre” | “post” | null\n\n如果有多个插件实现此钩子，则可以先运行此插件（&quot;pre&quot;），最后运行此插件（&quot;post&quot;），或在用户指定的位置运行（没有值或 null）。\nexport default function resolveFirst() &#123;\n  return &#123;\n    name: &quot;resolve-first&quot;,\n    resolveId: &#123;\n      order: &quot;pre&quot;,\n      handler(source) &#123;\n        console.log(source);\n        return null;\n      &#125;,\n    &#125;,\n  &#125;;\n&#125;\n\n构建钩子执行顺序\n\n通过 options 钩子读取配置，并进行配置的转换，得到处理后的配置对象\n调用 buildStart 钩子，考虑了所有 options钩子配置的转换，包含未设置选项的正确默认值，正式开始构建流程\n调用 resolveId 钩子解析模块文件路径。rollup 中模块文件的 id 就是文件地址，所以，类似 resolveId 这种就是解析文件地址的意思。从inputOption的input配置指定的入口文件开始，每当匹配到引入外部模块的语句(如：import moudleA from &#39;./moduleA&#39;)便依次执行注册插件中的每一个 resolveId 钩子，直到某一个插件中的 resolveId 执行完后返回非 null 或非 undefined 的值，将停止执行后续插件的 resolveId 逻辑并进入下一个钩子\n调用load钩子加载模块内容，resolveId中的路径一般为相对路径，load 中的路径为处理之后的绝对路径\n接着判断当前解析的模块是否存在缓存，若不存在则执行所有的 transform 钩子来对模块内容进行进行自定义的转换；若存在则判断shouldTransformCachedModule属性，true 则执行所有的 transform 钩子，false 则进入moduleParsed钩子逻辑\n拿到最后的模块内容，进行 AST 分析，调用 moduleParsed 钩子。如果内部没有imports内容，进入buildEnd环节。如果还有imports内容则继续，如果是普通的 import，则执行resolveId 钩子，继续回到步骤 3-调用 resolveId；如果是动态 import，则执行resolveDynamicImport 钩子解析路径，如果解析成功，则回到步骤 4-load加载模块，否则回到步骤 3 通过 resolveId 解析路径\n直到所有的 import 都解析完毕，Rollup 执行buildEnd钩子，Build 阶段结束\n\n&#x2F;&#x2F; rollup-plugin-example.js\n\nexport default function myExample() &#123;\n  return &#123;\n    name: &quot;my-example&quot;,\n    options(options) &#123;\n      console.log(&quot;🎉 -- options:&quot;, options);\n    &#125;,\n    buildStart(options) &#123;\n      console.log(&quot;✨ -- buildStart:&quot;, options);\n    &#125;,\n    resolveId(source, importer) &#123;\n      console.log(&quot;🚀 -- resolveId(source):&quot;, source);\n      console.log(&quot;🚀 -- resolveId(importer):&quot;, importer);\n      return null;\n    &#125;,\n    load(id) &#123;\n      console.log(&quot;🌈 ~ id:&quot;, id);\n      return null;\n    &#125;,\n    transform(code, id) &#123;\n      console.log(&quot;🌟 -- transform&quot;);\n      console.log(&quot;---&quot;, code);\n      console.log(&quot;---&quot;, id);\n    &#125;,\n    moduleParsed(info) &#123;\n      console.log(&quot;⭐️ -- moduleParsed:&quot;, info);\n    &#125;,\n    buildEnd() &#123;\n      console.log(&quot;😁 -- buildEnd&quot;);\n    &#125;,\n  &#125;;\n&#125;\n\n调用虚拟模块插件示例const virtualModuleId &#x3D; &quot;virtual-module&quot;;\n&#x2F;&#x2F; rollup约定插件使用“虚拟模块”，使用\\0前缀模块 ID。这可以防止其他插件尝试处理它。\nconst resolvedVirtualModuleId &#x3D; &quot;\\0&quot; + virtualModuleId;\nexport default function virtualModule() &#123;\n  return &#123;\n    name: &quot;virtual-module&quot;,\n    resolveId(source) &#123;\n      if (source &#x3D;&#x3D;&#x3D; &quot;virtual-module&quot;) &#123;\n        return resolvedVirtualModuleId; &#x2F;&#x2F; 告诉Rollup，这个ID是外部模块，不要在此处查找它\n      &#125;\n      return null; &#x2F;&#x2F; 其他ID应按通常方式处理\n    &#125;,\n    load(id) &#123;\n      console.log(&quot;🌈 - id:&quot;, id);\n      if (id &#x3D;&#x3D;&#x3D; resolvedVirtualModuleId) &#123;\n        &#x2F;&#x2F; return &#39;export default &quot;This is virtual!&quot;&#39;; &#x2F;&#x2F; 告诉Rollup，如何加载此模块\n        return &quot;export default function fib(n) &#123; return n &lt;&#x3D; 1 ? n : fib(n - 1) + fib(n - 2); &#125;&quot;;\n      &#125;\n      return null; &#x2F;&#x2F; 其他ID应按通常方式处理\n    &#125;,\n  &#125;;\n&#125;\n\n界面调用\nimport fib from &quot;virtual-module&quot;;\nconsole.log(fib(10));\n\nJSON 插件示例rollup 默认是不能直接读取 json 文件的内容的，我们自己写一个插件处理一下，不过写这个插件之前，有一些小知识点需要补充一下\n@rollup&#x2F;pluginutils rollup 官方提供的工具插件,里面有一些制作插件常用的方法\n安装\npnpm add @rollup&#x2F;plugin-commonjs @rollup&#x2F;plugin-node-resolve @rollup&#x2F;pluginutils -D\n\n插件上下文\n这个其实也是插件中很常用的一些 api，可以通过 this 从大多数钩子中访问一些实用函数和信息位\nrollup-plugin-json\nimport &#123; createFilter, dataToEsm &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\nimport path from &quot;path&quot;;\n\nexport default function myJson(options &#x3D; &#123;&#125;) &#123;\n  &#x2F;&#x2F; createFilter 返回一个函数，这个函数接收一个id路径参数，返回一个布尔值\n  &#x2F;&#x2F; 这个布尔值表示是否要处理这个id路径\n  &#x2F;&#x2F; rollup 推荐每一个 transform 类型的插件都需要提供 include 和 exclude 选项，生成过滤规则\n  const filter &#x3D; createFilter(options.include, options.exclude);\n  return &#123;\n    name: &quot;rollup-plugin-json&quot;,\n    transform: &#123;\n      order: &quot;pre&quot;,\n      handler(code, id) &#123;\n        if (!filter(id) || path.extname(id) !&#x3D;&#x3D; &quot;.json&quot;) return null;\n        try &#123;\n          const parse &#x3D; JSON.stringify(JSON.parse(code));\n          return &#123;\n            &#x2F;&#x2F; dataToEsm 将数据转换成esm模块\n            &#x2F;&#x2F; 其实就是 export default &quot;xxx&quot;\n            code: dataToEsm(parse),\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125; catch (err) &#123;\n          const message &#x3D; &quot;Could not parse JSON file&quot;;\n          this.error(&#123; message, id, cause: err &#125;);\n          return null;\n        &#125;\n      &#125;,\n    &#125;,\n  &#125;;\n&#125;\n\n界面调用\nimport pkg from &quot;..&#x2F;package.json&quot;;\nimport test from &quot;..&#x2F;test.json&quot;; &#x2F;&#x2F; 错误json格式演示\nconsole.log(pkg.name);\n\n插件上下文import &#123; createFilter &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\n\nexport default function customPlugin(options) &#123;\n  const filter &#x3D; createFilter(options.include, options.exclude);\n\n  return &#123;\n    name: &quot;custom-plugin&quot;,\n\n    transform(code, id) &#123;\n      if (!filter(id)) &#123;\n        return null;\n      &#125;\n\n      const parsedCode &#x3D; this.parse(code); &#x2F;&#x2F; 解析代码,获取AST\n\n      const source &#x3D; &#96;$&#123;code&#125;\\n\\n$&#123;JSON.stringify(parsedCode, null, 2)&#125;&#96;;\n\n      const fileName &#x3D; id.split(&quot;&#x2F;&quot;).pop();\n\n      if (options.emitFile) &#123;\n        this.emitFile(&#123;\n          type: &quot;asset&quot;,\n          fileName: fileName + &quot;.txt&quot;,\n          source,\n        &#125;);\n      &#125;\n    &#125;,\n  &#125;;\n&#125;\n\n图片读取import &#123; createFilter, dataToEsm &#125; from &quot;@rollup&#x2F;pluginutils&quot;;\nimport &#123; extname, resolve, basename, relative, normalize, sep &#125; from &quot;path&quot;;\nimport fs from &quot;fs&quot;;\nimport svgToMiniDataURI from &quot;mini-svg-data-uri&quot;;\n\nconst defaults &#x3D; &#123;\n  fileSize: 1024 * 4,\n  target: &quot;.&#x2F;dist&quot;,\n  include: null,\n  exclude: null,\n&#125;;\n\nconst mimeTypes &#x3D; &#123;\n  &quot;.png&quot;: &quot;image&#x2F;png&quot;,\n  &quot;.jpg&quot;: &quot;image&#x2F;jpeg&quot;,\n  &quot;.jpeg&quot;: &quot;image&#x2F;jpeg&quot;,\n  &quot;.gif&quot;: &quot;image&#x2F;gif&quot;,\n  &quot;.svg&quot;: &quot;image&#x2F;svg+xml&quot;,\n  &quot;.ico&quot;: &quot;image&#x2F;x-icon&quot;,\n  &quot;.webp&quot;: &quot;image&#x2F;webp&quot;,\n  &quot;.avif&quot;: &quot;image&#x2F;avif&quot;,\n&#125;;\n\nconst getDataUri &#x3D; (&#123; format, isSvg, mime, source &#125;) &#x3D;&gt;\n  isSvg ? svgToMiniDataURI(source) : &#96;data:$&#123;mime&#125;;$&#123;format&#125;,$&#123;source&#125;&#96;;\n\nconst ensureDirExists &#x3D; async (dirPath) &#x3D;&gt; &#123;\n  try &#123;\n    await fs.promises.access(dirPath);\n    return true;\n  &#125; catch (err) &#123;\n    &#x2F;&#x2F; 文件夹不存在就创建文件夹\n    try &#123;\n      await fs.promises.mkdir(dirPath, &#123; recursive: true &#125;);\n      return true;\n    &#125; catch (err) &#123;\n      console.error(err);\n      return false;\n    &#125;\n  &#125;\n&#125;;\n\nexport default function myImage(opts &#x3D; &#123;&#125;) &#123;\n  const options &#x3D; Object.assign(&#123;&#125;, defaults, opts);\n  const filter &#x3D; createFilter(options.include, options.exclude);\n  return &#123;\n    name: &quot;my-image&quot;,\n    async transform(code, id) &#123;\n      if (!filter(id)) return null;\n\n      &#x2F;&#x2F; 获取后缀\n      const ext &#x3D; extname(id);\n      &#x2F;&#x2F; 判断是否是图片\n      if (!mimeTypes.hasOwnProperty(ext)) &#123;\n        return null;\n      &#125;\n\n      &#x2F;&#x2F; 获取图片的mime类型\n      const mime &#x3D; mimeTypes[ext];\n      &#x2F;&#x2F; 判断是否svg\n      const isSvg &#x3D; mime &#x3D;&#x3D;&#x3D; mimeTypes[&quot;.svg&quot;];\n      &#x2F;&#x2F; 图片format格式\n      const format &#x3D; isSvg ? &quot;utf-8&quot; : &quot;base64&quot;;\n\n      &#x2F;&#x2F; 目标路径\n      const assetsPath &#x3D; resolve(process.cwd(), options.target);\n      console.log(&quot;---&quot;, process.cwd());\n      console.log(&quot;---&quot;, options.target);\n      console.log(&quot;---&quot;, assetsPath);\n\n      &#x2F;&#x2F;获取文件名\n      const fileName &#x3D; basename(id);\n      &#x2F;&#x2F; 最终文件路径\n      const filePath &#x3D; resolve(assetsPath, fileName);\n      console.log(&quot;&#x3D;&#x3D;&#x3D;&quot;, filePath);\n\n      let relativePath &#x3D; normalize(relative(process.cwd(), filePath));\n      relativePath &#x3D; relativePath.substring(relativePath.indexOf(sep) + 1);\n\n      console.log(relativePath);\n\n      try &#123;\n        &#x2F;&#x2F; 如果图片文件过大，就应该直接拷贝文件，返回文件路径\n        &#x2F;&#x2F; 读取图片文件大小与设置的大小进行比较\n        const stat &#x3D; await fs.promises.stat(id);\n        if (stat.size &gt; options.fileSize) &#123;\n          &#x2F;&#x2F; 文件的拷贝，以及对象的返回\n          &#x2F;&#x2F; 文件拷贝，无非就是文件源路径，目标路径\n          &#x2F;&#x2F;copyFile 拷贝文件地址的文件夹必须存在\n          &#x2F;&#x2F; 如果文件夹不存在，那么就创建文件夹\n          const dirExists &#x3D; await ensureDirExists(assetsPath);\n          dirExists &amp;&amp; (await fs.promises.copyFile(id, filePath));\n          return &#123;\n            code: dataToEsm(relativePath), &#x2F;&#x2F;返回拷贝之后处理的路径\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125; else &#123;\n          &#x2F;&#x2F; 否则转换为base64格式\n          &#x2F;&#x2F; 读取文件\n          const source &#x3D; await fs.promises.readFile(id, format);\n\n          return &#123;\n            code: dataToEsm(getDataUri(&#123; format, isSvg, mime, source &#125;)),\n            map: &#123; mappings: &quot;&quot; &#125;,\n          &#125;;\n        &#125;\n      &#125; catch (err) &#123;\n        const message &#x3D; &quot;图片转换失败:&quot; + id;\n        this.error(&#123; message, id, cause: err &#125;);\n        return null;\n      &#125;\n    &#125;,\n  &#125;;\n&#125;\n\n输出钩子执行顺序\n\n执行所有插件的 outputOptions 钩子函数，对 output 配置进行转换\n执行 renderStart，该钩子读取所有 outputOptions 钩子的转换之后的输出选项\n扫描 动态import 语句执行 renderDynamicImport 钩子，让开发者能自定义动态import的内容与行为\n并发执行所有插件的 banner、footer、intro、outro 钩子，这四个钩子功能简单，就是往打包产物的固定位置(比如头部和尾部)插入一些自定义的内容，比如版本号、作者、内容、项目介绍等等\n是否存在 import.meta 语句，没有就直接进入下一步，否则：对于import.meta.url调用 resolveFileUrl 来自定义 url 解析逻辑。对于import.meta调用 resolveImportMeta 来进行自定义元信息解析\n生成 chunk 调用renderChunk钩子，便于在该钩子中进行自定义操作。如果生成的 chunk 文件有 hash 值，执行 augmentChunkHash 钩子，来决定是否更改 chunk 的哈希值。\n调用 generateBundle 钩子，这个钩子的入参里面会包含所有的打包产物信息，包括 chunk (打包后的代码)、asset(最终的静态资源文件)。在这个钩子中你做自定义自己的操作，比如：可以在这里删除一些 chunk 或者 asset，最终被删除的内容将不会作为产物输出\n上节课讲解的 javascript api—rollup.rollup方法会返回一个bundle对象，bundle对象的 write 方法，会触发writeBundle钩子，传入所有的打包产物信息，包括 chunk 和 asset，与generateBundle钩子非常相似。唯一的区别是writeBundle钩子执行的时候，产物已经输出了。而 generateBundle 执行的时候产物还并没有输出。简单来说，顺序是：generateBundle---&gt;输出并保存产物到磁盘---&gt;writeBundle\n当bundle的close方法被调用时，会触发closeBundle钩子，这个 output 阶段结束\n\nexport default function myExample2() &#123;\n  return &#123;\n    name: &quot;my-example2&quot;,\n    outputOptions(options) &#123;\n      console.log(&quot;🎉 ~ options:&quot;, options);\n    &#125;,\n    renderStart(options) &#123;\n      console.log(&quot;✨ ~ renderStart:&quot;, options);\n    &#125;,\n    renderDynamicImport(options) &#123;\n      console.log(&quot;✨~ renderDynamicImport:&quot;, options);\n    &#125;,\n    banner(chunk) &#123;\n      console.log(&quot;🔥 ~ banner(chunk):&quot;, chunk);\n      return &quot;&quot;;\n    &#125;,\n    renderChunk(source) &#123;\n      console.log(&quot;🚀 ~ source:&quot;, source);\n      return null;\n    &#125;,\n    augmentChunkHash(chunk) &#123;\n      console.log(&quot;🎉 ~ augmentChunkHash:&quot;, chunk);\n    &#125;,\n    generateBundle(options, bundle) &#123;\n      console.log(&quot;🌈 ~ options:&quot;, options);\n      console.log(&quot;🌈 ~ bundle:&quot;, bundle);\n      Object.keys(bundle).forEach((key) &#x3D;&gt; &#123;\n        if (key.includes(&quot;sum&quot;)) &#123;\n          &#x2F;&#x2F;删除对象中的这个键值对\n          delete bundle[key];\n        &#125;\n      &#125;);\n    &#125;,\n    closeBundle() &#123;\n      console.log(&quot;😁 ~ closeBundle&quot;);\n    &#125;,\n  &#125;;\n&#125;\n\n打包大小和时间示例：export default function bundleStats() &#123;\n let startTime;\n return &#123;\n  name: &#39;bundle-stats&#39;,\n  options() &#123;\n   startTime &#x3D; Date.now();\n   &#125;,\n  generateBundle(_, bundle) &#123;\n   const fileSizes &#x3D; &#123;&#125;;\n​\n   for (const [fileName, output] of Object.entries(bundle)) &#123;\n    if (output.type &#x3D;&#x3D;&#x3D; &#39;chunk&#39;) &#123;\n     const content &#x3D; output.code;\n     const size &#x3D; Buffer.byteLength(content, &#39;utf8&#39;);\n     const sizeInKB &#x3D; (size &#x2F; 1024).toFixed(2);\n​\n     fileSizes[fileName] &#x3D; &#96;$&#123;sizeInKB&#125; KB&#96;;\n     &#125;\n    &#125;\n   console.log(&#39;Bundle Stats:&#39;);\n   console.log(&#39;-------------&#39;);\n   console.log(&#39;File Sizes:&#39;);\n   console.log(fileSizes);\n   console.log(&#39;-------------&#39;);\n   &#125;,\n  closeBundle() &#123;\n   const totalTime &#x3D; Date.now() - startTime;\n   console.log(&#96;Total Bundle Time: $&#123;totalTime&#125; ms&#96;);\n   console.log(&#39;-------------&#39;);\n   &#125;\n  &#125;;\n&#125;\n\n代码压缩import &#123; minify &#125; from &#39;uglify-js&#39;;\n​\nexport default function uglifyPlugin() &#123;\n return &#123;\n  name: &#39;uglify&#39;,\n​\n  renderChunk(code) &#123;\n   const result &#x3D; minify(code);\n   if (result.error) &#123;\n    throw new Error(&#96;minify error: $&#123;result.error&#125;&#96;);\n    &#125;\n   return &#123;\n    code: result.code,\n    map: &#123; mappings: &#39;&#39; &#125;\n    &#125;;\n   &#125;,\n  &#125;;\n&#125;\n","slug":"rollup","date":"2024-12-22T08:39:14.000Z","categories_index":"Academic","tags_index":"rollup","author_index":"X-29"},{"id":"6f35d21607cc4ac40e0305fd85e2df31","title":"React-Principle","content":"React-Principle此文章旨在于剖析 React 的一些基本原理，帮助读者更好地理解 React 的工作原理。并写出属于自己的 React 代码。\n前置任务搭建目录以及配置一些工具First of all！\n├── packages| ├── react| | ├── src| | ├── index.ts| | └── package.json| ├── react-reconciler| | └── package.json| └── shared| ├── package.json| ├── ReactSymbols.ts| └── ReactTypes.ts├── scripts| └── rollup| ├── react.config.js| └── utils.js├── .gitignore├── .prettier.json├── eslint.config.js├── package-lock.json├── package.json├── README.md└── tsconfig.json\n安装依赖根目录的package.json文件在根目录的package.json文件中，我们需要安装一些依赖并配置好 scripts 命令：\n&#123;\n  &quot;name&quot;: &quot;react&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;lint&quot;: &quot;eslint .&#x2F;packages&quot;,\n    &quot;build:dev&quot;: &quot;rimraf dist &amp;&amp; rollup --bundleConfigAsCjs --config scripts&#x2F;rollup&#x2F;react.config.js&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@eslint&#x2F;js&quot;: &quot;^9.15.0&quot;,\n    &quot;@rollup&#x2F;plugin-commonjs&quot;: &quot;^28.0.1&quot;,\n    &quot;@types&#x2F;node&quot;: &quot;^22.9.3&quot;,\n    &quot;@types&#x2F;rollup-plugin-generate-package-json&quot;: &quot;^3.2.9&quot;,\n    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^8.15.0&quot;,\n    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^8.15.0&quot;,\n    &quot;eslint&quot;: &quot;^9.15.0&quot;,\n    &quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,\n    &quot;eslint-plugin-prettier&quot;: &quot;^5.2.1&quot;,\n    &quot;prettier&quot;: &quot;^3.3.3&quot;,\n    &quot;rimraf&quot;: &quot;^6.0.1&quot;,\n    &quot;rollup&quot;: &quot;^4.27.3&quot;,\n    &quot;rollup-plugin-generate-package-json&quot;: &quot;^3.2.0&quot;,\n    &quot;rollup-plugin-typescript2&quot;: &quot;^0.36.0&quot;,\n    &quot;typescript&quot;: &quot;^5.6.3&quot;\n  &#125;\n&#125;\n\ntsconfig.json在根目录下创建tsconfig.json文件，并配置好编译选项：\n&#123;\n  &quot;compileOnSave&quot;: true,\n  &quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ESNext&quot;,\n    &quot;useDefineForClassFields&quot;: true,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;],\n    &quot;moduleResolution&quot;: &quot;Node&quot;,\n    &quot;strict&quot;: true,\n    &quot;sourceMap&quot;: true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;noEmit&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noImplicitReturns&quot;: false,\n    &quot;skipLibCheck&quot;: true,\n    &quot;baseUrl&quot;: &quot;.&#x2F;packages&quot;\n  &#125;\n&#125;\n\neslint.config.jsimport eslint from &quot;@eslint&#x2F;js&quot;;\nimport tseslint from &quot;@typescript-eslint&#x2F;eslint-plugin&quot;;\nimport tsparser from &quot;@typescript-eslint&#x2F;parser&quot;;\nimport prettier from &quot;eslint-plugin-prettier&quot;;\nimport eslintConfigPrettier from &quot;eslint-config-prettier&quot;;\n\nexport default [\n  &#x2F;&#x2F; 基础 ESLint 配置\n  eslint.configs.recommended,\n\n  &#x2F;&#x2F; Prettier 配置\n  eslintConfigPrettier,\n\n  &#123;\n    files: [&quot;**&#x2F;*.ts&quot;, &quot;**&#x2F;*.tsx&quot;],\n    languageOptions: &#123;\n      parser: tsparser,\n      parserOptions: &#123;\n        ecmaVersion: &quot;latest&quot;,\n        sourceType: &quot;module&quot;,\n      &#125;,\n    &#125;,\n    plugins: &#123;\n      &quot;@typescript-eslint&quot;: tseslint,\n      prettier: prettier,\n    &#125;,\n    rules: &#123;\n      &quot;prettier&#x2F;prettier&quot;: &quot;error&quot;,\n      &quot;no-case-declarations&quot;: &quot;off&quot;,\n      &quot;no-constant-condition&quot;: &quot;off&quot;,\n      &quot;@typescript-eslint&#x2F;ban-ts-comment&quot;: &quot;off&quot;,\n      &quot;@typescript-eslint&#x2F;no-var-requires&quot;: &quot;off&quot;,\n      &quot;react&#x2F;react-in-jsx-scope&quot;: &quot;off&quot;,\n      &quot;prettier&#x2F;prettier&quot;: [\n        &quot;error&quot;,\n        &#123;\n          endOfLine: &quot;auto&quot;,\n        &#125;,\n      ],\n    &#125;,\n  &#125;,\n];\n\n.prettier.json&#123;\n  &quot;printWidth&quot;: 80,\n  &quot;tabWidth&quot;: 2,\n  &quot;useTabs&quot;: true,\n  &quot;singleQuote&quot;: true,\n  &quot;semi&quot;: true,\n  &quot;trailingComma&quot;: &quot;none&quot;,\n  &quot;bracketSpacing&quot;: true\n&#125;\n\n打包脚本rollup.config.js在scripts目录下创建rollup.config.js文件，并配置打包选项：::: warning注意：rollup.config.js文件需要使用commonjs模块规范，因为rollup默认使用esm模块规范，而node环境不支持esm模块规范。并且一定要是js文件，不能是ts文件。:::\nimport &#123; getBaseRollupPlugins, getPackageJSON, resolvePkgPath &#125; from &quot;.&#x2F;utils&quot;;\n\nimport generatePackageJson from &quot;rollup-plugin-generate-package-json&quot;;\n\n&#x2F;&#x2F; 获取package.json下面的name字段\nconst &#123; name, module &#125; &#x3D; getPackageJSON(&quot;react&quot;, false); &#x2F;&#x2F; react\n&#x2F;&#x2F; react包的路径\nconst pkgPath &#x3D; resolvePkgPath(name, false);\n&#x2F;&#x2F;react 产物路劲\nconst pkgDistPath &#x3D; resolvePkgPath(name, true);\nexport default [\n  &#x2F;&#x2F; 对应react包\n  &#123;\n    input: &#96;$&#123;pkgPath&#125;&#x2F;$&#123;module&#125;&#96;,\n    output: &#123;\n      file: &#96;$&#123;pkgDistPath&#125;&#x2F;index.js&#96;,\n      name: &quot;react&quot;,\n      format: &quot;umd&quot;,\n    &#125;,\n    plugins: [\n      ...getBaseRollupPlugins(),\n      generatePackageJson(&#123;\n        inputFolder: pkgPath,\n        outputFolder: pkgDistPath,\n        baseContents: (&#123; name, description, version &#125;) &#x3D;&gt; (&#123;\n          name,\n          description,\n          version,\n          main: &quot;index.js&quot;,\n        &#125;),\n      &#125;),\n    ],\n  &#125;,\n  &#x2F;&#x2F; jsx-runtime包\n  &#123;\n    input: &#96;$&#123;pkgPath&#125;&#x2F;src&#x2F;jsx.ts&#96;,\n    output: [\n      &#x2F;&#x2F; jsx-runtime\n      &#123;\n        file: &#96;$&#123;pkgDistPath&#125;&#x2F;jsx-runtime.js&#96;,\n        name: &quot;jsx-runtime.js&quot;,\n        format: &quot;umd&quot;,\n      &#125;,\n      &#123;\n        file: &#96;$&#123;pkgDistPath&#125;&#x2F;jsx-dev-runtime.js&#96;,\n        name: &quot;jsx-dev-runtime.js&quot;,\n        format: &quot;umd&quot;,\n      &#125;,\n    ],\n    plugins: getBaseRollupPlugins(),\n  &#125;,\n];\n\nutils.js在scripts目录下创建utils.js文件，并配置一些工具函数：\nimport path from &quot;path&quot;;\nimport fs from &quot;fs&quot;;\nimport ts from &quot;rollup-plugin-typescript2&quot;;\nimport cjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\n\n&#x2F;&#x2F; 包路径\nconst pkgPath &#x3D; path.resolve(__dirname, &quot;..&#x2F;..&#x2F;packages&quot;);\n&#x2F;&#x2F; 打包产物路径\nconst distPath &#x3D; path.resolve(__dirname, &quot;..&#x2F;..&#x2F;dist&#x2F;node_modules&quot;);\n\n&#x2F;**\n * @name 获取包路径或者是打包产物路径\n * @param pkgName\n * @param isDist 是否是打包\n *&#x2F;\nexport const resolvePkgPath &#x3D; (pkgName, isDist) &#x3D;&gt; &#123;\n  return isDist ? &#96;$&#123;distPath&#125;&#x2F;$&#123;pkgName&#125;&#96; : &#96;$&#123;pkgPath&#125;&#x2F;$&#123;pkgName&#125;&#96;;\n&#125;;\n\n&#x2F;**\n * @name 解析包对应的package.json文件\n * @param pkgName\n *&#x2F;\nexport const getPackageJSON &#x3D; (pkgName, isDist) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;1. 包路径 + Package.json\n  const path &#x3D; &#96;$&#123;resolvePkgPath(pkgName, isDist)&#125;&#x2F;package.json&#96;;\n  const str &#x3D; fs.readFileSync(path, &#123; encoding: &quot;utf-8&quot; &#125;);\n  return JSON.parse(str);\n&#125;;\n\nexport const getBaseRollupPlugins &#x3D; (&#123; typeScriptConfig &#x3D; &#123;&#125; &#125; &#x3D; &#123;&#125;) &#x3D;&gt; [\n  cjs(),\n  ts(typeScriptConfig),\n];\n\npackage&#x2F;react该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;react&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;module&quot;: &quot;index.ts&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;shared&quot;: &quot;workspace:*&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;react公共方法&quot;\n&#125;\n\n其中 package&#x2F;index.ts 和 package&#x2F;src&#x2F;jsx.ts 文件先随便写点什么 ts 代码，为了npm run build:dev命令可以正常运行。package&#x2F;src&#x2F;jsx.ts 的目录和文件名在 rollup.config.js 中配置一一对应的\npackage&#x2F;shared该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;shared&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;所有公共方法以及类型定义&quot;\n&#125;\n\npackage&#x2F;react-reconciler该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;react-reconciler&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;&quot;\n&#125;\n\n至此，我们已经完成了项目的目录结构以及一些依赖的安装。在根目录下，我们可以运行npm run build:dev命令进行项目的打包。npm run lint命令可以对项目的代码进行 eslint 检查。\njsx基本介绍React 主要是将页面的结构通过 jsx 进行描述，在调和后，每一个 React element 对象的子节点都会形成一个对应的 fiberNode\n本节内容主要是实现 jsx 的生成。在 React 的源码中，jsx 的代码逻辑存在 packages 下面的 react 包中。为了兼容 React 的旧版本，我们主要是实现最后导出三个文件。\nindex.js: import React from &#39;react&#39; 这样使用jsx-runtime.js: 新版通过 babel 导入jsx-dev-runtime.js: 开发环境的包\n为了开发者方便，React 提供一种类似于 html 的方式去书写代码，然后 React 通过 babel 去进行转义。在 React 的新版本中，我们不再需要手动去引入 React, plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。\n&lt;div className&#x3D;&quot;x&quot;&gt;\n  123\n  &lt;span&gt;yx&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n\n新版Automaticimport &#123; jsx as _jsx &#125; from &quot;react&#x2F;jsx-runtime&quot;;\nimport &#123; jsxs as _jsxs &#125; from &quot;react&#x2F;jsx-runtime&quot;;\n&#x2F;*#__PURE__*&#x2F; _jsxs(&quot;div&quot;, &#123;\n  className: &quot;x&quot;,\n  children: [\n    &quot;123&quot;,\n    &#x2F;*#__PURE__*&#x2F; _jsx(&quot;span&quot;, &#123;\n      children: &quot;yx&quot;,\n    &#125;),\n  ],\n&#125;);\n\n旧版Classic&#x2F;*#__PURE__*&#x2F; React.createElement(\n  &quot;div&quot;,\n  &#123;\n    className: &quot;x&quot;,\n  &#125;,\n  &quot;123&quot;,\n  &#x2F;*#__PURE__*&#x2F; React.createElement(&quot;span&quot;, null, &quot;yx&quot;)\n);\n\n\n\n\n\n\n\n\n\n\n主要是分为三部分：1. 对应的 tag 字段， 2. 属性和 children， 3. key 等一些特殊字段。\n实现 JSX声明类型在 packages/shared/ReactTypes.ts 文件中，我们声明了 JSX 相关的类型。\n&#x2F;** 在这里集中定义React的类型 *&#x2F;\n\n&#x2F;** 定义 React 的 Type 类型 *&#x2F;\nexport type Type &#x3D; any;\n\n&#x2F;** 定义 React 的 Key 类型 *&#x2F;\nexport type Key &#x3D; string | null;\n\n&#x2F;** 定义 React 的 Ref 类型 *&#x2F;\nexport type Ref&lt;T &#x3D; any&gt; &#x3D;\n  | &#123; current: T | null &#125;\n  | ((instance: T | null) &#x3D;&gt; void)\n  | null;\n\n&#x2F;** 定义 React 的 Props 类型 *&#x2F;\nexport type Props &#x3D; &#123;\n  [key: string]: any;\n  children?: any;\n&#125;;\n\n&#x2F;** 定义 React 的 ElementType 类型 *&#x2F;\nexport type ElementType &#x3D; string | ((props: any) &#x3D;&gt; ReactElementType | null);\n\n&#x2F;** 定义 React 的 ReactElement 类型 *&#x2F;\nexport interface ReactElementType &#123;\n  $$typeof: symbol | number;\n  type: ElementType;\n  key: Key;\n  ref: Ref;\n  props: Props;\n  __mark: string;\n&#125;\n\n在 packages/shared/ReactSymbols.ts 文件中，我们声明了 JSX 相关的 symbol。\n&#x2F;**\n * 判断当前环境是否支持 Symbol 及其 for 方法\n * 1. typeof Symbol &#x3D;&#x3D;&#x3D; &#39;function&#39; 检查 Symbol 是否可用且是函数类型\n * 2. Symbol.for 检查是否支持全局 Symbol 注册表功能\n * 3. 在较老的浏览器中可能不支持 Symbol，此时返回 false\n *&#x2F;\nconst supportSymbol &#x3D; typeof Symbol &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; Symbol.for;\n\n&#x2F;**\n * 1. Symbol.for() 是什么：\n *   - 这是 JavaScript 的全局 Symbol 注册表功能\n *   - Symbol.for(&#39;react.element&#39;) 会创建一个全局唯一的 Symbol\n *   - 如果已经存在同名的 Symbol，则返回已存在的那个\n *   - 这确保了在不同的模块中使用相同的字符串创建的 Symbol 是完全相同的\n * 2.为什么需要降级方案 0xeac7：\n *   - 不是所有 JavaScript 环境都支持 Symbol（比如老版本浏览器）\n *   - 0xeac7 是一个十六进制数字，作为降级后的标识符\n *   - 这个数字是 React 团队选择的一个特定值，用来标识 React 元素\n * 3. 这个值的用途：\n *   - 用来标识一个对象是否是合法的 React 元素\n *   - 在 ReactElement 接口中，我们看到有 $$typeof 属性\n *   - $$typeof 就会被赋值为 REACT_ELEMENT_TYPE\n *   - React 内部会检查这个值来确保元素的合法性 *&#x2F;\nexport const REACT_ELEMENT_TYPE &#x3D; supportSymbol\n  ? Symbol.for(&quot;react.element&quot;)\n  : 0xeac7;\n\n实现 JSX在 packages/react/src/jsx.ts 文件中，我们实现 JSX 的逻辑。\nimport &#123; REACT_ELEMENT_TYPE &#125; from &quot;shared&#x2F;ReactSymbols&quot;;\nimport &#123;\n  ElementType,\n  Key,\n  Props,\n  ReactElementType,\n  Ref,\n  Type,\n&#125; from &quot;shared&#x2F;ReactTypes&quot;;\n\n&#x2F;**\n * 创建 React 元素的核心函数\n * @param type 元素类型 - 可以是字符串(原生 DOM 元素)或函数(组件)\n * @param key 用于标识元素的唯一键值，帮助 React 进行高效的 DOM diff\n * @param ref 引用对象，用于访问 DOM 节点或组件实例\n * @param props 元素的属性对象，包含所有传入的属性和子元素\n * @returns 返回一个 React 元素对象\n *&#x2F;\nconst ReactElement &#x3D; (\n  type: Type,\n  key: Key,\n  ref: Ref,\n  props: Props\n): ReactElementType &#x3D;&gt; (&#123;\n  &#x2F;&#x2F; 标识这是一个 React 元素的内部类型标记\n  $$typeof: REACT_ELEMENT_TYPE,\n  &#x2F;&#x2F; 元素类型（div, p, 或自定义组件等）\n  type,\n  &#x2F;&#x2F; 用于优化更新的 key 值\n  key,\n  &#x2F;&#x2F; DOM 或组件实例的引用\n  ref,\n  &#x2F;&#x2F; 元素的所有属性\n  props,\n  &#x2F;&#x2F; 自定义标记，用于标识这是我们的 React 实现\n  __mark: &quot;x-react&quot;,\n&#125;);\n\n&#x2F;**\n * 从配置对象中提取并处理 key、ref 和其他 props\n * @param &#123;Config&#125; Jsx.JsxConfig - React 元素的配置对象\n * @returns &#123;[Key, Ref, Props]&#125; 返回一个元组，包含处理后的 key、ref 和 props\n *\n * @description\n * 1. 通过解构获取 key 和 ref，设置默认值为 null\n * 2. 将 key 转换为字符串（如果存在）\n * 3. 使用 reduce 处理剩余的 props，确保只包含对象自身的属性\n * 4. 返回处理后的 [key, ref, props] 元组\n *&#x2F;\nconst extractPropsFromConfig &#x3D; (config: Jsx.JsxConfig): [Key, Ref, Props] &#x3D;&gt; &#123;\n  const &#123; key &#x3D; null, ref &#x3D; null, ...props &#125; &#x3D; config;\n  return [\n    key !&#x3D; null ? String(key) : null,\n    ref,\n    Object.keys(props).reduce((acc, prop) &#x3D;&gt; &#123;\n      if (&#123;&#125;.hasOwnProperty.call(config, prop)) &#123;\n        acc[prop] &#x3D; props[prop];\n      &#125;\n      return acc;\n    &#125;, &#123;&#125; as Props),\n  ];\n&#125;;\n\n&#x2F;**\n * 处理并合并 children 到 props 中\n * @param &#123;Props&#125; props - 原始的 props 对象\n * @param &#123;any[]&#125; children - 子元素数组\n * @returns &#123;Props&#125; 返回合并了 children 的新 props 对象\n *\n * @description\n * 1. 如果没有 children，直接返回原始 props\n * 2. 如果只有一个 child，直接使用该 child\n * 3. 如果有多个 children，保持数组形式\n * 4. 使用展开运算符创建新的 props 对象，确保不修改原始对象\n *&#x2F;\nconst processChildren &#x3D; (props: Props, children: any[]): Props &#x3D;&gt; &#123;\n  if (children.length &#x3D;&#x3D;&#x3D; 0) return props;\n\n  return &#123;\n    ...props,\n    children: children.length &#x3D;&#x3D;&#x3D; 1 ? children[0] : children,\n  &#125;;\n&#125;;\n\n&#x2F;**\n * JSX 转换函数 - 将 JSX 语法转换为 React 元素\n * @param &#123;ElementType&#125; type - 元素类型（可以是字符串或组件函数）\n * @param &#123;Config&#125; Jsx.JsxConfig - 元素的配置对象，包含 props、key、ref 等\n * @param &#123;...any&#125; children - 子元素列表\n * @returns &#123;ReactElementType&#125; 返回创建的 React 元素\n *\n * @description\n * 1. 首先从配置中提取必要的属性\n * 2. 处理并添加 children\n * 3. 使用这些处理后的值创建 React 元素\n *\n * @description\n * * 完整的处理流程：\n * 1. jsx(&#39;div&#39;, &#123; className: &#39;container&#39; &#125;, child1, child2) 被调用\n * 2. extractPropsFromConfig 处理配置对象：\n *    - 提取 key 和 ref（如果有）\n *    - 处理其余属性（如 className, onClick 等）\n * 3. processChildren 处理子元素：\n *    - 将所有子元素规范化处理\n *    - 添加到 props.children 中\n * 4. ReactElement 创建最终的 React 元素对象\n * 5. 返回的元素对象将被 React 用于后续的渲染流程\n *&#x2F;\nexport const jsx &#x3D; (\n  type: ElementType,\n  config: Jsx.JsxConfig,\n  ...children: any\n) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 第一步：提取和处理配置\n  const [key, ref, props] &#x3D; extractPropsFromConfig(config);\n  &#x2F;&#x2F; 第二步：处理子元素\n  const propsWithChildren &#x3D; processChildren(props, children);\n\n  &#x2F;&#x2F; 第三步：创建 React 元素\n  return ReactElement(type, key, ref, propsWithChildren);\n\n  &#x2F;* 返回的对象形如：\n   &#123;\n     $$typeof: Symbol(react.element),\n     type: &#39;div&#39;,\n     props: &#123;\n       className: &#39;container&#39;,\n       children: &#123;\n         $$typeof: Symbol(react.element),\n         type: &#39;span&#39;,\n         props: &#123; children: &#39;Hello&#39; &#125;\n       &#125;\n     &#125;\n   &#125; *&#x2F;\n&#125;;\n\n&#x2F;**\n * 开发环境使用的 JSX 转换函数\n * @param &#123;ElementType&#125; type - 元素类型\n * @param &#123;Config&#125; Jsx.JsxConfig - 元素配置对象\n * @returns &#123;ReactElementType&#125; 返回创建的 React 元素\n *\n * @description\n * 1. 开发环境版本，不处理 children\n * 2. 用于开发工具和调试\n * 3. 保持与生产版本相同的基本结构，但可能包含额外的开发时检查\n *\n * @description 开发环境的 JSX 转换函数\n * 与生产版本的主要区别：\n * 1. 可以进行额外的类型检查\n * 2. 可以提供更好的错误信息\n * 3. 可以进行开发时的警告提示\n * 4. 可以添加开发工具所需的调试信息\n *&#x2F;\nexport const jsxDev &#x3D; (type: ElementType, config: Jsx.JsxConfig) &#x3D;&gt; &#123;\n  const [key, ref, props] &#x3D; extractPropsFromConfig(config);\n  return ReactElement(type, key, ref, props);\n&#125;;\n\n整体 jsx 函数的调用流程\n\nJSX 代码：\n\nfunction App() &#123;\n  return (\n    &lt;div className&#x3D;&quot;container&quot;&gt;\n      &lt;span&gt;Hello&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n\nBabel 转义后的代码：\n\nfunction App() &#123;\n  return jsx(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;, jsx(&quot;span&quot;, null, &quot;Hello&quot;));\n&#125;\n\njsx 函数的作用就是接收 Babel 转换后的参数，并创建出 React 元素（虚拟 DOM 节点）\n\n最终生成的 React 元素结构：\n\n&#123;\n$$typeof: Symbol(react.element),\ntype: &#39;div&#39;,\nkey: null,\nref: null,\nprops: &#123;\n    className: &#39;container&#39;,\n    children: [\n      &#123;\n        $$typeof: Symbol(react.element),\n        type: &#39;span&#39;,\n        props: &#123; children: &#39;Hello&#39; &#125;,\n        &#x2F;&#x2F; ...\n      &#125;\n    ]\n&#125;\n&#125;\n\n\n所以整个流程是：\n\n\n开发者写 JSX 代码\nBabel 在编译时将 JSX 语法转换为 jsx() 函数调用\n运行时，jsx() 函数被调用，创建 React 元素\nReact 使用这些元素来渲染实际的 DOM 5.简单来说：Babel 的工作是：转换语法（ → jsx(‘div’)）,jsx 函数的工作是：创建虚拟 DOM 节点（jsx(‘div’) → { type: ‘div’, props: {…} }）,这就是为什么在 React 17 之后的版本中，我们不需要手动引入 React（import React from ‘react’），因为 Babel 会自动帮我们引入 jsx 函数。\n\n\n那么为什么还存在 jsxDev 函数呢？\n\njsxDev 函数的作用是为了开发环境的 JSX 转换，它的作用和 jsx 函数一样，只是它不处理 children 子元素，所以它的返回值和生产环境的 jsx 函数返回值是一样的。\n区别的具体体现：\n\nBabel 的转换会根据环境不同选择不同的函数：\n\n&#x2F;&#x2F; 开发环境下，Babel 会转换成：\njsxDev(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;);\n\n&#x2F;&#x2F; 生产环境下，Babel 会转换成：\njsx(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;);\n\n\n实际应用场景：\n\nfunction App() &#123;\n  &#x2F;&#x2F; 开发环境下，如果你这样写：\n  return &lt;div&gt;&#123;undefined.toString()&#125;&lt;&#x2F;div&gt;;\n\n  &#x2F;&#x2F; jsxDev 可以提供更友好的错误信息：\n  &#x2F;&#x2F; &quot;Cannot read property &#39;toString&#39; of undefined at App&quot;\n  &#x2F;&#x2F; 并显示具体的组件栈信息\n\n  &#x2F;&#x2F; 而在生产环境下，jsx 函数会简单地抛出错误，\n  &#x2F;&#x2F; 没有这些额外的调试信息\n&#125;\n\n\n性能考虑：\n\n&#x2F;&#x2F; 开发环境：更多的检查，更多的警告\njsxDev(&quot;div&quot;, &#123;\n  &#x2F;&#x2F; 可以检查 props 类型\n  &#x2F;&#x2F; 可以检查废弃的 API 使用\n  &#x2F;&#x2F; 可以添加更多的调试信息\n&#125;);\n\n&#x2F;&#x2F; 生产环境：更简洁的代码，更好的性能\njsx(&quot;div&quot;, &#123;\n  &#x2F;&#x2F; 只进行必要的转换\n  &#x2F;&#x2F; 没有额外的检查和警告\n  &#x2F;&#x2F; 代码体积更小，运行更快\n&#125;);\n\nSummary：\n\n开发体验：提供更好的错误信息和警告\n调试能力：支持 React DevTools 等开发工具\n性能优化：生产环境可以移除开发时的检查代码\n包体积：生产环境的代码更精简\n\n这就是为什么 React 需要维护两个版本的 JSX 转换函数，它们服务于不同的目的：jsx: 注重性能和包体积jsxDev: 注重开发体验和调试能力\nReact reconcilerReact reconciler 主要是实现了 React 的核心算法，包括调和、渲染、更新等。\n更改 packages&#x2F;react-reconciler&#x2F;package.json 文件&#123;\n  &quot;name&quot;: &quot;react-reconciler&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;react-reconciler&quot;,\n  &quot;module&quot;: &quot;index.ts&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;shared&quot;: &quot;workspace: *&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n在 packages&#x2F;react&#x2F;src&#x2F;currentBatchConfig.ts 文件中，我们声明了 currentBatchConfig 类型。\n\n\n\n\n\n\n\n\ncurrentBatchConfig.ts - React 批处理配置文件\n作用：\n\n存储当前 React 批量更新的配置信息\n主要用于 Transition 相关的功能\n在并发渲染中控制更新的优先级\n\n&#x2F;**\n * React 当前批处理配置对象\n *\n * 用途：\n * 1. 在组件更新时标记更新的类型\n * 2. 帮助 React 区分普通更新和 Transition 更新\n * 3. 影响更新的优先级和调度方式\n *\n * @type &#123;React.BatchConfig&#125;\n *\n * @example\n * &#x2F;&#x2F; React 内部使用示例\n * function scheduleUpdate(fiber, update) &#123;\n *   const transition &#x3D; ReactCurrentBatchConfig.transition;\n *   if (transition !&#x3D;&#x3D; null) &#123;\n *     &#x2F;&#x2F; 这是一个 Transition 更新，使用较低的优先级\n *     scheduleTransitionUpdate(fiber, update);\n *   &#125; else &#123;\n *     &#x2F;&#x2F; 这是一个普通更新，使用正常优先级\n *     scheduleRegularUpdate(fiber, update);\n *   &#125;\n * &#125;\n *&#x2F;\nconst ReactCurrentBatchConfig: React.BatchConfig &#x3D; &#123;\n  transition: null,\n&#125;;\n\nexport default ReactCurrentBatchConfig;\n\n\n\n\n\n\n\n\n\n\n实际应用场景：\n\nuseTransition Hook:\n\nfunction App() &#123;\n  const [isPending, startTransition] &#x3D; useTransition();\n  return (\n    &lt;button\n      onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n        startTransition(() &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 这里的更新会被标记为 Transition\n          setLargeList(generateLargeList());\n        &#125;);\n      &#125;&#125;\n    &gt;\n      Update List\n    &lt;&#x2F;button&gt;\n  );\n&#125;\n\n\n并发特性：\n\n\n允许 React 中断渲染以处理更高优先级的更新\n帮助实现更流畅的用户体验\n支持可中断的渲染过程\n\n在 packages&#x2F;react-reconciler&#x2F;src&#x2F;fiberFlags.ts 文件中\n\n\n\n\n\n\n\n\nfiberFlags.ts - React Fiber 节点的副作用（side-effects）标记定义\n作用：\n\n定义所有可能的 Fiber 节点副作用类型\n使用二进制位标记实现高效的副作用追踪\n通过位运算组合多个副作用\n\n&#x2F;**\n\n\n&#x2F;**\n * Flags 类型定义\n * 用于在 TypeScript 中标识副作用标记的类型\n *&#x2F;\nexport type Flags &#x3D; number;\n\n&#x2F;**\n * 无副作用标记\n * 表示节点不需要进行任何操作\n * 二进制：0000000\n *&#x2F;\nexport const NoFlags &#x3D; 0b0000000;\n\n&#x2F;**\n * 插入&#x2F;移动标记\n * 表示节点需要插入到 DOM 中或在 DOM 中移动位置\n * 二进制：0000001\n *&#x2F;\nexport const Placement &#x3D; 0b0000001;\n\n&#x2F;**\n * 更新标记\n * 表示节点的属性或内容需要更新\n * 二进制：0000010\n *&#x2F;\nexport const Update &#x3D; 0b0000010;\n\n&#x2F;**\n * 子节点删除标记\n * 表示需要删除子节点\n * 二进制：0000100\n *&#x2F;\nexport const ChildDeletion &#x3D; 0b0000100;\n\n&#x2F;**\n * 被动效果标记（如 useEffect）\n * 表示节点包含需要在提交阶段后异步执行的副作用\n * 二进制：0001000\n *&#x2F;\nexport const PassiveEffect &#x3D; 0b0001000;\n\n&#x2F;**\n * Ref 更新标记\n * 表示节点的 ref 需要更新\n * 二进制：0010000\n *&#x2F;\nexport const Ref &#x3D; 0b0010000;\n\n&#x2F;**\n * 可见性变更标记\n * 表示节点的显示&#x2F;隐藏状态需要更新\n * 二进制：0100000\n *&#x2F;\nexport const Visibility &#x3D; 0b0100000;\n\n&#x2F;**\n * 已捕获标记\n * 表示错误已经被捕获\n * 二进制：1000000\n *&#x2F;\nexport const DidCapture &#x3D; 0b1000000;\n\n&#x2F;**\n * 应该捕获标记\n * 表示这个节点应该尝试捕获错误\n * 二进制：01000000000\n *&#x2F;\nexport const ShouldCapture &#x3D; 0b01000000000;\n\n&#x2F;**\n * 突变阶段的标记集合\n * 包含了在 DOM 突变阶段需要处理的所有副作用\n * 通过位运算组合多个标记\n *\n * @example\n * if (fiber.flags &amp; MutationMask) &#123;\n *   &#x2F;&#x2F; 需要在突变阶段处理这个节点\n * &#125;\n *&#x2F;\nexport const MutationMask &#x3D;\n  Placement | Update | ChildDeletion | Ref | Visibility;\n\n&#x2F;**\n * 布局阶段的标记集合\n * 包含了在 DOM 布局阶段需要处理的所有副作用\n * 目前只包含 Ref 的更新\n *&#x2F;\nexport const LayoutMask &#x3D; Ref;\n\n&#x2F;**\n * 被动效果的标记集合\n * 包含了需要异步处理的副作用\n * 主要用于 useEffect 的处理\n *&#x2F;\nexport const PassiveMask &#x3D; PassiveEffect | ChildDeletion;\n\n使用示例：\n&#x2F;&#x2F; 添加副作用标记\nfiber.flags |&#x3D; Update;\n\n&#x2F;&#x2F; 检查是否包含某个副作用\nif (fiber.flags &amp; Placement) &#123;\n  &#x2F;&#x2F; 需要插入或移动节点\n&#125;\n\n&#x2F;&#x2F; 在不同阶段检查相关副作用\nif (fiber.flags &amp; MutationMask) &#123;\n  &#x2F;&#x2F; 处理 DOM 突变相关的副作用\n&#125;\n\nif (fiber.flags &amp; PassiveMask) &#123;\n  &#x2F;&#x2F; 处理 useEffect 相关的副作用\n&#125;\n\n在 packages&#x2F;react-reconciler&#x2F;src&#x2F;workTags.ts 文件中\n\n\n\n\n\n\n\n\nworkTags.ts - React Fiber 节点类型定义文件\n作用：\n\n定义所有可能的 Fiber 节点类型\n用于在 Fiber 树中标识不同类型的节点\n帮助 React 在协调过程中正确处理不同类型的组件\n\n&#x2F;**\n * 函数组件标识\n * 用于标识函数式组件创建的 Fiber 节点\n * @example\n * function App() &#123; return &lt;div&gt;Hello&lt;&#x2F;div&gt; &#125;\n * &#x2F;&#x2F; App 组件对应的 Fiber 节点的 tag 值为 FunctionComponent (0)\n *&#x2F;\nexport const FunctionComponent: React.FunctionComponent &#x3D; 0;\n\n&#x2F;**\n * 根节点标识\n * 用于标识应用的根节点（Root）\n * @example\n * ReactDOM.render(&lt;App &#x2F;&gt;, container)\n * &#x2F;&#x2F; container 对应的 Fiber 节点的 tag 值为 HostRoot (3)\n *&#x2F;\nexport const HostRoot: React.HostRoot &#x3D; 3;\n\n&#x2F;**\n * 原生 DOM 元素标识\n * 用于标识普通 HTML 元素的 Fiber 节点\n * @example\n * &lt;div&gt;Hello&lt;&#x2F;div&gt;\n * &#x2F;&#x2F; div 对应的 Fiber 节点的 tag 值为 HostComponent (5)\n *&#x2F;\nexport const HostComponent: React.HostComponent &#x3D; 5;\n\n&#x2F;**\n * 文本节点标识\n * 用于标识文本内容的 Fiber 节点\n * @example\n * &lt;div&gt;Hello World&lt;&#x2F;div&gt;\n * &#x2F;&#x2F; &quot;Hello World&quot; 对应的 Fiber 节点的 tag 值为 HostText (6)\n *&#x2F;\nexport const HostText: React.HostText &#x3D; 6;\n\n&#x2F;**\n * Fragment 标识\n * 用于标识 React.Fragment 的 Fiber 节点\n * @example\n * &lt;React.Fragment&gt;\n *   &lt;div&gt;Item 1&lt;&#x2F;div&gt;\n *   &lt;div&gt;Item 2&lt;&#x2F;div&gt;\n * &lt;&#x2F;React.Fragment&gt;\n * &#x2F;&#x2F; Fragment 对应的 Fiber 节点的 tag 值为 Fragment (7)\n *&#x2F;\nexport const Fragment: React.Fragment &#x3D; 7;\n\n&#x2F;**\n * Context Provider 标识\n * 用于标识 Context.Provider 的 Fiber 节点\n * @example\n * &lt;MyContext.Provider value&#x3D;&#123;value&#125;&gt;\n *   &#123;children&#125;\n * &lt;&#x2F;MyContext.Provider&gt;\n * &#x2F;&#x2F; Provider 对应的 Fiber 节点的 tag 值为 ContextProvider (11)\n *&#x2F;\nexport const ContextProvider: React.ContextProvider &#x3D; 11;\n\n&#x2F;**\n * Suspense 组件标识\n * 用于标识 Suspense 组件的 Fiber 节点\n * @example\n * &lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n *   &lt;SomeComponent &#x2F;&gt;\n * &lt;&#x2F;Suspense&gt;\n * &#x2F;&#x2F; Suspense 对应的 Fiber 节点的 tag 值为 SuspenseComponent (13)\n *&#x2F;\nexport const SuspenseComponent: React.SuspenseComponent &#x3D; 13;\n\n&#x2F;**\n * Offscreen 组件标识\n * 用于标识 Offscreen 组件的 Fiber 节点\n * 通常用于实现一些性能优化相关的功能\n * @example\n * &#x2F;&#x2F; React 内部使用，用于优化渲染性能\n * &#x2F;&#x2F; 对应的 Fiber 节点的 tag 值为 OffscreenComponent (14)\n *&#x2F;\nexport const OffscreenComponent: React.OffscreenComponent &#x3D; 14;\n\n\n\n\n\n\n\n\n\n\n使用示例：\nfunction processFiber(fiber: FiberNode) &#123;\n  switch (fiber.tag) &#123;\n    case FunctionComponent:\n      &#x2F;&#x2F; 处理函数组件\n      updateFunctionComponent(fiber);\n      break;\n    case HostComponent:\n      &#x2F;&#x2F; 处理 DOM 元素\n      updateHostComponent(fiber);\n      break;\n    case HostText:\n      &#x2F;&#x2F; 处理文本节点\n      updateTextContent(fiber);\n      break;\n    &#x2F;&#x2F; ... 处理其他类型\n  &#125;\n&#125;\n\n","slug":"React-Principle","date":"2024-11-23T16:50:47.000Z","categories_index":"React","tags_index":"React","author_index":"X-29"},{"id":"78c733f14091289904e8c5ab0e4b1c53","title":"前端自动化部署","content":"所谓自动化部署就是当代码触发提交的时候自动部署到服务器上\n前置准备工作\n\n服务器：需要有一台可以部署代码的服务器，比如阿里云、腾讯云、GitHub Pages 等\n代码仓库：需要有一个代码仓库，比如 GitHub、GitLab 等\n会 linux\n懂点 Ngnix\n懂点 Git\n\n买一台服务器\n不要贪便宜到不知名小平台买，之前我也有过投机取巧不想买大平台的服务器，因为觉得贵，但是贵有贵的道理，小平台的安装都会报错，可能对于当时的我技术还不够，不太能分析出错误的原因是什么，总之避雷就对了。\n\n到阿里云我买的 99&#x2F;年的，我买的是 Alibaba Cloud Linux3，和 CentOS 没差，用就行\n\n一路先确定直到支付完成就会看到有服务器的 IP 地址，记住这个 IP 地址，后面会用到。然后重置密码，记住密码，不管是脑子还是别的什么地方\n\n\n连接服务器固定模板 ssh root@服务器 IP 地址\n安装 Docker以下命令以此执行，无脑做就能成功\n**一些命令的解释: **\n\ndnf: 这是一个包管理工具，用于安装、更新和删除软件包。它是 yum 的下一代版本，提供更好的性能和依赖管理功能。\n\ninstall: 这是 dnf 的一个子命令，用于安装指定的软件包。\n\n-y: 这个选项表示自动回答“yes”给所有的提示。这意味着在安装过程中，如果有任何确认提示，使用此标志可以自动接受，避免手动干预。\n\ndocker-ce: 这是要安装的软件包的名称。在这里，docker-ce 指的是 Docker 的社区版（Community Edition）。Docker 是一个开源的容器化平台，用于自动化应用程序的部署、扩展和管理。\n\n–nobest: 这个选项告诉 dnf 在安装时不一定选择最好的（最新的）版本来进行安装，而是可以选择可用版本中的较好版本。这在某些情况下可以避免因为依赖问题而无法安装最新版本\n\n\n运行以下命令，安装Docker存储驱动的依赖包dnf install -y device-mapper-persistent-data lvm2\n\n运行以下命令，添加稳定的Docker软件源。dnf config-manager --add-repo&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n\n运行以下命令，查看已添加的Docker软件源。dnf list docker-ce\n\n正确的返回示例如下。docker-ce.x86_64        3:19.03.13-3.el7        docker-ce-stable\n\n运行以下命令安装Dockerdnf install -y docker-ce --nobest\n\n设置开机自启sudo systemctl enable docker\n\n启动dockersudo systemctl start docker\n\n检测是否安装成功 docker -v 查看版本号docker -v\n\n\n安装 docker-compose安sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -olink\n\n对二进制文件应用可执行权限sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n\n检测是否安装成功 docker-compose -v 查看版本号docker-compose -v\n\n安装 Nginx 镜像和 Jenkins 镜像安装 Nginx镜像docker pull nginx\n\n\n\n\n\n\n\n\n\n\n\nwarning: 如果报错内容是 Error response from daemon: Get “https://registry-1.docker.io/v2/“: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 就按下方命令执行\n\n修改下这个json文件，没有就创建vim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n\n写入以下内容&#123;\n  &quot;registry-mirrors&quot;: [\n    &quot;https:&#x2F;&#x2F;2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;,\n    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,\n    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;,\n    &quot;https:&#x2F;&#x2F;your_preferred_mirror&quot;,\n    &quot;https:&#x2F;&#x2F;dockerhub.icu&quot;,\n    &quot;https:&#x2F;&#x2F;docker.registry.cyou&quot;,\n    &quot;https:&#x2F;&#x2F;docker-cf.registry.cyou&quot;,\n    &quot;https:&#x2F;&#x2F;dockercf.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;docker.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;dockertest.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.aliyuncs.com&quot;,\n    &quot;https:&#x2F;&#x2F;dockerproxy.com&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;,\n    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,\n    &quot;https:&#x2F;&#x2F;docker.nju.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.mirrors.sjtug.sjtu.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.iscas.ac.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.rainbond.cc&quot;\n  ]\n&#125;\n\n重新加载配置文件systemctl daemon-reload\n\n重启docker服务systemctl restart docker\n\n检查下docker是否启动正常systemctl status docker\n\n这样再重新 pull Nginx 就正常了\n安装 Jenkins查看镜像listdocker search jenkins\n\n\n\n\n\n\n\n\n\n\nwarning:可能会报错，需要配置下镜像源无所谓，反正是查看列表的命令，往下走接着拉镜像\n拉取Jenkins镜像 本次镜像jenkins/jenkins:ltsdocker pull jenkins&#x2F;jenkins:lts\n\n\n\n\n\n\n\n\nWARNING\n就拉最新版的镜像，lts 版本是最稳定的版本，一般情况下都用这个版本，别整没有用的\n\n安装完成后执行docker images 查看已安装镜像docker images\n\n\n配置目录编写\n\n\n\n\n\n\nWARNING\n!! 注意：这里的 docker 是放在根目录的和&#x2F;root 平级的\n\n\ndocker\ncompose\ndocker-compose.yml &#x2F;&#x2F;docker-compose 配置\n\n\nhtml &#x2F;&#x2F;各环境代码目录(实际项目可能不在同一目录)\ndev &#x2F;&#x2F;dev 环境代码目录\nprod &#x2F;&#x2F;sit 环境代码目录\n\n\njenkins_home &#x2F;&#x2F;Jenkins 工程目录\nnginx &#x2F;&#x2F;nginx 工程目录\nconf\nnginx.conf &#x2F;&#x2F;nginx 配置\n\n\n\n\n\n\n\ndocker-compose.yml 配置文件version: &quot;3&quot;\n\nservices: # 容器\n  docker_jenkins:\n    privileged: true\n    user: root # root权限\n    restart: always # 重启方式\n    image: jenkins&#x2F;jenkins:lts # 使用的镜像\n    container_name: jenkins # 容器名称\n    ports: # 对外暴露的端口定义\n      - 8080:8080\n      - 50000:50000\n    volumes: # 卷挂载路径\n      - &#x2F;docker&#x2F;jenkins_home&#x2F;:&#x2F;var&#x2F;jenkins_home # 挂载到容器内的jenkins_home目录\n      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock\n      - &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n      - &#x2F;usr&#x2F;bin&#x2F;docker:&#x2F;usr&#x2F;bin&#x2F;docker\n\n  docker_nginx_dev: # nginx-dev环境\n    restart: always\n    image: nginx\n    container_name: nginx_dev\n    ports:\n      - 8001:8001\n    volumes:\n      - &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n      - &#x2F;docker&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html\n      - &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx\n\n  docker_nginx_prod: # nginx-prod环境\n    restart: always\n    image: nginx\n    container_name: nginx_prod\n    ports:\n      - 8002:8002\n    volumes:\n      - &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n      - &#x2F;docker&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html\n      - &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx\n\nnginx.conf 配置文件# nginx.conf 例：\nuser  nginx;\nworker_processes  1;\n\nerror_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;\npid        &#x2F;var&#x2F;run&#x2F;nginx.pid;\n\n\nevents &#123;\n    worker_connections  1024;\n&#125;\n\n\nhttp &#123;\n    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;\n    default_type  application&#x2F;octet-stream;\n\n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    gzip  on;\n\n    #dev环境\n    server &#123;\n            #监听的端口\n        listen  8001;\n        server_name  localhost;\n        #设置日志\n#        access_log  logs&#x2F;dev.access.log  main;\n\n        #定位到index.html\n           location &#x2F; &#123;\n               #linux下HTML文件夹,就是你的前端项目文件夹\n               root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;dev&#x2F;dist;\n#               root  &#x2F;home&#x2F;html&#x2F;dev&#x2F;dist;\n               #输入网址（server_name：port）后，默认的访问页面\n               index  index.html;\n               try_files $uri $uri&#x2F; &#x2F;index.html;\n           &#125;\n    &#125;\n\n    #prod环境\n    server &#123;\n            #监听的端口\n        listen  8002;\n        server_name  localhost;\n        #设置日志\n#        access_log  logs&#x2F;prod.access.log  main;\n\n        #定位到index.html\n           location &#x2F; &#123;\n               #linux下HTML文件夹,就是你的前端项目文件夹\n               root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;prod&#x2F;dist;\n#               root  &#x2F;home&#x2F;html&#x2F;dev&#x2F;dist;\n               #输入网址（server_name：port）后，默认的访问页面\n               index  index.html;\n               try_files $uri $uri&#x2F; &#x2F;index.html;\n           &#125;\n    &#125;\n\n\n#    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;\n\n\n&#125;\n\n\n\n\n\n\n\n\nTIP\n在 docker-compose.yml 文件所在目录下执行命令创建容器\n\n启动容器docker-compose up -d\n\n执行docker ps查看容器情况docker ps\n\nJenkins 配置爆坑来了！！！\n阿里云安全组配置\n\n\n\n\n\n\nWARNING\n此时通过 ip:8080 打不开 jenkins 的，因为阿里云那边需要手动加上要访问那个端口，就放行哪个端口\n\n防火墙配置\n\n\n\n\n\n\n\n\n输入命令开启防火墙和 8080 端口\n检查防火墙装填sudo systemctl status firewalld\n\n开启防火墙sudo systemctl start firewalld\n\nsudo systemctl enable firewalld\n\n开启8080端口sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent\n\n重启防火墙sudo firewall-cmd --reload\n\n\n\n\n\n\n\n\nWARNING\n后面每开放一个端口就要到安全组手动配置一下，然后防火墙开启端口，防火墙 reload 一下，三步，每一步都不能少\n\nJenkins 初次密码在容器启动后，可以在浏览器输入服务器 ip:8080 进入 jenkins 管理界面。至此，jenkins 配置完成。\n密码在 docker/jenkins_home/secrets/initialAdminPassword可以通过命令：\ncat &#x2F;docker&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword\n\nNginx 配置在对应目录/docker/html/dev/dist、/docker/html/prod/dist各新建一个 index.html\n经过上述步骤之后，可以通过 ip+对应的 nignx 端口访问到对应的环境的页面。\n\n\nJenkins 进入后的配置下载插件\nlocal（可选。将界面设置为中文）\nGitHub\npublish over SSH (用来连接远程服务器的)\nNodeJs\n\n下载插件后，Jenkins 需要重启地址栏输入ip:端口/restart\n\nPublish Over SSH 配置第一步\n第二步 进去找到 Publish Over SSH\n第三步 点击 Publish Over SSH 下方的 SSH Server,点击新增\n第四步 点击高级\n\n\nNodeJs 配置\n\n添加凭据添加凭据（账号密码）是为了方便后续使用\n\n\n添加 github 账号密码\n创建 job源码管理\n应用保存后，点击立即构建\n\n无论是否成功，都可以在构建记录控制台查看\n\nGithub WebHooks 配置webhooks 配置\n\n创建一个 Personal access tokens\n配置 jenkins进入一个 job\n\n\n\n\n\n\n(图片说明：描述就是取一个名称)\n\nBuild Steps在&#x2F;docker&#x2F;jenkins_home&#x2F;workspace&#x2F;gitlab_web,每次构建对应代码都会同步更新，由于代码没有在 git 上传 node_moudle 文件夹，所以后续需要在服务器重新安装 node_moudle\nExecute NodeJS script这里选的 node 是上面配置的\n点击应用后保存，然后点击立即构建，此次时间会长一点，此时构建会去自动安装对应的 nodejs 安装包到 jenkins 目录并配置好环境变量，注意尽量与本地开发环境的node版本一致，为了保持环境同步，等待构建好后再执行下一步\n\n应用保存并构建成功后，可以进入下一步\nShell 命令\n在 shell 命令这块有的执行 node -v 都报错，此时请检查环境变量是否与服务器的环境变量有差异，执行echo $PATH第一行代码一般要添加#!/bin/bash如果环境变量有问题可能要在第二行执行刷新环境变量命令\nsource ~&#x2F;.bash_profile\nsource &#x2F;etc&#x2F;profile\n\n上面哪个有效果用哪个然后执行对应命令，验证环境可用\n\n#!&#x2F;bin&#x2F;bash\n\nnode -v\nnpm -v\necho $PATH\n\n保存之后回到桌面在此构建一次上述命令如成功执行，进行下一步\n安装node_moule并build打包\n\n\n\n\n\n\nWARNING\n先自己本地build一下，看看哪里有问题\n\n修改job的shell配置\nnode -v\nnpm -v\n\nnpm i \nnpm run build:dev\n\n\n此时服务器代码出现dist文件夹目录在&#x2F;docker&#x2F;jenkins_home&#x2F;workspace&#x2F;github_test_web\n代码自动部署到对应环境项目目录同一服务器可以用cp命令，可以参考linux cp命令\n此处为另一种方式：压缩包ssh传输，因为使用cp命令到&#x2F;docker&#x2F;html&#x2F;dev目录报错了，遂采用第二种方式\n#!&#x2F;bin&#x2F;bash\n\nnode -v \nnpm -v \nnpm i\nnpm run build:dev\nrm -rf dist.tar\ntar -zcvf dist.tar .&#x2F;dist\n\n构建成功后多了个dist.tar文件\n连接SSH服务器系统配置已经设置过ssh相关配置再操作下面，如未设置，请往上翻 Publish Over SSH\n\n字段说明：Source files：准备发送的文件，该文件是相对于这个项目的workspace目录。例如要发送/docker/jenkins_home/workspace/gitlab_web/dist.tar到目标目录，则设置Source files为dist.tarRemove prefix：目标文件前缀添加，例如要操作src下面的某个文件，就设置成src,本案例是跟目录，无需设置Remote directory：目标目录，本案例要复制到dev环境下的dist文件，/docker/html/devExec command：最后执行的命令，可在这里进行解压，删除，复制等操作\n执行构建后，对应目录已经有了一个dist.tar文件\n\n这样肯定是不行的，还需要删除原有dist文件夹，解压dist.tar,再删除dist.tar,最终命令如下修改刚才配置的ssh最下方有个Exec command\ncd &#x2F;docker&#x2F;html&#x2F;dev\nrm  -rf   dist&#x2F;\ntar zxvf dist.tar\nrm dist.tar\n至此，shell命令执行结束，目前的效果是:gitlab 项目dev分支git提交后，触发jenkins自动构建，自动构建会先在服务器从gitlab的dev分支拉取最新代码，执行build打包后生成dist.tar文件，然后通过ssh将对应dist.tar发送到对应dev环境的项目目录解压dist.tar并更新对应文件，实现自动更新dev环境\n","slug":"automated-deployment","date":"2024-10-20T04:18:31.000Z","categories_index":"Academic","tags_index":"docker,nginx,jenkins,linux","author_index":"X-29"},{"id":"9668cd611991e16937a9fdd60d6dd807","title":"web多环境配置","content":"web 端多环境配置多环境无非就是请求的接口不一样所以本文将介绍如何在 web 端配置不同的请求接口的环境\n1. 准备工作npm init vite@latest\n\n完成之后长这样\n2.配置一些变量2.1 在根目录下新增 config 文件夹config\n├── plugins.ts\n├── constant.ts\n\nconstant 用于配置一些常量&#x2F;&#x2F; 基本路径\nexport const VITE_BASE_PATH &#x3D; &quot;&#x2F;&quot;;\n&#x2F;&#x2F; 应用名称\nexport const VITE_APP_TITLE &#x3D; &quot;xxx&quot;;\n&#x2F;&#x2F; 开启包依赖分析 可视化\nexport const VITE_APP_ANALYZE &#x3D; false;\n&#x2F;&#x2F; 开启Gzip压缩\nexport const VITE_APP_COMPRESS_GZIP &#x3D; false;\n&#x2F;&#x2F; 开启Gzip压缩，删除原文件\nexport const VITE_APP_COMPRESS_GZIP_DELETE_FILE &#x3D; false;\n&#x2F;&#x2F; 去除 console\nexport const VITE_DROP_CONSOLE &#x3D; true;\n&#x2F;&#x2F; 开启兼容\nexport const VITE_APP_LEGACY &#x3D; true;\n\nplugins 用于后续 vite 插件的配置npm install vite-plugin-compression vite-plugin-remove-console --save-dev\n\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\nimport viteCompression from &quot;vite-plugin-compression&quot;;\n\nimport removeConsole from &quot;vite-plugin-remove-console&quot;;\nimport &#123;\n  VITE_APP_COMPRESS_GZIP,\n  VITE_APP_COMPRESS_GZIP_DELETE_FILE,\n&#125; from &quot;.&#x2F;constant&quot;;\n\nexport const createVitePlugins &#x3D; (isBuild: boolean) &#x3D;&gt; &#123;\n  const vitePlugins &#x3D; [react(), removeConsole()];\n\n  if (isBuild) &#123;\n    if (VITE_APP_COMPRESS_GZIP) &#123;\n      vitePlugins.push(\n        viteCompression(&#123;\n          disable: true,\n          deleteOriginFile: VITE_APP_COMPRESS_GZIP_DELETE_FILE,\n        &#125;)\n      );\n    &#125;\n  &#125;\n\n  return vitePlugins;\n&#125;;\n\n3.查看 vite.config.ts 文件import &#123; defineConfig &#125; from &quot;vite&quot;;\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\n\nexport default defineConfig(&#123;\n  plugins: [react()],\n&#125;);\n\n修改 vite.config.ts 文件\n\n\n\n\n\n\n\n\n如果提示：找不到模块“path”或其相应的类型声明，智能导入一下导入类型就行，这样就报错了\nimport &#123; ConfigEnv, loadEnv, UserConfig &#125; from &quot;vite&quot;;\nimport &#123; createVitePlugins &#125; from &quot;.&#x2F;config&#x2F;plugins&quot;;\nimport &#123; resolve &#125; from &quot;path&quot;;\nimport &#123; VITE_DROP_CONSOLE &#125; from &quot;.&#x2F;config&#x2F;constant&quot;;\n\nexport default (&#123; command, mode &#125;: ConfigEnv): UserConfig &#x3D;&gt; &#123;\n  const isBuild &#x3D; command.includes(&quot;build&quot;);\n  const root &#x3D; process.cwd();\n  const env &#x3D; loadEnv(mode, root);\n  const &#123; VITE_PORT &#125; &#x3D; env;\n\n  return &#123;\n    root: process.cwd(),\n    publicDir: &quot;public&quot;,\n    base: &quot;.&#x2F;&quot;,\n    plugins: createVitePlugins(isBuild),\n    css: &#123;\n      modules: &#123;\n        generateScopedName: &quot;[name]__[local]___[hash:base64:5]&quot;,\n        hashPrefix: &quot;prefix&quot;,\n      &#125;,\n      postcss: &#123;\n        plugins: [],\n      &#125;,\n      preprocessorOptions: &#123;\n        less: &#123;\n          javascriptEnabled: true,\n        &#125;,\n      &#125;,\n    &#125;,\n    resolve: &#123;\n      alias: &#123;\n        &quot;@&quot;: &#96;$&#123;resolve(__dirname, &quot;src&quot;)&#125;&#96;,\n      &#125;,\n      mainFields: [&quot;module&quot;, &quot;jsnext:main&quot;, &quot;jsnext&quot;],\n    &#125;,\n    clearScreen: true,\n    logLevel: &quot;info&quot;,\n    server: &#123;\n      open: true,\n      host: &quot;0.0.0.0&quot;,\n      port: parseInt(VITE_PORT),\n    &#125;,\n    build: &#123;\n      target: &quot;modules&quot;,\n      outDir: &quot;build&quot;,\n      assetsDir: &quot;assets&quot;,\n      cssCodeSplit: true,\n      assetsInlineLimit: 4096,\n      sourcemap: !isBuild,\n      chunkSizeWarningLimit: 500,\n      emptyOutDir: true,\n      manifest: false,\n      terserOptions: &#123;\n        compress: &#123;\n          keep_infinity: true,\n          drop_console: VITE_DROP_CONSOLE,\n        &#125;,\n      &#125;,\n    &#125;,\n    define: &#123;\n      _GLOBAL_VARS_: JSON.stringify(&#123;\n        ...env,\n        MODE: mode,\n        BUILD_TIME: new Date().toLocaleString(),\n      &#125;),\n    &#125;,\n  &#125;;\n&#125;;\n\n4.修改 package.json 文件原先的 scripts 部分\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;vite&quot;,\n  &quot;build&quot;: &quot;tsc -b &amp;&amp; vite build&quot;,\n  &quot;lint&quot;: &quot;eslint .&quot;,\n  &quot;preview&quot;: &quot;vite preview&quot;\n&#125;,\n\n修改后的 scripts 部分\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;vite --mode dev&quot;,\n  &quot;prod&quot;: &quot;vite --mode prod&quot;,\n  &quot;build:dev&quot;: &quot;tsc -b &amp;&amp; vite build --mode dev&quot;,\n  &quot;build:prod&quot;: &quot;tsc -b &amp;&amp; vite build --mode prod&quot;,\n  &quot;lint&quot;: &quot;eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0&quot;,\n  &quot;preview&quot;: &quot;vite preview&quot;\n&#125;,\n\n5.根目录下新增 .env 文件VITE_PORT &#x3D; 7200\nVITE_HOST &#x3D; http:&#x2F;&#x2F;dev.example.com &#x2F;&#x2F; 修改为你的域名,这里就是测试环境的接口前缀\n\n6.根目录下新增 .env.prod 文件VITE_PORT &#x3D; 7200\nVITE_HOST &#x3D; http:&#x2F;&#x2F;prod.example.com &#x2F;&#x2F; 修改为你的域名,这里就是生产环境的接口前缀\n\n7.新增 types 目录，里面新增 global.d.ts 文件declare const _GLOBAL_VARS_: &#123;\n  VITE_HOST: string;\n  MODE: string;\n  &#x2F;&#x2F; 如果还有其他变量，可以在这里继续声明\n&#125;;\n\n8.修改 tsconfig.node.json 文件在 include 中加入\n&quot;compilerOptions&quot;: &#123;\n  &quot;jsx&quot;: &quot;react-jsx&quot;,\n&#125;,\n&quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;config&#x2F;*&quot;,&quot;vite.config.ts&quot;,&quot;.&#x2F;types&#x2F;global.d.ts&quot;],\n\n完整的 tsconfig.node.json 文件如下：\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;jsx&quot;: &quot;react-jsx&quot;, &#x2F;&#x2F; 为了避免识别不出jsx和避免提示需要导入react的提示\n    &quot;target&quot;: &quot;ES2022&quot;,\n    &quot;lib&quot;: [&quot;ES2023&quot;],\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;skipLibCheck&quot;: true,\n\n    &#x2F;* Bundler mode *&#x2F;\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;allowImportingTsExtensions&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;moduleDetection&quot;: &quot;force&quot;,\n    &quot;noEmit&quot;: true,\n\n    &#x2F;* Linting *&#x2F;\n    &quot;strict&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noFallthroughCasesInSwitch&quot;: true\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;, &quot;config&#x2F;*&quot;, &quot;vite.config.ts&quot;, &quot;.&#x2F;types&#x2F;global.d.ts&quot;]\n&#125;\n\n9.在 src 目录下创建 constant.ts 文件export const HOST &#x3D; _GLOBAL_VARS_.VITE_HOST;\nexport const MODE &#x3D; _GLOBAL_VARS_.MODE;\n\n查看效果npm run dev\n\n\nnpm run prod\n\n\n","slug":"multiple-environments","date":"2024-10-20T02:15:18.000Z","categories_index":"Skill","tags_index":"React,web,Vite","author_index":"X-29"}]