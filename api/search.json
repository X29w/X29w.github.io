[{"id":"6f35d21607cc4ac40e0305fd85e2df31","title":"React-Principle","content":"React-Principle此文章旨在于剖析 React 的一些基本原理，帮助读者更好地理解 React 的工作原理。并写出属于自己的 React 代码。\n前置任务搭建目录以及配置一些工具First of all！\n├── packages| ├── react| | ├── src| | ├── index.ts| | └── package.json| ├── react-reconciler| | └── package.json| └── shared| ├── package.json| ├── ReactSymbols.ts| └── ReactTypes.ts├── scripts| └── rollup| ├── react.config.js| └── utils.js├── .gitignore├── .prettier.json├── eslint.config.js├── package-lock.json├── package.json├── README.md└── tsconfig.json\n安装依赖根目录的package.json文件在根目录的package.json文件中，我们需要安装一些依赖并配置好 scripts 命令：\n&#123;\n  &quot;name&quot;: &quot;react&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;lint&quot;: &quot;eslint .&#x2F;packages&quot;,\n    &quot;build:dev&quot;: &quot;rimraf dist &amp;&amp; rollup --bundleConfigAsCjs --config scripts&#x2F;rollup&#x2F;react.config.js&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@eslint&#x2F;js&quot;: &quot;^9.15.0&quot;,\n    &quot;@rollup&#x2F;plugin-commonjs&quot;: &quot;^28.0.1&quot;,\n    &quot;@types&#x2F;node&quot;: &quot;^22.9.3&quot;,\n    &quot;@types&#x2F;rollup-plugin-generate-package-json&quot;: &quot;^3.2.9&quot;,\n    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^8.15.0&quot;,\n    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^8.15.0&quot;,\n    &quot;eslint&quot;: &quot;^9.15.0&quot;,\n    &quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,\n    &quot;eslint-plugin-prettier&quot;: &quot;^5.2.1&quot;,\n    &quot;prettier&quot;: &quot;^3.3.3&quot;,\n    &quot;rimraf&quot;: &quot;^6.0.1&quot;,\n    &quot;rollup&quot;: &quot;^4.27.3&quot;,\n    &quot;rollup-plugin-generate-package-json&quot;: &quot;^3.2.0&quot;,\n    &quot;rollup-plugin-typescript2&quot;: &quot;^0.36.0&quot;,\n    &quot;typescript&quot;: &quot;^5.6.3&quot;\n  &#125;\n&#125;\n\ntsconfig.json在根目录下创建tsconfig.json文件，并配置好编译选项：\n&#123;\n  &quot;compileOnSave&quot;: true,\n  &quot;compilerOptions&quot;: &#123;\n    &quot;target&quot;: &quot;ESNext&quot;,\n    &quot;useDefineForClassFields&quot;: true,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;],\n    &quot;moduleResolution&quot;: &quot;Node&quot;,\n    &quot;strict&quot;: true,\n    &quot;sourceMap&quot;: true,\n    &quot;resolveJsonModule&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;noEmit&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noImplicitReturns&quot;: false,\n    &quot;skipLibCheck&quot;: true,\n    &quot;baseUrl&quot;: &quot;.&#x2F;packages&quot;\n  &#125;\n&#125;\n\neslint.config.jsimport eslint from &quot;@eslint&#x2F;js&quot;;\nimport tseslint from &quot;@typescript-eslint&#x2F;eslint-plugin&quot;;\nimport tsparser from &quot;@typescript-eslint&#x2F;parser&quot;;\nimport prettier from &quot;eslint-plugin-prettier&quot;;\nimport eslintConfigPrettier from &quot;eslint-config-prettier&quot;;\n\nexport default [\n  &#x2F;&#x2F; 基础 ESLint 配置\n  eslint.configs.recommended,\n\n  &#x2F;&#x2F; Prettier 配置\n  eslintConfigPrettier,\n\n  &#123;\n    files: [&quot;**&#x2F;*.ts&quot;, &quot;**&#x2F;*.tsx&quot;],\n    languageOptions: &#123;\n      parser: tsparser,\n      parserOptions: &#123;\n        ecmaVersion: &quot;latest&quot;,\n        sourceType: &quot;module&quot;,\n      &#125;,\n    &#125;,\n    plugins: &#123;\n      &quot;@typescript-eslint&quot;: tseslint,\n      prettier: prettier,\n    &#125;,\n    rules: &#123;\n      &quot;prettier&#x2F;prettier&quot;: &quot;error&quot;,\n      &quot;no-case-declarations&quot;: &quot;off&quot;,\n      &quot;no-constant-condition&quot;: &quot;off&quot;,\n      &quot;@typescript-eslint&#x2F;ban-ts-comment&quot;: &quot;off&quot;,\n      &quot;@typescript-eslint&#x2F;no-var-requires&quot;: &quot;off&quot;,\n      &quot;react&#x2F;react-in-jsx-scope&quot;: &quot;off&quot;,\n      &quot;prettier&#x2F;prettier&quot;: [\n        &quot;error&quot;,\n        &#123;\n          endOfLine: &quot;auto&quot;,\n        &#125;,\n      ],\n    &#125;,\n  &#125;,\n];\n\n.prettier.json&#123;\n  &quot;printWidth&quot;: 80,\n  &quot;tabWidth&quot;: 2,\n  &quot;useTabs&quot;: true,\n  &quot;singleQuote&quot;: true,\n  &quot;semi&quot;: true,\n  &quot;trailingComma&quot;: &quot;none&quot;,\n  &quot;bracketSpacing&quot;: true\n&#125;\n\n打包脚本rollup.config.js在scripts目录下创建rollup.config.js文件，并配置打包选项：::: warning注意：rollup.config.js文件需要使用commonjs模块规范，因为rollup默认使用esm模块规范，而node环境不支持esm模块规范。并且一定要是js文件，不能是ts文件。:::\nimport &#123; getBaseRollupPlugins, getPackageJSON, resolvePkgPath &#125; from &quot;.&#x2F;utils&quot;;\n\nimport generatePackageJson from &quot;rollup-plugin-generate-package-json&quot;;\n\n&#x2F;&#x2F; 获取package.json下面的name字段\nconst &#123; name, module &#125; &#x3D; getPackageJSON(&quot;react&quot;, false); &#x2F;&#x2F; react\n&#x2F;&#x2F; react包的路径\nconst pkgPath &#x3D; resolvePkgPath(name, false);\n&#x2F;&#x2F;react 产物路劲\nconst pkgDistPath &#x3D; resolvePkgPath(name, true);\nexport default [\n  &#x2F;&#x2F; 对应react包\n  &#123;\n    input: &#96;$&#123;pkgPath&#125;&#x2F;$&#123;module&#125;&#96;,\n    output: &#123;\n      file: &#96;$&#123;pkgDistPath&#125;&#x2F;index.js&#96;,\n      name: &quot;react&quot;,\n      format: &quot;umd&quot;,\n    &#125;,\n    plugins: [\n      ...getBaseRollupPlugins(),\n      generatePackageJson(&#123;\n        inputFolder: pkgPath,\n        outputFolder: pkgDistPath,\n        baseContents: (&#123; name, description, version &#125;) &#x3D;&gt; (&#123;\n          name,\n          description,\n          version,\n          main: &quot;index.js&quot;,\n        &#125;),\n      &#125;),\n    ],\n  &#125;,\n  &#x2F;&#x2F; jsx-runtime包\n  &#123;\n    input: &#96;$&#123;pkgPath&#125;&#x2F;src&#x2F;jsx.ts&#96;,\n    output: [\n      &#x2F;&#x2F; jsx-runtime\n      &#123;\n        file: &#96;$&#123;pkgDistPath&#125;&#x2F;jsx-runtime.js&#96;,\n        name: &quot;jsx-runtime.js&quot;,\n        format: &quot;umd&quot;,\n      &#125;,\n      &#123;\n        file: &#96;$&#123;pkgDistPath&#125;&#x2F;jsx-dev-runtime.js&#96;,\n        name: &quot;jsx-dev-runtime.js&quot;,\n        format: &quot;umd&quot;,\n      &#125;,\n    ],\n    plugins: getBaseRollupPlugins(),\n  &#125;,\n];\n\nutils.js在scripts目录下创建utils.js文件，并配置一些工具函数：\nimport path from &quot;path&quot;;\nimport fs from &quot;fs&quot;;\nimport ts from &quot;rollup-plugin-typescript2&quot;;\nimport cjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;\n\n&#x2F;&#x2F; 包路径\nconst pkgPath &#x3D; path.resolve(__dirname, &quot;..&#x2F;..&#x2F;packages&quot;);\n&#x2F;&#x2F; 打包产物路径\nconst distPath &#x3D; path.resolve(__dirname, &quot;..&#x2F;..&#x2F;dist&#x2F;node_modules&quot;);\n\n&#x2F;**\n * @name 获取包路径或者是打包产物路径\n * @param pkgName\n * @param isDist 是否是打包\n *&#x2F;\nexport const resolvePkgPath &#x3D; (pkgName, isDist) &#x3D;&gt; &#123;\n  return isDist ? &#96;$&#123;distPath&#125;&#x2F;$&#123;pkgName&#125;&#96; : &#96;$&#123;pkgPath&#125;&#x2F;$&#123;pkgName&#125;&#96;;\n&#125;;\n\n&#x2F;**\n * @name 解析包对应的package.json文件\n * @param pkgName\n *&#x2F;\nexport const getPackageJSON &#x3D; (pkgName, isDist) &#x3D;&gt; &#123;\n  &#x2F;&#x2F;1. 包路径 + Package.json\n  const path &#x3D; &#96;$&#123;resolvePkgPath(pkgName, isDist)&#125;&#x2F;package.json&#96;;\n  const str &#x3D; fs.readFileSync(path, &#123; encoding: &quot;utf-8&quot; &#125;);\n  return JSON.parse(str);\n&#125;;\n\nexport const getBaseRollupPlugins &#x3D; (&#123; typeScriptConfig &#x3D; &#123;&#125; &#125; &#x3D; &#123;&#125;) &#x3D;&gt; [\n  cjs(),\n  ts(typeScriptConfig),\n];\n\npackage&#x2F;react该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;react&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;module&quot;: &quot;index.ts&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;shared&quot;: &quot;workspace:*&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;react公共方法&quot;\n&#125;\n\n其中 package&#x2F;index.ts 和 package&#x2F;src&#x2F;jsx.ts 文件先随便写点什么 ts 代码，为了npm run build:dev命令可以正常运行。package&#x2F;src&#x2F;jsx.ts 的目录和文件名在 rollup.config.js 中配置一一对应的\npackage&#x2F;shared该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;shared&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;所有公共方法以及类型定义&quot;\n&#125;\n\npackage&#x2F;react-reconciler该目录下的package.json文件\n&#123;\n  &quot;name&quot;: &quot;react-reconciler&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;description&quot;: &quot;&quot;\n&#125;\n\n至此，我们已经完成了项目的目录结构以及一些依赖的安装。在根目录下，我们可以运行npm run build:dev命令进行项目的打包。npm run lint命令可以对项目的代码进行 eslint 检查。\njsx基本介绍React 主要是将页面的结构通过 jsx 进行描述，在调和后，每一个 React element 对象的子节点都会形成一个对应的 fiberNode\n本节内容主要是实现 jsx 的生成。在 React 的源码中，jsx 的代码逻辑存在 packages 下面的 react 包中。为了兼容 React 的旧版本，我们主要是实现最后导出三个文件。\nindex.js: import React from &#39;react&#39; 这样使用jsx-runtime.js: 新版通过 babel 导入jsx-dev-runtime.js: 开发环境的包\n为了开发者方便，React 提供一种类似于 html 的方式去书写代码，然后 React 通过 babel 去进行转义。在 React 的新版本中，我们不再需要手动去引入 React, plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。\n&lt;div className&#x3D;&quot;x&quot;&gt;\n  123\n  &lt;span&gt;yx&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n\n新版Automaticimport &#123; jsx as _jsx &#125; from &quot;react&#x2F;jsx-runtime&quot;;\nimport &#123; jsxs as _jsxs &#125; from &quot;react&#x2F;jsx-runtime&quot;;\n&#x2F;*#__PURE__*&#x2F; _jsxs(&quot;div&quot;, &#123;\n  className: &quot;x&quot;,\n  children: [\n    &quot;123&quot;,\n    &#x2F;*#__PURE__*&#x2F; _jsx(&quot;span&quot;, &#123;\n      children: &quot;yx&quot;,\n    &#125;),\n  ],\n&#125;);\n\n旧版Classic&#x2F;*#__PURE__*&#x2F; React.createElement(\n  &quot;div&quot;,\n  &#123;\n    className: &quot;x&quot;,\n  &#125;,\n  &quot;123&quot;,\n  &#x2F;*#__PURE__*&#x2F; React.createElement(&quot;span&quot;, null, &quot;yx&quot;)\n);\n\n\n\n\n\n\n\n\n\n\n主要是分为三部分：1. 对应的 tag 字段， 2. 属性和 children， 3. key 等一些特殊字段。\n实现 JSX声明类型在 packages/shared/ReactTypes.ts 文件中，我们声明了 JSX 相关的类型。\n&#x2F;** 在这里集中定义React的类型 *&#x2F;\n\n&#x2F;** 定义 React 的 Type 类型 *&#x2F;\nexport type Type &#x3D; any;\n\n&#x2F;** 定义 React 的 Key 类型 *&#x2F;\nexport type Key &#x3D; string | null;\n\n&#x2F;** 定义 React 的 Ref 类型 *&#x2F;\nexport type Ref&lt;T &#x3D; any&gt; &#x3D;\n  | &#123; current: T | null &#125;\n  | ((instance: T | null) &#x3D;&gt; void)\n  | null;\n\n&#x2F;** 定义 React 的 Props 类型 *&#x2F;\nexport type Props &#x3D; &#123;\n  [key: string]: any;\n  children?: any;\n&#125;;\n\n&#x2F;** 定义 React 的 ElementType 类型 *&#x2F;\nexport type ElementType &#x3D; string | ((props: any) &#x3D;&gt; ReactElementType | null);\n\n&#x2F;** 定义 React 的 ReactElement 类型 *&#x2F;\nexport interface ReactElementType &#123;\n  $$typeof: symbol | number;\n  type: ElementType;\n  key: Key;\n  ref: Ref;\n  props: Props;\n  __mark: string;\n&#125;\n\n在 packages/shared/ReactSymbols.ts 文件中，我们声明了 JSX 相关的 symbol。\n&#x2F;**\n * 判断当前环境是否支持 Symbol 及其 for 方法\n * 1. typeof Symbol &#x3D;&#x3D;&#x3D; &#39;function&#39; 检查 Symbol 是否可用且是函数类型\n * 2. Symbol.for 检查是否支持全局 Symbol 注册表功能\n * 3. 在较老的浏览器中可能不支持 Symbol，此时返回 false\n *&#x2F;\nconst supportSymbol &#x3D; typeof Symbol &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; Symbol.for;\n\n&#x2F;**\n * 1. Symbol.for() 是什么：\n *   - 这是 JavaScript 的全局 Symbol 注册表功能\n *   - Symbol.for(&#39;react.element&#39;) 会创建一个全局唯一的 Symbol\n *   - 如果已经存在同名的 Symbol，则返回已存在的那个\n *   - 这确保了在不同的模块中使用相同的字符串创建的 Symbol 是完全相同的\n * 2.为什么需要降级方案 0xeac7：\n *   - 不是所有 JavaScript 环境都支持 Symbol（比如老版本浏览器）\n *   - 0xeac7 是一个十六进制数字，作为降级后的标识符\n *   - 这个数字是 React 团队选择的一个特定值，用来标识 React 元素\n * 3. 这个值的用途：\n *   - 用来标识一个对象是否是合法的 React 元素\n *   - 在 ReactElement 接口中，我们看到有 $$typeof 属性\n *   - $$typeof 就会被赋值为 REACT_ELEMENT_TYPE\n *   - React 内部会检查这个值来确保元素的合法性 *&#x2F;\nexport const REACT_ELEMENT_TYPE &#x3D; supportSymbol\n  ? Symbol.for(&quot;react.element&quot;)\n  : 0xeac7;\n\n实现 JSX在 packages/react/src/jsx.ts 文件中，我们实现 JSX 的逻辑。\nimport &#123; REACT_ELEMENT_TYPE &#125; from &quot;shared&#x2F;ReactSymbols&quot;;\nimport &#123;\n  ElementType,\n  Key,\n  Props,\n  ReactElementType,\n  Ref,\n  Type,\n&#125; from &quot;shared&#x2F;ReactTypes&quot;;\n\n&#x2F;**\n * 创建 React 元素的核心函数\n * @param type 元素类型 - 可以是字符串(原生 DOM 元素)或函数(组件)\n * @param key 用于标识元素的唯一键值，帮助 React 进行高效的 DOM diff\n * @param ref 引用对象，用于访问 DOM 节点或组件实例\n * @param props 元素的属性对象，包含所有传入的属性和子元素\n * @returns 返回一个 React 元素对象\n *&#x2F;\nconst ReactElement &#x3D; (\n  type: Type,\n  key: Key,\n  ref: Ref,\n  props: Props\n): ReactElementType &#x3D;&gt; (&#123;\n  &#x2F;&#x2F; 标识这是一个 React 元素的内部类型标记\n  $$typeof: REACT_ELEMENT_TYPE,\n  &#x2F;&#x2F; 元素类型（div, p, 或自定义组件等）\n  type,\n  &#x2F;&#x2F; 用于优化更新的 key 值\n  key,\n  &#x2F;&#x2F; DOM 或组件实例的引用\n  ref,\n  &#x2F;&#x2F; 元素的所有属性\n  props,\n  &#x2F;&#x2F; 自定义标记，用于标识这是我们的 React 实现\n  __mark: &quot;x-react&quot;,\n&#125;);\n\n&#x2F;**\n * 从配置对象中提取并处理 key、ref 和其他 props\n * @param &#123;Config&#125; Jsx.JsxConfig - React 元素的配置对象\n * @returns &#123;[Key, Ref, Props]&#125; 返回一个元组，包含处理后的 key、ref 和 props\n *\n * @description\n * 1. 通过解构获取 key 和 ref，设置默认值为 null\n * 2. 将 key 转换为字符串（如果存在）\n * 3. 使用 reduce 处理剩余的 props，确保只包含对象自身的属性\n * 4. 返回处理后的 [key, ref, props] 元组\n *&#x2F;\nconst extractPropsFromConfig &#x3D; (config: Jsx.JsxConfig): [Key, Ref, Props] &#x3D;&gt; &#123;\n  const &#123; key &#x3D; null, ref &#x3D; null, ...props &#125; &#x3D; config;\n  return [\n    key !&#x3D; null ? String(key) : null,\n    ref,\n    Object.keys(props).reduce((acc, prop) &#x3D;&gt; &#123;\n      if (&#123;&#125;.hasOwnProperty.call(config, prop)) &#123;\n        acc[prop] &#x3D; props[prop];\n      &#125;\n      return acc;\n    &#125;, &#123;&#125; as Props),\n  ];\n&#125;;\n\n&#x2F;**\n * 处理并合并 children 到 props 中\n * @param &#123;Props&#125; props - 原始的 props 对象\n * @param &#123;any[]&#125; children - 子元素数组\n * @returns &#123;Props&#125; 返回合并了 children 的新 props 对象\n *\n * @description\n * 1. 如果没有 children，直接返回原始 props\n * 2. 如果只有一个 child，直接使用该 child\n * 3. 如果有多个 children，保持数组形式\n * 4. 使用展开运算符创建新的 props 对象，确保不修改原始对象\n *&#x2F;\nconst processChildren &#x3D; (props: Props, children: any[]): Props &#x3D;&gt; &#123;\n  if (children.length &#x3D;&#x3D;&#x3D; 0) return props;\n\n  return &#123;\n    ...props,\n    children: children.length &#x3D;&#x3D;&#x3D; 1 ? children[0] : children,\n  &#125;;\n&#125;;\n\n&#x2F;**\n * JSX 转换函数 - 将 JSX 语法转换为 React 元素\n * @param &#123;ElementType&#125; type - 元素类型（可以是字符串或组件函数）\n * @param &#123;Config&#125; Jsx.JsxConfig - 元素的配置对象，包含 props、key、ref 等\n * @param &#123;...any&#125; children - 子元素列表\n * @returns &#123;ReactElementType&#125; 返回创建的 React 元素\n *\n * @description\n * 1. 首先从配置中提取必要的属性\n * 2. 处理并添加 children\n * 3. 使用这些处理后的值创建 React 元素\n *\n * @description\n * * 完整的处理流程：\n * 1. jsx(&#39;div&#39;, &#123; className: &#39;container&#39; &#125;, child1, child2) 被调用\n * 2. extractPropsFromConfig 处理配置对象：\n *    - 提取 key 和 ref（如果有）\n *    - 处理其余属性（如 className, onClick 等）\n * 3. processChildren 处理子元素：\n *    - 将所有子元素规范化处理\n *    - 添加到 props.children 中\n * 4. ReactElement 创建最终的 React 元素对象\n * 5. 返回的元素对象将被 React 用于后续的渲染流程\n *&#x2F;\nexport const jsx &#x3D; (\n  type: ElementType,\n  config: Jsx.JsxConfig,\n  ...children: any\n) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 第一步：提取和处理配置\n  const [key, ref, props] &#x3D; extractPropsFromConfig(config);\n  &#x2F;&#x2F; 第二步：处理子元素\n  const propsWithChildren &#x3D; processChildren(props, children);\n\n  &#x2F;&#x2F; 第三步：创建 React 元素\n  return ReactElement(type, key, ref, propsWithChildren);\n\n  &#x2F;* 返回的对象形如：\n   &#123;\n     $$typeof: Symbol(react.element),\n     type: &#39;div&#39;,\n     props: &#123;\n       className: &#39;container&#39;,\n       children: &#123;\n         $$typeof: Symbol(react.element),\n         type: &#39;span&#39;,\n         props: &#123; children: &#39;Hello&#39; &#125;\n       &#125;\n     &#125;\n   &#125; *&#x2F;\n&#125;;\n\n&#x2F;**\n * 开发环境使用的 JSX 转换函数\n * @param &#123;ElementType&#125; type - 元素类型\n * @param &#123;Config&#125; Jsx.JsxConfig - 元素配置对象\n * @returns &#123;ReactElementType&#125; 返回创建的 React 元素\n *\n * @description\n * 1. 开发环境版本，不处理 children\n * 2. 用于开发工具和调试\n * 3. 保持与生产版本相同的基本结构，但可能包含额外的开发时检查\n *\n * @description 开发环境的 JSX 转换函数\n * 与生产版本的主要区别：\n * 1. 可以进行额外的类型检查\n * 2. 可以提供更好的错误信息\n * 3. 可以进行开发时的警告提示\n * 4. 可以添加开发工具所需的调试信息\n *&#x2F;\nexport const jsxDev &#x3D; (type: ElementType, config: Jsx.JsxConfig) &#x3D;&gt; &#123;\n  const [key, ref, props] &#x3D; extractPropsFromConfig(config);\n  return ReactElement(type, key, ref, props);\n&#125;;\n\n整体 jsx 函数的调用流程\n\nJSX 代码：\n\nfunction App() &#123;\n  return (\n    &lt;div className&#x3D;&quot;container&quot;&gt;\n      &lt;span&gt;Hello&lt;&#x2F;span&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n\nBabel 转义后的代码：\n\nfunction App() &#123;\n  return jsx(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;, jsx(&quot;span&quot;, null, &quot;Hello&quot;));\n&#125;\n\njsx 函数的作用就是接收 Babel 转换后的参数，并创建出 React 元素（虚拟 DOM 节点）\n\n最终生成的 React 元素结构：\n\n&#123;\n$$typeof: Symbol(react.element),\ntype: &#39;div&#39;,\nkey: null,\nref: null,\nprops: &#123;\n    className: &#39;container&#39;,\n    children: [\n      &#123;\n        $$typeof: Symbol(react.element),\n        type: &#39;span&#39;,\n        props: &#123; children: &#39;Hello&#39; &#125;,\n        &#x2F;&#x2F; ...\n      &#125;\n    ]\n&#125;\n&#125;\n\n\n所以整个流程是：\n\n\n开发者写 JSX 代码\nBabel 在编译时将 JSX 语法转换为 jsx() 函数调用\n运行时，jsx() 函数被调用，创建 React 元素\nReact 使用这些元素来渲染实际的 DOM 5.简单来说：Babel 的工作是：转换语法（ → jsx(‘div’)）,jsx 函数的工作是：创建虚拟 DOM 节点（jsx(‘div’) → { type: ‘div’, props: {…} }）,这就是为什么在 React 17 之后的版本中，我们不需要手动引入 React（import React from ‘react’），因为 Babel 会自动帮我们引入 jsx 函数。\n\n\n那么为什么还存在 jsxDev 函数呢？\n\njsxDev 函数的作用是为了开发环境的 JSX 转换，它的作用和 jsx 函数一样，只是它不处理 children 子元素，所以它的返回值和生产环境的 jsx 函数返回值是一样的。\n区别的具体体现：\n\nBabel 的转换会根据环境不同选择不同的函数：\n\n&#x2F;&#x2F; 开发环境下，Babel 会转换成：\njsxDev(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;);\n\n&#x2F;&#x2F; 生产环境下，Babel 会转换成：\njsx(&quot;div&quot;, &#123; className: &quot;container&quot; &#125;);\n\n\n实际应用场景：\n\nfunction App() &#123;\n  &#x2F;&#x2F; 开发环境下，如果你这样写：\n  return &lt;div&gt;&#123;undefined.toString()&#125;&lt;&#x2F;div&gt;;\n\n  &#x2F;&#x2F; jsxDev 可以提供更友好的错误信息：\n  &#x2F;&#x2F; &quot;Cannot read property &#39;toString&#39; of undefined at App&quot;\n  &#x2F;&#x2F; 并显示具体的组件栈信息\n\n  &#x2F;&#x2F; 而在生产环境下，jsx 函数会简单地抛出错误，\n  &#x2F;&#x2F; 没有这些额外的调试信息\n&#125;\n\n\n性能考虑：\n\n&#x2F;&#x2F; 开发环境：更多的检查，更多的警告\njsxDev(&quot;div&quot;, &#123;\n  &#x2F;&#x2F; 可以检查 props 类型\n  &#x2F;&#x2F; 可以检查废弃的 API 使用\n  &#x2F;&#x2F; 可以添加更多的调试信息\n&#125;);\n\n&#x2F;&#x2F; 生产环境：更简洁的代码，更好的性能\njsx(&quot;div&quot;, &#123;\n  &#x2F;&#x2F; 只进行必要的转换\n  &#x2F;&#x2F; 没有额外的检查和警告\n  &#x2F;&#x2F; 代码体积更小，运行更快\n&#125;);\n\nSummary：\n\n开发体验：提供更好的错误信息和警告\n调试能力：支持 React DevTools 等开发工具\n性能优化：生产环境可以移除开发时的检查代码\n包体积：生产环境的代码更精简\n\n这就是为什么 React 需要维护两个版本的 JSX 转换函数，它们服务于不同的目的：jsx: 注重性能和包体积jsxDev: 注重开发体验和调试能力\nReact reconcilerReact reconciler 主要是实现了 React 的核心算法，包括调和、渲染、更新等。\n更改 packages&#x2F;react-reconciler&#x2F;package.json 文件&#123;\n  &quot;name&quot;: &quot;react-reconciler&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;react-reconciler&quot;,\n  &quot;module&quot;: &quot;index.ts&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;shared&quot;: &quot;workspace: *&quot;\n  &#125;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;x29&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n在 packages&#x2F;react&#x2F;src&#x2F;currentBatchConfig.ts 文件中，我们声明了 currentBatchConfig 类型。\n\n\n\n\n\n\n\n\ncurrentBatchConfig.ts - React 批处理配置文件\n作用：\n\n存储当前 React 批量更新的配置信息\n主要用于 Transition 相关的功能\n在并发渲染中控制更新的优先级\n\n&#x2F;**\n * React 当前批处理配置对象\n *\n * 用途：\n * 1. 在组件更新时标记更新的类型\n * 2. 帮助 React 区分普通更新和 Transition 更新\n * 3. 影响更新的优先级和调度方式\n *\n * @type &#123;React.BatchConfig&#125;\n *\n * @example\n * &#x2F;&#x2F; React 内部使用示例\n * function scheduleUpdate(fiber, update) &#123;\n *   const transition &#x3D; ReactCurrentBatchConfig.transition;\n *   if (transition !&#x3D;&#x3D; null) &#123;\n *     &#x2F;&#x2F; 这是一个 Transition 更新，使用较低的优先级\n *     scheduleTransitionUpdate(fiber, update);\n *   &#125; else &#123;\n *     &#x2F;&#x2F; 这是一个普通更新，使用正常优先级\n *     scheduleRegularUpdate(fiber, update);\n *   &#125;\n * &#125;\n *&#x2F;\nconst ReactCurrentBatchConfig: React.BatchConfig &#x3D; &#123;\n  transition: null,\n&#125;;\n\nexport default ReactCurrentBatchConfig;\n\n\n\n\n\n\n\n\n\n\n实际应用场景：\n\nuseTransition Hook:\n\nfunction App() &#123;\n  const [isPending, startTransition] &#x3D; useTransition();\n  return (\n    &lt;button\n      onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n        startTransition(() &#x3D;&gt; &#123;\n          &#x2F;&#x2F; 这里的更新会被标记为 Transition\n          setLargeList(generateLargeList());\n        &#125;);\n      &#125;&#125;\n    &gt;\n      Update List\n    &lt;&#x2F;button&gt;\n  );\n&#125;\n\n\n并发特性：\n\n\n允许 React 中断渲染以处理更高优先级的更新\n帮助实现更流畅的用户体验\n支持可中断的渲染过程\n\n在 packages&#x2F;react-reconciler&#x2F;src&#x2F;fiberFlags.ts 文件中\n\n\n\n\n\n\n\n\nfiberFlags.ts - React Fiber 节点的副作用（side-effects）标记定义\n作用：\n\n定义所有可能的 Fiber 节点副作用类型\n使用二进制位标记实现高效的副作用追踪\n通过位运算组合多个副作用\n\n&#x2F;**\n\n\n&#x2F;**\n * Flags 类型定义\n * 用于在 TypeScript 中标识副作用标记的类型\n *&#x2F;\nexport type Flags &#x3D; number;\n\n&#x2F;**\n * 无副作用标记\n * 表示节点不需要进行任何操作\n * 二进制：0000000\n *&#x2F;\nexport const NoFlags &#x3D; 0b0000000;\n\n&#x2F;**\n * 插入&#x2F;移动标记\n * 表示节点需要插入到 DOM 中或在 DOM 中移动位置\n * 二进制：0000001\n *&#x2F;\nexport const Placement &#x3D; 0b0000001;\n\n&#x2F;**\n * 更新标记\n * 表示节点的属性或内容需要更新\n * 二进制：0000010\n *&#x2F;\nexport const Update &#x3D; 0b0000010;\n\n&#x2F;**\n * 子节点删除标记\n * 表示需要删除子节点\n * 二进制：0000100\n *&#x2F;\nexport const ChildDeletion &#x3D; 0b0000100;\n\n&#x2F;**\n * 被动效果标记（如 useEffect）\n * 表示节点包含需要在提交阶段后异步执行的副作用\n * 二进制：0001000\n *&#x2F;\nexport const PassiveEffect &#x3D; 0b0001000;\n\n&#x2F;**\n * Ref 更新标记\n * 表示节点的 ref 需要更新\n * 二进制：0010000\n *&#x2F;\nexport const Ref &#x3D; 0b0010000;\n\n&#x2F;**\n * 可见性变更标记\n * 表示节点的显示&#x2F;隐藏状态需要更新\n * 二进制：0100000\n *&#x2F;\nexport const Visibility &#x3D; 0b0100000;\n\n&#x2F;**\n * 已捕获标记\n * 表示错误已经被捕获\n * 二进制：1000000\n *&#x2F;\nexport const DidCapture &#x3D; 0b1000000;\n\n&#x2F;**\n * 应该捕获标记\n * 表示这个节点应该尝试捕获错误\n * 二进制：01000000000\n *&#x2F;\nexport const ShouldCapture &#x3D; 0b01000000000;\n\n&#x2F;**\n * 突变阶段的标记集合\n * 包含了在 DOM 突变阶段需要处理的所有副作用\n * 通过位运算组合多个标记\n *\n * @example\n * if (fiber.flags &amp; MutationMask) &#123;\n *   &#x2F;&#x2F; 需要在突变阶段处理这个节点\n * &#125;\n *&#x2F;\nexport const MutationMask &#x3D;\n  Placement | Update | ChildDeletion | Ref | Visibility;\n\n&#x2F;**\n * 布局阶段的标记集合\n * 包含了在 DOM 布局阶段需要处理的所有副作用\n * 目前只包含 Ref 的更新\n *&#x2F;\nexport const LayoutMask &#x3D; Ref;\n\n&#x2F;**\n * 被动效果的标记集合\n * 包含了需要异步处理的副作用\n * 主要用于 useEffect 的处理\n *&#x2F;\nexport const PassiveMask &#x3D; PassiveEffect | ChildDeletion;\n\n使用示例：\n&#x2F;&#x2F; 添加副作用标记\nfiber.flags |&#x3D; Update;\n\n&#x2F;&#x2F; 检查是否包含某个副作用\nif (fiber.flags &amp; Placement) &#123;\n  &#x2F;&#x2F; 需要插入或移动节点\n&#125;\n\n&#x2F;&#x2F; 在不同阶段检查相关副作用\nif (fiber.flags &amp; MutationMask) &#123;\n  &#x2F;&#x2F; 处理 DOM 突变相关的副作用\n&#125;\n\nif (fiber.flags &amp; PassiveMask) &#123;\n  &#x2F;&#x2F; 处理 useEffect 相关的副作用\n&#125;\n\n在 packages&#x2F;react-reconciler&#x2F;src&#x2F;workTags.ts 文件中\n\n\n\n\n\n\n\n\nworkTags.ts - React Fiber 节点类型定义文件\n作用：\n\n定义所有可能的 Fiber 节点类型\n用于在 Fiber 树中标识不同类型的节点\n帮助 React 在协调过程中正确处理不同类型的组件\n\n&#x2F;**\n * 函数组件标识\n * 用于标识函数式组件创建的 Fiber 节点\n * @example\n * function App() &#123; return &lt;div&gt;Hello&lt;&#x2F;div&gt; &#125;\n * &#x2F;&#x2F; App 组件对应的 Fiber 节点的 tag 值为 FunctionComponent (0)\n *&#x2F;\nexport const FunctionComponent: React.FunctionComponent &#x3D; 0;\n\n&#x2F;**\n * 根节点标识\n * 用于标识应用的根节点（Root）\n * @example\n * ReactDOM.render(&lt;App &#x2F;&gt;, container)\n * &#x2F;&#x2F; container 对应的 Fiber 节点的 tag 值为 HostRoot (3)\n *&#x2F;\nexport const HostRoot: React.HostRoot &#x3D; 3;\n\n&#x2F;**\n * 原生 DOM 元素标识\n * 用于标识普通 HTML 元素的 Fiber 节点\n * @example\n * &lt;div&gt;Hello&lt;&#x2F;div&gt;\n * &#x2F;&#x2F; div 对应的 Fiber 节点的 tag 值为 HostComponent (5)\n *&#x2F;\nexport const HostComponent: React.HostComponent &#x3D; 5;\n\n&#x2F;**\n * 文本节点标识\n * 用于标识文本内容的 Fiber 节点\n * @example\n * &lt;div&gt;Hello World&lt;&#x2F;div&gt;\n * &#x2F;&#x2F; &quot;Hello World&quot; 对应的 Fiber 节点的 tag 值为 HostText (6)\n *&#x2F;\nexport const HostText: React.HostText &#x3D; 6;\n\n&#x2F;**\n * Fragment 标识\n * 用于标识 React.Fragment 的 Fiber 节点\n * @example\n * &lt;React.Fragment&gt;\n *   &lt;div&gt;Item 1&lt;&#x2F;div&gt;\n *   &lt;div&gt;Item 2&lt;&#x2F;div&gt;\n * &lt;&#x2F;React.Fragment&gt;\n * &#x2F;&#x2F; Fragment 对应的 Fiber 节点的 tag 值为 Fragment (7)\n *&#x2F;\nexport const Fragment: React.Fragment &#x3D; 7;\n\n&#x2F;**\n * Context Provider 标识\n * 用于标识 Context.Provider 的 Fiber 节点\n * @example\n * &lt;MyContext.Provider value&#x3D;&#123;value&#125;&gt;\n *   &#123;children&#125;\n * &lt;&#x2F;MyContext.Provider&gt;\n * &#x2F;&#x2F; Provider 对应的 Fiber 节点的 tag 值为 ContextProvider (11)\n *&#x2F;\nexport const ContextProvider: React.ContextProvider &#x3D; 11;\n\n&#x2F;**\n * Suspense 组件标识\n * 用于标识 Suspense 组件的 Fiber 节点\n * @example\n * &lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n *   &lt;SomeComponent &#x2F;&gt;\n * &lt;&#x2F;Suspense&gt;\n * &#x2F;&#x2F; Suspense 对应的 Fiber 节点的 tag 值为 SuspenseComponent (13)\n *&#x2F;\nexport const SuspenseComponent: React.SuspenseComponent &#x3D; 13;\n\n&#x2F;**\n * Offscreen 组件标识\n * 用于标识 Offscreen 组件的 Fiber 节点\n * 通常用于实现一些性能优化相关的功能\n * @example\n * &#x2F;&#x2F; React 内部使用，用于优化渲染性能\n * &#x2F;&#x2F; 对应的 Fiber 节点的 tag 值为 OffscreenComponent (14)\n *&#x2F;\nexport const OffscreenComponent: React.OffscreenComponent &#x3D; 14;\n\n\n\n\n\n\n\n\n\n\n使用示例：\nfunction processFiber(fiber: FiberNode) &#123;\n  switch (fiber.tag) &#123;\n    case FunctionComponent:\n      &#x2F;&#x2F; 处理函数组件\n      updateFunctionComponent(fiber);\n      break;\n    case HostComponent:\n      &#x2F;&#x2F; 处理 DOM 元素\n      updateHostComponent(fiber);\n      break;\n    case HostText:\n      &#x2F;&#x2F; 处理文本节点\n      updateTextContent(fiber);\n      break;\n    &#x2F;&#x2F; ... 处理其他类型\n  &#125;\n&#125;\n\n在根目录的 typing 中声明全局的类型定义文件React.d.tsdeclare module React &#123;\n  &#x2F;**\n   * React 配置对象的类型定义\n   * @interface JsxConfig\n   * @property &#123;Key&#125; [key] - 可选的 key 属性，用于 React 的 diff 算法\n   * @property &#123;Ref&#125; [ref] - 可选的 ref 属性，用于获取 DOM 或组件实例\n   * @property &#123;any&#125; [key: string] - 允许任意其他字符串键的属性\n   *&#x2F;\n  export interface JsxConfig &#123;\n    [key: string]: any;\n    key?: Key;\n    ref?: Ref;\n  &#125;\n\n  &#x2F;**\n   * BatchConfig 接口定义\n   *\n   * @interface BatchConfig\n   * @property &#123;number | null&#125; transition - Transition 的标识符\n   *\n   * 说明：\n   * 1. 当 transition 为 null 时，表示普通更新\n   * 2. 当 transition 为数字时，表示这是一个 Transition 更新\n   *\n   * @example\n   * &#x2F;&#x2F; 在 useTransition 中的使用\n   * const [isPending, startTransition] &#x3D; useTransition();\n   * startTransition(() &#x3D;&gt; &#123;\n   *   &#x2F;&#x2F; 在这个回调中，ReactCurrentBatchConfig.transition 会被设置为一个数字\n   *   setCount(count + 1);\n   * &#125;);\n   *&#x2F;\n  export interface BatchConfig &#123;\n    transition: number | null;\n  &#125;\n\n  &#x2F;**\n   * 函数组件标识\n   * 用于标识函数式组件创建的 Fiber 节点\n   * @example\n   * function App() &#123; return &lt;div&gt;Hello&lt;&#x2F;div&gt; &#125;\n   * &#x2F;&#x2F; App 组件对应的 Fiber 节点的 tag 值为 FunctionComponent (0)\n   *&#x2F;\n  export type FunctionComponent &#x3D; 0;\n\n  &#x2F;**\n   * 根节点标识\n   * 用于标识应用的根节点（Root）\n   * @example\n   * ReactDOM.render(&lt;App &#x2F;&gt;, container)\n   * &#x2F;&#x2F; container 对应的 Fiber 节点的 tag 值为 HostRoot (3)\n   *&#x2F;\n  export type HostRoot &#x3D; 3;\n\n  &#x2F;**\n   * 原生 DOM 元素标识\n   * 用于标识普通 HTML 元素的 Fiber 节点\n   * @example\n   * &lt;div&gt;Hello&lt;&#x2F;div&gt;\n   * &#x2F;&#x2F; div 对应的 Fiber 节点的 tag 值为 HostComponent (5)\n   *&#x2F;\n  export type HostComponent &#x3D; 5;\n\n  &#x2F;**\n   * 文本节点标识\n   * 用于标识文本内容的 Fiber 节点\n   * @example\n   * &lt;div&gt;Hello World&lt;&#x2F;div&gt;\n   * &#x2F;&#x2F; &quot;Hello World&quot; 对应的 Fiber 节点的 tag 值为 HostText (6)\n   *&#x2F;\n  export type HostText &#x3D; 6;\n\n  &#x2F;**\n   * Fragment 标识\n   * 用于标识 React.Fragment 的 Fiber 节点\n   * @example\n   * &lt;React.Fragment&gt;\n   *   &lt;div&gt;Item 1&lt;&#x2F;div&gt;\n   *   &lt;div&gt;Item 2&lt;&#x2F;div&gt;\n   * &lt;&#x2F;React.Fragment&gt;\n   * &#x2F;&#x2F; Fragment 对应的 Fiber 节点的 tag 值为 Fragment (7)\n   *&#x2F;\n  export type Fragment &#x3D; 7;\n\n  &#x2F;**\n   * Context Provider 标识\n   * 用于标识 Context.Provider 的 Fiber 节点\n   * @example\n   * &lt;MyContext.Provider value&#x3D;&#123;value&#125;&gt;\n   *   &#123;children&#125;\n   * &lt;&#x2F;MyContext.Provider&gt;\n   * &#x2F;&#x2F; Provider 对应的 Fiber 节点的 tag 值为 ContextProvider (11)\n   *&#x2F;\n  export type ContextProvider &#x3D; 11;\n\n  &#x2F;**\n   * Suspense 组件标识\n   * 用于标识 Suspense 组件的 Fiber 节点\n   * @example\n   * &lt;Suspense fallback&#x3D;&#123;&lt;Loading &#x2F;&gt;&#125;&gt;\n   *   &lt;SomeComponent &#x2F;&gt;\n   * &lt;&#x2F;Suspense&gt;\n   * &#x2F;&#x2F; Suspense 对应的 Fiber 节点的 tag 值为 SuspenseComponent (13)\n   *&#x2F;\n  export type SuspenseComponent &#x3D; 13;\n\n  &#x2F;**\n   * Offscreen 组件标识\n   * 用于标识 Offscreen 组件的 Fiber 节点\n   * 通常用于实现一些性能优化相关的功能\n   * @example\n   * &#x2F;&#x2F; React 内部使用，用于优化渲染性能\n   * &#x2F;&#x2F; 对应的 Fiber 节点的 tag 值为 OffscreenComponent (14)\n   *&#x2F;\n  export type OffscreenComponent &#x3D; 14;\n\n  &#x2F;**\n   * WorkTag 类型定义\n   * 联合类型，包含所有可能的 Fiber 节点类型标识\n   * 在 FiberNode 的 tag 属性中使用\n   *&#x2F;\n  export type WorkTag &#x3D;\n    | typeof FunctionComponent &#x2F;&#x2F; 函数组件\n    | typeof HostRoot &#x2F;&#x2F; 根节点\n    | typeof HostComponent &#x2F;&#x2F; 原生 DOM 元素\n    | typeof HostText &#x2F;&#x2F; 文本节点\n    | typeof Fragment &#x2F;&#x2F; Fragment 片段\n    | typeof ContextProvider &#x2F;&#x2F; Context Provider 组件\n    | typeof SuspenseComponent &#x2F;&#x2F; Suspense 组件\n    | typeof OffscreenComponent; &#x2F;&#x2F; Offscreen 组件\n&#125;\n","slug":"React-Principle","date":"2024-11-23T16:50:47.000Z","categories_index":"React","tags_index":"React","author_index":"X-29"},{"id":"78c733f14091289904e8c5ab0e4b1c53","title":"前端自动化部署","content":"所谓自动化部署就是当代码触发提交的时候自动部署到服务器上\n前置准备工作\n\n服务器：需要有一台可以部署代码的服务器，比如阿里云、腾讯云、GitHub Pages 等\n代码仓库：需要有一个代码仓库，比如 GitHub、GitLab 等\n会 linux\n懂点 Ngnix\n懂点 Git\n\n买一台服务器\n不要贪便宜到不知名小平台买，之前我也有过投机取巧不想买大平台的服务器，因为觉得贵，但是贵有贵的道理，小平台的安装都会报错，可能对于当时的我技术还不够，不太能分析出错误的原因是什么，总之避雷就对了。\n\n到阿里云我买的 99&#x2F;年的，我买的是 Alibaba Cloud Linux3，和 CentOS 没差，用就行\n\n一路先确定直到支付完成就会看到有服务器的 IP 地址，记住这个 IP 地址，后面会用到。然后重置密码，记住密码，不管是脑子还是别的什么地方\n\n\n连接服务器固定模板 ssh root@服务器 IP 地址\n安装 Docker以下命令以此执行，无脑做就能成功\n**一些命令的解释: **\n\ndnf: 这是一个包管理工具，用于安装、更新和删除软件包。它是 yum 的下一代版本，提供更好的性能和依赖管理功能。\n\ninstall: 这是 dnf 的一个子命令，用于安装指定的软件包。\n\n-y: 这个选项表示自动回答“yes”给所有的提示。这意味着在安装过程中，如果有任何确认提示，使用此标志可以自动接受，避免手动干预。\n\ndocker-ce: 这是要安装的软件包的名称。在这里，docker-ce 指的是 Docker 的社区版（Community Edition）。Docker 是一个开源的容器化平台，用于自动化应用程序的部署、扩展和管理。\n\n–nobest: 这个选项告诉 dnf 在安装时不一定选择最好的（最新的）版本来进行安装，而是可以选择可用版本中的较好版本。这在某些情况下可以避免因为依赖问题而无法安装最新版本\n\n\n运行以下命令，安装Docker存储驱动的依赖包dnf install -y device-mapper-persistent-data lvm2\n\n运行以下命令，添加稳定的Docker软件源。dnf config-manager --add-repo&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n\n运行以下命令，查看已添加的Docker软件源。dnf list docker-ce\n\n正确的返回示例如下。docker-ce.x86_64        3:19.03.13-3.el7        docker-ce-stable\n\n运行以下命令安装Dockerdnf install -y docker-ce --nobest\n\n设置开机自启sudo systemctl enable docker\n\n启动dockersudo systemctl start docker\n\n检测是否安装成功 docker -v 查看版本号docker -v\n\n\n安装 docker-compose安sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -olink\n\n对二进制文件应用可执行权限sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n\n检测是否安装成功 docker-compose -v 查看版本号docker-compose -v\n\n安装 Nginx 镜像和 Jenkins 镜像安装 Nginx镜像docker pull nginx\n\n\n\n\n\n\n\n\n\n\n\nwarning: 如果报错内容是 Error response from daemon: Get “https://registry-1.docker.io/v2/“: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 就按下方命令执行\n\n修改下这个json文件，没有就创建vim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n\n写入以下内容&#123;\n  &quot;registry-mirrors&quot;: [\n    &quot;https:&#x2F;&#x2F;2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;,\n    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,\n    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;,\n    &quot;https:&#x2F;&#x2F;your_preferred_mirror&quot;,\n    &quot;https:&#x2F;&#x2F;dockerhub.icu&quot;,\n    &quot;https:&#x2F;&#x2F;docker.registry.cyou&quot;,\n    &quot;https:&#x2F;&#x2F;docker-cf.registry.cyou&quot;,\n    &quot;https:&#x2F;&#x2F;dockercf.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;docker.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;dockertest.jsdelivr.fyi&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.aliyuncs.com&quot;,\n    &quot;https:&#x2F;&#x2F;dockerproxy.com&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;,\n    &quot;https:&#x2F;&#x2F;docker.m.daocloud.io&quot;,\n    &quot;https:&#x2F;&#x2F;docker.nju.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.mirrors.sjtug.sjtu.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.iscas.ac.cn&quot;,\n    &quot;https:&#x2F;&#x2F;docker.rainbond.cc&quot;\n  ]\n&#125;\n\n重新加载配置文件systemctl daemon-reload\n\n重启docker服务systemctl restart docker\n\n检查下docker是否启动正常systemctl status docker\n\n这样再重新 pull Nginx 就正常了\n安装 Jenkins查看镜像listdocker search jenkins\n\n\n\n\n\n\n\n\n\n\nwarning:可能会报错，需要配置下镜像源无所谓，反正是查看列表的命令，往下走接着拉镜像\n拉取Jenkins镜像 本次镜像jenkins/jenkins:ltsdocker pull jenkins&#x2F;jenkins:lts\n\n\n\n\n\n\n\n\nWARNING\n就拉最新版的镜像，lts 版本是最稳定的版本，一般情况下都用这个版本，别整没有用的\n\n安装完成后执行docker images 查看已安装镜像docker images\n\n\n配置目录编写\n\n\n\n\n\n\nWARNING\n!! 注意：这里的 docker 是放在根目录的和&#x2F;root 平级的\n\n\ndocker\ncompose\ndocker-compose.yml &#x2F;&#x2F;docker-compose 配置\n\n\nhtml &#x2F;&#x2F;各环境代码目录(实际项目可能不在同一目录)\ndev &#x2F;&#x2F;dev 环境代码目录\nprod &#x2F;&#x2F;sit 环境代码目录\n\n\njenkins_home &#x2F;&#x2F;Jenkins 工程目录\nnginx &#x2F;&#x2F;nginx 工程目录\nconf\nnginx.conf &#x2F;&#x2F;nginx 配置\n\n\n\n\n\n\n\ndocker-compose.yml 配置文件version: &quot;3&quot;\n\nservices: # 容器\n  docker_jenkins:\n    privileged: true\n    user: root # root权限\n    restart: always # 重启方式\n    image: jenkins&#x2F;jenkins:lts # 使用的镜像\n    container_name: jenkins # 容器名称\n    ports: # 对外暴露的端口定义\n      - 8080:8080\n      - 50000:50000\n    volumes: # 卷挂载路径\n      - &#x2F;docker&#x2F;jenkins_home&#x2F;:&#x2F;var&#x2F;jenkins_home # 挂载到容器内的jenkins_home目录\n      - &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock\n      - &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n      - &#x2F;usr&#x2F;bin&#x2F;docker:&#x2F;usr&#x2F;bin&#x2F;docker\n\n  docker_nginx_dev: # nginx-dev环境\n    restart: always\n    image: nginx\n    container_name: nginx_dev\n    ports:\n      - 8001:8001\n    volumes:\n      - &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n      - &#x2F;docker&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html\n      - &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx\n\n  docker_nginx_prod: # nginx-prod环境\n    restart: always\n    image: nginx\n    container_name: nginx_prod\n    ports:\n      - 8002:8002\n    volumes:\n      - &#x2F;docker&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n      - &#x2F;docker&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html\n      - &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx\n\nnginx.conf 配置文件# nginx.conf 例：\nuser  nginx;\nworker_processes  1;\n\nerror_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;\npid        &#x2F;var&#x2F;run&#x2F;nginx.pid;\n\n\nevents &#123;\n    worker_connections  1024;\n&#125;\n\n\nhttp &#123;\n    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;\n    default_type  application&#x2F;octet-stream;\n\n    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\n    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    gzip  on;\n\n    #dev环境\n    server &#123;\n            #监听的端口\n        listen  8001;\n        server_name  localhost;\n        #设置日志\n#        access_log  logs&#x2F;dev.access.log  main;\n\n        #定位到index.html\n           location &#x2F; &#123;\n               #linux下HTML文件夹,就是你的前端项目文件夹\n               root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;dev&#x2F;dist;\n#               root  &#x2F;home&#x2F;html&#x2F;dev&#x2F;dist;\n               #输入网址（server_name：port）后，默认的访问页面\n               index  index.html;\n               try_files $uri $uri&#x2F; &#x2F;index.html;\n           &#125;\n    &#125;\n\n    #prod环境\n    server &#123;\n            #监听的端口\n        listen  8002;\n        server_name  localhost;\n        #设置日志\n#        access_log  logs&#x2F;prod.access.log  main;\n\n        #定位到index.html\n           location &#x2F; &#123;\n               #linux下HTML文件夹,就是你的前端项目文件夹\n               root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;prod&#x2F;dist;\n#               root  &#x2F;home&#x2F;html&#x2F;dev&#x2F;dist;\n               #输入网址（server_name：port）后，默认的访问页面\n               index  index.html;\n               try_files $uri $uri&#x2F; &#x2F;index.html;\n           &#125;\n    &#125;\n\n\n#    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;\n\n\n&#125;\n\n\n\n\n\n\n\n\nTIP\n在 docker-compose.yml 文件所在目录下执行命令创建容器\n\n启动容器docker-compose up -d\n\n执行docker ps查看容器情况docker ps\n\nJenkins 配置爆坑来了！！！\n阿里云安全组配置\n\n\n\n\n\n\nWARNING\n此时通过 ip:8080 打不开 jenkins 的，因为阿里云那边需要手动加上要访问那个端口，就放行哪个端口\n\n防火墙配置\n\n\n\n\n\n\n\n\n输入命令开启防火墙和 8080 端口\n检查防火墙装填sudo systemctl status firewalld\n\n开启防火墙sudo systemctl start firewalld\n\nsudo systemctl enable firewalld\n\n开启8080端口sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent\n\n重启防火墙sudo firewall-cmd --reload\n\n\n\n\n\n\n\n\nWARNING\n后面每开放一个端口就要到安全组手动配置一下，然后防火墙开启端口，防火墙 reload 一下，三步，每一步都不能少\n\nJenkins 初次密码在容器启动后，可以在浏览器输入服务器 ip:8080 进入 jenkins 管理界面。至此，jenkins 配置完成。\n密码在 docker/jenkins_home/secrets/initialAdminPassword可以通过命令：\ncat &#x2F;docker&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword\n\nNginx 配置在对应目录/docker/html/dev/dist、/docker/html/prod/dist各新建一个 index.html\n经过上述步骤之后，可以通过 ip+对应的 nignx 端口访问到对应的环境的页面。\n\n\nJenkins 进入后的配置下载插件\nlocal（可选。将界面设置为中文）\nGitHub\npublish over SSH (用来连接远程服务器的)\nNodeJs\n\n下载插件后，Jenkins 需要重启地址栏输入ip:端口/restart\n\nPublish Over SSH 配置第一步\n第二步 进去找到 Publish Over SSH\n第三步 点击 Publish Over SSH 下方的 SSH Server,点击新增\n第四步 点击高级\n\n\nNodeJs 配置\n\n添加凭据添加凭据（账号密码）是为了方便后续使用\n\n\n添加 github 账号密码\n创建 job源码管理\n应用保存后，点击立即构建\n\n无论是否成功，都可以在构建记录控制台查看\n\nGithub WebHooks 配置webhooks 配置\n\n创建一个 Personal access tokens\n配置 jenkins进入一个 job\n\n\n\n\n\n\n(图片说明：描述就是取一个名称)\n\nBuild Steps在&#x2F;docker&#x2F;jenkins_home&#x2F;workspace&#x2F;gitlab_web,每次构建对应代码都会同步更新，由于代码没有在 git 上传 node_moudle 文件夹，所以后续需要在服务器重新安装 node_moudle\nExecute NodeJS script这里选的 node 是上面配置的\n点击应用后保存，然后点击立即构建，此次时间会长一点，此时构建会去自动安装对应的 nodejs 安装包到 jenkins 目录并配置好环境变量，注意尽量与本地开发环境的node版本一致，为了保持环境同步，等待构建好后再执行下一步\n\n应用保存并构建成功后，可以进入下一步\nShell 命令\n在 shell 命令这块有的执行 node -v 都报错，此时请检查环境变量是否与服务器的环境变量有差异，执行echo $PATH第一行代码一般要添加#!/bin/bash如果环境变量有问题可能要在第二行执行刷新环境变量命令\nsource ~&#x2F;.bash_profile\nsource &#x2F;etc&#x2F;profile\n\n上面哪个有效果用哪个然后执行对应命令，验证环境可用\n\n#!&#x2F;bin&#x2F;bash\n\nnode -v\nnpm -v\necho $PATH\n\n保存之后回到桌面在此构建一次上述命令如成功执行，进行下一步\n安装node_moule并build打包\n\n\n\n\n\n\nWARNING\n先自己本地build一下，看看哪里有问题\n\n修改job的shell配置\nnode -v\nnpm -v\n\nnpm i \nnpm run build:dev\n\n\n此时服务器代码出现dist文件夹目录在&#x2F;docker&#x2F;jenkins_home&#x2F;workspace&#x2F;github_test_web\n代码自动部署到对应环境项目目录同一服务器可以用cp命令，可以参考linux cp命令\n此处为另一种方式：压缩包ssh传输，因为使用cp命令到&#x2F;docker&#x2F;html&#x2F;dev目录报错了，遂采用第二种方式\n#!&#x2F;bin&#x2F;bash\n\nnode -v \nnpm -v \nnpm i\nnpm run build:dev\nrm -rf dist.tar\ntar -zcvf dist.tar .&#x2F;dist\n\n构建成功后多了个dist.tar文件\n连接SSH服务器系统配置已经设置过ssh相关配置再操作下面，如未设置，请往上翻 Publish Over SSH\n\n字段说明：Source files：准备发送的文件，该文件是相对于这个项目的workspace目录。例如要发送/docker/jenkins_home/workspace/gitlab_web/dist.tar到目标目录，则设置Source files为dist.tarRemove prefix：目标文件前缀添加，例如要操作src下面的某个文件，就设置成src,本案例是跟目录，无需设置Remote directory：目标目录，本案例要复制到dev环境下的dist文件，/docker/html/devExec command：最后执行的命令，可在这里进行解压，删除，复制等操作\n执行构建后，对应目录已经有了一个dist.tar文件\n\n这样肯定是不行的，还需要删除原有dist文件夹，解压dist.tar,再删除dist.tar,最终命令如下修改刚才配置的ssh最下方有个Exec command\ncd &#x2F;docker&#x2F;html&#x2F;dev\nrm  -rf   dist&#x2F;\ntar zxvf dist.tar\nrm dist.tar\n至此，shell命令执行结束，目前的效果是:gitlab 项目dev分支git提交后，触发jenkins自动构建，自动构建会先在服务器从gitlab的dev分支拉取最新代码，执行build打包后生成dist.tar文件，然后通过ssh将对应dist.tar发送到对应dev环境的项目目录解压dist.tar并更新对应文件，实现自动更新dev环境\n","slug":"automated-deployment","date":"2024-10-20T04:18:31.000Z","categories_index":"Academic","tags_index":"docker,nginx,jenkins,linux","author_index":"X-29"},{"id":"9668cd611991e16937a9fdd60d6dd807","title":"web多环境配置","content":"web 端多环境配置多环境无非就是请求的接口不一样所以本文将介绍如何在 web 端配置不同的请求接口的环境\n1. 准备工作npm init vite@latest\n\n完成之后长这样\n2.配置一些变量2.1 在根目录下新增 config 文件夹config\n├── plugins.ts\n├── constant.ts\n\nconstant 用于配置一些常量&#x2F;&#x2F; 基本路径\nexport const VITE_BASE_PATH &#x3D; &quot;&#x2F;&quot;;\n&#x2F;&#x2F; 应用名称\nexport const VITE_APP_TITLE &#x3D; &quot;xxx&quot;;\n&#x2F;&#x2F; 开启包依赖分析 可视化\nexport const VITE_APP_ANALYZE &#x3D; false;\n&#x2F;&#x2F; 开启Gzip压缩\nexport const VITE_APP_COMPRESS_GZIP &#x3D; false;\n&#x2F;&#x2F; 开启Gzip压缩，删除原文件\nexport const VITE_APP_COMPRESS_GZIP_DELETE_FILE &#x3D; false;\n&#x2F;&#x2F; 去除 console\nexport const VITE_DROP_CONSOLE &#x3D; true;\n&#x2F;&#x2F; 开启兼容\nexport const VITE_APP_LEGACY &#x3D; true;\n\nplugins 用于后续 vite 插件的配置npm install vite-plugin-compression vite-plugin-remove-console --save-dev\n\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\nimport viteCompression from &quot;vite-plugin-compression&quot;;\n\nimport removeConsole from &quot;vite-plugin-remove-console&quot;;\nimport &#123;\n  VITE_APP_COMPRESS_GZIP,\n  VITE_APP_COMPRESS_GZIP_DELETE_FILE,\n&#125; from &quot;.&#x2F;constant&quot;;\n\nexport const createVitePlugins &#x3D; (isBuild: boolean) &#x3D;&gt; &#123;\n  const vitePlugins &#x3D; [react(), removeConsole()];\n\n  if (isBuild) &#123;\n    if (VITE_APP_COMPRESS_GZIP) &#123;\n      vitePlugins.push(\n        viteCompression(&#123;\n          disable: true,\n          deleteOriginFile: VITE_APP_COMPRESS_GZIP_DELETE_FILE,\n        &#125;)\n      );\n    &#125;\n  &#125;\n\n  return vitePlugins;\n&#125;;\n\n3.查看 vite.config.ts 文件import &#123; defineConfig &#125; from &quot;vite&quot;;\nimport react from &quot;@vitejs&#x2F;plugin-react&quot;;\n\nexport default defineConfig(&#123;\n  plugins: [react()],\n&#125;);\n\n修改 vite.config.ts 文件\n\n\n\n\n\n\n\n\n如果提示：找不到模块“path”或其相应的类型声明，智能导入一下导入类型就行，这样就报错了\nimport &#123; ConfigEnv, loadEnv, UserConfig &#125; from &quot;vite&quot;;\nimport &#123; createVitePlugins &#125; from &quot;.&#x2F;config&#x2F;plugins&quot;;\nimport &#123; resolve &#125; from &quot;path&quot;;\nimport &#123; VITE_DROP_CONSOLE &#125; from &quot;.&#x2F;config&#x2F;constant&quot;;\n\nexport default (&#123; command, mode &#125;: ConfigEnv): UserConfig &#x3D;&gt; &#123;\n  const isBuild &#x3D; command.includes(&quot;build&quot;);\n  const root &#x3D; process.cwd();\n  const env &#x3D; loadEnv(mode, root);\n  const &#123; VITE_PORT &#125; &#x3D; env;\n\n  return &#123;\n    root: process.cwd(),\n    publicDir: &quot;public&quot;,\n    base: &quot;.&#x2F;&quot;,\n    plugins: createVitePlugins(isBuild),\n    css: &#123;\n      modules: &#123;\n        generateScopedName: &quot;[name]__[local]___[hash:base64:5]&quot;,\n        hashPrefix: &quot;prefix&quot;,\n      &#125;,\n      postcss: &#123;\n        plugins: [],\n      &#125;,\n      preprocessorOptions: &#123;\n        less: &#123;\n          javascriptEnabled: true,\n        &#125;,\n      &#125;,\n    &#125;,\n    resolve: &#123;\n      alias: &#123;\n        &quot;@&quot;: &#96;$&#123;resolve(__dirname, &quot;src&quot;)&#125;&#96;,\n      &#125;,\n      mainFields: [&quot;module&quot;, &quot;jsnext:main&quot;, &quot;jsnext&quot;],\n    &#125;,\n    clearScreen: true,\n    logLevel: &quot;info&quot;,\n    server: &#123;\n      open: true,\n      host: &quot;0.0.0.0&quot;,\n      port: parseInt(VITE_PORT),\n    &#125;,\n    build: &#123;\n      target: &quot;modules&quot;,\n      outDir: &quot;build&quot;,\n      assetsDir: &quot;assets&quot;,\n      cssCodeSplit: true,\n      assetsInlineLimit: 4096,\n      sourcemap: !isBuild,\n      chunkSizeWarningLimit: 500,\n      emptyOutDir: true,\n      manifest: false,\n      terserOptions: &#123;\n        compress: &#123;\n          keep_infinity: true,\n          drop_console: VITE_DROP_CONSOLE,\n        &#125;,\n      &#125;,\n    &#125;,\n    define: &#123;\n      _GLOBAL_VARS_: JSON.stringify(&#123;\n        ...env,\n        MODE: mode,\n        BUILD_TIME: new Date().toLocaleString(),\n      &#125;),\n    &#125;,\n  &#125;;\n&#125;;\n\n4.修改 package.json 文件原先的 scripts 部分\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;vite&quot;,\n  &quot;build&quot;: &quot;tsc -b &amp;&amp; vite build&quot;,\n  &quot;lint&quot;: &quot;eslint .&quot;,\n  &quot;preview&quot;: &quot;vite preview&quot;\n&#125;,\n\n修改后的 scripts 部分\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;vite --mode dev&quot;,\n  &quot;prod&quot;: &quot;vite --mode prod&quot;,\n  &quot;build:dev&quot;: &quot;tsc -b &amp;&amp; vite build --mode dev&quot;,\n  &quot;build:prod&quot;: &quot;tsc -b &amp;&amp; vite build --mode prod&quot;,\n  &quot;lint&quot;: &quot;eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0&quot;,\n  &quot;preview&quot;: &quot;vite preview&quot;\n&#125;,\n\n5.根目录下新增 .env 文件VITE_PORT &#x3D; 7200\nVITE_HOST &#x3D; http:&#x2F;&#x2F;dev.example.com &#x2F;&#x2F; 修改为你的域名,这里就是测试环境的接口前缀\n\n6.根目录下新增 .env.prod 文件VITE_PORT &#x3D; 7200\nVITE_HOST &#x3D; http:&#x2F;&#x2F;prod.example.com &#x2F;&#x2F; 修改为你的域名,这里就是生产环境的接口前缀\n\n7.新增 types 目录，里面新增 global.d.ts 文件declare const _GLOBAL_VARS_: &#123;\n  VITE_HOST: string;\n  MODE: string;\n  &#x2F;&#x2F; 如果还有其他变量，可以在这里继续声明\n&#125;;\n\n8.修改 tsconfig.node.json 文件在 include 中加入\n&quot;compilerOptions&quot;: &#123;\n  &quot;jsx&quot;: &quot;react-jsx&quot;,\n&#125;,\n&quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;,&quot;config&#x2F;*&quot;,&quot;vite.config.ts&quot;,&quot;.&#x2F;types&#x2F;global.d.ts&quot;],\n\n完整的 tsconfig.node.json 文件如下：\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;jsx&quot;: &quot;react-jsx&quot;, &#x2F;&#x2F; 为了避免识别不出jsx和避免提示需要导入react的提示\n    &quot;target&quot;: &quot;ES2022&quot;,\n    &quot;lib&quot;: [&quot;ES2023&quot;],\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;skipLibCheck&quot;: true,\n\n    &#x2F;* Bundler mode *&#x2F;\n    &quot;moduleResolution&quot;: &quot;bundler&quot;,\n    &quot;allowImportingTsExtensions&quot;: true,\n    &quot;isolatedModules&quot;: true,\n    &quot;moduleDetection&quot;: &quot;force&quot;,\n    &quot;noEmit&quot;: true,\n\n    &#x2F;* Linting *&#x2F;\n    &quot;strict&quot;: true,\n    &quot;noUnusedLocals&quot;: true,\n    &quot;noUnusedParameters&quot;: true,\n    &quot;noFallthroughCasesInSwitch&quot;: true\n  &#125;,\n  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;, &quot;config&#x2F;*&quot;, &quot;vite.config.ts&quot;, &quot;.&#x2F;types&#x2F;global.d.ts&quot;]\n&#125;\n\n9.在 src 目录下创建 constant.ts 文件export const HOST &#x3D; _GLOBAL_VARS_.VITE_HOST;\nexport const MODE &#x3D; _GLOBAL_VARS_.MODE;\n\n查看效果npm run dev\n\n\nnpm run prod\n\n\n","slug":"multiple-environments","date":"2024-10-20T02:15:18.000Z","categories_index":"Skill","tags_index":"React,web,Vite","author_index":"X-29"}]